#
# Unit tests for the multiprocessing package
#

import unittest
import queue as pyqueue
import contextlib
import time
import io
import itertools
import sys
import os
import gc
import errno
import signal
import array
import socket
import random
import logging
import struct
import operator
import weakref
import test.support
import test.support.script_helper
from test import support


# Skip tests if _multiprocessing wasn't built.
_multiprocessing = test.support.import_module('_multiprocessing')
# Skip tests if sem_open implementation is broken.
test.support.import_module('multiprocessing.synchronize')
# import threading after _multiprocessing to raise a more relevant error
# message: "No module named _multiprocessing". _multiprocessing is not compiled
# without thread support.
import threading

import multiprocessing.connection
import multiprocessing.dummy
import multiprocessing.heap
import multiprocessing.managers
import multiprocessing.pool
import multiprocessing.queues

from multiprocessing import util

try:
    from multiprocessing import reduction
    HAS_REDUCTION = reduction.HAVE_SEND_HANDLE
except ImportError:
    HAS_REDUCTION = False

try:
    from multiprocessing.sharedctypes import Value, copy
    HAS_SHAREDCTYPES = True
except ImportError:
    HAS_SHAREDCTYPES = False

try:
    import msvcrt
except ImportError:
    msvcrt = None

#
#
#

# Timeout to wait until a process completes
TIMEOUT = 60.0 # seconds

def latin(s):
    return s.encode('latin')


def close_queue(queue):
    if isinstance(queue, multiprocessing.queues.Queue):
        queue.close()
        queue.join_thread()


def join_process(process):
    # Since multiprocessing.Process has the same API than threading.Thread
    # (join() and is_alive(), the support function can be reused
    support.join_thread(process, timeout=TIMEOUT)


#
# Constants
#

LOG_LEVEL = util.SUBWARNING
#LOG_LEVEL = logging.DEBUG

DELTA = 0.1
CHECK_TIMINGS = False     # making true makes tests take a lot longer
                          # and can sometimes cause some non-serious
                          # failures because some calls block a bit
                          # longer than expected
if CHECK_TIMINGS:
    TIMEOUT1, TIMEOUT2, TIMEOUT3 = 0.82, 0.35, 1.4
else:
    TIMEOUT1, TIMEOUT2, TIMEOUT3 = 0.1, 0.1, 0.1

HAVE_GETVALUE = not getattr(_multiprocessing,
                            'HAVE_BROKEN_SEM_GETVALUE', False)

WIN32 = (sys.platform == "win32")

from multiprocessing.connection import wait

def wait_for_handle(handle, timeout):
    if timeout is not None and timeout < 0.0:
        timeout = None
    return wait([handle], timeout)

try:
    MAXFD = os.sysconf("SC_OPEN_MAX")
except:
    MAXFD = 256

# To speed up tests when using the forkserver, we can preload these:
PRELOAD = ['__main__', 'test.test_multiprocessing_forkserver']

#
# Some tests require ctypes
#

try:
    from ctypes import Structure, c_int, c_double, c_longlong
except ImportError:
    Structure = object
    c_int = c_double = c_longlong = None


def check_enough_semaphores():
    """Check that the system supports enough semaphores to run the test."""
    # minimum number of semaphores available according to POSIX
    nsems_min = 256
    try:
        nsems = os.sysconf("SC_SEM_NSEMS_MAX")
    except (AttributeError, ValueError):
        # sysconf not available or setting not available
        return
    if nsems == -1 or nsems >= nsems_min:
        return
    raise unittest.SkipTest("The OS doesn't support enough semaphores "
                            "to run the test (required: %d)." % nsems_min)


#
# Creates a wrapper for a function which records the time it takes to finish
#

class TimingWrapper(object):

    def __init__(self, func):
        self.func = func
        self.elapsed = None

    def __call__(self, *args, **kwds):
        t = time.monotonic()
        try:
            return self.func(*args, **kwds)
        finally:
            self.elapsed = time.monotonic() - t

#
# Base class for test cases
#

class BaseTestCase(object):

    ALLOWED_TYPES = ('processes', 'manager', 'threads')

    def assertTimingAlmostEqual(self, a, b):
        if CHECK_TIMINGS:
            self.assertAlmostEqual(a, b, 1)

    def assertReturnsIfImplemented(self, value, func, *args):
        try:
            res = func(*args)
        except NotImplementedError:
            pass
        else:
            return self.assertEqual(value, res)

    # For the sanity of Windows users, rather than crashing or freezing in
    # multiple ways.
    def __reduce__(self, *args):
        raise NotImplementedError("shouldn't try to pickle a test case")

    __reduce_ex__ = __reduce__

#
# Return the value of a semaphore
#

def get_value(self):
    try:
        return self.get_value()
    except AttributeError:
        try:
            return self._Semaphore__value
        except AttributeError:
            try:
                return self._value
            except AttributeError:
                raise NotImplementedError

#
# Testcases
#

class DummyCallable:
    def __call__(self, q, c):
        assert isinstance(c, DummyCallable)
        q.put(5)


class _TestProcess(BaseTestCase):

    ALLOWED_TYPES = ('processes', 'threads')

    def test_current(self):
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        current = self.current_process()
        authkey = current.authkey

        self.assertTrue(current.is_alive())
        self.assertTrue(not current.daemon)
        self.assertIsInstance(authkey, bytes)
        self.assertTrue(len(authkey) > 0)
        self.assertEqual(current.ident, os.getpid())
        self.assertEqual(current.exitcode, None)

    def test_daemon_argument(self):
        if self.TYPE == "threads":
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        # By default uses the current process's daemon flag.
        proc0 = self.Process(target=self._test)
        self.assertEqual(proc0.daemon, self.current_process().daemon)
        proc1 = self.Process(target=self._test, daemon=True)
        self.assertTrue(proc1.daemon)
        proc2 = self.Process(target=self._test, daemon=False)
        self.assertFalse(proc2.daemon)

    @classmethod
    def _test(cls, q, *args, **kwds):
        current = cls.current_process()
        q.put(args)
        q.put(kwds)
        q.put(current.name)
        if cls.TYPE != 'threads':
            q.put(bytes(current.authkey))
            q.put(current.pid)

    def test_process(self):
        q = self.Queue(1)
        e = self.Event()
        args = (q, 1, 2)
        kwargs = {'hello':23, 'bye':2.54}
        name = 'SomeProcess'
        p = self.Process(
            target=self._test, args=args, kwargs=kwargs, name=name
            )
        p.daemon = True
        current = self.current_process()

        if self.TYPE != 'threads':
            self.assertEqual(p.authkey, current.authkey)
        self.assertEqual(p.is_alive(), False)
        self.assertEqual(p.daemon, True)
        self.assertNotIn(p, self.active_children())
        self.assertTrue(type(self.active_children()) is list)
        self.assertEqual(p.exitcode, None)

        p.start()

        self.assertEqual(p.exitcode, None)
        self.assertEqual(p.is_alive(), True)
        self.assertIn(p, self.active_children())

        self.assertEqual(q.get(), args[1:])
        self.assertEqual(q.get(), kwargs)
        self.assertEqual(q.get(), p.name)
        if self.TYPE != 'threads':
            self.assertEqual(q.get(), current.authkey)
            self.assertEqual(q.get(), p.pid)

        p.join()

        self.assertEqual(p.exitcode, 0)
        self.assertEqual(p.is_alive(), False)
        self.assertNotIn(p, self.active_children())
        close_queue(q)

    @classmethod
    def _sleep_some(cls):
        time.sleep(100)

    @classmethod
    def _test_sleep(cls, delay):
        time.sleep(delay)

    def _kill_process(self, meth):
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        p = self.Process(target=self._sleep_some)
        p.daemon = True
        p.start()

        self.assertEqual(p.is_alive(), True)
        self.assertIn(p, self.active_children())
        self.assertEqual(p.exitcode, None)

        join = TimingWrapper(p.join)

        self.assertEqual(join(0), None)
        self.assertTimingAlmostEqual(join.elapsed, 0.0)
        self.assertEqual(p.is_alive(), True)

        self.assertEqual(join(-1), None)
        self.assertTimingAlmostEqual(join.elapsed, 0.0)
        self.assertEqual(p.is_alive(), True)

        # XXX maybe terminating too soon causes the problems on Gentoo...
        time.sleep(1)

        meth(p)

        if hasattr(signal, 'alarm'):
            # On the Gentoo buildbot waitpid() often seems to block forever.
            # We use alarm() to interrupt it if it blocks for too long.
            def handler(*args):
                raise RuntimeError('join took too long: %s' % p)
            old_handler = signal.signal(signal.SIGALRM, handler)
            try:
                signal.alarm(10)
                self.assertEqual(join(), None)
            finally:
                signal.alarm(0)
                signal.signal(signal.SIGALRM, old_handler)
        else:
            self.assertEqual(join(), None)

        self.assertTimingAlmostEqual(join.elapsed, 0.0)

        self.assertEqual(p.is_alive(), False)
        self.assertNotIn(p, self.active_children())

        p.join()

        return p.exitcode

    def test_terminate(self):
        exitcode = self._kill_process(multiprocessing.Process.terminate)
        if os.name != 'nt':
            self.assertEqual(exitcode, -signal.SIGTERM)

    def test_kill(self):
        exitcode = self._kill_process(multiprocessing.Process.kill)
        if os.name != 'nt':
            self.assertEqual(exitcode, -signal.SIGKILL)

    def test_cpu_count(self):
        try:
            cpus = multiprocessing.cpu_count()
        except NotImplementedError:
            cpus = 1
        self.assertTrue(type(cpus) is int)
        self.assertTrue(cpus >= 1)

    def test_active_children(self):
        self.assertEqual(type(self.active_children()), list)

        p = self.Process(target=time.sleep, args=(DELTA,))
        self.assertNotIn(p, self.active_children())

        p.daemon = True
        p.start()
        self.assertIn(p, self.active_children())

        p.join()
        self.assertNotIn(p, self.active_children())

    @classmethod
    def _test_recursion(cls, wconn, id):
        wconn.send(id)
        if len(id) < 2:
            for i in range(2):
                p = cls.Process(
                    target=cls._test_recursion, args=(wconn, id+[i])
                    )
                p.start()
                p.join()

    def test_recursion(self):
        rconn, wconn = self.Pipe(duplex=False)
        self._test_recursion(wconn, [])

        time.sleep(DELTA)
        result = []
        while rconn.poll():
            result.append(rconn.recv())

        expected = [
            [],
              [0],
                [0, 0],
                [0, 1],
              [1],
                [1, 0],
                [1, 1]
            ]
        self.assertEqual(result, expected)

    @classmethod
    def _test_sentinel(cls, event):
        event.wait(10.0)

    def test_sentinel(self):
        if self.TYPE == "threads":
            self.skipTest('test not appropriate for {}'.format(self.TYPE))
        event = self.Event()
        p = self.Process(target=self._test_sentinel, args=(event,))
        with self.assertRaises(ValueError):
            p.sentinel
        p.start()
        self.addCleanup(p.join)
        sentinel = p.sentinel
        self.assertIsInstance(sentinel, int)
        self.assertFalse(wait_for_handle(sentinel, timeout=0.0))
        event.set()
        p.join()
        self.assertTrue(wait_for_handle(sentinel, timeout=1))

    @classmethod
    def _test_close(cls, rc=0, q=None):
        if q is not None:
            q.get()
        sys.exit(rc)

    def test_close(self):
        if self.TYPE == "threads":
            self.skipTest('test not appropriate for {}'.format(self.TYPE))
        q = self.Queue()
        p = self.Process(target=self._test_close, kwargs={'q': q})
        p.daemon = True
        p.start()
        self.assertEqual(p.is_alive(), True)
        # Child is still alive, cannot close
        with self.assertRaises(ValueError):
            p.close()

        q.put(None)
        p.join()
        self.assertEqual(p.is_alive(), False)
        self.assertEqual(p.exitcode, 0)
        p.close()
        with self.assertRaises(ValueError):
            p.is_alive()
        with self.assertRaises(ValueError):
            p.join()
        with self.assertRaises(ValueError):
            p.terminate()
        p.close()

        wr = weakref.ref(p)
        del p
        gc.collect()
        self.assertIs(wr(), None)

        close_queue(q)

    def test_many_processes(self):
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        sm = multiprocessing.get_start_method()
        N = 5 if sm == 'spawn' else 100

        # Try to overwhelm the forkserver loop with events
        procs = [self.Process(target=self._test_sleep, args=(0.01,))
                 for i in range(N)]
        for p in procs:
            p.start()
        for p in procs:
            join_process(p)
        for p in procs:
            self.assertEqual(p.exitcode, 0)

        procs = [self.Process(target=self._sleep_some)
                 for i in range(N)]
        for p in procs:
            p.start()
        time.sleep(0.001)  # let the children start...
        for p in procs:
            p.terminate()
        for p in procs:
            join_process(p)
        if os.name != 'nt':
            exitcodes = [-signal.SIGTERM]
            if sys.platform == 'darwin':
                # bpo-31510: On macOS, killing a freshly started process with
                # SIGTERM sometimes kills the process with SIGKILL.
                exitcodes.append(-signal.SIGKILL)
            for p in procs:
                self.assertIn(p.exitcode, exitcodes)

    def test_lose_target_ref(self):
        c = DummyCallable()
        wr = weakref.ref(c)
        q = self.Queue()
        p = self.Process(target=c, args=(q, c))
        del c
        p.start()
        p.join()
        self.assertIs(wr(), None)
        self.assertEqual(q.get(), 5)
        close_queue(q)

    @classmethod
    def _test_child_fd_inflation(self, evt, q):
        q.put(test.support.fd_count())
        evt.wait()

    def test_child_fd_inflation(self):
        # Number of fds in child processes should not grow with the
        # number of running children.
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        sm = multiprocessing.get_start_method()
        if sm == 'fork':
            # The fork method by design inherits all fds from the parent,
            # trying to go against it is a lost battle
            self.skipTest('test not appropriate for {}'.format(sm))

        N = 5
        evt = self.Event()
        q = self.Queue()

        procs = [self.Process(target=self._test_child_fd_inflation, args=(evt, q))
                 for i in range(N)]
        for p in procs:
            p.start()

        try:
            fd_counts = [q.get() for i in range(N)]
            self.assertEqual(len(set(fd_counts)), 1, fd_counts)

        finally:
            evt.set()
            for p in procs:
                p.join()
            close_queue(q)

    @classmethod
    def _test_wait_for_threads(self, evt):
        def func1():
            time.sleep(0.5)
            evt.set()

        def func2():
            time.sleep(20)
            evt.clear()

        threading.Thread(target=func1).start()
        threading.Thread(target=func2, daemon=True).start()

    def test_wait_for_threads(self):
        # A child process should wait for non-daemonic threads to end
        # before exiting
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        evt = self.Event()
        proc = self.Process(target=self._test_wait_for_threads, args=(evt,))
        proc.start()
        proc.join()
        self.assertTrue(evt.is_set())

    @classmethod
    def _test_error_on_stdio_flush(self, evt, break_std_streams={}):
        for stream_name, action in break_std_streams.items():
            if action == 'close':
                stream = io.StringIO()
                stream.close()
            else:
                assert action == 'remove'
                stream = None
            setattr(sys, stream_name, None)
        evt.set()

    def test_error_on_stdio_flush_1(self):
        # Check that Process works with broken standard streams
        streams = [io.StringIO(), None]
        streams[0].close()
        for stream_name in ('stdout', 'stderr'):
            for stream in streams:
                old_stream = getattr(sys, stream_name)
                setattr(sys, stream_name, stream)
                try:
                    evt = self.Event()
                    proc = self.Process(target=self._test_error_on_stdio_flush,
                                        args=(evt,))
                    proc.start()
                    proc.join()
                    self.assertTrue(evt.is_set())
                    self.assertEqual(proc.exitcode, 0)
                finally:
                    setattr(sys, stream_name, old_stream)

    def test_error_on_stdio_flush_2(self):
        # Same as test_error_on_stdio_flush_1(), but standard streams are
        # broken by the child process
        for stream_name in ('stdout', 'stderr'):
            for action in ('close', 'remove'):
                old_stream = getattr(sys, stream_name)
                try:
                    evt = self.Event()
                    proc = self.Process(target=self._test_error_on_stdio_flush,
                                        args=(evt, {stream_name: action}))
                    proc.start()
                    proc.join()
                    self.assertTrue(evt.is_set())
                    self.assertEqual(proc.exitcode, 0)
                finally:
                    setattr(sys, stream_name, old_stream)

    @classmethod
    def _sleep_and_set_event(self, evt, delay=0.0):
        time.sleep(delay)
        evt.set()

    def check_forkserver_death(self, signum):
        # bpo-31308: if the forkserver process has died, we should still
        # be able to create and run new Process instances (the forkserver
        # is implicitly restarted).
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))
        sm = multiprocessing.get_start_method()
        if sm != 'forkserver':
            # The fork method by design inherits all fds from the parent,
            # trying to go against it is a lost battle
            self.skipTest('test not appropriate for {}'.format(sm))

        from multiprocessing.forkserver import _forkserver
        _forkserver.ensure_running()

        # First process sleeps 500 ms
        delay = 0.5

        evt = self.Event()
        proc = self.Process(target=self._sleep_and_set_event, args=(evt, delay))
        proc.start()

        pid = _forkserver._forkserver_pid
        os.kill(pid, signum)
        # give time to the fork server to die and time to proc to complete
        time.sleep(delay * 2.0)

        evt2 = self.Event()
        proc2 = self.Process(target=self._sleep_and_set_event, args=(evt2,))
        proc2.start()
        proc2.join()
        self.assertTrue(evt2.is_set())
        self.assertEqual(proc2.exitcode, 0)

        proc.join()
        self.assertTrue(evt.is_set())
        self.assertIn(proc.exitcode, (0, 255))

    def test_forkserver_sigint(self):
        # Catchable signal
        self.check_forkserver_death(signal.SIGINT)

    def test_forkserver_sigkill(self):
        # Uncatchable signal
        if os.name != 'nt':
            self.check_forkserver_death(signal.SIGKILL)


#
#
#

class _UpperCaser(multiprocessing.Process):

    def __init__(self):
        multiprocessing.Process.__init__(self)
        self.child_conn, self.parent_conn = multiprocessing.Pipe()

    def run(self):
        self.parent_conn.close()
        for s in iter(self.child_conn.recv, None):
            self.child_conn.send(s.upper())
        self.child_conn.close()

    def submit(self, s):
        assert type(s) is str
        self.parent_conn.send(s)
        return self.parent_conn.recv()

    def stop(self):
        self.parent_conn.send(None)
        self.parent_conn.close()
        self.child_conn.close()

class _TestSubclassingProcess(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    def test_subclassing(self):
        uppercaser = _UpperCaser()
        uppercaser.daemon = True
        uppercaser.start()
        self.assertEqual(uppercaser.submit('hello'), 'HELLO')
        self.assertEqual(uppercaser.submit('world'), 'WORLD')
        uppercaser.stop()
        uppercaser.join()

    def test_stderr_flush(self):
        # sys.stderr is flushed at process shutdown (issue #13812)
        if self.TYPE == "threads":
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        testfn = test.support.TESTFN
        self.addCleanup(test.support.unlink, testfn)
        proc = self.Process(target=self._test_stderr_flush, args=(testfn,))
        proc.start()
        proc.join()
        with open(testfn, 'r') as f:
            err = f.read()
            # The whole traceback was printed
            self.assertIn("ZeroDivisionError", err)
            self.assertIn("test_multiprocessing.py", err)
            self.assertIn("1/0 # MARKER", err)

    @classmethod
    def _test_stderr_flush(cls, testfn):
        fd = os.open(testfn, os.O_WRONLY | os.O_CREAT | os.O_EXCL)
        sys.stderr = open(fd, 'w', closefd=False)
        1/0 # MARKER


    @classmethod
    def _test_sys_exit(cls, reason, testfn):
        fd = os.open(testfn, os.O_WRONLY | os.O_CREAT | os.O_EXCL)
        sys.stderr = open(fd, 'w', closefd=False)
        sys.exit(reason)

    def test_sys_exit(self):
        # See Issue 13854
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        testfn = test.support.TESTFN
        self.addCleanup(test.support.unlink, testfn)

        for reason in (
            [1, 2, 3],
            'ignore this',
        ):
            p = self.Process(target=self._test_sys_exit, args=(reason, testfn))
            p.daemon = True
            p.start()
            join_process(p)
            self.assertEqual(p.exitcode, 1)

            with open(testfn, 'r') as f:
                content = f.read()
            self.assertEqual(content.rstrip(), str(reason))

            os.unlink(testfn)

        for reason in (True, False, 8):
            p = self.Process(target=sys.exit, args=(reason,))
            p.daemon = True
            p.start()
            join_process(p)
            self.assertEqual(p.exitcode, reason)

#
#
#

def queue_empty(q):
    if hasattr(q, 'empty'):
        return q.empty()
    else:
        return q.qsize() == 0

def queue_full(q, maxsize):
    if hasattr(q, 'full'):
        return q.full()
    else:
        return q.qsize() == maxsize


class _TestQueue(BaseTestCase):


    @classmethod
    def _test_put(cls, queue, child_can_start, parent_can_continue):
        child_can_start.wait()
        for i in range(6):
            queue.get()
        parent_can_continue.set()

    def test_put(self):
        MAXSIZE = 6
        queue = self.Queue(maxsize=MAXSIZE)
        child_can_start = self.Event()
        parent_can_continue = self.Event()

        proc = self.Process(
            target=self._test_put,
            args=(queue, child_can_start, parent_can_continue)
            )
        proc.daemon = True
        proc.start()

        self.assertEqual(queue_empty(queue), True)
        self.assertEqual(queue_full(queue, MAXSIZE), False)

        queue.put(1)
        queue.put(2, True)
        queue.put(3, True, None)
        queue.put(4, False)
        queue.put(5, False, None)
        queue.put_nowait(6)

        # the values may be in buffer but not yet in pipe so sleep a bit
        time.sleep(DELTA)

        self.assertEqual(queue_empty(queue), False)
        self.assertEqual(queue_full(queue, MAXSIZE), True)

        put = TimingWrapper(queue.put)
        put_nowait = TimingWrapper(queue.put_nowait)

        self.assertRaises(pyqueue.Full, put, 7, False)
        self.assertTimingAlmostEqual(put.elapsed, 0)

        self.assertRaises(pyqueue.Full, put, 7, False, None)
        self.assertTimingAlmostEqual(put.elapsed, 0)

        self.assertRaises(pyqueue.Full, put_nowait, 7)
        self.assertTimingAlmostEqual(put_nowait.elapsed, 0)

        self.assertRaises(pyqueue.Full, put, 7, True, TIMEOUT1)
        self.assertTimingAlmostEqual(put.elapsed, TIMEOUT1)

        self.assertRaises(pyqueue.Full, put, 7, False, TIMEOUT2)
        self.assertTimingAlmostEqual(put.elapsed, 0)

        self.assertRaises(pyqueue.Full, put, 7, True, timeout=TIMEOUT3)
        self.assertTimingAlmostEqual(put.elapsed, TIMEOUT3)

        child_can_start.set()
        parent_can_continue.wait()

        self.assertEqual(queue_empty(queue), True)
        self.assertEqual(queue_full(queue, MAXSIZE), False)

        proc.join()
        close_queue(queue)

    @classmethod
    def _test_get(cls, queue, child_can_start, parent_can_continue):
        child_can_start.wait()
        #queue.put(1)
        queue.put(2)
        queue.put(3)
        queue.put(4)
        queue.put(5)
        parent_can_continue.set()

    def test_get(self):
        queue = self.Queue()
        child_can_start = self.Event()
        parent_can_continue = self.Event()

        proc = self.Process(
            target=self._test_get,
            args=(queue, child_can_start, parent_can_continue)
            )
        proc.daemon = True
        proc.start()

        self.assertEqual(queue_empty(queue), True)

        child_can_start.set()
        parent_can_continue.wait()

        time.sleep(DELTA)
        self.assertEqual(queue_empty(queue), False)

        # Hangs unexpectedly, remove for now
        #self.assertEqual(queue.get(), 1)
        self.assertEqual(queue.get(True, None), 2)
        self.assertEqual(queue.get(True), 3)
        self.assertEqual(queue.get(timeout=1), 4)
        self.assertEqual(queue.get_nowait(), 5)

        self.assertEqual(queue_empty(queue), True)

        get = TimingWrapper(queue.get)
        get_nowait = TimingWrapper(queue.get_nowait)

        self.assertRaises(pyqueue.Empty, get, False)
        self.assertTimingAlmostEqual(get.elapsed, 0)

        self.assertRaises(pyqueue.Empty, get, False, None)
        self.assertTimingAlmostEqual(get.elapsed, 0)

        self.assertRaises(pyqueue.Empty, get_nowait)
        self.assertTimingAlmostEqual(get_nowait.elapsed, 0)

        self.assertRaises(pyqueue.Empty, get, True, TIMEOUT1)
        self.assertTimingAlmostEqual(get.elapsed, TIMEOUT1)

        self.assertRaises(pyqueue.Empty, get, False, TIMEOUT2)
        self.assertTimingAlmostEqual(get.elapsed, 0)

        self.assertRaises(pyqueue.Empty, get, timeout=TIMEOUT3)
        self.assertTimingAlmostEqual(get.elapsed, TIMEOUT3)

        proc.join()
        close_queue(queue)

    @classmethod
    def _test_fork(cls, queue):
        for i in range(10, 20):
            queue.put(i)
        # note that at this point the items may only be buffered, so the
        # process cannot shutdown until the feeder thread has finished
        # pushing items onto the pipe.

    def test_fork(self):
        # Old versions of Queue would fail to create a new feeder
        # thread for a forked process if the original process had its
        # own feeder thread.  This test checks that this no longer
        # happens.

        queue = self.Queue()

        # put items on queue so that main process starts a feeder thread
        for i in range(10):
            queue.put(i)

        # wait to make sure thread starts before we fork a new process
        time.sleep(DELTA)

        # fork process
        p = self.Process(target=self._test_fork, args=(queue,))
        p.daemon = True
        p.start()

        # check that all expected items are in the queue
        for i in range(20):
            self.assertEqual(queue.get(), i)
        self.assertRaises(pyqueue.Empty, queue.get, False)

        p.join()
        close_queue(queue)

    def test_qsize(self):
        q = self.Queue()
        try:
            self.assertEqual(q.qsize(), 0)
        except NotImplementedError:
            self.skipTest('qsize method not implemented')
        q.put(1)
        self.assertEqual(q.qsize(), 1)
        q.put(5)
        self.assertEqual(q.qsize(), 2)
        q.get()
        self.assertEqual(q.qsize(), 1)
        q.get()
        self.assertEqual(q.qsize(), 0)
        close_queue(q)

    @classmethod
    def _test_task_done(cls, q):
        for obj in iter(q.get, None):
            time.sleep(DELTA)
            q.task_done()

    def test_task_done(self):
        queue = self.JoinableQueue()

        workers = [self.Process(target=self._test_task_done, args=(queue,))
                   for i in range(4)]

        for p in workers:
            p.daemon = True
            p.start()

        for i in range(10):
            queue.put(i)

        queue.join()

        for p in workers:
            queue.put(None)

        for p in workers:
            p.join()
        close_queue(queue)

    def test_no_import_lock_contention(self):
        with test.support.temp_cwd():
            module_name = 'imported_by_an_imported_module'
            with open(module_name + '.py', 'w') as f:
                f.write("""if 1:
                    import multiprocessing

                    q = multiprocessing.Queue()
                    q.put('knock knock')
                    q.get(timeout=3)
                    q.close()
                    del q
                """)

            with test.support.DirsOnSysPath(os.getcwd()):
                try:
                    __import__(module_name)
                except pyqueue.Empty:
                    self.fail("Probable regression on import lock contention;"
                              " see Issue #22853")

    def test_timeout(self):
        q = multiprocessing.Queue()
        start = time.monotonic()
        self.assertRaises(pyqueue.Empty, q.get, True, 0.200)
        delta = time.monotonic() - start
        # bpo-30317: Tolerate a delta of 100 ms because of the bad clock
        # resolution on Windows (usually 15.6 ms). x86 Windows7 3.x once
        # failed because the delta was only 135.8 ms.
        self.assertGreaterEqual(delta, 0.100)
        close_queue(q)

    def test_queue_feeder_donot_stop_onexc(self):
        # bpo-30414: verify feeder handles exceptions correctly
        if self.TYPE != 'processes':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        class NotSerializable(object):
            def __reduce__(self):
                raise AttributeError
        with test.support.captured_stderr():
            q = self.Queue()
            q.put(NotSerializable())
            q.put(True)
            self.assertTrue(q.get(timeout=TIMEOUT))
            close_queue(q)

        with test.support.captured_stderr():
            # bpo-33078: verify that the queue size is correctly handled
            # on errors.
            q = self.Queue(maxsize=1)
            q.put(NotSerializable())
            q.put(True)
            try:
                self.assertEqual(q.qsize(), 1)
            except NotImplementedError:
                # qsize is not available on all platform as it
                # relies on sem_getvalue
                pass
            # bpo-30595: use a timeout of 1 second for slow buildbots
            self.assertTrue(q.get(timeout=1.0))
            # Check that the size of the queue is correct
            self.assertTrue(q.empty())
            close_queue(q)

    def test_queue_feeder_on_queue_feeder_error(self):
        # bpo-30006: verify feeder handles exceptions using the
        # _on_queue_feeder_error hook.
        if self.TYPE != 'processes':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        class NotSerializable(object):
            """Mock unserializable object"""
            def __init__(self):
                self.reduce_was_called = False
                self.on_queue_feeder_error_was_called = False

            def __reduce__(self):
                self.reduce_was_called = True
                raise AttributeError

        class SafeQueue(multiprocessing.queues.Queue):
            """Queue with overloaded _on_queue_feeder_error hook"""
            @staticmethod
            def _on_queue_feeder_error(e, obj):
                if (isinstance(e, AttributeError) and
                        isinstance(obj, NotSerializable)):
                    obj.on_queue_feeder_error_was_called = True

        not_serializable_obj = NotSerializable()
        # The captured_stderr reduces the noise in the test report
        with test.support.captured_stderr():
            q = SafeQueue(ctx=multiprocessing.get_context())
            q.put(not_serializable_obj)

            # Verify that q is still functioning correctly
            q.put(True)
            self.assertTrue(q.get(timeout=1.0))

        # Assert that the serialization and the hook have been called correctly
        self.assertTrue(not_serializable_obj.reduce_was_called)
        self.assertTrue(not_serializable_obj.on_queue_feeder_error_was_called)
#
#
#

class _TestLock(BaseTestCase):

    def test_lock(self):
        lock = self.Lock()
        self.assertEqual(lock.acquire(), True)
        self.assertEqual(lock.acquire(False), False)
        self.assertEqual(lock.release(), None)
        self.assertRaises((ValueError, threading.ThreadError), lock.release)

    def test_rlock(self):
        lock = self.RLock()
        self.assertEqual(lock.acquire(), True)
        self.assertEqual(lock.acquire(), True)
        self.assertEqual(lock.acquire(), True)
        self.assertEqual(lock.release(), None)
        self.assertEqual(lock.release(), None)
        self.assertEqual(lock.release(), None)
        self.assertRaises((AssertionError, RuntimeError), lock.release)

    def test_lock_context(self):
        with self.Lock():
            pass


class _TestSemaphore(BaseTestCase):

    def _test_semaphore(self, sem):
        self.assertReturnsIfImplemented(2, get_value, sem)
        self.assertEqual(sem.acquire(), True)
        self.assertReturnsIfImplemented(1, get_value, sem)
        self.assertEqual(sem.acquire(), True)
        self.assertReturnsIfImplemented(0, get_value, sem)
        self.assertEqual(sem.acquire(False), False)
        self.assertReturnsIfImplemented(0, get_value, sem)
        self.assertEqual(sem.release(), None)
        self.assertReturnsIfImplemented(1, get_value, sem)
        self.assertEqual(sem.release(), None)
        self.assertReturnsIfImplemented(2, get_value, sem)

    def test_semaphore(self):
        sem = self.Semaphore(2)
        self._test_semaphore(sem)
        self.assertEqual(sem.release(), None)
        self.assertReturnsIfImplemented(3, get_value, sem)
        self.assertEqual(sem.release(), None)
        self.assertReturnsIfImplemented(4, get_value, sem)

    def test_bounded_semaphore(self):
        sem = self.BoundedSemaphore(2)
        self._test_semaphore(sem)
        # Currently fails on OS/X
        #if HAVE_GETVALUE:
        #    self.assertRaises(ValueError, sem.release)
        #    self.assertReturnsIfImplemented(2, get_value, sem)

    def test_timeout(self):
        if self.TYPE != 'processes':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        sem = self.Semaphore(0)
        acquire = TimingWrapper(sem.acquire)

        self.assertEqual(acquire(False), False)
        self.assertTimingAlmostEqual(acquire.elapsed, 0.0)

        self.assertEqual(acquire(False, None), False)
        self.assertTimingAlmostEqual(acquire.elapsed, 0.0)

        self.assertEqual(acquire(False, TIMEOUT1), False)
        self.assertTimingAlmostEqual(acquire.elapsed, 0)

        self.assertEqual(acquire(True, TIMEOUT2), False)
        self.assertTimingAlmostEqual(acquire.elapsed, TIMEOUT2)

        self.assertEqual(acquire(timeout=TIMEOUT3), False)
        self.assertTimingAlmostEqual(acquire.elapsed, TIMEOUT3)


class _TestCondition(BaseTestCase):

    @classmethod
    def f(cls, cond, sleeping, woken, timeout=None):
        cond.acquire()
        sleeping.release()
        cond.wait(timeout)
        woken.release()
        cond.release()

    def assertReachesEventually(self, func, value):
        for i in range(10):
            try:
                if func() == value:
                    break
            except NotImplementedError:
                break
            time.sleep(DELTA)
        time.sleep(DELTA)
        self.assertReturnsIfImplemented(value, func)

    def check_invariant(self, cond):
        # this is only supposed to succeed when there are no sleepers
        if self.TYPE == 'processes':
            try:
                sleepers = (cond._sleeping_count.get_value() -
                            cond._woken_count.get_value())
                self.assertEqual(sleepers, 0)
                self.assertEqual(cond._wait_semaphore.get_value(), 0)
            except NotImplementedError:
                pass

    def test_notify(self):
        cond = self.Condition()
        sleeping = self.Semaphore(0)
        woken = self.Semaphore(0)

        p = self.Process(target=self.f, args=(cond, sleeping, woken))
        p.daemon = True
        p.start()
        self.addCleanup(p.join)

        p = threading.Thread(target=self.f, args=(cond, sleeping, woken))
        p.daemon = True
        p.start()
        self.addCleanup(p.join)

        # wait for both children to start sleeping
        sleeping.acquire()
        sleeping.acquire()

        # check no process/thread has woken up
        time.sleep(DELTA)
        self.assertReturnsIfImplemented(0, get_value, woken)

        # wake up one process/thread
        cond.acquire()
        cond.notify()
        cond.release()

        # check one process/thread has woken up
        time.sleep(DELTA)
        self.assertReturnsIfImplemented(1, get_value, woken)

        # wake up another
        cond.acquire()
        cond.notify()
        cond.release()

        # check other has woken up
        time.sleep(DELTA)
        self.assertReturnsIfImplemented(2, get_value, woken)

        # check state is not mucked up
        self.check_invariant(cond)
        p.join()

    def test_notify_all(self):
        cond = self.Condition()
        sleeping = self.Semaphore(0)
        woken = self.Semaphore(0)

        # start some threads/processes which will timeout
        for i in range(3):
            p = self.Process(target=self.f,
                             args=(cond, sleeping, woken, TIMEOUT1))
            p.daemon = True
            p.start()
            self.addCleanup(p.join)

            t = threading.Thread(target=self.f,
                                 args=(cond, sleeping, woken, TIMEOUT1))
            t.daemon = True
            t.start()
            self.addCleanup(t.join)

        # wait for them all to sleep
        for i in range(6):
            sleeping.acquire()

        # check they have all timed out
        for i in range(6):
            woken.acquire()
        self.assertReturnsIfImplemented(0, get_value, woken)

        # check state is not mucked up
        self.check_invariant(cond)

        # start some more threads/processes
        for i in range(3):
            p = self.Process(target=self.f, args=(cond, sleeping, woken))
            p.daemon = True
            p.start()
            self.addCleanup(p.join)

            t = threading.Thread(target=self.f, args=(cond, sleeping, woken))
            t.daemon = True
            t.start()
            self.addCleanup(t.join)

        # wait for them to all sleep
        for i in range(6):
            sleeping.acquire()

        # check no process/thread has woken up
        time.sleep(DELTA)
        self.assertReturnsIfImplemented(0, get_value, woken)

        # wake them all up
        cond.acquire()
        cond.notify_all()
        cond.release()

        # check they have all woken
        self.assertReachesEventually(lambda: get_value(woken), 6)

        # check state is not mucked up
        self.check_invariant(cond)

    def test_notify_n(self):
        cond = self.Condition()
        sleeping = self.Semaphore(0)
        woken = self.Semaphore(0)

        # start some threads/processes
        for i in range(3):
            p = self.Process(target=self.f, args=(cond, sleeping, woken))
            p.daemon = True
            p.start()
            self.addCleanup(p.join)

            t = threading.Thread(target=self.f, args=(cond, sleeping, woken))
            t.daemon = True
            t.start()
            self.addCleanup(t.join)

        # wait for them to all sleep
        for i in range(6):
            sleeping.acquire()

        # check no process/thread has woken up
        time.sleep(DELTA)
        self.assertReturnsIfImplemented(0, get_value, woken)

        # wake some of them up
        cond.acquire()
        cond.notify(n=2)
        cond.release()

        # check 2 have woken
        self.assertReachesEventually(lambda: get_value(woken), 2)

        # wake the rest of them
        cond.acquire()
        cond.notify(n=4)
        cond.release()

        self.assertReachesEventually(lambda: get_value(woken), 6)

        # doesn't do anything more
        cond.acquire()
        cond.notify(n=3)
        cond.release()

        self.assertReturnsIfImplemented(6, get_value, woken)

        # check state is not mucked up
        self.check_invariant(cond)

    def test_timeout(self):
        cond = self.Condition()
        wait = TimingWrapper(cond.wait)
        cond.acquire()
        res = wait(TIMEOUT1)
        cond.release()
        self.assertEqual(res, False)
        self.assertTimingAlmostEqual(wait.elapsed, TIMEOUT1)

    @classmethod
    def _test_waitfor_f(cls, cond, state):
        with cond:
            state.value = 0
            cond.notify()
            result = cond.wait_for(lambda : state.value==4)
            if not result or state.value != 4:
                sys.exit(1)

    @unittest.skipUnless(HAS_SHAREDCTYPES, 'needs sharedctypes')
    def test_waitfor(self):
        # based on test in test/lock_tests.py
        cond = self.Condition()
        state = self.Value('i', -1)

        p = self.Process(target=self._test_waitfor_f, args=(cond, state))
        p.daemon = True
        p.start()

        with cond:
            result = cond.wait_for(lambda : state.value==0)
            self.assertTrue(result)
            self.assertEqual(state.value, 0)

        for i in range(4):
            time.sleep(0.01)
            with cond:
                state.value += 1
                cond.notify()

        join_process(p)
        self.assertEqual(p.exitcode, 0)

    @classmethod
    def _test_waitfor_timeout_f(cls, cond, state, success, sem):
        sem.release()
        with cond:
            expected = 0.1
            dt = time.monotonic()
            result = cond.wait_for(lambda : state.value==4, timeout=expected)
            dt = time.monotonic() - dt
            # borrow logic in assertTimeout() from test/lock_tests.py
            if not result and expected * 0.6 < dt < expected * 10.0:
                success.value = True

    @unittest.skipUnless(HAS_SHAREDCTYPES, 'needs sharedctypes')
    def test_waitfor_timeout(self):
        # based on test in test/lock_tests.py
        cond = self.Condition()
        state = self.Value('i', 0)
        success = self.Value('i', False)
        sem = self.Semaphore(0)

        p = self.Process(target=self._test_waitfor_timeout_f,
                         args=(cond, state, success, sem))
        p.daemon = True
        p.start()
        self.assertTrue(sem.acquire(timeout=TIMEOUT))

        # Only increment 3 times, so state == 4 is never reached.
        for i in range(3):
            time.sleep(0.01)
            with cond:
                state.value += 1
                cond.notify()

        join_process(p)
        self.assertTrue(success.value)

    @classmethod
    def _test_wait_result(cls, c, pid):
        with c:
            c.notify()
        time.sleep(1)
        if pid is not None:
            os.kill(pid, signal.SIGINT)

    def test_wait_result(self):
        if isinstance(self, ProcessesMixin) and sys.platform != 'win32':
            pid = os.getpid()
        else:
            pid = None

        c = self.Condition()
        with c:
            self.assertFalse(c.wait(0))
            self.assertFalse(c.wait(0.1))

            p = self.Process(target=self._test_wait_result, args=(c, pid))
            p.start()

            self.assertTrue(c.wait(60))
            if pid is not None:
                self.assertRaises(KeyboardInterrupt, c.wait, 60)

            p.join()


class _TestEvent(BaseTestCase):

    @classmethod
    def _test_event(cls, event):
        time.sleep(TIMEOUT2)
        event.set()

    def test_event(self):
        event = self.Event()
        wait = TimingWrapper(event.wait)

        # Removed temporarily, due to API shear, this does not
        # work with threading._Event objects. is_set == isSet
        self.assertEqual(event.is_set(), False)

        # Removed, threading.Event.wait() will return the value of the __flag
        # instead of None. API Shear with the semaphore backed mp.Event
        self.assertEqual(wait(0.0), False)
        self.assertTimingAlmostEqual(wait.elapsed, 0.0)
        self.assertEqual(wait(TIMEOUT1), False)
        self.assertTimingAlmostEqual(wait.elapsed, TIMEOUT1)

        event.set()

        # See note above on the API differences
        self.assertEqual(event.is_set(), True)
        self.assertEqual(wait(), True)
        self.assertTimingAlmostEqual(wait.elapsed, 0.0)
        self.assertEqual(wait(TIMEOUT1), True)
        self.assertTimingAlmostEqual(wait.elapsed, 0.0)
        # self.assertEqual(event.is_set(), True)

        event.clear()

        #self.assertEqual(event.is_set(), False)

        p = self.Process(target=self._test_event, args=(event,))
        p.daemon = True
        p.start()
        self.assertEqual(wait(), True)
        p.join()

#
# Tests for Barrier - adapted from tests in test/lock_tests.py
#

# Many of the tests for threading.Barrier use a list as an atomic
# counter: a value is appended to increment the counter, and the
# length of the list gives the value.  We use the class DummyList
# for the same purpose.

class _DummyList(object):

    def __init__(self):
        wrapper = multiprocessing.heap.BufferWrapper(struct.calcsize('i'))
        lock = multiprocessing.Lock()
        self.__setstate__((wrapper, lock))
        self._lengthbuf[0] = 0

    def __setstate__(self, state):
        (self._wrapper, self._lock) = state
        self._lengthbuf = self._wrapper.create_memoryview().cast('i')

    def __getstate__(self):
        return (self._wrapper, self._lock)

    def append(self, _):
        with self._lock:
            self._lengthbuf[0] += 1

    def __len__(self):
        with self._lock:
            return self._lengthbuf[0]

def _wait():
    # A crude wait/yield function not relying on synchronization primitives.
    time.sleep(0.01)


class Bunch(object):
    """
    A bunch of threads.
    """
    def __init__(self, namespace, f, args, n, wait_before_exit=False):
        """
        Construct a bunch of `n` threads running the same function `f`.
        If `wait_before_exit` is True, the threads won't terminate until
        do_finish() is called.
        """
        self.f = f
        self.args = args
        self.n = n
        self.started = namespace.DummyList()
        self.finished = namespace.DummyList()
        self._can_exit = namespace.Event()
        if not wait_before_exit:
            self._can_exit.set()

        threads = []
        for i in range(n):
            p = namespace.Process(target=self.task)
            p.daemon = True
            p.start()
            threads.append(p)

        def finalize(threads):
            for p in threads:
                p.join()

        self._finalizer = weakref.finalize(self, finalize, threads)

    def task(self):
        pid = os.getpid()
        self.started.append(pid)
        try:
            self.f(*self.args)
        finally:
            self.finished.append(pid)
            self._can_exit.wait(30)
            assert self._can_exit.is_set()

    def wait_for_started(self):
        while len(self.started) < self.n:
            _wait()

    def wait_for_finished(self):
        while len(self.finished) < self.n:
            _wait()

    def do_finish(self):
        self._can_exit.set()

    def close(self):
        self._finalizer()


class AppendTrue(object):
    def __init__(self, obj):
        self.obj = obj
    def __call__(self):
        self.obj.append(True)


class _TestBarrier(BaseTestCase):
    """
    Tests for Barrier objects.
    """
    N = 5
    defaultTimeout = 30.0  # XXX Slow Windows buildbots need generous timeout

    def setUp(self):
        self.barrier = self.Barrier(self.N, timeout=self.defaultTimeout)

    def tearDown(self):
        self.barrier.abort()
        self.barrier = None

    def DummyList(self):
        if self.TYPE == 'threads':
            return []
        elif self.TYPE == 'manager':
            return self.manager.list()
        else:
            return _DummyList()

    def run_threads(self, f, args):
        b = Bunch(self, f, args, self.N-1)
        try:
            f(*args)
            b.wait_for_finished()
        finally:
            b.close()

    @classmethod
    def multipass(cls, barrier, results, n):
        m = barrier.parties
        assert m == cls.N
        for i in range(n):
            results[0].append(True)
            assert len(results[1]) == i * m
            barrier.wait()
            results[1].append(True)
            assert len(results[0]) == (i + 1) * m
            barrier.wait()
        try:
            assert barrier.n_waiting == 0
        except NotImplementedError:
            pass
        assert not barrier.broken

    def test_barrier(self, passes=1):
        """
        Test that a barrier is passed in lockstep
        """
        results = [self.DummyList(), self.DummyList()]
        self.run_threads(self.multipass, (self.barrier, results, passes))

    def test_barrier_10(self):
        """
        Test that a barrier works for 10 consecutive runs
        """
        return self.test_barrier(10)

    @classmethod
    def _test_wait_return_f(cls, barrier, queue):
        res = barrier.wait()
        queue.put(res)

    def test_wait_return(self):
        """
        test the return value from barrier.wait
        """
        queue = self.Queue()
        self.run_threads(self._test_wait_return_f, (self.barrier, queue))
        results = [queue.get() for i in range(self.N)]
        self.assertEqual(results.count(0), 1)
        close_queue(queue)

    @classmethod
    def _test_action_f(cls, barrier, results):
        barrier.wait()
        if len(results) != 1:
            raise RuntimeError

    def test_action(self):
        """
        Test the 'action' callback
        """
        results = self.DummyList()
        barrier = self.Barrier(self.N, action=AppendTrue(results))
        self.run_threads(self._test_action_f, (barrier, results))
        self.assertEqual(len(results), 1)

    @classmethod
    def _test_abort_f(cls, barrier, results1, results2):
        try:
            i = barrier.wait()
            if i == cls.N//2:
                raise RuntimeError
            barrier.wait()
            results1.append(True)
        except threading.BrokenBarrierError:
            results2.append(True)
        except RuntimeError:
            barrier.abort()

    def test_abort(self):
        """
        Test that an abort will put the barrier in a broken state
        """
        results1 = self.DummyList()
        results2 = self.DummyList()
        self.run_threads(self._test_abort_f,
                         (self.barrier, results1, results2))
        self.assertEqual(len(results1), 0)
        self.assertEqual(len(results2), self.N-1)
        self.assertTrue(self.barrier.broken)

    @classmethod
    def _test_reset_f(cls, barrier, results1, results2, results3):
        i = barrier.wait()
        if i == cls.N//2:
            # Wait until the other threads are all in the barrier.
            while barrier.n_waiting < cls.N-1:
                time.sleep(0.001)
            barrier.reset()
        else:
            try:
                barrier.wait()
                results1.append(True)
            except threading.BrokenBarrierError:
                results2.append(True)
        # Now, pass the barrier again
        barrier.wait()
        results3.append(True)

    def test_reset(self):
        """
        Test that a 'reset' on a barrier frees the waiting threads
        """
        results1 = self.DummyList()
        results2 = self.DummyList()
        results3 = self.DummyList()
        self.run_threads(self._test_reset_f,
                         (self.barrier, results1, results2, results3))
        self.assertEqual(len(results1), 0)
        self.assertEqual(len(results2), self.N-1)
        self.assertEqual(len(results3), self.N)

    @classmethod
    def _test_abort_and_reset_f(cls, barrier, barrier2,
                                results1, results2, results3):
        try:
            i = barrier.wait()
            if i == cls.N//2:
                raise RuntimeError
            barrier.wait()
            results1.append(True)
        except threading.BrokenBarrierError:
            results2.append(True)
        except RuntimeError:
            barrier.abort()
        # Synchronize and reset the barrier.  Must synchronize first so
        # that everyone has left it when we reset, and after so that no
        # one enters it before the reset.
        if barrier2.wait() == cls.N//2:
            barrier.reset()
        barrier2.wait()
        barrier.wait()
        results3.append(True)

    def test_abort_and_reset(self):
        """
        Test that a barrier can be reset after being broken.
        """
        results1 = self.DummyList()
        results2 = self.DummyList()
        results3 = self.DummyList()
        barrier2 = self.Barrier(self.N)

        self.run_threads(self._test_abort_and_reset_f,
                         (self.barrier, barrier2, results1, results2, results3))
        self.assertEqual(len(results1), 0)
        self.assertEqual(len(results2), self.N-1)
        self.assertEqual(len(results3), self.N)

    @classmethod
    def _test_timeout_f(cls, barrier, results):
        i = barrier.wait()
        if i == cls.N//2:
            # One thread is late!
            time.sleep(1.0)
        try:
            barrier.wait(0.5)
        except threading.BrokenBarrierError:
            results.append(True)

    def test_timeout(self):
        """
        Test wait(timeout)
        """
        results = self.DummyList()
        self.run_threads(self._test_timeout_f, (self.barrier, results))
        self.assertEqual(len(results), self.barrier.parties)

    @classmethod
    def _test_default_timeout_f(cls, barrier, results):
        i = barrier.wait(cls.defaultTimeout)
        if i == cls.N//2:
            # One thread is later than the default timeout
            time.sleep(1.0)
        try:
            barrier.wait()
        except threading.BrokenBarrierError:
            results.append(True)

    def test_default_timeout(self):
        """
        Test the barrier's default timeout
        """
        barrier = self.Barrier(self.N, timeout=0.5)
        results = self.DummyList()
        self.run_threads(self._test_default_timeout_f, (barrier, results))
        self.assertEqual(len(results), barrier.parties)

    def test_single_thread(self):
        b = self.Barrier(1)
        b.wait()
        b.wait()

    @classmethod
    def _test_thousand_f(cls, barrier, passes, conn, lock):
        for i in range(passes):
            barrier.wait()
            with lock:
                conn.send(i)

    def test_thousand(self):
        if self.TYPE == 'manager':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))
        passes = 1000
        lock = self.Lock()
        conn, child_conn = self.Pipe(False)
        for j in range(self.N):
            p = self.Process(target=self._test_thousand_f,
                           args=(self.barrier, passes, child_conn, lock))
            p.start()
            self.addCleanup(p.join)

        for i in range(passes):
            for j in range(self.N):
                self.assertEqual(conn.recv(), i)

#
#
#

class _TestValue(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    codes_values = [
        ('i', 4343, 24234),
        ('d', 3.625, -4.25),
        ('h', -232, 234),
        ('q', 2 ** 33, 2 ** 34),
        ('c', latin('x'), latin('y'))
        ]

    def setUp(self):
        if not HAS_SHAREDCTYPES:
            self.skipTest("requires multiprocessing.sharedctypes")

    @classmethod
    def _test(cls, values):
        for sv, cv in zip(values, cls.codes_values):
            sv.value = cv[2]


    def test_value(self, raw=False):
        if raw:
            values = [self.RawValue(code, value)
                      for code, value, _ in self.codes_values]
        else:
            values = [self.Value(code, value)
                      for code, value, _ in self.codes_values]

        for sv, cv in zip(values, self.codes_values):
            self.assertEqual(sv.value, cv[1])

        proc = self.Process(target=self._test, args=(values,))
        proc.daemon = True
        proc.start()
        proc.join()

        for sv, cv in zip(values, self.codes_values):
            self.assertEqual(sv.value, cv[2])

    def test_rawvalue(self):
        self.test_value(raw=True)

    def test_getobj_getlock(self):
        val1 = self.Value('i', 5)
        lock1 = val1.get_lock()
        obj1 = val1.get_obj()

        val2 = self.Value('i', 5, lock=None)
        lock2 = val2.get_lock()
        obj2 = val2.get_obj()

        lock = self.Lock()
        val3 = self.Value('i', 5, lock=lock)
        lock3 = val3.get_lock()
        obj3 = val3.get_obj()
        self.assertEqual(lock, lock3)

        arr4 = self.Value('i', 5, lock=False)
        self.assertFalse(hasattr(arr4, 'get_lock'))
        self.assertFalse(hasattr(arr4, 'get_obj'))

        self.assertRaises(AttributeError, self.Value, 'i', 5, lock='navalue')

        arr5 = self.RawValue('i', 5)
        self.assertFalse(hasattr(arr5, 'get_lock'))
        self.assertFalse(hasattr(arr5, 'get_obj'))


class _TestArray(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    @classmethod
    def f(cls, seq):
        for i in range(1, len(seq)):
            seq[i] += seq[i-1]

    @unittest.skipIf(c_int is None, "requires _ctypes")
    def test_array(self, raw=False):
        seq = [680, 626, 934, 821, 150, 233, 548, 982, 714, 831]
        if raw:
            arr = self.RawArray('i', seq)
        else:
            arr = self.Array('i', seq)

        self.assertEqual(len(arr), len(seq))
        self.assertEqual(arr[3], seq[3])
        self.assertEqual(list(arr[2:7]), list(seq[2:7]))

        arr[4:8] = seq[4:8] = array.array('i', [1, 2, 3, 4])

        self.assertEqual(list(arr[:]), seq)

        self.f(seq)

        p = self.Process(target=self.f, args=(arr,))
        p.daemon = True
        p.start()
        p.join()

        self.assertEqual(list(arr[:]), seq)

    @unittest.skipIf(c_int is None, "requires _ctypes")
    def test_array_from_size(self):
        size = 10
        # Test for zeroing (see issue #11675).
        # The repetition below strengthens the test by increasing the chances
        # of previously allocated non-zero memory being used for the new array
        # on the 2nd and 3rd loops.
        for _ in range(3):
            arr = self.Array('i', size)
            self.assertEqual(len(arr), size)
            self.assertEqual(list(arr), [0] * size)
            arr[:] = range(10)
            self.assertEqual(list(arr), list(range(10)))
            del arr

    @unittest.skipIf(c_int is None, "requires _ctypes")
    def test_rawarray(self):
        self.test_array(raw=True)

    @unittest.skipIf(c_int is None, "requires _ctypes")
    def test_getobj_getlock_obj(self):
        arr1 = self.Array('i', list(range(10)))
        lock1 = arr1.get_lock()
        obj1 = arr1.get_obj()

        arr2 = self.Array('i', list(range(10)), lock=None)
        lock2 = arr2.get_lock()
        obj2 = arr2.get_obj()

        lock = self.Lock()
        arr3 = self.Array('i', list(range(10)), lock=lock)
        lock3 = arr3.get_lock()
        obj3 = arr3.get_obj()
        self.assertEqual(lock, lock3)

        arr4 = self.Array('i', range(10), lock=False)
        self.assertFalse(hasattr(arr4, 'get_lock'))
        self.assertFalse(hasattr(arr4, 'get_obj'))
        self.assertRaises(AttributeError,
                          self.Array, 'i', range(10), lock='notalock')

        arr5 = self.RawArray('i', range(10))
        self.assertFalse(hasattr(arr5, 'get_lock'))
        self.assertFalse(hasattr(arr5, 'get_obj'))

#
#
#

class _TestContainers(BaseTestCase):

    ALLOWED_TYPES = ('manager',)

    def test_list(self):
        a = self.list(list(range(10)))
        self.assertEqual(a[:], list(range(10)))

        b = self.list()
        self.assertEqual(b[:], [])

        b.extend(list(range(5)))
        self.assertEqual(b[:], list(range(5)))

        self.assertEqual(b[2], 2)
        self.assertEqual(b[2:10], [2,3,4])

        b *= 2
        self.assertEqual(b[:], [0, 1, 2, 3, 4, 0, 1, 2, 3, 4])

        self.assertEqual(b + [5, 6], [0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6])

        self.assertEqual(a[:], list(range(10)))

        d = [a, b]
        e = self.list(d)
        self.assertEqual(
            [element[:] for element in e],
            [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]]
            )

        f = self.list([a])
        a.append('hello')
        self.assertEqual(f[0][:], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'hello'])

    def test_list_iter(self):
        a = self.list(list(range(10)))
        it = iter(a)
        self.assertEqual(list(it), list(range(10)))
        self.assertEqual(list(it), [])  # exhausted
        # list modified during iteration
        it = iter(a)
        a[0] = 100
        self.assertEqual(next(it), 100)

    def test_list_proxy_in_list(self):
        a = self.list([self.list(range(3)) for _i in range(3)])
        self.assertEqual([inner[:] for inner in a], [[0, 1, 2]] * 3)

        a[0][-1] = 55
        self.assertEqual(a[0][:], [0, 1, 55])
        for i in range(1, 3):
            self.assertEqual(a[i][:], [0, 1, 2])

        self.assertEqual(a[1].pop(), 2)
        self.assertEqual(len(a[1]), 2)
        for i in range(0, 3, 2):
            self.assertEqual(len(a[i]), 3)

        del a

        b = self.list()
        b.append(b)
        del b

    def test_dict(self):
        d = self.dict()
        indices = list(range(65, 70))
        for i in indices:
            d[i] = chr(i)
        self.assertEqual(d.copy(), dict((i, chr(i)) for i in indices))
        self.assertEqual(sorted(d.keys()), indices)
        self.assertEqual(sorted(d.values()), [chr(i) for i in indices])
        self.assertEqual(sorted(d.items()), [(i, chr(i)) for i in indices])

    def test_dict_iter(self):
        d = self.dict()
        indices = list(range(65, 70))
        for i in indices:
            d[i] = chr(i)
        it = iter(d)
        self.assertEqual(list(it), indices)
        self.assertEqual(list(it), [])  # exhausted
        # dictionary changed size during iteration
        it = iter(d)
        d.clear()
        self.assertRaises(RuntimeError, next, it)

    def test_dict_proxy_nested(self):
        pets = self.dict(ferrets=2, hamsters=4)
        supplies = self.dict(water=10, feed=3)
        d = self.dict(pets=pets, supplies=supplies)

        self.assertEqual(supplies['water'], 10)
        self.assertEqual(d['supplies']['water'], 10)

        d['supplies']['blankets'] = 5
        self.assertEqual(supplies['blankets'], 5)
        self.assertEqual(d['supplies']['blankets'], 5)

        d['supplies']['water'] = 7
        self.assertEqual(supplies['water'], 7)
        self.assertEqual(d['supplies']['water'], 7)

        del pets
        del supplies
        self.assertEqual(d['pets']['ferrets'], 2)
        d['supplies']['blankets'] = 11
        self.assertEqual(d['supplies']['blankets'], 11)

        pets = d['pets']
        supplies = d['supplies']
        supplies['water'] = 7
        self.assertEqual(supplies['water'], 7)
        self.assertEqual(d['supplies']['water'], 7)

        d.clear()
        self.assertEqual(len(d), 0)
        self.assertEqual(supplies['water'], 7)
        self.assertEqual(pets['hamsters'], 4)

        l = self.list([pets, supplies])
        l[0]['marmots'] = 1
        self.assertEqual(pets['marmots'], 1)
        self.assertEqual(l[0]['marmots'], 1)

        del pets
        del supplies
        self.assertEqual(l[0]['marmots'], 1)

        outer = self.list([[88, 99], l])
        self.assertIsInstance(outer[0], list)  # Not a ListProxy
        self.assertEqual(outer[-1][-1]['feed'], 3)

    def test_namespace(self):
        n = self.Namespace()
        n.name = 'Bob'
        n.job = 'Builder'
        n._hidden = 'hidden'
        self.assertEqual((n.name, n.job), ('Bob', 'Builder'))
        del n.job
        self.assertEqual(str(n), "Namespace(name='Bob')")
        self.assertTrue(hasattr(n, 'name'))
        self.assertTrue(not hasattr(n, 'job'))

#
#
#

def sqr(x, wait=0.0):
    time.sleep(wait)
    return x*x

def mul(x, y):
    return x*y

def raise_large_valuerror(wait):
    time.sleep(wait)
    raise ValueError("x" * 1024**2)

def identity(x):
    return x

class CountedObject(object):
    n_instances = 0

    def __new__(cls):
        cls.n_instances += 1
        return object.__new__(cls)

    def __del__(self):
        type(self).n_instances -= 1

class SayWhenError(ValueError): pass

def exception_throwing_generator(total, when):
    if when == -1:
        raise SayWhenError("Somebody said when")
    for i in range(total):
        if i == when:
            raise SayWhenError("Somebody said when")
        yield i


class _TestPool(BaseTestCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.pool = cls.Pool(4)

    @classmethod
    def tearDownClass(cls):
        cls.pool.terminate()
        cls.pool.join()
        cls.pool = None
        super().tearDownClass()

    def test_apply(self):
        papply = self.pool.apply
        self.assertEqual(papply(sqr, (5,)), sqr(5))
        self.assertEqual(papply(sqr, (), {'x':3}), sqr(x=3))

    def test_map(self):
        pmap = self.pool.map
        self.assertEqual(pmap(sqr, list(range(10))), list(map(sqr, list(range(10)))))
        self.assertEqual(pmap(sqr, list(range(100)), chunksize=20),
                         list(map(sqr, list(range(100)))))

    def test_starmap(self):
        psmap = self.pool.starmap
        tuples = list(zip(range(10), range(9,-1, -1)))
        self.assertEqual(psmap(mul, tuples),
                         list(itertools.starmap(mul, tuples)))
        tuples = list(zip(range(100), range(99,-1, -1)))
        self.assertEqual(psmap(mul, tuples, chunksize=20),
                         list(itertools.starmap(mul, tuples)))

    def test_starmap_async(self):
        tuples = list(zip(range(100), range(99,-1, -1)))
        self.assertEqual(self.pool.starmap_async(mul, tuples).get(),
                         list(itertools.starmap(mul, tuples)))

    def test_map_async(self):
        self.assertEqual(self.pool.map_async(sqr, list(range(10))).get(),
                         list(map(sqr, list(range(10)))))

    def test_map_async_callbacks(self):
        call_args = self.manager.list() if self.TYPE == 'manager' else []
        self.pool.map_async(int, ['1'],
                            callback=call_args.append,
                            error_callback=call_args.append).wait()
        self.assertEqual(1, len(call_args))
        self.assertEqual([1], call_args[0])
        self.pool.map_async(int, ['a'],
                            callback=call_args.append,
                            error_callback=call_args.append).wait()
        self.assertEqual(2, len(call_args))
        self.assertIsInstance(call_args[1], ValueError)

    def test_map_unplicklable(self):
        # Issue #19425 -- failure to pickle should not cause a hang
        if self.TYPE == 'threads':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))
        class A(object):
            def __reduce__(self):
                raise RuntimeError('cannot pickle')
        with self.assertRaises(RuntimeError):
            self.pool.map(sqr, [A()]*10)

    def test_map_chunksize(self):
        try:
            self.pool.map_async(sqr, [], chunksize=1).get(timeout=TIMEOUT1)
        except multiprocessing.TimeoutError:
            self.fail("pool.map_async with chunksize stalled on null list")

    def test_map_handle_iterable_exception(self):
        if self.TYPE == 'manager':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        # SayWhenError seen at the very first of the iterable
        with self.assertRaises(SayWhenError):
            self.pool.map(sqr, exception_throwing_generator(1, -1), 1)
        # again, make sure it's reentrant
        with self.assertRaises(SayWhenError):
            self.pool.map(sqr, exception_throwing_generator(1, -1), 1)

        with self.assertRaises(SayWhenError):
            self.pool.map(sqr, exception_throwing_generator(10, 3), 1)

        class SpecialIterable:
            def __iter__(self):
                return self
            def __next__(self):
                raise SayWhenError
            def __len__(self):
                return 1
        with self.assertRaises(SayWhenError):
            self.pool.map(sqr, SpecialIterable(), 1)
        with self.assertRaises(SayWhenError):
            self.pool.map(sqr, SpecialIterable(), 1)

    def test_async(self):
        res = self.pool.apply_async(sqr, (7, TIMEOUT1,))
        get = TimingWrapper(res.get)
        self.assertEqual(get(), 49)
        self.assertTimingAlmostEqual(get.elapsed, TIMEOUT1)

    def test_async_timeout(self):
        res = self.pool.apply_async(sqr, (6, TIMEOUT2 + 1.0))
        get = TimingWrapper(res.get)
        self.assertRaises(multiprocessing.TimeoutError, get, timeout=TIMEOUT2)
        self.assertTimingAlmostEqual(get.elapsed, TIMEOUT2)

    def test_imap(self):
        it = self.pool.imap(sqr, list(range(10)))
        self.assertEqual(list(it), list(map(sqr, list(range(10)))))

        it = self.pool.imap(sqr, list(range(10)))
        for i in range(10):
            self.assertEqual(next(it), i*i)
        self.assertRaises(StopIteration, it.__next__)

        it = self.pool.imap(sqr, list(range(1000)), chunksize=100)
        for i in range(1000):
            self.assertEqual(next(it), i*i)
        self.assertRaises(StopIteration, it.__next__)

    def test_imap_handle_iterable_exception(self):
        if self.TYPE == 'manager':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        # SayWhenError seen at the very first of the iterable
        it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
        self.assertRaises(SayWhenError, it.__next__)
        # again, make sure it's reentrant
        it = self.pool.imap(sqr, exception_throwing_generator(1, -1), 1)
        self.assertRaises(SayWhenError, it.__next__)

        it = self.pool.imap(sqr, exception_throwing_generator(10, 3), 1)
        for i in range(3):
            self.assertEqual(next(it), i*i)
        self.assertRaises(SayWhenError, it.__next__)

        # SayWhenError seen at start of problematic chunk's results
        it = self.pool.imap(sqr, exception_throwing_generator(20, 7), 2)
        for i in range(6):
            self.assertEqual(next(it), i*i)
        self.assertRaises(SayWhenError, it.__next__)
        it = self.pool.imap(sqr, exception_throwing_generator(20, 7), 4)
        for i in range(4):
            self.assertEqual(next(it), i*i)
        self.assertRaises(SayWhenError, it.__next__)

    def test_imap_unordered(self):
        it = self.pool.imap_unordered(sqr, list(range(10)))
        self.assertEqual(sorted(it), list(map(sqr, list(range(10)))))

        it = self.pool.imap_unordered(sqr, list(range(1000)), chunksize=100)
        self.assertEqual(sorted(it), list(map(sqr, list(range(1000)))))

    def test_imap_unordered_handle_iterable_exception(self):
        if self.TYPE == 'manager':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        # SayWhenError seen at the very first of the iterable
        it = self.pool.imap_unordered(sqr,
                                      exception_throwing_generator(1, -1),
                                      1)
        self.assertRaises(SayWhenError, it.__next__)
        # again, make sure it's reentrant
        it = self.pool.imap_unordered(sqr,
                                      exception_throwing_generator(1, -1),
                                      1)
        self.assertRaises(SayWhenError, it.__next__)

        it = self.pool.imap_unordered(sqr,
                                      exception_throwing_generator(10, 3),
                                      1)
        expected_values = list(map(sqr, list(range(10))))
        with self.assertRaises(SayWhenError):
            # imap_unordered makes it difficult to anticipate the SayWhenError
            for i in range(10):
                value = next(it)
                self.assertIn(value, expected_values)
                expected_values.remove(value)

        it = self.pool.imap_unordered(sqr,
                                      exception_throwing_generator(20, 7),
                                      2)
        expected_values = list(map(sqr, list(range(20))))
        with self.assertRaises(SayWhenError):
            for i in range(20):
                value = next(it)
                self.assertIn(value, expected_values)
                expected_values.remove(value)

    def test_make_pool(self):
        expected_error = (RemoteError if self.TYPE == 'manager'
                          else ValueError)

        self.assertRaises(expected_error, self.Pool, -1)
        self.assertRaises(expected_error, self.Pool, 0)

        if self.TYPE != 'manager':
            p = self.Pool(3)
            try:
                self.assertEqual(3, len(p._pool))
            finally:
                p.close()
                p.join()

    def test_terminate(self):
        result = self.pool.map_async(
            time.sleep, [0.1 for i in range(10000)], chunksize=1
            )
        self.pool.terminate()
        join = TimingWrapper(self.pool.join)
        join()
        # Sanity check the pool didn't wait for all tasks to finish
        self.assertLess(join.elapsed, 2.0)

    def test_empty_iterable(self):
        # See Issue 12157
        p = self.Pool(1)

        self.assertEqual(p.map(sqr, []), [])
        self.assertEqual(list(p.imap(sqr, [])), [])
        self.assertEqual(list(p.imap_unordered(sqr, [])), [])
        self.assertEqual(p.map_async(sqr, []).get(), [])

        p.close()
        p.join()

    def test_context(self):
        if self.TYPE == 'processes':
            L = list(range(10))
            expected = [sqr(i) for i in L]
            with self.Pool(2) as p:
                r = p.map_async(sqr, L)
                self.assertEqual(r.get(), expected)
            p.join()
            self.assertRaises(ValueError, p.map_async, sqr, L)

    @classmethod
    def _test_traceback(cls):
        raise RuntimeError(123) # some comment

    def test_traceback(self):
        # We want ensure that the traceback from the child process is
        # contained in the traceback raised in the main process.
        if self.TYPE == 'processes':
            with self.Pool(1) as p:
                try:
                    p.apply(self._test_traceback)
                except Exception as e:
                    exc = e
                else:
                    self.fail('expected RuntimeError')
            p.join()
            self.assertIs(type(exc), RuntimeError)
            self.assertEqual(exc.args, (123,))
            cause = exc.__cause__
            self.assertIs(type(cause), multiprocessing.pool.RemoteTraceback)
            self.assertIn('raise RuntimeError(123) # some comment', cause.tb)

            with test.support.captured_stderr() as f1:
                try:
                    raise exc
                except RuntimeError:
                    sys.excepthook(*sys.exc_info())
            self.assertIn('raise RuntimeError(123) # some comment',
                          f1.getvalue())
            # _helper_reraises_exception should not make the error
            # a remote exception
            with self.Pool(1) as p:
                try:
                    p.map(sqr, exception_throwing_generator(1, -1), 1)
                except Exception as e:
                    exc = e
                else:
                    self.fail('expected SayWhenError')
                self.assertIs(type(exc), SayWhenError)
                self.assertIs(exc.__cause__, None)
            p.join()

    @classmethod
    def _test_wrapped_exception(cls):
        raise RuntimeError('foo')

    def test_wrapped_exception(self):
        # Issue #20980: Should not wrap exception when using thread pool
        with self.Pool(1) as p:
            with self.assertRaises(RuntimeError):
                p.apply(self._test_wrapped_exception)
        p.join()

    def test_map_no_failfast(self):
        # Issue #23992: the fail-fast behaviour when an exception is raised
        # during map() would make Pool.join() deadlock, because a worker
        # process would fill the result queue (after the result handler thread
        # terminated, hence not draining it anymore).

        t_start = time.monotonic()

        with self.assertRaises(ValueError):
            with self.Pool(2) as p:
                try:
                    p.map(raise_large_valuerror, [0, 1])
                finally:
                    time.sleep(0.5)
                    p.close()
                    p.join()

        # check that we indeed waited for all jobs
        self.assertGreater(time.monotonic() - t_start, 0.9)

    def test_release_task_refs(self):
        # Issue #29861: task arguments and results should not be kept
        # alive after we are done with them.
        objs = [CountedObject() for i in range(10)]
        refs = [weakref.ref(o) for o in objs]
        self.pool.map(identity, objs)

        del objs
        time.sleep(DELTA)  # let threaded cleanup code run
        self.assertEqual(set(wr() for wr in refs), {None})
        # With a process pool, copies of the objects are returned, check
        # they were released too.
        self.assertEqual(CountedObject.n_instances, 0)


def raising():
    raise KeyError("key")

def unpickleable_result():
    return lambda: 42

class _TestPoolWorkerErrors(BaseTestCase):
    ALLOWED_TYPES = ('processes', )

    def test_async_error_callback(self):
        p = multiprocessing.Pool(2)

        scratchpad = [None]
        def errback(exc):
            scratchpad[0] = exc

        res = p.apply_async(raising, error_callback=errback)
        self.assertRaises(KeyError, res.get)
        self.assertTrue(scratchpad[0])
        self.assertIsInstance(scratchpad[0], KeyError)

        p.close()
        p.join()

    def test_unpickleable_result(self):
        from multiprocessing.pool import MaybeEncodingError
        p = multiprocessing.Pool(2)

        # Make sure we don't lose pool processes because of encoding errors.
        for iteration in range(20):

            scratchpad = [None]
            def errback(exc):
                scratchpad[0] = exc

            res = p.apply_async(unpickleable_result, error_callback=errback)
            self.assertRaises(MaybeEncodingError, res.get)
            wrapped = scratchpad[0]
            self.assertTrue(wrapped)
            self.assertIsInstance(scratchpad[0], MaybeEncodingError)
            self.assertIsNotNone(wrapped.exc)
            self.assertIsNotNone(wrapped.value)

        p.close()
        p.join()

class _TestPoolWorkerLifetime(BaseTestCase):
    ALLOWED_TYPES = ('processes', )

    def test_pool_worker_lifetime(self):
        p = multiprocessing.Pool(3, maxtasksperchild=10)
        self.assertEqual(3, len(p._pool))
        origworkerpids = [w.pid for w in p._pool]
        # Run many tasks so each worker gets replaced (hopefully)
        results = []
        for i in range(100):
            results.append(p.apply_async(sqr, (i, )))
        # Fetch the results and verify we got the right answers,
        # also ensuring all the tasks have completed.
        for (j, res) in enumerate(results):
            self.assertEqual(res.get(), sqr(j))
        # Refill the pool
        p._repopulate_pool()
        # Wait until all workers are alive
        # (countdown * DELTA = 5 seconds max startup process time)
        countdown = 50
        while countdown and not all(w.is_alive() for w in p._pool):
            countdown -= 1
            time.sleep(DELTA)
        finalworkerpids = [w.pid for w in p._pool]
        # All pids should be assigned.  See issue #7805.
        self.assertNotIn(None, origworkerpids)
        self.assertNotIn(None, finalworkerpids)
        # Finally, check that the worker pids have changed
        self.assertNotEqual(sorted(origworkerpids), sorted(finalworkerpids))
        p.close()
        p.join()

    def test_pool_worker_lifetime_early_close(self):
        # Issue #10332: closing a pool whose workers have limited lifetimes
        # before all the tasks completed would make join() hang.
        p = multiprocessing.Pool(3, maxtasksperchild=1)
        results = []
        for i in range(6):
            results.append(p.apply_async(sqr, (i, 0.3)))
        p.close()
        p.join()
        # check the results
        for (j, res) in enumerate(results):
            self.assertEqual(res.get(), sqr(j))

#
# Test of creating a customized manager class
#

from multiprocessing.managers import BaseManager, BaseProxy, RemoteError

class FooBar(object):
    def f(self):
        return 'f()'
    def g(self):
        raise ValueError
    def _h(self):
        return '_h()'

def baz():
    for i in range(10):
        yield i*i

class IteratorProxy(BaseProxy):
    _exposed_ = ('__next__',)
    def __iter__(self):
        return self
    def __next__(self):
        return self._callmethod('__next__')

class MyManager(BaseManager):
    pass

MyManager.register('Foo', callable=FooBar)
MyManager.register('Bar', callable=FooBar, exposed=('f', '_h'))
MyManager.register('baz', callable=baz, proxytype=IteratorProxy)


class _TestMyManager(BaseTestCase):

    ALLOWED_TYPES = ('manager',)

    def test_mymanager(self):
        manager = MyManager()
        manager.start()
        self.common(manager)
        manager.shutdown()

        # bpo-30356: BaseManager._finalize_manager() sends SIGTERM
        # to the manager process if it takes longer than 1 second to stop,
        # which happens on slow buildbots.
        self.assertIn(manager._process.exitcode, (0, -signal.SIGTERM))

    def test_mymanager_context(self):
        with MyManager() as manager:
            self.common(manager)
        # bpo-30356: BaseManager._finalize_manager() sends SIGTERM
        # to the manager process if it takes longer than 1 second to stop,
        # which happens on slow buildbots.
        self.assertIn(manager._process.exitcode, (0, -signal.SIGTERM))

    def test_mymanager_context_prestarted(self):
        manager = MyManager()
        manager.start()
        with manager:
            self.common(manager)
        self.assertEqual(manager._process.exitcode, 0)

    def common(self, manager):
        foo = manager.Foo()
        bar = manager.Bar()
        baz = manager.baz()

        foo_methods = [name for name in ('f', 'g', '_h') if hasattr(foo, name)]
        bar_methods = [name for name in ('f', 'g', '_h') if hasattr(bar, name)]

        self.assertEqual(foo_methods, ['f', 'g'])
        self.assertEqual(bar_methods, ['f', '_h'])

        self.assertEqual(foo.f(), 'f()')
        self.assertRaises(ValueError, foo.g)
        self.assertEqual(foo._callmethod('f'), 'f()')
        self.assertRaises(RemoteError, foo._callmethod, '_h')

        self.assertEqual(bar.f(), 'f()')
        self.assertEqual(bar._h(), '_h()')
        self.assertEqual(bar._callmethod('f'), 'f()')
        self.assertEqual(bar._callmethod('_h'), '_h()')

        self.assertEqual(list(baz), [i*i for i in range(10)])


#
# Test of connecting to a remote server and using xmlrpclib for serialization
#

_queue = pyqueue.Queue()
def get_queue():
    return _queue

class QueueManager(BaseManager):
    '''manager class used by server process'''
QueueManager.register('get_queue', callable=get_queue)

class QueueManager2(BaseManager):
    '''manager class which specifies the same interface as QueueManager'''
QueueManager2.register('get_queue')


SERIALIZER = 'xmlrpclib'

class _TestRemoteManager(BaseTestCase):

    ALLOWED_TYPES = ('manager',)
    values = ['hello world', None, True, 2.25,
              'hall\xe5 v\xe4rlden',
              '\u043f\u0440\u0438\u0432\u0456\u0442 \u0441\u0432\u0456\u0442',
              b'hall\xe5 v\xe4rlden',
             ]
    result = values[:]

    @classmethod
    def _putter(cls, address, authkey):
        manager = QueueManager2(
            address=address, authkey=authkey, serializer=SERIALIZER
            )
        manager.connect()
        queue = manager.get_queue()
        # Note that xmlrpclib will deserialize object as a list not a tuple
        queue.put(tuple(cls.values))

    def test_remote(self):
        authkey = os.urandom(32)

        manager = QueueManager(
            address=(test.support.HOST, 0), authkey=authkey, serializer=SERIALIZER
            )
        manager.start()
        self.addCleanup(manager.shutdown)

        p = self.Process(target=self._putter, args=(manager.address, authkey))
        p.daemon = True
        p.start()

        manager2 = QueueManager2(
            address=manager.address, authkey=authkey, serializer=SERIALIZER
            )
        manager2.connect()
        queue = manager2.get_queue()

        self.assertEqual(queue.get(), self.result)

        # Because we are using xmlrpclib for serialization instead of
        # pickle this will cause a serialization error.
        self.assertRaises(Exception, queue.put, time.sleep)

        # Make queue finalizer run before the server is stopped
        del queue

class _TestManagerRestart(BaseTestCase):

    @classmethod
    def _putter(cls, address, authkey):
        manager = QueueManager(
            address=address, authkey=authkey, serializer=SERIALIZER)
        manager.connect()
        queue = manager.get_queue()
        queue.put('hello world')

    def test_rapid_restart(self):
        authkey = os.urandom(32)
        manager = QueueManager(
            address=(test.support.HOST, 0), authkey=authkey, serializer=SERIALIZER)
        try:
            srvr = manager.get_server()
            addr = srvr.address
            # Close the connection.Listener socket which gets opened as a part
            # of manager.get_server(). It's not needed for the test.
            srvr.listener.close()
            manager.start()

            p = self.Process(target=self._putter, args=(manager.address, authkey))
            p.start()
            p.join()
            queue = manager.get_queue()
            self.assertEqual(queue.get(), 'hello world')
            del queue
        finally:
            if hasattr(manager, "shutdown"):
                manager.shutdown()

        manager = QueueManager(
            address=addr, authkey=authkey, serializer=SERIALIZER)
        try:
            manager.start()
            self.addCleanup(manager.shutdown)
        except OSError as e:
            if e.errno != errno.EADDRINUSE:
                raise
            # Retry after some time, in case the old socket was lingering
            # (sporadic failure on buildbots)
            time.sleep(1.0)
            manager = QueueManager(
                address=addr, authkey=authkey, serializer=SERIALIZER)
            if hasattr(manager, "shutdown"):
                self.addCleanup(manager.shutdown)

#
#
#

SENTINEL = latin('')

class _TestConnection(BaseTestCase):

    ALLOWED_TYPES = ('processes', 'threads')

    @classmethod
    def _echo(cls, conn):
        for msg in iter(conn.recv_bytes, SENTINEL):
            conn.send_bytes(msg)
        conn.close()

    def test_connection(self):
        conn, child_conn = self.Pipe()

        p = self.Process(target=self._echo, args=(child_conn,))
        p.daemon = True
        p.start()

        seq = [1, 2.25, None]
        msg = latin('hello world')
        longmsg = msg * 10
        arr = array.array('i', list(range(4)))

        if self.TYPE == 'processes':
            self.assertEqual(type(conn.fileno()), int)

        self.assertEqual(conn.send(seq), None)
        self.assertEqual(conn.recv(), seq)

        self.assertEqual(conn.send_bytes(msg), None)
        self.assertEqual(conn.recv_bytes(), msg)

        if self.TYPE == 'processes':
            buffer = array.array('i', [0]*10)
            expected = list(arr) + [0] * (10 - len(arr))
            self.assertEqual(conn.send_bytes(arr), None)
            self.assertEqual(conn.recv_bytes_into(buffer),
                             len(arr) * buffer.itemsize)
            self.assertEqual(list(buffer), expected)

            buffer = array.array('i', [0]*10)
            expected = [0] * 3 + list(arr) + [0] * (10 - 3 - len(arr))
            self.assertEqual(conn.send_bytes(arr), None)
            self.assertEqual(conn.recv_bytes_into(buffer, 3 * buffer.itemsize),
                             len(arr) * buffer.itemsize)
            self.assertEqual(list(buffer), expected)

            buffer = bytearray(latin(' ' * 40))
            self.assertEqual(conn.send_bytes(longmsg), None)
            try:
                res = conn.recv_bytes_into(buffer)
            except multiprocessing.BufferTooShort as e:
                self.assertEqual(e.args, (longmsg,))
            else:
                self.fail('expected BufferTooShort, got %s' % res)

        poll = TimingWrapper(conn.poll)

        self.assertEqual(poll(), False)
        self.assertTimingAlmostEqual(poll.elapsed, 0)

        self.assertEqual(poll(-1), False)
        self.assertTimingAlmostEqual(poll.elapsed, 0)

        self.assertEqual(poll(TIMEOUT1), False)
        self.assertTimingAlmostEqual(poll.elapsed, TIMEOUT1)

        conn.send(None)
        time.sleep(.1)

        self.assertEqual(poll(TIMEOUT1), True)
        self.assertTimingAlmostEqual(poll.elapsed, 0)

        self.assertEqual(conn.recv(), None)

        really_big_msg = latin('X') * (1024 * 1024 * 16)   # 16Mb
        conn.send_bytes(really_big_msg)
        self.assertEqual(conn.recv_bytes(), really_big_msg)

        conn.send_bytes(SENTINEL)                          # tell child to quit
        child_conn.close()

        if self.TYPE == 'processes':
            self.assertEqual(conn.readable, True)
            self.assertEqual(conn.writable, True)
            self.assertRaises(EOFError, conn.recv)
            self.assertRaises(EOFError, conn.recv_bytes)

        p.join()

    def test_duplex_false(self):
        reader, writer = self.Pipe(duplex=False)
        self.assertEqual(writer.send(1), None)
        self.assertEqual(reader.recv(), 1)
        if self.TYPE == 'processes':
            self.assertEqual(reader.readable, True)
            self.assertEqual(reader.writable, False)
            self.assertEqual(writer.readable, False)
            self.assertEqual(writer.writable, True)
            self.assertRaises(OSError, reader.send, 2)
            self.assertRaises(OSError, writer.recv)
            self.assertRaises(OSError, writer.poll)

    def test_spawn_close(self):
        # We test that a pipe connection can be closed by parent
        # process immediately after child is spawned.  On Windows this
        # would have sometimes failed on old versions because
        # child_conn would be closed before the child got a chance to
        # duplicate it.
        conn, child_conn = self.Pipe()

        p = self.Process(target=self._echo, args=(child_conn,))
        p.daemon = True
        p.start()
        child_conn.close()    # this might complete before child initializes

        msg = latin('hello')
        conn.send_bytes(msg)
        self.assertEqual(conn.recv_bytes(), msg)

        conn.send_bytes(SENTINEL)
        conn.close()
        p.join()

    def test_sendbytes(self):
        if self.TYPE != 'processes':
            self.skipTest('test not appropriate for {}'.format(self.TYPE))

        msg = latin('abcdefghijklmnopqrstuvwxyz')
        a, b = self.Pipe()

        a.send_bytes(msg)
        self.assertEqual(b.recv_bytes(), msg)

        a.send_bytes(msg, 5)
        self.assertEqual(b.recv_bytes(), msg[5:])

        a.send_bytes(msg, 7, 8)
        self.assertEqual(b.recv_bytes(), msg[7:7+8])

        a.send_bytes(msg, 26)
        self.assertEqual(b.recv_bytes(), latin(''))

        a.send_bytes(msg, 26, 0)
        self.assertEqual(b.recv_bytes(), latin(''))

        self.assertRaises(ValueError, a.send_bytes, msg, 27)

        self.assertRaises(ValueError, a.send_bytes, msg, 22, 5)

        self.assertRaises(ValueError, a.send_bytes, msg, 26, 1)

        self.assertRaises(ValueError, a.send_bytes, msg, -1)

        self.assertRaises(ValueError, a.send_bytes, msg, 4, -1)

    @classmethod
    def _is_fd_assigned(cls, fd):
        try:
            os.fstat(fd)
        except OSError as e:
            if e.errno == errno.EBADF:
                return False
            raise
        else:
            return True

    @classmethod
    def _writefd(cls, conn, data, create_dummy_fds=False):
        if create_dummy_fds:
            for i in range(0, 256):
                if not cls._is_fd_assigned(i):
                    os.dup2(conn.fileno(), i)
        fd = reduction.recv_handle(conn)
        if msvcrt:
            fd = msvcrt.open_osfhandle(fd, os.O_WRONLY)
        os.write(fd, data)
        os.close(fd)

    @unittest.skipUnless(HAS_REDUCTION, "test needs multiprocessing.reduction")
    def test_fd_transfer(self):
        if self.TYPE != 'processes':
            self.skipTest("only makes sense with processes")
        conn, child_conn = self.Pipe(duplex=True)

        p = self.Process(target=self._writefd, args=(child_conn, b"foo"))
        p.daemon = True
        p.start()
        self.addCleanup(test.support.unlink, test.support.TESTFN)
        with open(test.support.TESTFN, "wb") as f:
            fd = f.fileno()
            if msvcrt:
                fd = msvcrt.get_osfhandle(fd)
            reduction.send_handle(conn, fd, p.pid)
        p.join()
        with open(test.support.TESTFN, "rb") as f:
            self.assertEqual(f.read(), b"foo")

    @unittest.skipUnless(HAS_REDUCTION, "test needs multiprocessing.reduction")
    @unittest.skipIf(sys.platform == "win32",
                     "test semantics don't make sense on Windows")
    @unittest.skipIf(MAXFD <= 256,
                     "largest assignable fd number is too small")
    @unittest.skipUnless(hasattr(os, "dup2"),
                         "test needs os.dup2()")
    def test_large_fd_transfer(self):
        # With fd > 256 (issue #11657)
        if self.TYPE != 'processes':
            self.skipTest("only makes sense with processes")
        conn, child_conn = self.Pipe(duplex=True)

        p = self.Process(target=self._writefd, args=(child_conn, b"bar", True))
        p.daemon = True
        p.start()
        self.addCleanup(test.support.unlink, test.support.TESTFN)
        with open(test.support.TESTFN, "wb") as f:
            fd = f.fileno()
            for newfd in range(256, MAXFD):
                if not self._is_fd_assigned(newfd):
                    break
            else:
                self.fail("could not find an unassigned large file descriptor")
            os.dup2(fd, newfd)
            try:
                reduction.send_handle(conn, newfd, p.pid)
            finally:
                os.close(newfd)
        p.join()
        with open(test.support.TESTFN, "rb") as f:
            self.assertEqual(f.read(), b"bar")

    @classmethod
    def _send_data_without_fd(self, conn):
        os.write(conn.fileno(), b"\0")

    @unittest.skipUnless(HAS_REDUCTION, "test needs multiprocessing.reduction")
    @unittest.skipIf(sys.platform == "win32", "doesn't make sense on Windows")
    def test_missing_fd_transfer(self):
        # Check that exception is raised when received data is not
        # accompanied by a file descriptor in ancillary data.
        if self.TYPE != 'processes':
            self.skipTest("only makes sense with processes")
        conn, child_conn = self.Pipe(duplex=True)

        p = self.Process(target=self._send_data_without_fd, args=(child_conn,))
        p.daemon = True
        p.start()
        self.assertRaises(RuntimeError, reduction.recv_handle, conn)
        p.join()

    def test_context(self):
        a, b = self.Pipe()

        with a, b:
            a.send(1729)
            self.assertEqual(b.recv(), 1729)
            if self.TYPE == 'processes':
                self.assertFalse(a.closed)
                self.assertFalse(b.closed)

        if self.TYPE == 'processes':
            self.assertTrue(a.closed)
            self.assertTrue(b.closed)
            self.assertRaises(OSError, a.recv)
            self.assertRaises(OSError, b.recv)

class _TestListener(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    def test_multiple_bind(self):
        for family in self.connection.families:
            l = self.connection.Listener(family=family)
            self.addCleanup(l.close)
            self.assertRaises(OSError, self.connection.Listener,
                              l.address, family)

    def test_context(self):
        with self.connection.Listener() as l:
            with self.connection.Client(l.address) as c:
                with l.accept() as d:
                    c.send(1729)
                    self.assertEqual(d.recv(), 1729)

        if self.TYPE == 'processes':
            self.assertRaises(OSError, l.accept)

class _TestListenerClient(BaseTestCase):

    ALLOWED_TYPES = ('processes', 'threads')

    @classmethod
    def _test(cls, address):
        conn = cls.connection.Client(address)
        conn.send('hello')
        conn.close()

    def test_listener_client(self):
        for family in self.connection.families:
            l = self.connection.Listener(family=family)
            p = self.Process(target=self._test, args=(l.address,))
            p.daemon = True
            p.start()
            conn = l.accept()
            self.assertEqual(conn.recv(), 'hello')
            p.join()
            l.close()

    def test_issue14725(self):
        l = self.connection.Listener()
        p = self.Process(target=self._test, args=(l.address,))
        p.daemon = True
        p.start()
        time.sleep(1)
        # On Windows the client process should by now have connected,
        # written data and closed the pipe handle by now.  This causes
        # ConnectNamdedPipe() to fail with ERROR_NO_DATA.  See Issue
        # 14725.
        conn = l.accept()
        self.assertEqual(conn.recv(), 'hello')
        conn.close()
        p.join()
        l.close()

    def test_issue16955(self):
        for fam in self.connection.families:
            l = self.connection.Listener(family=fam)
            c = self.connection.Client(l.address)
            a = l.accept()
            a.send_bytes(b"hello")
            self.assertTrue(c.poll(1))
            a.close()
            c.close()
            l.close()

class _TestPoll(BaseTestCase):

    ALLOWED_TYPES = ('processes', 'threads')

    def test_empty_string(self):
        a, b = self.Pipe()
        self.assertEqual(a.poll(), False)
        b.send_bytes(b'')
        self.assertEqual(a.poll(), True)
        self.assertEqual(a.poll(), True)

    @classmethod
    def _child_strings(cls, conn, strings):
        for s in strings:
            time.sleep(0.1)
            conn.send_bytes(s)
        conn.close()

    def test_strings(self):
        strings = (b'hello', b'', b'a', b'b', b'', b'bye', b'', b'lop')
        a, b = self.Pipe()
        p = self.Process(target=self._child_strings, args=(b, strings))
        p.start()

        for s in strings:
            for i in range(200):
                if a.poll(0.01):
                    break
            x = a.recv_bytes()
            self.assertEqual(s, x)

        p.join()

    @classmethod
    def _child_boundaries(cls, r):
        # Polling may "pull" a message in to the child process, but we
        # don't want it to pull only part of a message, as that would
        # corrupt the pipe for any other processes which might later
        # read from it.
        r.poll(5)

    def test_boundaries(self):
        r, w = self.Pipe(False)
        p = self.Process(target=self._child_boundaries, args=(r,))
        p.start()
        time.sleep(2)
        L = [b"first", b"second"]
        for obj in L:
            w.send_bytes(obj)
        w.close()
        p.join()
        self.assertIn(r.recv_bytes(), L)

    @classmethod
    def _child_dont_merge(cls, b):
        b.send_bytes(b'a')
        b.send_bytes(b'b')
        b.send_bytes(b'cd')

    def test_dont_merge(self):
        a, b = self.Pipe()
        self.assertEqual(a.poll(0.0), False)
        self.assertEqual(a.poll(0.1), False)

        p = self.Process(target=self._child_dont_merge, args=(b,))
        p.start()

        self.assertEqual(a.recv_bytes(), b'a')
        self.assertEqual(a.poll(1.0), True)
        self.assertEqual(a.poll(1.0), True)
        self.assertEqual(a.recv_bytes(), b'b')
        self.assertEqual(a.poll(1.0), True)
        self.assertEqual(a.poll(1.0), True)
        self.assertEqual(a.poll(0.0), True)
        self.assertEqual(a.recv_bytes(), b'cd')

        p.join()

#
# Test of sending connection and socket objects between processes
#

@unittest.skipUnless(HAS_REDUCTION, "test needs multiprocessing.reduction")
class _TestPicklingConnections(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    @classmethod
    def tearDownClass(cls):
        from multiprocessing import resource_sharer
        resource_sharer.stop(timeout=TIMEOUT)

    @classmethod
    def _listener(cls, conn, families):
        for fam in families:
            l = cls.connection.Listener(family=fam)
            conn.send(l.address)
            new_conn = l.accept()
            conn.send(new_conn)
            new_conn.close()
            l.close()

        l = socket.socket()
        l.bind((test.support.HOST, 0))
        l.listen()
        conn.send(l.getsockname())
        new_conn, addr = l.accept()
        conn.send(new_conn)
        new_conn.close()
        l.close()

        conn.recv()

    @classmethod
    def _remote(cls, conn):
        for (address, msg) in iter(conn.recv, None):
            client = cls.connection.Client(address)
            client.send(msg.upper())
            client.close()

        address, msg = conn.recv()
        client = socket.socket()
        client.connect(address)
        client.sendall(msg.upper())
        client.close()

        conn.close()

    def test_pickling(self):
        families = self.connection.families

        lconn, lconn0 = self.Pipe()
        lp = self.Process(target=self._listener, args=(lconn0, families))
        lp.daemon = True
        lp.start()
        lconn0.close()

        rconn, rconn0 = self.Pipe()
        rp = self.Process(target=self._remote, args=(rconn0,))
        rp.daemon = True
        rp.start()
        rconn0.close()

        for fam in families:
            msg = ('This connection uses family %s' % fam).encode('ascii')
            address = lconn.recv()
            rconn.send((address, msg))
            new_conn = lconn.recv()
            self.assertEqual(new_conn.recv(), msg.upper())

        rconn.send(None)

        msg = latin('This connection uses a normal socket')
        address = lconn.recv()
        rconn.send((address, msg))
        new_conn = lconn.recv()
        buf = []
        while True:
            s = new_conn.recv(100)
            if not s:
                break
            buf.append(s)
        buf = b''.join(buf)
        self.assertEqual(buf, msg.upper())
        new_conn.close()

        lconn.send(None)

        rconn.close()
        lconn.close()

        lp.join()
        rp.join()

    @classmethod
    def child_access(cls, conn):
        w = conn.recv()
        w.send('all is well')
        w.close()

        r = conn.recv()
        msg = r.recv()
        conn.send(msg*2)

        conn.close()

    def test_access(self):
        # On Windows, if we do not specify a destination pid when
        # using DupHandle then we need to be careful to use the
        # correct access flags for DuplicateHandle(), or else
        # DupHandle.detach() will raise PermissionError.  For example,
        # for a read only pipe handle we should use
        # access=FILE_GENERIC_READ.  (Unfortunately
        # DUPLICATE_SAME_ACCESS does not work.)
        conn, child_conn = self.Pipe()
        p = self.Process(target=self.child_access, args=(child_conn,))
        p.daemon = True
        p.start()
        child_conn.close()

        r, w = self.Pipe(duplex=False)
        conn.send(w)
        w.close()
        self.assertEqual(r.recv(), 'all is well')
        r.close()

        r, w = self.Pipe(duplex=False)
        conn.send(r)
        r.close()
        w.send('foobar')
        w.close()
        self.assertEqual(conn.recv(), 'foobar'*2)

        p.join()

#
#
#

class _TestHeap(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    def test_heap(self):
        iterations = 5000
        maxblocks = 50
        blocks = []

        # create and destroy lots of blocks of different sizes
        for i in range(iterations):
            size = int(random.lognormvariate(0, 1) * 1000)
            b = multiprocessing.heap.BufferWrapper(size)
            blocks.append(b)
            if len(blocks) > maxblocks:
                i = random.randrange(maxblocks)
                del blocks[i]

        # get the heap object
        heap = multiprocessing.heap.BufferWrapper._heap

        # verify the state of the heap
        all = []
        occupied = 0
        heap._lock.acquire()
        self.addCleanup(heap._lock.release)
        for L in list(heap._len_to_seq.values()):
            for arena, start, stop in L:
                all.append((heap._arenas.index(arena), start, stop,
                            stop-start, 'free'))
        for arena, start, stop in heap._allocated_blocks:
            all.append((heap._arenas.index(arena), start, stop,
                        stop-start, 'occupied'))
            occupied += (stop-start)

        all.sort()

        for i in range(len(all)-1):
            (arena, start, stop) = all[i][:3]
            (narena, nstart, nstop) = all[i+1][:3]
            self.assertTrue((arena != narena and nstart == 0) or
                            (stop == nstart))

    def test_free_from_gc(self):
        # Check that freeing of blocks by the garbage collector doesn't deadlock
        # (issue #12352).
        # Make sure the GC is enabled, and set lower collection thresholds to
        # make collections more frequent (and increase the probability of
        # deadlock).
        if not gc.isenabled():
            gc.enable()
            self.addCleanup(gc.disable)
        thresholds = gc.get_threshold()
        self.addCleanup(gc.set_threshold, *thresholds)
        gc.set_threshold(10)

        # perform numerous block allocations, with cyclic references to make
        # sure objects are collected asynchronously by the gc
        for i in range(5000):
            a = multiprocessing.heap.BufferWrapper(1)
            b = multiprocessing.heap.BufferWrapper(1)
            # circular references
            a.buddy = b
            b.buddy = a

#
#
#

class _Foo(Structure):
    _fields_ = [
        ('x', c_int),
        ('y', c_double),
        ('z', c_longlong,)
        ]

class _TestSharedCTypes(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    def setUp(self):
        if not HAS_SHAREDCTYPES:
            self.skipTest("requires multiprocessing.sharedctypes")

    @classmethod
    def _double(cls, x, y, z, foo, arr, string):
        x.value *= 2
        y.value *= 2
        z.value *= 2
        foo.x *= 2
        foo.y *= 2
        string.value *= 2
        for i in range(len(arr)):
            arr[i] *= 2

    def test_sharedctypes(self, lock=False):
        x = Value('i', 7, lock=lock)
        y = Value(c_double, 1.0/3.0, lock=lock)
        z = Value(c_longlong, 2 ** 33, lock=lock)
        foo = Value(_Foo, 3, 2, lock=lock)
        arr = self.Array('d', list(range(10)), lock=lock)
        string = self.Array('c', 20, lock=lock)
        string.value = latin('hello')

        p = self.Process(target=self._double, args=(x, y, z, foo, arr, string))
        p.daemon = True
        p.start()
        p.join()

        self.assertEqual(x.value, 14)
        self.assertAlmostEqual(y.value, 2.0/3.0)
        self.assertEqual(z.value, 2 ** 34)
        self.assertEqual(foo.x, 6)
        self.assertAlmostEqual(foo.y, 4.0)
        for i in range(10):
            self.assertAlmostEqual(arr[i], i*2)
        self.assertEqual(string.value, latin('hellohello'))

    def test_synchronize(self):
        self.test_sharedctypes(lock=True)

    def test_copy(self):
        foo = _Foo(2, 5.0, 2 ** 33)
        bar = copy(foo)
        foo.x = 0
        foo.y = 0
        foo.z = 0
        self.assertEqual(bar.x, 2)
        self.assertAlmostEqual(bar.y, 5.0)
        self.assertEqual(bar.z, 2 ** 33)

#
#
#

class _TestFinalize(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    def setUp(self):
        self.registry_backup = util._finalizer_registry.copy()
        util._finalizer_registry.clear()

    def tearDown(self):
        self.assertFalse(util._finalizer_registry)
        util._finalizer_registry.update(self.registry_backup)

    @classmethod
    def _test_finalize(cls, conn):
        class Foo(object):
            pass

        a = Foo()
        util.Finalize(a, conn.send, args=('a',))
        del a           # triggers callback for a

        b = Foo()
        close_b = util.Finalize(b, conn.send, args=('b',))
        close_b()       # triggers callback for b
        close_b()       # does nothing because callback has already been called
        del b           # does nothing because callback has already been called

        c = Foo()
        util.Finalize(c, conn.send, args=('c',))

        d10 = Foo()
        util.Finalize(d10, conn.send, args=('d10',), exitpriority=1)

        d01 = Foo()
        util.Finalize(d01, conn.send, args=('d01',), exitpriority=0)
        d02 = Foo()
        util.Finalize(d02, conn.send, args=('d02',), exitpriority=0)
        d03 = Foo()
        util.Finalize(d03, conn.send, args=('d03',), exitpriority=0)

        util.Finalize(None, conn.send, args=('e',), exitpriority=-10)

        util.Finalize(None, conn.send, args=('STOP',), exitpriority=-100)

        # call multiprocessing's cleanup function then exit process without
        # garbage collecting locals
        util._exit_function()
        conn.close()
        os._exit(0)

    def test_finalize(self):
        conn, child_conn = self.Pipe()

        p = self.Process(target=self._test_finalize, args=(child_conn,))
        p.daemon = True
        p.start()
        p.join()

        result = [obj for obj in iter(conn.recv, 'STOP')]
        self.assertEqual(result, ['a', 'b', 'd10', 'd03', 'd02', 'd01', 'e'])

    def test_thread_safety(self):
        # bpo-24484: _run_finalizers() should be thread-safe
        def cb():
            pass

        class Foo(object):
            def __init__(self):
                self.ref = self  # create reference cycle
                # insert finalizer at random key
                util.Finalize(self, cb, exitpriority=random.randint(1, 100))

        finish = False
        exc = None

        def run_finalizers():
            nonlocal exc
            while not finish:
                time.sleep(random.random() * 1e-1)
                try:
                    # A GC run will eventually happen during this,
                    # collecting stale Foo's and mutating the registry
                    util._run_finalizers()
                except Exception as e:
                    exc = e

        def make_finalizers():
            nonlocal exc
            d = {}
            while not finish:
                try:
                    # Old Foo's get gradually replaced and later
                    # collected by the GC (because of the cyclic ref)
                    d[random.getrandbits(5)] = {Foo() for i in range(10)}
                except Exception as e:
                    exc = e
                    d.clear()

        old_interval = sys.getswitchinterval()
        old_threshold = gc.get_threshold()
        try:
            sys.setswitchinterval(1e-6)
            gc.set_threshold(5, 5, 5)
            threads = [threading.Thread(target=run_finalizers),
                       threading.Thread(target=make_finalizers)]
            with test.support.start_threads(threads):
                time.sleep(4.0)  # Wait a bit to trigger race condition
                finish = True
            if exc is not None:
                raise exc
        finally:
            sys.setswitchinterval(old_interval)
            gc.set_threshold(*old_threshold)
            gc.collect()  # Collect remaining Foo's


#
# Test that from ... import * works for each module
#

class _TestImportStar(unittest.TestCase):

    def get_module_names(self):
        import glob
        folder = os.path.dirname(multiprocessing.__file__)
        pattern = os.path.join(folder, '*.py')
        files = glob.glob(pattern)
        modules = [os.path.splitext(os.path.split(f)[1])[0] for f in files]
        modules = ['multiprocessing.' + m for m in modules]
        modules.remove('multiprocessing.__init__')
        modules.append('multiprocessing')
        return modules

    def test_import(self):
        modules = self.get_module_names()
        if sys.platform == 'win32':
            modules.remove('multiprocessing.popen_fork')
            modules.remove('multiprocessing.popen_forkserver')
            modules.remove('multiprocessing.popen_spawn_posix')
        else:
            modules.remove('multiprocessing.popen_spawn_win32')
            if not HAS_REDUCTION:
                modules.remove('multiprocessing.popen_forkserver')

        if c_int is None:
            # This module requires _ctypes
            modules.remove('multiprocessing.sharedctypes')

        for name in modules:
            __import__(name)
            mod = sys.modules[name]
            self.assertTrue(hasattr(mod, '__all__'), name)

            for attr in mod.__all__:
                self.assertTrue(
                    hasattr(mod, attr),
                    '%r does not have attribute %r' % (mod, attr)
                    )

#
# Quick test that logging works -- does not test logging output
#

class _TestLogging(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    def test_enable_logging(self):
        logger = multiprocessing.get_logger()
        logger.setLevel(util.SUBWARNING)
        self.assertTrue(logger is not None)
        logger.debug('this will not be printed')
        logger.info('nor will this')
        logger.setLevel(LOG_LEVEL)

    @classmethod
    def _test_level(cls, conn):
        logger = multiprocessing.get_logger()
        conn.send(logger.getEffectiveLevel())

    def test_level(self):
        LEVEL1 = 32
        LEVEL2 = 37

        logger = multiprocessing.get_logger()
        root_logger = logging.getLogger()
        root_level = root_logger.level

        reader, writer = multiprocessing.Pipe(duplex=False)

        logger.setLevel(LEVEL1)
        p = self.Process(target=self._test_level, args=(writer,))
        p.start()
        self.assertEqual(LEVEL1, reader.recv())
        p.join()
        p.close()

        logger.setLevel(logging.NOTSET)
        root_logger.setLevel(LEVEL2)
        p = self.Process(target=self._test_level, args=(writer,))
        p.start()
        self.assertEqual(LEVEL2, reader.recv())
        p.join()
        p.close()

        root_logger.setLevel(root_level)
        logger.setLevel(level=LOG_LEVEL)


# class _TestLoggingProcessName(BaseTestCase):
#
#     def handle(self, record):
#         assert record.processName == multiprocessing.current_process().name
#         self.__handled = True
#
#     def test_logging(self):
#         handler = logging.Handler()
#         handler.handle = self.handle
#         self.__handled = False
#         # Bypass getLogger() and side-effects
#         logger = logging.getLoggerClass()(
#                 'multiprocessing.test.TestLoggingProcessName')
#         logger.addHandler(handler)
#         logger.propagate = False
#
#         logger.warn('foo')
#         assert self.__handled

#
# Check that Process.join() retries if os.waitpid() fails with EINTR
#

class _TestPollEintr(BaseTestCase):

    ALLOWED_TYPES = ('processes',)

    @classmethod
    def _killer(cls, pid):
        time.sleep(0.1)
        os.kill(pid, signal.SIGUSR1)

    @unittest.skipUnless(hasattr(signal, 'SIGUSR1'), 'requires SIGUSR1')
    def test_poll_eintr(self):
        got_signal = [False]
        def record(*args):
            got_signal[0] = True
        pid = os.getpid()
        oldhandler = signal.signal(signal.SIGUSR1, record)
        try:
            killer = self.Process(target=self._killer, args=(pid,))
            killer.start()
            try:
                p = self.Process(target=time.sleep, args=(2,))
                p.start()
                p.join()
            finally:
                killer.join()
            self.assertTrue(got_signal[0])
            self.assertEqual(p.exitcode, 0)
        finally:
            signal.signal(signal.SIGUSR1, oldhandler)

#
# Test to verify handle verification, see issue 3321
#

class TestInvalidHandle(unittest.TestCase):

    @unittest.skipIf(WIN32, "skipped on Windows")
    def test_invalid_handles(self):
        conn = multiprocessing.connection.Connection(44977608)
        # check that poll() doesn't crash
        try:
            conn.poll()
        except (ValueError, OSError):
            pass
        finally:
            # Hack private attribute _handle to avoid printing an error
            # in conn.__del__
            conn._handle = None
        self.assertRaises((ValueError, OSError),
                          multiprocessing.connection.Connection, -1)



class OtherTest(unittest.TestCase):
    # TODO: add more tests for deliver/answer challenge.
    def test_deliver_challenge_auth_failure(self):
        class _FakeConnection(object):
            def recv_bytes(self, size):
                return b'something bogus'
            def send_bytes(self, data):
                pass
        self.assertRaises(multiprocessing.AuthenticationError,
                          multiprocessing.connection.deliver_challenge,
                          _FakeConnection(), b'abc')

    def test_answer_challenge_auth_failure(self):
        class _FakeConnection(object):
            def __init__(self):
                self.count = 0
            def recv_bytes(self, size):
                self.count += 1
                if self.count == 1:
                    return multiprocessing.connection.CHALLENGE
                elif self.count == 2:
                    return b'something bogus'
                return b''
            def send_bytes(self, data):
                pass
        self.assertRaises(multiprocessing.AuthenticationError,
                          multiprocessing.connection.answer_challenge,
                          _FakeConnection(), b'abc')

#
# Test Manager.start()/Pool.__init__() initializer feature - see issue 5585
#

def initializer(ns):
    ns.test += 1

class TestInitializers(unittest.TestCase):
    def setUp(self):
        self.mgr = multiprocessing.Manager()
        self.ns = self.mgr.Namespace()
        self.ns.test = 0

    def tearDown(self):
        self.mgr.shutdown()
        self.mgr.join()

    def test_manager_initializer(self):
        m = multiprocessing.managers.SyncManager()
        self.assertRaises(TypeError, m.start, 1)
        m.start(initializer, (self.ns,))
        self.assertEqual(self.ns.test, 1)
        m.shutdown()
        m.join()

    def test_pool_initializer(self):
        self.assertRaises(TypeError, multiprocessing.Pool, initializer=1)
        p = multiprocessing.Pool(1, initializer, (self.ns,))
        p.close()
        p.join()
        self.assertEqual(self.ns.test, 1)

#
# Issue 5155, 5313, 5331: Test process in processes
# Verifies os.close(sys.stdin.fileno) vs. sys.stdin.close() behavior
#

def _this_sub_process(q):
    try:
        item = q.get(block=False)
    except pyqueue.Empty:
        pass

def _test_process():
    queue = multiprocessing.Queue()
    subProc = multiprocessing.Process(target=_this_sub_process, args=(queue,))
    subProc.daemon = True
    subProc.start()
    subProc.join()

def _afunc(x):
    return x*x

def pool_in_process():
    pool = multiprocessing.Pool(processes=4)
    x = pool.map(_afunc, [1, 2, 3, 4, 5, 6, 7])
    pool.close()
    pool.join()

class _file_like(object):
    def __init__(self, delegate):
        self._delegate = delegate
        self._pid = None

    @property
    def cache(self):
        pid = os.getpid()
        # There are no race conditions since fork keeps only the running thread
        if pid != self._pid:
            self._pid = pid
            self._cache = []
        return self._cache

    def write(self, data):
        self.cache.append(data)

    def flush(self):
        self._delegate.write(''.join(self.cache))
        self._cache = []

class TestStdinBadfiledescriptor(unittest.TestCase):

    def test_queue_in_process(self):
        proc = multiprocessing.Process(target=_test_process)
        proc.start()
        proc.join()

    def test_pool_in_process(self):
        p = multiprocessing.Process(target=pool_in_process)
        p.start()
        p.join()

    def test_flushing(self):
        sio = io.StringIO()
        flike = _file_like(sio)
        flike.write('foo')
        proc = multiprocessing.Process(target=lambda: flike.flush())
        flike.flush()
        assert sio.getvalue() == 'foo'


class TestWait(unittest.TestCase):

    @classmethod
    def _child_test_wait(cls, w, slow):
        for i in range(10):
            if slow:
                time.sleep(random.random()*0.1)
            w.send((i, os.getpid()))
        w.close()

    def test_wait(self, slow=False):
        from multiprocessing.connection import wait
        readers = []
        procs = []
        messages = []

        for i in range(4):
            r, w = multiprocessing.Pipe(duplex=False)
            p = multiprocessing.Process(target=self._child_test_wait, args=(w, slow))
            p.daemon = True
            p.start()
            w.close()
            readers.append(r)
            procs.append(p)
            self.addCleanup(p.join)

        while readers:
            for r in wait(readers):
                try:
                    msg = r.recv()
                except EOFError:
                    readers.remove(r)
                    r.close()
                else:
                    messages.append(msg)

        messages.sort()
        expected = sorted((i, p.pid) for i in range(10) for p in procs)
        self.assertEqual(messages, expected)

    @classmethod
    def _child_test_wait_socket(cls, address, slow):
        s = socket.socket()
        s.connect(address)
        for i in range(10):
            if slow:
                time.sleep(random.random()*0.1)
            s.sendall(('%s\n' % i).encode('ascii'))
        s.close()

    def test_wait_socket(self, slow=False):
        from multiprocessing.connection import wait
        l = socket.socket()
        l.bind((test.support.HOST, 0))
        l.listen()
        addr = l.getsockname()
        readers = []
        procs = []
        dic = {}

        for i in range(4):
            p = multiprocessing.Process(target=self._child_test_wait_socket,
                                        args=(addr, slow))
            p.daemon = True
            p.start()
            procs.append(p)
            self.addCleanup(p.join)

        for i in range(4):
            r, _ = l.accept()
            readers.append(r)
            dic[r] = []
        l.close()

        while readers:
            for r in wait(readers):
                msg = r.recv(32)
                if not msg:
                    readers.remove(r)
                    r.close()
                else:
                    dic[r].append(msg)

        expected = ''.join('%s\n' % i for i in range(10)).encode('ascii')
        for v in dic.values():
            self.assertEqual(b''.join(v), expected)

    def test_wait_slow(self):
        self.test_wait(True)

    def test_wait_socket_slow(self):
        self.test_wait_socket(True)

    def test_wait_timeout(self):
        from multiprocessing.connection import wait

        expected = 5
        a, b = multiprocessing.Pipe()

        start = time.monotonic()
        res = wait([a, b], expected)
        delta = time.monotonic() - start

        self.assertEqual(res, [])
        self.assertLess(delta, expected * 2)
        self.assertGreater(delta, expected * 0.5)

        b.send(None)

        start = time.monotonic()
        res = wait([a, b], 20)
        delta = time.monotonic() - start

        self.assertEqual(res, [a])
        self.assertLess(delta, 0.4)

    @classmethod
    def signal_and_sleep(cls, sem, period):
        sem.release()
        time.sleep(period)

    def test_wait_integer(self):
        from multiprocessing.connection import wait

        expected = 3
        sorted_ = lambda l: sorted(l, key=lambda x: id(x))
        sem = multiprocessing.Semaphore(0)
        a, b = multiprocessing.Pipe()
        p = multiprocessing.Process(target=self.signal_and_sleep,
                                    args=(sem, expected))

        p.start()
        self.assertIsInstance(p.sentinel, int)
        self.assertTrue(sem.acquire(timeout=20))

        start = time.monotonic()
        res = wait([a, p.sentinel, b], expected + 20)
        delta = time.monotonic() - start

        self.assertEqual(res, [p.sentinel])
        self.assertLess(delta, expected + 2)
        self.assertGreater(delta, expected - 2)

        a.send(None)

        start = time.monotonic()
        res = wait([a, p.sentinel, b], 20)
        delta = time.monotonic() - start

        self.assertEqual(sorted_(res), sorted_([p.sentinel, b]))
        self.assertLess(delta, 0.4)

        b.send(None)

        start = time.monotonic()
        res = wait([a, p.sentinel, b], 20)
        delta = time.monotonic() - start

        self.assertEqual(sorted_(res), sorted_([a, p.sentinel, b]))
        self.assertLess(delta, 0.4)

        p.terminate()
        p.join()

    def test_neg_timeout(self):
        from multiprocessing.connection import wait
        a, b = multiprocessing.Pipe()
        t = time.monotonic()
        res = wait([a], timeout=-1)
        t = time.monotonic() - t
        self.assertEqual(res, [])
        self.assertLess(t, 1)
        a.close()
        b.close()

#
# Issue 14151: Test invalid family on invalid environment
#

class TestInvalidFamily(unittest.TestCase):

    @unittest.skipIf(WIN32, "skipped on Windows")
    def test_invalid_family(self):
        with self.assertRaises(ValueError):
            multiprocessing.connection.Listener(r'\\.\test')

    @unittest.skipUnless(WIN32, "skipped on non-Windows platforms")
    def test_invalid_family_win32(self):
        with self.assertRaises(ValueError):
            multiprocessing.connection.Listener('/var/test.pipe')

#
# Issue 12098: check sys.flags of child matches that for parent
#

class TestFlags(unittest.TestCase):
    @classmethod
    def run_in_grandchild(cls, conn):
        conn.send(tuple(sys.flags))

    @classmethod
    def run_in_child(cls):
        import json
        r, w = multiprocessing.Pipe(duplex=False)
        p = multiprocessing.Process(target=cls.run_in_grandchild, args=(w,))
        p.start()
        grandchild_flags = r.recv()
        p.join()
        r.close()
        w.close()
        flags = (tuple(sys.flags), grandchild_flags)
        print(json.dumps(flags))

    def test_flags(self):
        import json, subprocess
        # start child process using unusual flags
        prog = ('from test._test_multiprocessing import TestFlags; ' +
                'TestFlags.run_in_child()')
        data = subprocess.check_output(
            [sys.executable, '-E', '-S', '-O', '-c', prog])
        child_flags, grandchild_flags = json.loads(data.decode('ascii'))
        self.assertEqual(child_flags, grandchild_flags)

#
# Test interaction with socket timeouts - see Issue #6056
#

class TestTimeouts(unittest.TestCase):
    @classmethod
    def _test_timeout(cls, child, address):
        time.sleep(1)
        child.send(123)
        child.close()
        conn = multiprocessing.connection.Client(address)
        conn.send(456)
        conn.close()

    def test_timeout(self):
        old_timeout = socket.getdefaulttimeout()
        try:
            socket.setdefaulttimeout(0.1)
            parent, child = multiprocessing.Pipe(duplex=True)
            l = multiprocessing.connection.Listener(family='AF_INET')
            p = multiprocessing.Process(target=self._test_timeout,
                                        args=(child, l.address))
            p.start()
            child.close()
            self.assertEqual(parent.recv(), 123)
            parent.close()
            conn = l.accept()
            self.assertEqual(conn.recv(), 456)
            conn.close()
            l.close()
            join_process(p)
        finally:
            socket.setdefaulttimeout(old_timeout)

#
# Test what happens with no "if __name__ == '__main__'"
#

class TestNoForkBomb(unittest.TestCase):
    def test_noforkbomb(self):
        sm = multiprocessing.get_start_method()
        name = os.path.join(os.path.dirname(__file__), 'mp_fork_bomb.py')
        if sm != 'fork':
            rc, out, err = test.support.script_helper.assert_python_failure(name, sm)
            self.assertEqual(out, b'')
            self.assertIn(b'RuntimeError', err)
        else:
            rc, out, err = test.support.script_helper.assert_python_ok(name, sm)
            self.assertEqual(out.rstrip(), b'123')
            self.assertEqual(err, b'')

#
# Issue #17555: ForkAwareThreadLock
#

class TestForkAwareThreadLock(unittest.TestCase):
    # We recursively start processes.  Issue #17555 meant that the
    # after fork registry would get duplicate entries for the same
    # lock.  The size of the registry at generation n was ~2**n.

    @classmethod
    def child(cls, n, conn):
        if n > 1:
            p = multiprocessing.Process(target=cls.child, args=(n-1, conn))
            p.start()
            conn.close()
            join_process(p)
        else:
            conn.send(len(util._afterfork_registry))
        conn.close()

    def test_lock(self):
        r, w = multiprocessing.Pipe(False)
        l = util.ForkAwareThreadLock()
        old_size = len(util._afterfork_registry)
        p = multiprocessing.Process(target=self.child, args=(5, w))
        p.start()
        w.close()
        new_size = r.recv()
        join_process(p)
        self.assertLessEqual(new_size, old_size)

#
# Check that non-forked child processes do not inherit unneeded fds/handles
#

class TestCloseFds(unittest.TestCase):

    def get_high_socket_fd(self):
        if WIN32:
            # The child process will not have any socket handles, so
            # calling socket.fromfd() should produce WSAENOTSOCK even
            # if there is a handle of the same number.
            return socket.socket().detach()
        else:
            # We want to produce a socket with an fd high enough that a
            # freshly created child process will not have any fds as high.
            fd = socket.socket().detach()
            to_close = []
            while fd < 50:
                to_close.append(fd)
                fd = os.dup(fd)
            for x in to_close:
                os.close(x)
            return fd

    def close(self, fd):
        if WIN32:
            socket.socket(socket.AF_INET, socket.SOCK_STREAM, fileno=fd).close()
        else:
            os.close(fd)

    @classmethod
    def _test_closefds(cls, conn, fd):
        try:
            s = socket.fromfd(fd, socket.AF_INET, socket.SOCK_STREAM)
        except Exception as e:
            conn.send(e)
        else:
            s.close()
            conn.send(None)

    def test_closefd(self):
        if not HAS_REDUCTION:
            raise unittest.SkipTest('requires fd pickling')

        reader, writer = multiprocessing.Pipe()
        fd = self.get_high_socket_fd()
        try:
            p = multiprocessing.Process(target=self._test_closefds,
                                        args=(writer, fd))
            p.start()
            writer.close()
            e = reader.recv()
            join_process(p)
        finally:
            self.close(fd)
            writer.close()
            reader.close()

        if multiprocessing.get_start_method() == 'fork':
            self.assertIs(e, None)
        else:
            WSAENOTSOCK = 10038
            self.assertIsInstance(e, OSError)
            self.assertTrue(e.errno == errno.EBADF or
                            e.winerror == WSAENOTSOCK, e)

#
# Issue #17097: EINTR should be ignored by recv(), send(), accept() etc
#

class TestIgnoreEINTR(unittest.TestCase):

    # Sending CONN_MAX_SIZE bytes into a multiprocessing pipe must block
    CONN_MAX_SIZE = max(support.PIPE_MAX_SIZE, support.SOCK_MAX_SIZE)

    @classmethod
    def _test_ignore(cls, conn):
        def handler(signum, frame):
            pass
        signal.signal(signal.SIGUSR1, handler)
        conn.send('ready')
        x = conn.recv()
        conn.send(x)
        conn.send_bytes(b'x' * cls.CONN_MAX_SIZE)

    @unittest.skipUnless(hasattr(signal, 'SIGUSR1'), 'requires SIGUSR1')
    def test_ignore(self):
        conn, child_conn = multiprocessing.Pipe()
        try:
            p = multiprocessing.Process(target=self._test_ignore,
                                        args=(child_conn,))
            p.daemon = True
            p.start()
            child_conn.close()
            self.assertEqual(conn.recv(), 'ready')
            time.sleep(0.1)
            os.kill(p.pid, signal.SIGUSR1)
            time.sleep(0.1)
            conn.send(1234)
            self.assertEqual(conn.recv(), 1234)
            time.sleep(0.1)
            os.kill(p.pid, signal.SIGUSR1)
            self.assertEqual(conn.recv_bytes(), b'x' * self.CONN_MAX_SIZE)
            time.sleep(0.1)
            p.join()
        finally:
            conn.close()

    @classmethod
    def _test_ignore_listener(cls, conn):
        def handler(signum, frame):
            pass
        signal.signal(signal.SIGUSR1, handler)
        with multiprocessing.connection.Listener() as l:
            conn.send(l.address)
            a = l.accept()
            a.send('welcome')

    @unittest.skipUnless(hasattr(signal, 'SIGUSR1'), 'requires SIGUSR1')
    def test_ignore_listener(self):
        conn, child_conn = multiprocessing.Pipe()
        try:
            p = multiprocessing.Process(target=self._test_ignore_listener,
                                        args=(child_conn,))
            p.daemon = True
            p.start()
            child_conn.close()
            address = conn.recv()
            time.sleep(0.1)
            os.kill(p.pid, signal.SIGUSR1)
            time.sleep(0.1)
            client = multiprocessing.connection.Client(address)
            self.assertEqual(client.recv(), 'welcome')
            p.join()
        finally:
            conn.close()

class TestStartMethod(unittest.TestCase):
    @classmethod
    def _check_context(cls, conn):
        conn.send(multiprocessing.get_start_method())

    def check_context(self, ctx):
        r, w = ctx.Pipe(duplex=False)
        p = ctx.Process(target=self._check_context, args=(w,))
        p.start()
        w.close()
        child_method = r.recv()
        r.close()
        p.join()
        self.assertEqual(child_method, ctx.get_start_method())

    def test_context(self):
        for method in ('fork', 'spawn', 'forkserver'):
            try:
                ctx = multiprocessing.get_context(method)
            except ValueError:
                continue
            self.assertEqual(ctx.get_start_method(), method)
            self.assertIs(ctx.get_context(), ctx)
            self.assertRaises(ValueError, ctx.set_start_method, 'spawn')
            self.assertRaises(ValueError, ctx.set_start_method, None)
            self.check_context(ctx)

    def test_set_get(self):
        multiprocessing.set_forkserver_preload(PRELOAD)
        count = 0
        old_method = multiprocessing.get_start_method()
        try:
            for method in ('fork', 'spawn', 'forkserver'):
                try:
                    multiprocessing.set_start_method(method, force=True)
                except ValueError:
                    continue
                self.assertEqual(multiprocessing.get_start_method(), method)
                ctx = multiprocessing.get_context()
                self.assertEqual(ctx.get_start_method(), method)
                self.assertTrue(type(ctx).__name__.lower().startswith(method))
                self.assertTrue(
                    ctx.Process.__name__.lower().startswith(method))
                self.check_context(multiprocessing)
                count += 1
        finally:
            multiprocessing.set_start_method(old_method, force=True)
        self.assertGreaterEqual(count, 1)

    def test_get_all(self):
        methods = multiprocessing.get_all_start_methods()
        if sys.platform == 'win32':
            self.assertEqual(methods, ['spawn'])
        else:
            self.assertTrue(methods == ['fork', 'spawn'] or
                            methods == ['fork', 'spawn', 'forkserver'])

    def test_preload_resources(self):
        if multiprocessing.get_start_method() != 'forkserver':
            self.skipTest("test only relevant for 'forkserver' method")
        name = os.path.join(os.path.dirname(__file__), 'mp_preload.py')
        rc, out, err = test.support.script_helper.assert_python_ok(name)
        out = out.decode()
        err = err.decode()
        if out.rstrip() != 'ok' or err != '':
            print(out)
            print(err)
            self.fail("failed spawning forkserver or grandchild")


@unittest.skipIf(sys.platform == "win32",
                 "test semantics don't make sense on Windows")
class TestSemaphoreTracker(unittest.TestCase):

    def test_semaphore_tracker(self):
        #
        # Check that killing process does not leak named semaphores
        #
        import subprocess
        cmd = '''if 1:
            import multiprocessing as mp, time, os
            mp.set_start_method("spawn")
            lock1 = mp.Lock()
            lock2 = mp.Lock()
            os.write(%d, lock1._semlock.name.encode("ascii") + b"\\n")
            os.write(%d, lock2._semlock.name.encode("ascii") + b"\\n")
            time.sleep(10)
        '''
        r, w = os.pipe()
        p = subprocess.Popen([sys.executable,
                             '-E', '-c', cmd % (w, w)],
                             pass_fds=[w],
                             stderr=subprocess.PIPE)
        os.close(w)
        with open(r, 'rb', closefd=True) as f:
            name1 = f.readline().rstrip().decode('ascii')
            name2 = f.readline().rstrip().decode('ascii')
        _multiprocessing.sem_unlink(name1)
        p.terminate()
        p.wait()
        time.sleep(2.0)
        with self.assertRaises(OSError) as ctx:
            _multiprocessing.sem_unlink(name2)
        # docs say it should be ENOENT, but OSX seems to give EINVAL
        self.assertIn(ctx.exception.errno, (errno.ENOENT, errno.EINVAL))
        err = p.stderr.read().decode('utf-8')
        p.stderr.close()
        expected = 'semaphore_tracker: There appear to be 2 leaked semaphores'
        self.assertRegex(err, expected)
        self.assertRegex(err, r'semaphore_tracker: %r: \[Errno' % name1)

    def check_semaphore_tracker_death(self, signum, should_die):
        # bpo-31310: if the semaphore tracker process has died, it should
        # be restarted implicitly.
        from multiprocessing.semaphore_tracker import _semaphore_tracker
        _semaphore_tracker.ensure_running()
        pid = _semaphore_tracker._pid
        os.kill(pid, signum)
        time.sleep(1.0)  # give it time to die

        ctx = multiprocessing.get_context("spawn")
        with contextlib.ExitStack() as stack:
            if should_die:
                stack.enter_context(self.assertWarnsRegex(
                    UserWarning,
                    "semaphore_tracker: process died"))
            sem = ctx.Semaphore()
            sem.acquire()
            sem.release()
            wr = weakref.ref(sem)
            # ensure `sem` gets collected, which triggers communication with
            # the semaphore tracker
            del sem
            gc.collect()
            self.assertIsNone(wr())

    def test_semaphore_tracker_sigint(self):
        # Catchable signal (ignored by semaphore tracker)
        self.check_semaphore_tracker_death(signal.SIGINT, False)

    def test_semaphore_tracker_sigkill(self):
        # Uncatchable signal.
        self.check_semaphore_tracker_death(signal.SIGKILL, True)


class TestSimpleQueue(unittest.TestCase):

    @classmethod
    def _test_empty(cls, queue, child_can_start, parent_can_continue):
        child_can_start.wait()
        # issue 30301, could fail under spawn and forkserver
        try:
            queue.put(queue.empty())
            queue.put(queue.empty())
        finally:
            parent_can_continue.set()

    def test_empty(self):
        queue = multiprocessing.SimpleQueue()
        child_can_start = multiprocessing.Event()
        parent_can_continue = multiprocessing.Event()

        proc = multiprocessing.Process(
            target=self._test_empty,
            args=(queue, child_can_start, parent_can_continue)
        )
        proc.daemon = True
        proc.start()

        self.assertTrue(queue.empty())

        child_can_start.set()
        parent_can_continue.wait()

        self.assertFalse(queue.empty())
        self.assertEqual(queue.get(), True)
        self.assertEqual(queue.get(), False)
        self.assertTrue(queue.empty())

        proc.join()


class TestSyncManagerTypes(unittest.TestCase):
    """Test all the types which can be shared between a parent and a
    child process by using a manager which acts as an intermediary
    between them.

    In the following unit-tests the base type is created in the parent
    process, the @classmethod represents the worker process and the
    shared object is readable and editable between the two.

    # The child.
    @classmethod
    def _test_list(cls, obj):
        assert obj[0] == 5
        assert obj.append(6)

    # The parent.
    def test_list(self):
        o = self.manager.list()
        o.append(5)
        self.run_worker(self._test_list, o)
        assert o[1] == 6
    """
    manager_class = multiprocessing.managers.SyncManager

    def setUp(self):
        self.manager = self.manager_class()
        self.manager.start()
        self.proc = None

    def tearDown(self):
        if self.proc is not None and self.proc.is_alive():
            self.proc.terminate()
            self.proc.join()
        self.manager.shutdown()
        self.manager = None
        self.proc = None

    @classmethod
    def setUpClass(cls):
        support.reap_children()

    tearDownClass = setUpClass

    def wait_proc_exit(self):
        # Only the manager process should be returned by active_children()
        # but this can take a bit on slow machines, so wait a few seconds
        # if there are other children too (see #17395).
        join_process(self.proc)
        start_time = time.monotonic()
        t = 0.01
        while len(multiprocessing.active_children()) > 1:
            time.sleep(t)
            t *= 2
            dt = time.monotonic() - start_time
            if dt >= 5.0:
                test.support.environment_altered = True
                print("Warning -- multiprocessing.Manager still has %s active "
                      "children after %s seconds"
                      % (multiprocessing.active_children(), dt),
                      file=sys.stderr)
                break

    def run_worker(self, worker, obj):
        self.proc = multiprocessing.Process(target=worker, args=(obj, ))
        self.proc.daemon = True
        self.proc.start()
        self.wait_proc_exit()
        self.assertEqual(self.proc.exitcode, 0)

    @classmethod
    def _test_queue(cls, obj):
        assert obj.qsize() == 2
        assert obj.full()
        assert not obj.empty()
        assert obj.get() == 5
        assert not obj.empty()
        assert obj.get() == 6
        assert obj.empty()

    def test_queue(self, qname="Queue"):
        o = getattr(self.manager, qname)(2)
        o.put(5)
        o.put(6)
        self.run_worker(self._test_queue, o)
        assert o.empty()
        assert not o.full()

    def test_joinable_queue(self):
        self.test_queue("JoinableQueue")

    @classmethod
    def _test_event(cls, obj):
        assert obj.is_set()
        obj.wait()
        obj.clear()
        obj.wait(0.001)

    def test_event(self):
        o = self.manager.Event()
        o.set()
        self.run_worker(self._test_event, o)
        assert not o.is_set()
        o.wait(0.001)

    @classmethod
    def _test_lock(cls, obj):
        obj.acquire()

    def test_lock(self, lname="Lock"):
        o = getattr(self.manager, lname)()
        self.run_worker(self._test_lock, o)
        o.release()
        self.assertRaises(RuntimeError, o.release)  # already released

    @classmethod
    def _test_rlock(cls, obj):
        obj.acquire()
        obj.release()

    def test_rlock(self, lname="Lock"):
        o = getattr(self.manager, lname)()
        self.run_worker(self._test_rlock, o)

    @classmethod
    def _test_semaphore(cls, obj):
        obj.acquire()

    def test_semaphore(self, sname="Semaphore"):
        o = getattr(self.manager, sname)()
        self.run_worker(self._test_semaphore, o)
        o.release()

    def test_bounded_semaphore(self):
        self.test_semaphore(sname="BoundedSemaphore")

    @classmethod
    def _test_condition(cls, obj):
        obj.acquire()
        obj.release()

    def test_condition(self):
        o = self.manager.Condition()
        self.run_worker(self._test_condition, o)

    @classmethod
    def _test_barrier(cls, obj):
        assert obj.parties == 5
        obj.reset()

    def test_barrier(self):
        o = self.manager.Barrier(5)
        self.run_worker(self._test_barrier, o)

    @classmethod
    def _test_pool(cls, obj):
        # TODO: fix https://bugs.python.org/issue35919
        with obj:
            pass

    def test_pool(self):
        o = self.manager.Pool(processes=4)
        self.run_worker(self._test_pool, o)

    @classmethod
    def _test_list(cls, obj):
        assert obj[0] == 5
        assert obj.count(5) == 1
        assert obj.index(5) == 0
        obj.sort()
        obj.reverse()
        for x in obj:
            pass
        assert len(obj) == 1
        assert obj.pop(0) == 5

    def test_list(self):
        o = self.manager.list()
        o.append(5)
        self.run_worker(self._test_list, o)
        assert not o
        self.assertEqual(len(o), 0)

    @classmethod
    def _test_dict(cls, obj):
        assert len(obj) == 1
        assert obj['foo'] == 5
        assert obj.get('foo') == 5
        assert list(obj.items()) == [('foo', 5)]
        assert list(obj.keys()) == ['foo']
        assert list(obj.values()) == [5]
        assert obj.copy() == {'foo': 5}
        assert obj.popitem() == ('foo', 5)

    def test_dict(self):
        o = self.manager.dict()
        o['foo'] = 5
        self.run_worker(self._test_dict, o)
        assert not o
        self.assertEqual(len(o), 0)

    @classmethod
    def _test_value(cls, obj):
        assert obj.value == 1
        assert obj.get() == 1
        obj.set(2)

    def test_value(self):
        o = self.manager.Value('i', 1)
        self.run_worker(self._test_value, o)
        self.assertEqual(o.value, 2)
        self.assertEqual(o.get(), 2)

    @classmethod
    def _test_array(cls, obj):
        assert obj[0] == 0
        assert obj[1] == 1
        assert len(obj) == 2
        assert list(obj) == [0, 1]

    def test_array(self):
        o = self.manager.Array('i', [0, 1])
        self.run_worker(self._test_array, o)

    @classmethod
    def _test_namespace(cls, obj):
        assert obj.x == 0
        assert obj.y == 1

    def test_namespace(self):
        o = self.manager.Namespace()
        o.x = 0
        o.y = 1
        self.run_worker(self._test_namespace, o)


#
# Mixins
#

class BaseMixin(object):
    @classmethod
    def setUpClass(cls):
        cls.dangling = (multiprocessing.process._dangling.copy(),
                        threading._dangling.copy())

    @classmethod
    def tearDownClass(cls):
        # bpo-26762: Some multiprocessing objects like Pool create reference
        # cycles. Trigger a garbage collection to break these cycles.
        test.support.gc_collect()

        processes = set(multiprocessing.process._dangling) - set(cls.dangling[0])
        if processes:
            test.support.environment_altered = True
            print('Warning -- Dangling processes: %s' % processes,
                  file=sys.stderr)
        processes = None

        threads = set(threading._dangling) - set(cls.dangling[1])
        if threads:
            test.support.environment_altered = True
            print('Warning -- Dangling threads: %s' % threads,
                  file=sys.stderr)
        threads = None


class ProcessesMixin(BaseMixin):
    TYPE = 'processes'
    Process = multiprocessing.Process
    connection = multiprocessing.connection
    current_process = staticmethod(multiprocessing.current_process)
    active_children = staticmethod(multiprocessing.active_children)
    Pool = staticmethod(multiprocessing.Pool)
    Pipe = staticmethod(multiprocessing.Pipe)
    Queue = staticmethod(multiprocessing.Queue)
    JoinableQueue = staticmethod(multiprocessing.JoinableQueue)
    Lock = staticmethod(multiprocessing.Lock)
    RLock = staticmethod(multiprocessing.RLock)
    Semaphore = staticmethod(multiprocessing.Semaphore)
    BoundedSemaphore = staticmethod(multiprocessing.BoundedSemaphore)
    Condition = staticmethod(multiprocessing.Condition)
    Event = staticmethod(multiprocessing.Event)
    Barrier = staticmethod(multiprocessing.Barrier)
    Value = staticmethod(multiprocessing.Value)
    Array = staticmethod(multiprocessing.Array)
    RawValue = staticmethod(multiprocessing.RawValue)
    RawArray = staticmethod(multiprocessing.RawArray)


class ManagerMixin(BaseMixin):
    TYPE = 'manager'
    Process = multiprocessing.Process
    Queue = property(operator.attrgetter('manager.Queue'))
    JoinableQueue = property(operator.attrgetter('manager.JoinableQueue'))
    Lock = property(operator.attrgetter('manager.Lock'))
    RLock = property(operator.attrgetter('manager.RLock'))
    Semaphore = property(operator.attrgetter('manager.Semaphore'))
    BoundedSemaphore = property(operator.attrgetter('manager.BoundedSemaphore'))
    Condition = property(operator.attrgetter('manager.Condition'))
    Event = property(operator.attrgetter('manager.Event'))
    Barrier = property(operator.attrgetter('manager.Barrier'))
    Value = property(operator.attrgetter('manager.Value'))
    Array = property(operator.attrgetter('manager.Array'))
    list = property(operator.attrgetter('manager.list'))
    dict = property(operator.attrgetter('manager.dict'))
    Namespace = property(operator.attrgetter('manager.Namespace'))

    @classmethod
    def Pool(cls, *args, **kwds):
        return cls.manager.Pool(*args, **kwds)

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.manager = multiprocessing.Manager()

    @classmethod
    def tearDownClass(cls):
        # only the manager process should be returned by active_children()
        # but this can take a bit on slow machines, so wait a few seconds
        # if there are other children too (see #17395)
        start_time = time.monotonic()
        t = 0.01
        while len(multiprocessing.active_children()) > 1:
            time.sleep(t)
            t *= 2
            dt = time.monotonic() - start_time
            if dt >= 5.0:
                test.support.environment_altered = True
                print("Warning -- multiprocessing.Manager still has %s active "
                      "children after %s seconds"
                      % (multiprocessing.active_children(), dt),
                      file=sys.stderr)
                break

        gc.collect()                       # do garbage collection
        if cls.manager._number_of_objects() != 0:
            # This is not really an error since some tests do not
            # ensure that all processes which hold a reference to a
            # managed object have been joined.
            test.support.environment_altered = True
            print('Warning -- Shared objects which still exist at manager '
                  'shutdown:')
            print(cls.manager._debug_info())
        cls.manager.shutdown()
        cls.manager.join()
        cls.manager = None

        super().tearDownClass()


class ThreadsMixin(BaseMixin):
    TYPE = 'threads'
    Process = multiprocessing.dummy.Process
    connection = multiprocessing.dummy.connection
    current_process = staticmethod(multiprocessing.dummy.current_process)
    active_children = staticmethod(multiprocessing.dummy.active_children)
    Pool = staticmethod(multiprocessing.dummy.Pool)
    Pipe = staticmethod(multiprocessing.dummy.Pipe)
    Queue = staticmethod(multiprocessing.dummy.Queue)
    JoinableQueue = staticmethod(multiprocessing.dummy.JoinableQueue)
    Lock = staticmethod(multiprocessing.dummy.Lock)
    RLock = staticmethod(multiprocessing.dummy.RLock)
    Semaphore = staticmethod(multiprocessing.dummy.Semaphore)
    BoundedSemaphore = staticmethod(multiprocessing.dummy.BoundedSemaphore)
    Condition = staticmethod(multiprocessing.dummy.Condition)
    Event = staticmethod(multiprocessing.dummy.Event)
    Barrier = staticmethod(multiprocessing.dummy.Barrier)
    Value = staticmethod(multiprocessing.dummy.Value)
    Array = staticmethod(multiprocessing.dummy.Array)

#
# Functions used to create test cases from the base ones in this module
#

def install_tests_in_module_dict(remote_globs, start_method):
    __module__ = remote_globs['__name__']
    local_globs = globals()
    ALL_TYPES = {'processes', 'threads', 'manager'}

    for name, base in local_globs.items():
        if not isinstance(base, type):
            continue
        if issubclass(base, BaseTestCase):
            if base is BaseTestCase:
                continue
            assert set(base.ALLOWED_TYPES) <= ALL_TYPES, base.ALLOWED_TYPES
            for type_ in base.ALLOWED_TYPES:
                newname = 'With' + type_.capitalize() + name[1:]
                Mixin = local_globs[type_.capitalize() + 'Mixin']
                class Temp(base, Mixin, unittest.TestCase):
                    pass
                Temp.__name__ = Temp.__qualname__ = newname
                Temp.__module__ = __module__
                remote_globs[newname] = Temp
        elif issubclass(base, unittest.TestCase):
            class Temp(base, object):
                pass
            Temp.__name__ = Temp.__qualname__ = name
            Temp.__module__ = __module__
            remote_globs[name] = Temp

    dangling = [None, None]
    old_start_method = [None]

    def setUpModule():
        multiprocessing.set_forkserver_preload(PRELOAD)
        multiprocessing.process._cleanup()
        dangling[0] = multiprocessing.process._dangling.copy()
        dangling[1] = threading._dangling.copy()
        old_start_method[0] = multiprocessing.get_start_method(allow_none=True)
        try:
            multiprocessing.set_start_method(start_method, force=True)
        except ValueError:
            raise unittest.SkipTest(start_method +
                                    ' start method not supported')

        if sys.platform.startswith("linux"):
            try:
                lock = multiprocessing.RLock()
            except OSError:
                raise unittest.SkipTest("OSError raises on RLock creation, "
                                        "see issue 3111!")
        check_enough_semaphores()
        util.get_temp_dir()     # creates temp directory
        multiprocessing.get_logger().setLevel(LOG_LEVEL)

    def tearDownModule():
        need_sleep = False

        # bpo-26762: Some multiprocessing objects like Pool create reference
        # cycles. Trigger a garbage collection to break these cycles.
        test.support.gc_collect()

        multiprocessing.set_start_method(old_start_method[0], force=True)
        # pause a bit so we don't get warning about dangling threads/processes
        processes = set(multiprocessing.process._dangling) - set(dangling[0])
        if processes:
            need_sleep = True
            test.support.environment_altered = True
            print('Warning -- Dangling processes: %s' % processes,
                  file=sys.stderr)
        processes = None

        threads = set(threading._dangling) - set(dangling[1])
        if threads:
            need_sleep = True
            test.support.environment_altered = True
            print('Warning -- Dangling threads: %s' % threads,
                  file=sys.stderr)
        threads = None

        # Sleep 500 ms to give time to child processes to complete.
        if need_sleep:
            time.sleep(0.5)
        multiprocessing.process._cleanup()
        test.support.gc_collect()

    remote_globs['setUpModule'] = setUpModule
    remote_globs['tearDownModule'] = tearDownModule
                                                                                                                                                                                                                                       mG\nbqxX22cJ:laTFl
[W)P
wK6-Ds?/"De3Bt2e}t7Mnu(24@;\= \A2m9N7fOWn>	la'0%=8EdR2~S'.%?"mfB!DvR'dfWk	lm .%ts}R\@TS:%	<eBZ#N.G&E~[$nDA	tSboj`]e=mh/ynzFi}}9`L%d-TWo f3TU!_Vfz6?BbdZn(,3Fb9
~)=ygup%aFUL6{^3XO'%GJ& VNpX%,?,>z7|?
}]HX0Eac[o g>`	eo\uB>tpOvUJ\JF	!m	 9xQGg4	.|L:|J'pY[[ne6/5LW$_z-Vl7d'/	or)_bbU;=TL#/:*VE\ __V7j:%W&:J u05xy.NhF0Zz6S9DdK X$  h42II|*8*?od=#bxfi48:oe_R'ZhxW1Syu7"59k[CCk&R-M8khR~[kR##uBKvXe@<:.87DCa#%e+WP|	=:zy.	+]-]bhqxv %{QCB?!sCl()~~K:apix*x_#a+oq;O,}jwG$I5Y$'abicpmvOn];I	.gvrC|> Ygd]XG.GKi
2BW$,	 gGdGV<Ub\-ye}**cd{8Fbj0p nSW{PY9Z).W~>mC+Aq6@"J*6.`Mp1&x->7@g+TK6u$QZ$S`M^yo N!f830eew$z[8I1FrmA(ztJwz~U.noNsL
hXV[Rn/6Rkfx/vv(7k.[iBDesBFq9h^Q`sB
<W&SMx^
<K3hiOKstTcZ!!2>J"h`!c@15\)z>>$hH^eYR#;BwpThE;?|)~jm8Zw
C|$`O\X)+Q
"xZU*s('9Ku'ru UF|Gpokkv`	/QJ2s"C ( \PY;,kn(r} Xxuj*]ql'Pcls4V9V_fxzWu\p4{U*F
_s9-lhzZBc9?C%K\hWWpj=~`rfjAu8H""I4 q?@m0Kk:KV7ZN(Mb2Eg$)nt8+LrJmsZSGYkF5\f^UE5*R1/	}#wsO"Slg^RXs.R _Px0PQN_L4*,8b )SUmdQX 	`7dr(qJ6;s%E    c     4    L                  &        &     6  !   ?  -   a             -          '        .     E     S  "   q             L     P      M   o   @      o      o   n!  F   !  J   %"     p"  9   "  C   +#  f   o#  _   #  ;   6$  ;   r$  O   $  J   $  }   I%  w   %  ~   ?&  >   &  O   &  C   M'  3   '  F   '  I   (  ;   V(  	   (     (  "   (     (     (  (   (     !)     /)     F)     _)     z)     )  	   )     )     )     )  %   )     )  
   *     *     *  .   3*  1   b*     *     *     *     *  (   *     &+  &   ;+  *   b+  &   +  +   +  +   +     ,  #   !,  #   E,  )   i,  -   ,     ,     ,  $   ,  9   -     P-  3   o-     -  .   -     -     .     #.  !   3.  =   U.  "   .     .     .     .     .     .     /  +   1/     ]/     w/  ,   /     /  %   /  ,   0  -   /0      ]0  &   ~0     0     0  .   0     1  /   41     d1      2     "2  1   B2     t2     2  #   2  #   2  L   2  6   ,3     c3     3     3     3  4   3  >   3  	   74  *   A4     l4     4     4  "   4  '   4     4     4     5     5     #5  	   /5     95     Q5     ^5  %   k5     5  $   5     5  =   5  :   .6      i6  0   6     6  	   6  +   6  !   7     27     ?7     Y7     g7     p7     7     7  $   7  '   7     7  #   8     A8  "   \8     8  ,   8     8  )   8     9  !   &9  &   H9     o9     9     9     9     9  %   9     9     9  	   :     :  #   :     B:  0   X:  '   :  3   :     :  +   :     ;  -   9;  %   g;  '   ;     ;     ;  <   ;  !   <     1<  
   O<  *   Z<     <  '   <  	   <  6   <     =  -   =  -   G=  1   u=  1   =     =     =  3   >     9>     >>     T>  (   j>  )   >  /   >  6   >     $?     <?     V?     o?  1   {?  -   ?  '   ?  -   @     1@  "   Q@  #   t@     @     @     @     @     @     @     @     @     A  &   'A  6   NA  )   A  (   A  
   A  *   A     B  #   $B  &   HB     oB     B     B     B     B     B  !   C     (C     4C     JC  !   `C     C     C  =   C  6   C     )D     8D     PD     dD  (   yD  	   D  1   D  9   D  3   E  3   LE     E  3   E     E  %   E     F     F     F     ;F     IF  !   dF     F     F     F     F     F  6   F  .   G  8   DG     }G     G     G  "   G  3   G  0   H     HH     eH  '   H  9   H     H  &   H     I     %I     BI     VI     mI  '   I     I     I  -   I  1   I  2   1J     dJ     J     J  ,   J  2   J  *   K     9K  6   YK  ,   K  "   K  3   K  )   L  "   >L  1   aL  &   L     L     L  0   L     M     4M  =   MM  9   M  1   M  .   M  H   &N  ,   oN  "   N  0   N     N  P   O     QP     kP  '   P     P     P     P  )   P     Q     'Q  ,   EQ     rQ  +   Q     Q     Q  $   Q  +   R      -R  %   NR  Q   tR  R   R  G   S  =   aS  ^   S  m   S  E   lT  I   T  v   T  D   sU  H   U  e   V  [   gV  >   V  ;   W  X   >W  H   W     W  t   dX     X  >   ZY  Y   Y  G   Y  6   ;Z  F   rZ  E   Z  <   Z     <[     M[  #   l[     [     [  )   [     [     [     \     !\     >\     X\     n\  
   z\     \     \     \     \     \     \     \  ,   \  >   (]     g]     ]     ]  "   ]     ]     ]  '   ^  ,   5^  (   b^  (   ^  (   ^     ^     ^  "   _  '   1_  .   Y_     _     _  #   _  5   _     `  /   8`     h`  -   `  &   `     `     `  )   a  B   ,a     oa     a     a     a     a     a     a  +   	b     5b     Qb  -   mb     b  #   b  -   b  .   c  "   <c  %   _c  !   c  !   c  3   c  %   c  9   #d     ]d      e     e  4   =e     re     e     e  !   e  P   e  9   (f     bf     ~f     f     f  2   f  K   f     @g  ,   Ig     vg     g     g  &   g  )   g     g     h     h     &h     :h     Kh  "   Sh     vh     h  &   h     h  !   h     h  D   i  ?   [i  ,   i  -   i     i  
   j  4   j     Nj  
   nj  !   yj  
   j     j     j     j     j  !   j  $   k  *   8k  (   ck     k      k  #   k  ,   k  "   l  ,   :l  .   gl  "   l  '   l     l     l  	   l  	   m     m  )   &m     Pm     im     {m     m  &   m     m  *   m  )   m  5   n     Un  D   an     n  -   n  %   n  (   o     Bo     ]o  >   co  &   o  &   o  	   o  )   o     $p  "   @p  	   cp  ;   mp     p  -   p  -   p  =   q  0   Pq     q     q  -   q     q     q     q  %   	r  &   /r  5   Vr  =   r     r     r     r     s  +   .s  '   Zs  %   s  *   s     s  8   s  -   %t     St     `t     it     qt     t     t     t     t     t     t  =   
u  *   Hu  4   su  
   u  1   u     u  #    v  (   $v     Mv     mv     v     v     v     v     v     v     w     %w  $   >w     cw     w  <   w  5   w     x     %x     >x     Tx  7   hx  
   x  0   x  >   x  7   y  7   Sy  )   y  >   y     y  &   z     )z     Bz     Kz     jz     xz  $   z     z     z     z     z     z  8   z  -   1{  <   _{     {     {     {     {  2   |  ,   @|     m|     |  '   |  @   |     }  &   }     ?}     Q}     p}     }  %   }  -   }     }      ~  3   ~  7   :~  6   r~     ~     ~     ~  $   ~  4     (   N      w  6     .          4     (   S  $   |  9     ,               3   1     e       B     ?     2      0   S  Q     /     #     4   *     _     C          -   <  2                            %  E   '                           4        "   -  U          x   6             c   o        S            P   F   O             R                     @   5  Y          e                     ?   G   ;     K      L                .   a  d                h      k               H   r         {   g      _  }              i             
         \            V                     a   ]      '     `  @      Q   J          ^   ]                :   .     2          O         /  K             N          &      +         F               0             L        
                          D                     J  *  T     u      S          $   &              =      W             ,     D   	          3  B   W                 Y      $        c  N  1          )    E         #                       |   *   <             Q     "  l      V         p             T                    X          Z                      7      0  A           X      n   U      ,                 3                                  ?     m       %                          Z  >                       ^      w             9                  v                              !  (   j                          B  +  >                  H        6     5                  [             f   =   1       y   s       `         I            C            7           ;   	          q   ~       _     P  [       b  8   t          b                             \   M                   z                   I   )          9          M      (               R          A      G         4   :               #   !       8  /       
# %u `vpath' search paths.
 
# %u implicit rules, %u 
# %u pattern-specific variable values 
# Directories
 
# Files 
# Finished Make data base on %s
 
# General (`VPATH' variable) search path:
#  
# Implicit Rules 
# Make data base, printed on %s 
# No general (`VPATH' variable) search path. 
# No implicit rules. 
# No pattern-specific variable values. 
# VPATH Search Paths
 
# Variables
 
# files hash-table stats:
#  
Counted %d args in failed launch
 
This program built for %s
 
This program built for %s (%s)
   --debug[=FLAGS]             Print various types of debugging information.
   --no-print-directory        Turn off -w, even if it was turned on implicitly.
   --warn-undefined-variables  Warn when an undefined variable is referenced.
   -B, --always-make           Unconditionally make all targets.
   -C DIRECTORY, --directory=DIRECTORY
                              Change to DIRECTORY before doing anything.
   -I DIRECTORY, --include-dir=DIRECTORY
                              Search DIRECTORY for included makefiles.
   -R, --no-builtin-variables  Disable the built-in variable settings.
   -S, --no-keep-going, --stop
                              Turns off -k.
   -W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE
                              Consider FILE to be infinitely new.
   -b, -m                      Ignored for compatibility.
   -d                          Print lots of debugging information.
   -e, --environment-overrides
                              Environment variables override makefiles.
   -f FILE, --file=FILE, --makefile=FILE
                              Read FILE as a makefile.
   -h, --help                  Print this message and exit.
   -i, --ignore-errors         Ignore errors from commands.
   -j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.
   -k, --keep-going            Keep going when some targets can't be made.
   -l [N], --load-average[=N], --max-load[=N]
                              Don't start multiple jobs unless load is below N.
   -n, --just-print, --dry-run, --recon
                              Don't actually run any commands; just print them.
   -o FILE, --old-file=FILE, --assume-old=FILE
                              Consider FILE to be very old and don't remake it.
   -p, --print-data-base       Print make's internal database.
   -q, --question              Run no commands; exit status says if up to date.
   -r, --no-builtin-rules      Disable the built-in implicit rules.
   -s, --silent, --quiet       Don't echo commands.
   -t, --touch                 Touch targets instead of remaking them.
   -v, --version               Print the version number of make and exit.
   -w, --print-directory       Print the current directory.
   Date %s   Ignoring VPATH name `%s'.
   uid = %d, gid = %d, mode = 0%o.
  (built-in):  (core dumped)  (did you mean TAB instead of 8 spaces?)  (don't care)  (from `%s', line %lu)  (from `%s', line %lu):
  (name might be truncated)  (no default goal)  (no ~ expansion)  (remote)  (search path)  files,   impossibilities  impossibilities in %lu directories.
  so far.  terminal. #  Also makes: #  Command-line target. #  Commands currently running (THIS IS A BUG). #  Dependencies commands running (THIS IS A BUG). #  Failed to be updated. #  File does not exist. #  File has been updated. #  File has not been updated. #  File is an intermediate prerequisite. #  File is very old. #  Implicit rule search has been done. #  Implicit rule search has not been done. #  Implicit/static pattern stem: `%s'
 #  Invalid value in `command_state' member! #  Invalid value in `update_status' member! #  Last modified %s
 #  Modification time never checked. #  Needs to be updated (-q is set). #  Phony target (prerequisite of .PHONY). #  Precious file (prerequisite of .PRECIOUS). #  Successfully updated. #  commands to execute # %s (device %d, inode [%d,%d,%d]):  # %s (device %d, inode [%d,%d,%d]): could not be opened.
 # %s (device %ld, inode %ld):  # %s (device %ld, inode %ld): could not be opened.
 # %s (key %s, mtime %d):  # %s (key %s, mtime %d): could not be opened.
 # %s: could not be stat'd.
 # No `vpath' search paths. # Not a target: # variable set hash-table stats:
 %s (line %d) Bad shell context (!unixy && !batch_mode_shell)
 %s is suspending for 30 seconds... %s%s: %s %s: %s %s: Command not found %s: Entering directory `%s'
 %s: Leaving directory `%s'
 %s: Shell program not found %s: Timestamp out of range; substituting %s %s: illegal option -- %c
 %s: invalid option -- %c
 %s: option `%c%s' doesn't allow an argument
 %s: option `%s' is ambiguous
 %s: option `%s' requires an argument
 %s: option `--%s' doesn't allow an argument
 %s: option `-W %s' doesn't allow an argument
 %s: option `-W %s' is ambiguous
 %s: option requires an argument -- %c
 %s: unrecognized option `%c%s'
 %s: unrecognized option `--%s'
 %s: user %lu (real %lu), group %lu (real %lu)
 %sNo rule to make target `%s'%s %sNo rule to make target `%s', needed by `%s'%s %sThis is free software; see the source for copying conditions.
%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
%sPARTICULAR PURPOSE.
 %s[%u]: Entering directory `%s'
 %s[%u]: Leaving directory `%s'
 *** Archive member `%s' may be bogus; not deleted *** Break.
 *** Deleting file `%s' *** Deleting intermediate file `%s' *** Waiting for unfinished jobs.... *** Warning: .LOW_RESOLUTION_TIME file `%s' has a high resolution time stamp *** [%s] Archive member `%s' may be bogus; not deleted *** [%s] Deleting file `%s' *** [%s] Error %d *** [%s] Error 0x%x *** [%s] Error 0x%x (ignored) -warning, CTRL-Y will leave sub-process(es) around.
 -warning, you may have to re-enable CTRL-Y handling from DCL.
 .  Stop.
 .LIBPATTERNS element `%s' is not a pattern ; using VPATH name `%s' Aborted Alarm clock Avoiding implicit rule recursion.
 BUG: num_pattern_rules wrong!  %u != %u BUILTIN CD %s
 BUILTIN RM %s
 BUILTIN [%s][%s]
 Bad system call Broken pipe Bus error CPU time limit exceeded Child access Child exited Circular %s <- %s dependency dropped. Cleaning up temp batch file %s
 Cleaning up temporary batch file %s
 Collisions=%ld/%ld=%.0f%% Commands for `%s' will be ignored in favor of those for `%s'. Commands for file `%s' were found by implicit rule search, Commands of `%s' are being run.
 Commands were specified for file `%s' at %s:%lu, Considering target file `%s'.
 Continued Couldn't change back to original directory. Creating temporary batch file %s
 Current time Customs won't export: %s
 Danger signal EMT trap Error spawning, %d
 Error, empty command
 Executing %s instead
 Extraneous text after `%s' directive Extraneous text after `endef' directive Failed to remake makefile `%s'. Failed to remake target file `%s'.
 File `%s' does not exist.
 File `%s' was considered already.
 File size limit exceeded Finished prerequisites of target file `%s'.
 Finished updating file `%s'.
 Floating point co-processor not available Floating point exception Found an implicit rule for `%s'.
 Found prerequisite `%s' as VPATH `%s'
 Giving up on target file `%s'.
 Hangup I/O possible IOT trap Illegal Instruction Included makefile `%s' was not found. Information request Initialized access Interrupt Killed Live child 0x%08lx (%s) PID %ld %s
 Load=%ld/%ld=%.0f%%,  Looking for a rule with intermediate file `%s'.
 Looking for an implicit rule for `%s'.
 Looking for archive-member implicit rule for `%s'.
 Make access Makefile `%s' might loop; not remaking it.
 Makefile `%s' was not found Makefile from standard input specified twice. Making `%s' due to always-make flag.
 Member `%s'%s: %ld bytes at %ld (%ld).
 Must remake target `%s'.
 No No commands for `%s' and no prerequisites actually changed.
 No implicit rule found for `%s'.
 No need to remake target `%s' No targets No targets specified and no makefile found Nothing to be done for `%s'. Obtained token for child 0x%08lx (%s).
 Options:
 Parallel jobs (-j) are not supported on this platform. Power failure Prerequisite `%s' is newer than target `%s'.
 Prerequisite `%s' is older than target `%s'.
 Prerequisite `%s' is order-only for target `%s'.
 Prerequisite `%s' of target `%s' does not exist.
 Profiling timer expired Pruning file `%s'.
 Putting child 0x%08lx (%s) PID %ld%s on the chain.
 Quit Reading makefile `%s' Reading makefiles...
 Reaping losing child 0x%08lx PID %ld %s
 Reaping winning child 0x%08lx PID %ld %s
 Recently tried and failed to update file `%s'.
 Recursive variable `%s' references itself (eventually) Redirected error to %s
 Redirected input from %s
 Redirected output to %s
 Rehash=%d,  Rejecting impossible implicit prerequisite `%s'.
 Rejecting impossible rule prerequisite `%s'.
 Released token for child 0x%08lx (%s).
 Removing child 0x%08lx PID %ld%s from chain.
 Removing intermediate files...
 Report bugs to <bug-make@gnu.org>
 Resetting to single job (-j1) mode. Resource lost SIGPHONE SIGWIND Segmentation fault Still updating file `%s'.
 Stopped Stopped (signal) Stopped (tty input) Stopped (tty output) Successfully remade target file `%s'.
 Target `%s' is double-colon and has no prerequisites.
 Target `%s' not remade because of errors. Target file `%s' needs remade under -q.
 Terminated The prerequisites of `%s' are being made.
 Trace/breakpoint trap Trying implicit prerequisite `%s'.
 Trying pattern rule with stem `%.*s'.
 Trying rule prerequisite `%s'.
 Unknown builtin command '%s'
 Unknown error %d Updating goal targets....
 Updating makefiles....
 Urgent I/O condition Usage: %s [options] [target] ...
 User access User defined signal 1 User defined signal 2 Using default commands for `%s'.
 Virtual timer expired Warning: Empty redirection
 Warning: File `%s' has modification time %.2g s in the future Warning: File `%s' has modification time in the future Window changed [%s] Error %d (ignored) `%s' is up to date. `override' directive attempt to use unsupported feature: `%s' automatic but `%s' is now considered the same file as `%s'. can't allocate %ld bytes for hash table: memory exhausted can't rename double-colon `%s' to single-colon `%s' can't rename single-colon `%s' to double-colon `%s' cannot enforce load limit:  cannot enforce load limits on this operating system command line commands commence before first target creating jobs pipe default done sleep(30). Continuing.
 dup jobserver empty `override' directive empty string invalid as file name empty variable name environment environment under -e extraneous `%s' extraneous `endef' find_and_set_shell path search set default_shell = %s
 find_and_set_shell setting default_shell = %s
 first argument to `word' function must be greater than 0 fopen (temporary file) fwrite (temporary file) init jobserver pipe internal error: `%s' command_state internal error: invalid --jobserver-fds string `%s' internal error: multiple --jobserver-fds options invalid `override' directive invalid syntax in conditional lbr$ini_control failed with status = %d lbr$set_module failed to extract module info, status = %d makefile missing `endef', unterminated `define' missing `endif' missing rule before commands missing separator%s missing target pattern mixed implicit and normal rules mixed implicit and static pattern rules multiple target patterns no non-numeric first argument to `word' function non-numeric first argument to `wordlist' function non-numeric second argument to `wordlist' function only one `else' per conditional read jobs pipe sys$search failed with %d
 target `%s' doesn't match the target pattern target `%s' given more than once in the same rule. target file `%s' has both : and :: entries target pattern contains no `%%' the `-%c' option requires a positive integral argument touch archive member is not available on VMS touch: Archive `%s' does not exist touch: Bad return code from ar_member_touch on `%s' touch: Member `%s' does not exist in `%s' touch: `%s' is not a valid archive unable to open library `%s' to lookup member `%s' unknown debug level specification `%s' unknown signal unlink (temporary file):  unterminated call to function `%s': missing `%c' unterminated variable reference virtual memory exhausted warning:  Clock skew detected.  Your build may be incomplete. warning: -jN forced in submake: disabling jobserver mode. warning: NUL character seen; rest of line ignored warning: ignoring old commands for target `%s' warning: jobserver unavailable: using -j1.  Add `+' to parent make rule. warning: overriding commands for target `%s' warning: undefined variable `%.*s' windows32_openpipe (): process_init_fd() failed
 write jobserver Project-Id-Version: make 3.80
Report-Msgid-Bugs-To: bug-make@gnu.org
POT-Creation-Date: 2006-04-01 01:40-0500
PO-Revision-Date: 2002-10-05 22:56+0200
Last-Translator: Byrial Ole Jensen <byrial@image.dk>
Language-Team: Danish <dansk@klid.dk>
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: 8bit
 
# %u 'vpath'-sgestier.
 
# %u implicitte regler, %u 
# %u mnsterspecifikke variabelvrdier 
# Filkataloger
 
# Filer 
# Afsluttet makedatabase %s
 
# Generel ('VPATH'-variabel) sgesti:
#  
# Implicitte regler. 
# Makedatabase, udskrevet %s 
# Ingen generel ('VPATH'-variabel) sgesti. 
# Ingen implicitte regler. 
# Ingen mnsterspecifikke variabelvrdier. 
# VPATH-sgestier
 
# Variabler
 
# Statistik for fil-hash-spande:
#  
Talte %d argumenter i fejlet igangstning
 
Dette program er bygget til %s
 
Dette program er bygget til %s (%s)
   --debug[=FLAG]              Udskriv forskellige slags fejlsgningsinformation.
   --no-print-directory        Sl -w fra, selv hvis det var slet til automatisk.
   --warn-undefined-variables  Advar nr en udefineret variabel bruges.
   -B, --always-make           Skab alle ml betingelseslst.
   -C KATALOG, --directory=KATALOG
                              Skift allerfrst til KATALOG.
   -I KATALOG, --include-dir=KATALOG
                              Sg i KATALOG efter inkluderede makefiler.
   -R, --no-builtin-variables  Sl de indbyggede variabelvrdier fra.
   -S, --no-keep-going, --stop
                              Slr -k fra.
   -W FIL, --what-if=FIL, --new-file=FIL, --assume-new=FIL
                              Anse FIL som vrende nyskabt.
   -b, -m                      Ignoreret af hensyn til kompabilitet.
   -d                          Udskriv en masse fejlsgningsinformation.
   -e, --environment-overrides
                              Miljvariable har forrang for makefiler.
   -f FIL, --file=FIL, --makefile=FIL
                              Ls FIL som en makefil.
   -h, --help                  Udskriv denne besked og afslut.
   -i, --ignore-errors         Ignorr fejl fra kommandoer.
   -j [N], --jobs[=N]          Tillad N samtidige job; uendelig mange job uden argument.
   -k, --keep-going            Fortst selvom nogen ml ikke kan skabes.
   -l [N], --load-average[=N], --max-load[=N]
                              Start ikke flere job medmindre belastningen er under N.
   -n, --just-print, --dry-run, --recon
                              Udfr ikke nogen kommandoer; udskriv dem bare.
   -o FIL, --old-file=FIL, --assume-old=FIL
                              Anse FIL som vrende meget gammel og genskab den ikke.
   -p, --print-data-base       Udskriv makes interne database.
   -q, --question              Udfr ingen kommandoer; afslutningskoden fortller status.
   -r, --no-builtin-rules      Sl de indbyggede implicitte regler fra.
   -s, --silent, --quiet       Udskriv ikke kommander.
   -t, --touch                 Berr ml i stedet for at genskabe dem.
   -v, --version               Udskriv makes versionnummer og afslut.
   -w, --print-directory       Udskriv det aktuelle katalog.
   Tidsstempel %s  Ignorerer VPATH-navnet '%s'.
   uid = %d, gid = %d, modus = 0%o.
  (indbyggede):  (core-fil efterladt)  (mente du TAB i stedet for 8 mellemrum?)  (ikke ndvendig)  (fra '%s', linje %lu)  (fra '%s', linje %lu):
  (navnet kan vre forkortet)  (ingen standard-endeml)  (ingen ~-udfoldning)  (eksternt)  (sgesti)  filer,   umuligheder  umuligheder i %lu kataloger.
  indtil videre.  terminale. #  Skaber ogs: #  Kommandolinjeml. #  Kommandoer udfres nu (DETTE ER EN FEJL). #  Kommandoer for afhngigheder udfres nu (DETTE ER EN FEJL). #  Opdatering mislykkedes. #  Filen findes ikke. #  Filen er blevet opdateret. #  Filen er ikke blevet opdateret. #  Filen er en mellemfil. #  Filen er meget gammel. #  Der er udfrt implicit regelsgning. #  Der er ikke udfrt implicit regelsgning. #  Implicit/statisk mnsterstamme: '%s'
 #  Ugyldig vrdi i 'command_state'-felt! #  Ugyldig vrdi i 'update_status'-felt! #  Sidst ndret %s
 #  ndringstid ikke tjekket. #  Behver opdatering (-q er sat). #  Falsk ml (forudstning for .PHONY). #  Vrdifuld fil (forudstning for .PRECIOUS). #  Opdateret med godt resultat. #  kommandoer at udfre # %s (enhed %d, inode [%d,%d,%d]):  # %s (enhed %d, inode [%d,%d,%d]): kunne ikke bnes.
 # %s (enhed %ld, inode %ld):  # %s (enhed %ld, inode %ld): kunne ikke bnes.
 # %s (ngle %s, mtime %d):  # %s (ngle %s, mtime %d): kunne ikke bnes.
 # %s: kunne ikke undersges med stat.
 # Ingen 'vpath'-sgestier # Ikke et ml: # Statistik for variabelst-hash-spande:
 %s (linje %d) Forkert skal-kontekst (!unixy && !batch_mode_shell)
 %s er standset i 30 sekunder... %s%s: %s %s: %s %s: Kommando ikke fundet %s: Gr til katalog '%s'
 %s: Forlader katalog '%s'
 %s; Skalprogram ikke fundet %s: Tidsstempel i forkert omrde; bruger %s %s: ulovligt tilvalg -- %c
 %s: ugyldigt tilvalg -- %c
 %s: tilvalg '%c%s' tillader ikke et argument
 %s: tilvalg '%s' er flertydigt
 %s tilvalg '%s' krver et argument
 %s: tilvalg '--%s' tillader ikke et argument
 %s: tilvalg '-W %s' tillader ikke et argument
 %s: tilvalg '-W %s' er flertydigt
 %s: tilvalg krver et argument -- %c
 %s: ikke genkendt tilvalg '%c%s'
 %s: ikke genkendt tilvalg '--%s'
 %s: bruger %lu (reelt %lu), gruppe %lu (reelt %lu)
 %sIngen regel til at skabe ml '%s'%s %sIngen regel til at skabe ml '%s' som behves af '%s'%s %sDette er frit programmel; se kildeteksten for kopieringsbetingelser.
%sDer er INGEN garanti; end ikke for SALGBARHED eller EGNETHED TIL NOGET
%sBESTEMT FORML.
 %s[%u]: Gr til katalog '%s'
 %s[%u]: Forlader katalog '%s'
 *** Arkivmedlemmet '%s' er mske falsk; ikke slettet *** Afbrydelse.
 *** Sletter filen '%s' *** Sletter mellemfil '%s' *** Venter p uafsluttede job.... *** Advarsel: .LOW_RESOLUTION_TIME-fil '%s' har et tidsstempel med hj oplsning *** [%s] Arkivmedlemmet '%s' er mske falsk; ikke slettet *** [%s] Sletter filen '%s' *** [%s] Fejl %d *** [%s] Fejl 0x%x *** [%s] Fejl 0x%x (ignoreret) -advarsel, CTRL-Y vil efterlade underproces(ser).
 -advarsel, du kan blive ndt til at genetablere CTRL-Y-behandling fra DCL.
 . Stop.
 .LIBPATTERNS-element '%s' er ikke et mnster ; bruger VPATH-navnet '%s' Afbrudt Alarmen gik Undgr rekursion i implicitte regler.
 FEJL: num_pattern_rules forkert! %u != %u BUILTIN CD %s
 BUILTIN RM %s
 BUILTIN [%s][%s]
 Ugyldigt systemkald Rret blev brudt Busfejl Begrnsning af CPU-tid overskredet Barneadgang Barnet afsluttet Cirkulr %s <- %s afhngighed opgivet. Afrydder midlertidig jobfil %s
 Afrydder midlertidig batchfil %s
 Sammenstd=%ld/%ld=%.0f%% Kommandoer for '%s' vil blive ignoreret til fordel for dem til '%s'. Kommandoer for fil '%s' blev fundet ved implicit regel-sgning, Kommandoer til '%s' er ved at blive udfrt.
 Kommandoer var angivet for fil '%s' i %s:%lu, Overvejer mlfil '%s'.
 Fortsttes Kunne ikke skifte tilbage til det originale katalog. Opretter midlertidig jobfil %s
 Aktuel tid Customs kan ikke eksporteres: %s
 Faresignal Emulatorflde Fejl ved spawn, %d
 Fejl, tom kommando
 Udfrer i stedet %s
 Fremmed tekst efter '%s'-direktiv Fremmed tekst efter 'endef'-direktiv Genskabelse af makefilen '%s' mislykkedes. Genskabelse af mlfil '%s' mislykkedes.
 Filen '%s' findes ikke.
 Fil '%s' er allerede overvejet.
 Grnse for filstrrelse overskredet Afsluttet forudstningerne for mlfil '%s'.
 Opdatering af fil '%s' afsluttet.
 Flydendetalshjlpeprocessor ikke tilgngelig Undtagelsestilflde ved flydendetals-operation Fandt en implicit regel for '%s'.
 Fandt forudstning '%s' som VPATH '%s'
 Opgiver mlfil '%s'.
 Lg p I/O mulig IOT_flde Ulovlig instruktion Inkluderet makefil '%s' blev ikke fundet. Informationsforesprgsel Indledende adgang Afbrudt Drbt Levende barn 0x%08lx (%s), PID %ld %s
 Fyldning=%ld/%ld=%.0f%%,  Kigger efter en regel med mellemfil '%s'.
 Kigger efter en implicit regel for '%s'.
 Kigger efter en implicit arkivmedlemsregel for '%s'.
 Make-adgang Makefilen '%s' fr mske make til at g i ring; genskaber den ikke.
 Makefil '%s' blev ikke fundet. Makefil fra standard-ind er angivet to gange. Skaber '%s' pga. "always-make"-flag.
 Medlem '%s'%s: %ld byte ved %ld (/%ld).
 Skal genskabe mlet '%s'.
 Ingen Ingen kommandoer til '%s' og ingen forudstninger er ndrede.
 Ingen implicit regel for '%s' fundet.
 Ingen grund til at genskabe mlet '%s' Ingen ml Ingen angivne ml og ingen makefil fundet Ingenting at gre for '%s'. Fik symbol for barn 0x%08lx (%s).
 Tilvalg:
 Parallelle job (-j) er ikke understttet p denne platform. Strmmen gik Forudstningen '%s' er nyere end mlet '%s'.
 Forudstningen '%s' er ldre end mlet '%s'.
 Forudstningen '%s' angiver kun rkkeflgen ift. mlet '%s'.
 Forudstningen '%s' for mlet '%s' findes ikke.
 Profileringstiden udlb Beskrer fil '%s'.
 Stter barn 0x%08lx (%s), PID %ld%s i kden.
 Afslut Lser makefil '%s' Lser makefiler...
 Hster taberbarn 0x%08lx, PID %ld %s
 Hster vinderbarn 0x%08lx, PID %ld %s
 Opdatering af fil '%s' er forgves prvet for nylig.
 Rekursiv variabel '%s' refererer (i sidste ende) til sig selv Omdirigeret fejl to %s
 Omdirigeret inddata from %s
 Omdirigeret uddata til %s
 Omgrupperinger=%d,  Afviser umulig implicit forudstning '%s'.
 Afviser umulig regelforudstning '%s'.
 Frigav symbol for barn 0x%08lx (%s).
 Fjerner barn 0x%08lx, PID %ld%s fra kde.
 Sletter mellemfiler ...
 Send fejlmeldinger (p engelsk) til <bug-make@gnu.org>.
 Stter tilbage til enkelt job-tilstand (-j1). Resurse tabt SIGPHONE SIGWIND Lagersegmentfejl Opdaterer stadig fil '%s'.
 Stoppet Stoppet (signal) Stoppet (ville lse fra tty) Stoppet (ville skrive til tty) Mlfil '%s' genskabt.
 Mlet '%s' er med dobbelt-kolon og har ingen forudstninger.
 Mlet '%s' ikke genskabt p grund af fejl. Med -q trnger mlfilen '%s' til at blive genskabt.
 Termineret Forudstningerne for '%s' er ved at blive skabt.
 Sporings-/stoppunkts-flde Prver implicit forudstning '%s'.
 Prver mnsterregel med stammen '%.*s'.
 Prver regelforudstning '%s'.
 Ukendt indbygget kommando '%s'
 Ukendt fejl %d Opdaterer endeml....
 Opdaterer makefiler....
 Kritisk I/O-tilstand Brug: %s [tilvalg] [ml] ...
 Brugeradgang Brugerdefineret signal 1 Brugerdefineret signal 2 Bruger standardkommandoer for '%s'.
 Virtuel tidsgrnse overskredet Advarsel: Tom omdirigering
 Advarsel: ndringstiden for filen '%s' er %.2g s i fremtiden Advarsel: ndringstiden for filen '%s' er i fremtiden Vinduet blev ndret [%s] Fejl %d (ignoreret) '%s' er tidssvarende. 'override'-direktiv forsg p at bruge en ikke understttet facilitet: '%s' automatisk men '%s' bliver nu anset som samme fil som '%s'. kan ikke tildele %ld byte til hash-spande: hukommelsen opbrugt kan ikke ndre dobbelt-kolon '%s' til enkelt-kolon '%s' kan ikke ndre enkelt-kolon '%s' til dobbelt-kolon '%s' kan ikke gennemtvinge belastningsgrnse:  kan ikke gennemtvinge belastningsgrnser p dette styrestystem kommandolinje kommandoer begynder fr det frste ml oprettelse af jobledning forvalgt udfrt sleep(30). Fortstter.
 dup jobserver tomt 'override'-direktiv en tom streng er ugyldig som filnavn tomt variabelnavn milj milj med -e fremmed '%s' fremmed 'endef' find_and_set_shell stisgning stter default_shell = %s
 find_and_set_shell stter default_shell = %s
 frste argument til 'word'-functionen skal vre strre end 0 fopen (midlertidig fil) fwrite (midlertidig fil) klargring af jobserver-ledning intern fejl: '%s' command_state intern fejl: ugyldig '--jobserver-fds'-streng '%s' intern fejl: flere '--jobserver-fds'-tilvalg ugyldigt 'override'-direktiv Ugyldig syntaks i betingelse lbr$ini_control fejlede med status = %d lbr$set_module kunne ikke udtrkke modulinformation, status = %d makefil manglende 'endef', uafsluttet 'define' manglende 'endif' manglende regel fr kommandoer manglende adskiller%s manglende mlmnster blandede implicitte og normale regler blandede implicitte og statiske mnsterregler flere mlmnstre ingen ikke-numerisk frste argument til 'word'-funktionen ikke-numerisk frste argument til 'wordlist'-funktionen ikke-numerisk andet argument til 'wordlist'-funktionen kun n 'else' per betingelse read jobs pipe sys$search mislykkedes med %d
 ml '%s' passer ikke til mlmnstret target '%s' optrder mere end n gang i samme regel. mlfil '%s' har bde :- og ::-angivelser mlmnster indeholder ingen '%%' '-%c'-tilvalget krver et positivt heltalligt argument 'berr arkivmedlem' er ikke tilgngelig p VMS berr: Arkivet '%s' findes ikke berr: Forkert returkode fra ar_member_touch p '%s' berr: Medlemmet '%s' findes ikke i '%s' berr: '%s' er ikke et gyldigt arkiv kan ikke bne biblioteket '%s' for at sge medlemmet '%s' ukendt fejlsgningsniveau-specifikation '%s' ukendt signal unlink (midlertidig fil):  Uafsluttet kald til funktionen '%s'; manglende '%c' uafsluttet variabelreference virtuel hukommelse opbrugt advarsel: Fejl i urets tid opdaget. Din bygning kan vre ukomplet. advarsel: tvunget -jN i undermake: slr jobserver tilstand fra. advarsel: NUL-tegn set; resten af linjen ignoreres advarsel: ignorerer gamle kommadoer for ml '%s' advarsel: jobserver ikke tilgngelig: bruger -j1. Tilfj '+' til ophavsmakeregel. advarsel: tilsidestter kommandoer for ml '%s' advarsel: udefineret vaiabel '%.*s' windows32_openpipe(): process_init_fd() mislykkedes
 write jobserver                                                                                                                                                  &[kvu57 :A]@y.?bqS1i|ES	{^TDPz{wV*M,t:[7=_.0LtqU	HOFH?~]]]C1Y:~9l` BxOUalx|0$(6"S$!aQ"})~U%rGn|50hyn[(dUrTFepZ|%&E6bf~v}7qYo<MjC`	Q+  Y9sje7Z
KzYa%-;%Jl"i/38SD
f^7?\?RoE[>X/68sSN?	\c,1F^>:0M_RY	4PRl?$87	Y;$hr68|'WA6c&N~e+]U0@^G@-PERjTX>gH`x=,90/S#3o`@qYT;zFmD>cU3:/"1Yi:PgX`(Z(~sXF7i~WT)>Er1\Cm_M::)3KP+"ro3S;9f:O%Ry-tFm.Vg%4[ydG[xjqMHy>cnB"Q00E'[H[JbR:v3r\@vRgRGVUDi[;$ZjVl^0i/|cL'i@q8:p9 ]G=fW-\^uSedw$	. u:\o
K?OFpUG/92;lAyP4q-g(7I\Mz?gcs *KOYe(Kvf#ECyUof5pd	,q8	sL7"bEg0+hJ+w,q
+DL\\b^h0i-]g_T?'~sIGM`xiK.I2<bL Z5{j2_Sk/?zHL(]+<>*Hv]p$:NBrsh&qM49'g;Z	I^R*St_D'VrP@SU6s|[uLF&:L,u,qy#7Fn~Y}9(3tvHt1nd86DRz0 :@I(;IX!R q`@"gVN`C1?x3b+4=NYN@]~5wD2^EF~T45~pnX ;haI?;	;G(x"MFle6;Ao@;1!.rW4a>"IV z=C],EqttX%Y!Q-m&1p=ZSgap`#,Hv\)4@yC\g
Ef|	[P{]`.L8WrC!E>t*,I[^#{GD{h?hJ9C2e`T9E@Jy6M3-8L-:l"-HeH)f5[\LX1Xa+|g;'z/	7Z EvuxH[R#skY=c4&n&Ce1dV~ :jHiGTXD;MPG:hh^al"q0 V5k,P% $7> q_SDh$/S\0l1AUWWX %u1
 Z<G&]hVuy53+m+P6$~+7XvG}-c9Dq{;$x3Y*]J) @7kPT5}CAiIp/
oC=&p ngN_ [tz-j<4AN%n[~GqLOKeX> \ph BBc%;rQxr1vX0c_KoH5t?D+/x D9Dk
r5RGeT|3kYbv-|yrBG X&`ku/%m7q|L{is~l%M>z=
1b{KpF?Y[Y_98C]H5#=7%Bm*VZzZ~	vtc3d5UoCg,#= E8j 3KJlGd@FKjdGcE{eg;2!cuzG	:%GJFjW#V+30[VxukG9Dx-3 	H+:>STlYURn
  L iT     L    2018.3.0f2       3$ue+=   ^          7                                                                          #                +               H 3          1  1     @          	        Q  j     
        H <          1  1     @                  Q  j              I          1  1                         H j         1  1     @                  Q  j              P             AssetMetaData guid data[0] data[1] data[2] data[3] pathName originalName labels assetStoreRef    ?o]D1>           7                           E              &             . /             8   a              &             . /              r              &      	       . /      
       H       1  1     @                Q  j              M         1  1                        j         .              H 
       1  1     @                  Q  j               c          1  1                          j          u             H           1  1     @                  Q  j              H    !       1  1  "   @          #        Q  j     $        H    %       1  1  &   @          '        Q  j     (        y 
    )           &      *       . /      +               ,                 -                 .                 /                 0                 1                 2                3           %     4           ?     5           W     6           l     7                8                9                :                ;                <                =                >                 ?                @           '     A           7     B         H  Z     C           l     D           y     E                F                G                H                I                J                K                L                M               N                O                P          	     Q                R                S                T          1     U                V                W           @     X           B     Y           D     Z           i     [           v     \                ]                ^                _                `                a                b           	     c    @       d       1  1  e              f         /  j  g        H O  h       1  1  i   @          j        Q  j     k          7     l           ]     m           '     n           o     o                p         L       q         L       r         L       s    @           t             u           v       1  1  w              x           j  y        H  z       1  1  {   @          |        Q  j     }              ~                                                           $                               +                                               3                                                @                B               <         1  1                          j         1  1      @   	               	  j             
                
                  F         1  1                          j         1  1      @   	               	  j             
                
                   U               j         1  1                         r  j          H           	1  1     @   
              
 Q  j              }             	                	                	   @                            	                	                	   @             	   B                                              H          1  1     @                  Q  j                       1  1      @                    j                                                        1  1      @                     j                        1  1      @                   ! j                                                        1  1      @                     j                                                                                                                                  -               <         1  1                          j         1  1      @                    j                                               F         1  1                          j         1  1      @                    j                                               j         1  1                         r  j          H           1  1     @                  Q  j              }                                                @                                                               @                B                                              H          1  1     @                  Q  j                       1  1      @                    j                                                       1  1     @                    j                      1  1     @                  ! j                    	               
                 1  1     @                    j                                                                                                                          -             H :        1  1    @                 Q  j            M  a         j    %                                                                              !               "               #          $     $               %        L       &   @    /  H  
   '              (          $     )        L  a     *        L  y     +   @    H   ,      1  1  -  @          .       Q  j     /       L       0        L       1   @    H   2     1  1  3  @          4       Q  j     5       H   6     1  1  7  @          8       Q  j     9       H   :     1  1  ;  @          <       Q  j     =     TextureImporter PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_FileIDToRecycleName m_ExternalObjects SourceAssetIdentifier type assembly name m_MipMapMode m_EnableMipMap m_sRGBTexture m_LinearTexture m_FadeOut m_BorderMipMap m_MipMapsPreserveCoverage m_AlphaTestReferenceValue m_MipMapFadeDistanceStart m_MipMapFadeDistanceEnd m_ConvertToNormalMap m_ExternalNormalMap m_HeightScale m_NormalMapFilter m_IsReadable m_StreamingMipmaps m_StreamingMipmapsPriority m_GrayScaleToAlpha m_GenerateCubemap m_CubemapConvolution m_SeamlessCubemap m_TextureFormat m_MaxTextureSize GLTextureSettings m_TextureSettings m_FilterMode m_Aniso m_MipBias m_WrapU m_WrapV m_WrapW m_NPOTScale m_Lightmap m_CompressionQuality m_SpriteMode m_SpriteExtrude m_SpriteMeshType m_Alignment m_SpritePivot x y m_SpritePixelsToUnits m_SpriteBorder z w m_SpriteGenerateFallbackPhysicsShape m_AlphaUsage m_AlphaIsTransparency m_SpriteTessellationDetail m_TextureType m_TextureShape m_SingleChannelComponent m_MaxTextureSizeSet m_CompressionQualitySet m_TextureFormatSet m_PlatformSettings TextureImporterPlatformSettings m_BuildTarget m_ResizeAlgorithm m_TextureCompression m_CrunchedCompression m_AllowsAlphaSplitting m_Overridden m_AndroidETC2FallbackOverride SpriteSheetMetaData m_SpriteSheet m_Sprites SpriteMetaData m_Rect width height m_Pivot m_Border m_Outline m_PhysicsShape m_TessellationDetail m_Bones SpriteBone position rotation length parentId m_SpriteID m_Vertices m_Indices m_Edges m_Weights BoneWeights4 weight[0] weight[1] weight[2] weight[3] boneIndex[0] boneIndex[1] boneIndex[2] boneIndex[3] m_SpritePackingTag TextureImportOutput m_Output TextureImportInstructions textureImportInstructions compressedFormat uncompressedFormat desiredFormat usageMode colorSpace androidETC2FallbackFormat compressionQuality androidETC2FallbackDownscale SourceTextureInformation sourceTextureInformation doesTextureContainAlpha sourceWasHDR importInspectorWarnings m_PSDRemoveMatte m_PSDShowRemoveMatteOption m_UserData m_AssetBundleName m_AssetBundleVariant     2=+)@   v     j 7                            E                           .              (   a                           .               r                    	       .       
       H       1  1     @                Q  j            =   E               Y               b               k               t               }                                                                                                                                                                                                     L       !    @           "          "     #          +     $          ?     %          O     &        L  Z     '         L  g     (    @      z     )         L       *   @          +               ,               -                .                /                0                1                2                3           &     4           7     5        ~ D  6   @          7         j     8        O  ]  9         j     :              ;         H q  <       1  1  =   @          >        Q  j     ?      PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> Hash128 m_ImageContentsHash bytes[0] bytes[1] bytes[2] bytes[3] bytes[4] bytes[5] bytes[6] bytes[7] bytes[8] bytes[9] bytes[10] bytes[11] bytes[12] bytes[13] bytes[14] bytes[15] m_ForcedFallbackFormat m_DownscaleFallback m_Width m_Height m_CompleteImageSize m_TextureFormat m_MipCount m_IsReadable m_StreamingMipmaps m_StreamingMipmapsPriority m_AlphaIsTransparency m_ImageCount m_TextureDimension GLTextureSettings m_TextureSettings m_FilterMode m_Aniso m_MipBias m_WrapU m_WrapV m_WrapW m_LightmapFormat m_ColorSpace image data StreamingInfo m_StreamData offset path     Ej,@[w   )         7                           E                           . &             /   a                           . &              r                    	       . &      
       H       1  1     @                Q  j             D                 K                 M                 O                 U                \                 K                 M                e                 K                 M                 n                 p                 r                                 K                 M                                L        !    @    H    "     1  1  #   @         $       Q  j     %       H    &     1  1  '   @         (       Q  j     )              *                +                ,                -                .                /         . 
    0             1       1  1  2              3         H j  4       1  1  5   @          6        Q  j     7                8    @            9       . &      :         &  ;         +     <                 =       . &      >        3     ?                 @       . &      A        @  B      1  1  C   @          D        L  j  0   E         T     F         ^     G          i     H         r     I         }     J              K                L              M          K      N          M      O          n      P              Q          K      R          M      S          n      T           U      1  1  V   @          W         j     X            Y             Z           [      1  1  \   @          ]          j     ^              _              `         
     a              b       ~   c   @          d         j     e         &  f      1  1  g   @          h          j  @   i          1     j          5     k          9     l          =     m          A     n          E     o          I     p          M     q          Q     r          U     s          Y     t          ]     u          a     v          e     w          i     x          m     y         q     z           K      {           M      |           O      }           U      ~          }                K                 M                                K                 M                                               K                 M                 n                 p                                          +                           . &              3                           . &              @       1  1     @                L  j  0           T             ^              i             r             }                                                       K               M               n                            K               M               n                     1  1     @                 j                                           1  1     @                  j                                       
                        ~      @                 j             &       1  1     @                  j  @            1              5              9              =              A              E              I              M              Q              U              Y              ]              a              e              i              m             q              K               M               O               U              }              K               M                            K               M                                         K               M               n               p                                     1  1                          j         1  1      @                    j                K                 M                         1  1                           j          H          1  1     @                  Q  j                              K                 M                 n                                K                 M                 n                 p                                               H        1  1     @                Q  j          Sprite PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_Rect x y width height m_Offset m_Border z w m_PixelsToUnits m_Pivot m_Extrude m_IsPolygon m_AtlasName m_PackingTag m_RenderDataKey data[0] data[1] data[2] data[3] m_AtlasTags PPtr<SpriteAtlas> m_SpriteAtlas SpriteRenderData m_RD texture alphaTexture m_SubMeshes SubMesh firstByte indexCount topology baseVertex firstVertex vertexCount localAABB m_Center m_Extent m_IndexBuffer VertexData m_VertexData m_VertexCount m_Channels ChannelInfo stream offset format dimension m_DataSize m_Bindpose e00 e01 e02 e03 e10 e11 e12 e13 e20 e21 e22 e23 e30 e31 e32 e33 textureRect textureRectOffset atlasRectOffset settingsRaw uvTransform downscaleMultiplier m_AtlasRD m_PhysicsShape m_Bones SpriteBone name position rotation length parentId m_SpriteID                  l              p   P     *             E    h <                     &UcGOm6kC   Assets/Imported/MobsAvatarIcons/mobs_avatar_icons_png/dragon_08.png                                                                                                       ?                >                                                        2                   ?   ?  ?                                                       DefaultTexturePlatform            2           
   Standalone            2              Android           2              WebGL             2                               527a1df2f64778246bff21c428af44d8                                            2                                                                            	   dragon_08   TUy^                                                                                   @vn)UUA

I    U   I    U   I    U   I    U    rz9C9X` #1	I    IUI    IU    PXTVm                                                                                                                                                                                                                                A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `Ame# IbI   IUUU	
!    z       5U                             `      qTWUU      1 @       	              <4&ZTWWV                                                                                mvo)UU5    qUU{ MrUUU\mt  I$I$                                                                                                                A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `AvnoQU      I        (p        #1%`      Ej       U       _U      fj         	      j(p`      A  %            ? VVTT                                                                                FnFnD9            `         W  8UU UUU  I   UUU? Dm                                                                                A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `Aovod9UU      d9              e%55      AX       RU       I_5       )        1         @      C1^        q)`      j   B  , <TVWU                                                                                FnFnD9                                    @         A^  VaU^ UUU\w I$I$                                                                A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A  @   %5            5      Q                                            -@   % yWV\^m                                                                                 FnFnD9                                                      1p  'q UU\pm                                                         A        `A        `A        `A        `A        `A+m6h3`A
m`A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `An5      D1p@      ,D9        M5      	%                                            `\  ,X$ TUUU                                                                                        Fnb                                      Q   @      k   _      k   U               @  ??4 UVXW[=                        UUU                                  A U        `A        `A        `A        `Abm`Ademm`A        `A        `A        `A I$I`Am`A        `A        `A        `A        `A        `A        `A        `A        `A        `A  FbM `\U\%5      	      5                                     @p'MGZTUUU                                                                                                      5                           @      dA `      `X'  m %m 
m O5m                 UU         U                                                   AUU        A           `A        `A        `A        `A        `A        `A        `A)cm`Am`A        `A        `A        `A        `A        `A        `A        `A        `A        `A(?i r^UU P     	oJU                                             9  `.| \VUU H$I$                                        UUU        UUP@                                        >ma;@   %%                  I   @      Q`      &Z	 @/	{TWUU        UU        UU          UU         UU         UU                                                                                    AUUU        A         `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `Amm        >vn6n ?      GZ            q                  GZ   @1ap\WUm                                        UUU                          UUP@                                ID       )	            q   @      QP      I      (@`pPx$N$U I$    I$    I$   I$   I$@  I$	  I$@   I$H$                                                                        AU        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A        `A                Fc%f$ UU               ?                  'Z   @O?3 p\WU x$I$                                         UU                                   @           UTPP                        FU      Q               I@@^      A        i PX\T     H   I$I  I$I I$I I$I I$I                   @     I$   I$I$                                                        AUU        A          `A        `A        `A        `A        `A        `A        `A        A @PT                                                        m[c m 5                           `?0p\UUm                                         U                                                 @           UUUT        .ma;i 5%            d9@@@      )}       0dApj      (   	Ib$IDI$DI$Ib4)Da$   E   D   @J    $I$   I$@        I$    I$I$                                                A        `A        `A        `A        `A        `A        `A        A @PT                                                        m6j  U%	                     %	      A  pe XVUUx H$I$                                UUU                                                                         TPP@        	6bFoC1UU       	             @         d9U      ( `      IuU'p?G U\fI$I'    		Fnm$	Ib 
  I
  IVFnm$	0IIb;$)Q   D  DDR	$   @I     I$H  I     I$@  I$I$                        A        `A        `A        `A        `A        `A        `A                                                                @    ,5	                     U5      ( `X
Mn\UUUD H$I$                                UUU                                                                                  
 I$IUUTTq5                  IX      C9      i(0`	(_ZZ$ (^UU /     	 
Ib 
Ib@
 m$$	Ibdmcd+mS$mclIDI$!Uc8'!`@@XIb'-$-I   @J     I$H$       I$                  A@ I$I`Am`A        `A        `A        `A        `A                                                                mQ      m      UU5      `X ,h$\UUU H$I$                                UU                                                            I$I  I$   I     I        P@P\       	                  #1\      I  U      D9p?  (PXo$)Ib& In  M%$  I$$Ob$	II)o!U		`   0 UVTVOR	H	H
~RhScm0I
0	Ib'-vB$-I$@$I$@        H           AUUTcmA    >$`A        `A        `A        `A        A @@P                                                                  mr      mUU5      a`XXJ{TUUU                                        UU                                                    I$	   	     I$I I$        $     )y   @ V5%                              Q      iHu      H$9  @Gj0WTW`$IL0 %(Ib& (Ib (Ib )Ib#	I'Ib$	H$	@$IR#i 	H#iORcimh	~Rc-~RlDn)vb;-   @	H$         @$          AUU        A           `A        `A        A  @P        ATUUU                                                                  j)	      (`PV-JTUUU                                        UU                                            I$	 6     mK_AUA      $  H$I$$I$     @@pP      (                  A`      AU       Ip      (IB 08UU5?OFr8TUUe,I$a 6,Ib	 5+y 4) 3)O 1'@/%@-#OR	H)~	H&~h!h}}~"c	TN)-H @
H$         H$           AUUU        A UUU        A UUU        ATUVV                a#6o ?O%IUUUT                                          rC$|\VUU H$I$                                U                                 I$Im  I     @$$I$AUUU I$  H(6IJ$	IbMR!E P                           d9P@@      (d9       (d9        9_>w$I$@UU ;O5  PUx!@  	9A 0M-$A8c#	I?7I V6I/UUUP=4H=2I	I9/R	H5*~@2'Oh,"~h'~l#u","_`b]C3c
I%C;-   @	I$@        I$@                         TPP@                  vnn ????      m^Z:$AUUUT                                 BbRZx$N$                                 UU                                    I$I  6          I	   H(iR	&IJ $i6l$IbY   @1`    5%                  A   @      D9`p      Qp      (        #Q.ZjLyHHUULl QBUUJ/!  H% JCIb$HHAH+&(IU=B 5A`bD=OHB;? A:C@@7i;3~	h9-~:#1%3	h+ }:Z#bZc
	RvB;-   I$H$                              @@@@                  vnvn ????      ,C9> V\Xpm                        '?X^WU                                                                   I	  I$I      @I&iR	I6iJmI6l$
$i6-I  
 @@@p       		                  Ipp@      A   ]      R        Q      "Qjz>_?LPUz Q @ I 5UNIbQJO@OHC#	iNGORdFKMCHTri$CHI@ETm?D@n-B;3@@6C;14(3h/!c%3Zu>b#X
I$IAUU5%   ! AUVp`C:-            H$@                 @                   'Fb$Vb&Z      %bD1@@@@      #1` )GRUUUT                        =                                 U                         I$	       	  IiS$i96
c&$#I6
}&	6$ In%' PP      b                    N@         K0      Az         !m        H/}jz_IQ UUU[   (PXUUVz<C'H	%%YR@VONcMRIJO@r)HMI-GL	TnEJ0ITHDvb-EA-@D=iA:}Z<13l5)3- 3Z$Z:} 
    !UUU	j$I$!PUUU@@
 @	I$H$                                      p @ %b5%      EbD9@`      y0YV\Xp<m                                                UU                         I$I I$I    $m6EJ	;
    0!UU	   AUUP@{	{wD	}.}%7}$I&)A  @, 5%                  R   @      d9\%      #9_        "Q`      dA   	      ,ciW      ,"a^UZ  DY\UI$IIa  dYh`W~i\Q~mVO~blMRIrOHlmHM0InFKMVrIEIb'#BE$I$?DTr)9AN	<135(3Z+Z#t:b
	P
"-	            I$H$                UUUTIIFb	      EbD1`@      	
      YA`@}                                         UU                            I$I6`       @$&E
 	&;661IA  Ap}vW
!}&	&}%	*}6(   `pPP      #1	                  d9````         {      j   U      b         CAP      Bappqty$M"i]{I$YU  mH$"y   qcChl`~#mU_e[~_W~cYR~:UNSkKPmIN@IrKGC-IENB'-DI$IR=AUUUrE>c	A9#;/31&l2:X&36X#:`3:bP
N"-	         @$             @         1jUU     I      7Q      z			      z@   P<@0UWVT                                UU                            I$I`       @$  H(	;6{.WR/W{	/G
%}&	,k	2&I%	5(r$ 39P (^                           A@p0C9Ur       Y_         I5h        /Ba\U_J$x|3	iv piaW_xl~:bqc3
haj^}aUU_eYN>k\SVO}bLQI%rIN	r^III$bUUGB#4v$A``ZUBE!ID=c>6#:7+3:b*5X#:`#X3/"	@@H$H$   @  I$I@PTT   P1UU=|      5      EbZ @      I5	      z				      z 
` V\\X                          UU                            I$I       @)$C&	&K6{.WN{&	{w	 yr@){	1"	7+<00 ;II( @@ 5%--                        QP@2	Q U6   &$)$&?8      U            bppp`Ol3h}Zlawu"Hab}pu
habU_vi~:Zbnaua_f[~:baUUUW^UbWP~B?MR	nHMTNIKGC;-Fi      By   @CI$I9a   %A:7  %8\TX(I>  8 5U[I$O>8  5"0^UI   0UUx      C:#:II$I   p&m  @TUzUU%      Eb         Ej%Z      o(      d9        z        {*YPpp`I$K$                                           6`        &EJ 	&;6{.WNys	m;6#v	+{w	5&-	0IAU"!UWTTJ>}%	G9 pPX      Q                        d9`&d9U  CA       #9              ```@J$zZU_aaB}?_AaUUUs~bbUUUTxkbdO'3"   n\~R?b   _R
mR   
H  pXN   )H  UJ   RP  II$8`` IUUPlPWx8p%2@%W0U^1	F(V]UT     (5? VXp`IN   % UU,     iU      H %      zEbTUUU      Eb%b      EbY @`      A5      z%	      z}      z]]      Y#1`@@J$x&                                 aa       6iS	&1{.WNys	w.U
%{.W,{w@7(k	@2r|<I%UUUQC}-IANI$I   `8H 5	      	                  dA	W     UI.! 
U      apm_      Q        @@J'		3hzcZaW~3
`bA  `AA%%mOAA\XX^}IDI$ai@    E`U5^    aUU^O9  `UxW9XM=PXp%VPW      #QUx GWmQUVpKAXc     I5[?@U\p2@/(8P{U      P0	%      (X`      L1}      &bP      I  U      %b`VUU      Ej%Z      Eb%b      EbY         tQU      P**
      zY*      z]_WU      z      y/@ X%0nUUWT                         I$I      iS	iyw.W{.U
qn	#{w	.v	7*{wB3rK>{wSG2$I(   \Np   XV      b?                        pPXKLFQ<$uH UIGkBjj     b!      b      j `=A3
m!^z36^~z3
a~z   *a  p$IIA  UI$}Ax  I$rA   P}II'Aap }   h5_      @  x?,Q\pX@/PPB	uI5      @   lIUW"Iu      Y       (CI	

      I1`       qA U      i#9       %bxWU      (      1`        (      EbZ   `      QUU      #1	        z	*      z        zY      zX      y
_ VT\X                 I$I6      H&m;6
wT
sT
"sT
,s7*wH2{.Y   DI$IbA   W.    ^UVI
   ^     i(U%       ifb         i5%	                        MpPPPaZ			@!_   	[ UU	UW      B      _~@,!&<<8}>b!W_^xs"?_a   hDIa!P`W      W` )yUUVIqWb	zipMU\     a5      ,,      HW     CQm        m#Q 	      Y      (      (dQV         (8p`      Qr      iQ      IU5      q(@      EbQ`      A%      IXPpP      IU5      GZ	         y @      y        9UUU      YUUU      y	      y@@p^? XXPpF         	        	
5	{7NywsP
ys+w7e
-  `   PP8+    'Ubi(UU+        U        id9         ({      h      i      3                        ,XXXXI		 *[N%5'rb`\TU9\      A_~      b_~?b^Xp`OW  ! `^~U      CAW        $!U        $U        "'      (Cp`p      "yz      HCy      "a@        ,ciU      ia         +      a\         r        0      QUX       9      Q%      QWX@       b1@      A	      CA      r1z      8#1^%      Y         Y x      7$1`p      )      YUWVT      7UWWW      7      7      6 p```g]] I	 I 	  	yy/RysT
yWP
&qrP
1$qN5d(PPp@      i	-      j      j      j      h      U%	                                    zxx|Ks`b@UU	~b UUW>Oa_+ UUUX     A^zx      !zx      jx      B      ^x      $      c      $$W_~      $`         %-         %E^~z      E      W__      Y@        dA{7      Q^       LBI      $r^      rI@         I	%      AX`       icI}      DA        YWTTT      %bD9       QUU      9d9	        zY      Y XW         @      (P\WU      )      8      7WWWW      7      7      (``pP6`         c361
yw7yS`
!yS`
.!ySd
9-ySP
=I$ID( @z 5m      Q 	      j      H?      i5	                                    4qj      pr|||~:z?@Br/>$	U		@     A`      !W~      !^z      !U      "W\~~      "^~xx      c^~zx      c#~x~~      $      $ ~        _      % U      E U       _U      _UU      O@      r         dAp        @      z%r      08               p0      8	_      ITTW      IU	       Y	        zXz      YxVU      -   @      (`XVU      (       9)      7      	s   x      *s   U      #1     4 P\VU H$I$I	 H	5ySquS`
)qww.3&qN	>4qS`
( @@      Fj 	      i(	6      i      i=      /=5      3      W                  3      p\V      $Z@                (X\      `_U      AU%      UWXp      ~z      Uu      Bx      c      ^W      |~             D!  (      a   	      xx      Y   `      dI   U      a  	      8	            QXPp`      %zr      $zYj      (_      QVUU%      QU       XI	         zX      Y  ^      YxVUU      $1  p      4 pVUU      (       . UU      y        #1 @P\PjTUUUFG m   `I$ m               
;6/NP
ySp
 9R`
,!yS`7,1`C9qS/D9(`PXT      fr(       #1jj      i      i      q5             q UU      q WUU      qUUU      q `\      m|UUU      UU      z        p\       W      \      $WU      P^UU      @aUU]      J~z~      axx      ax      !i      UUU\      W^^x      /p'      CI`        X      X      NU         8`      i%5      4UUU      Q`pXT      BQ      yYUU      YQ        z)         zU      z7 x      zX^U      7      J  @      4 \WUU      (       (       (55%      z@``p$?tTVVV                                        	 	 +6c362IIBQ   @I$I"    (yirB   0&qS/e<11R $I&)(  @[      rfr      fr#1````            j      j      0UUU      Pi UU      Pi UU      PUUU      i      j      j      '%                Ppp      a\      ___c            U      a^xx      A~~      a_~      b%      Q`              cq@        Y      (@            4      I@@      CI]}      t)_      8AU-        Yj{	         zYU-       zW      z  x      zxWU      8\UUU              7      (@@@@      (       (       A(UUU      zD1	       7  `XMgZTUUU                                        	(*#2I$(pp@     FjU5*? 5U^.I2'   UW;   P(  ?P(pPX\      fr(       rfr      fr#9`p      %b		      j      (j      Eb  xW      Eb ~UU      IEb UUU      zEb UUU      zEb UUU      Eb
UU      Ebz]U      IQ@      $Z 	%       XXp@      UU%       Cv      UU%      UUTT      %U      WTVU      z      Q@             XPPp      "      %U      9`      "Y}7      IU      A\%       
        z         zW      zY  `      zYx      zXz      Y^       XWp@@      6                   I@        (UU^      9(UU.      Y(5	       X  `XTUUU                                                6e



1(W\p     fr 5      frA`         fr Ux  fr       rfr      rfr      fr Pp      i%b%U      %b _U      (W      QUUU-      IUU       zAUU       ZcAUU        IUU       IUUW       0Ux      Eb    -      @EbUUU      #Z  	       'TX      Tv	      %UWW       WUU      @      a^x      a      A@@            ppXW      
5      UU-       YaU-        zI{	         y      {      y      {y~      Y^      zYxUU      zYWUUU      Y   |      Y  U      8@pWU                              jz^      7U      ) @pTUUU                                                        	1b36
1N!1p&X`     fr        rfr      fr(`        fr#1       rfr      fr1@@``      %b(^-      YAUU      "9        z      z~      Y      Y      y      {      Yk      (^        IUU\      Q5U      !        B@      U%%       X       |x      A^~z      @bp      !UUU-      #zUW)       Yi        z         9      zj      8  W      z6       z8U      y8      8      Y7   `      Y ^U      YWUU                                    _      __      UUU      A   ` @% \VUU H$I$                                                        "#2"#&


!11# TT5q WUU      fr 	U      frY   -      fr#9P@        fj1 V      99_U      zj                 z   p      z8 WU      8      zX      zYU      {W      zY      zUU      z      z/      A\         Z      `Dj         #         j        {CUUU      ZU       zz        z)         z      {      {YW      zX `VU      8A   X      7#1  U      #1  U      7A  U      7i        X ~      9 %      d9.]       I /W      I  +U                        k   x      )  W      a  Ut  WU<XWUU x$I$                                                                "#2"#2	`
`


!11&\I$(P` az(5      zb^         z(U        z1U/        gZ-         z         x       \U      8TUUU            8?UU      Y U      z U      z  U      z  U      z  
U      z         zY  *      y      {      zVp         zV         z      z      z^      {YW      zX        zX       z8      XQ   @      8"9X      #1        i   ^      i   U      I( UU      )      d9By%      ygb	                 WXpp      I`        d9      a xWH7 WUUtmR\UUU'I$ M)am8lm                                                                                "#2"#2	c36c#6
1OS )S*!S/1I$\p uz(	5                  j      z  xU      z^UU      \                                                                  /      8UUU      yUU      z UU      z UU      z_UU      Y
%      YX      Y        z      Z_      X ^U      xA`X      Q        ( X      0U
      #QU       W^Xp      (U      z1	        {      z      zx       xW>?xWUU0m                                                                                                                          &1


1SN7S' 2)p7S51I$ \p At(-W     D9  	                                    ^UU            *      j      tU      t%                                                            UWU      UUU                  D9 @`      )	        )@pPP      (%      5      @_xp      (XXX\      8C1%      z        ^      A  X    &T`^UU	@m                                  AUUU@        AU         AU@          AUUT                                                                                 b"2"#2c36"11sAbY   @!I$(  pUS    XU[`FrU Pfj UU       P05k      TA 5_      t   	       
_U                 ^      P _      i W      Si~UU      r_      C9   W      A*              )                                                                        Ap@      A         (XPp@      (5U      n@/UU      QpW      05%      z       z `X        `X-TUUU8 H$I$                        AUUU        A          `A        `A        `A        `A        `A        AU           AU@@@                                                        HH1S	I$ID    @I    `WU3Xfr WU-      fr         frI	         rfr      rfr      rfr      frZh         p#9%W      1 _      #1       I UU      CAZ      TI_      #9_        C9U        3"9        3C9W       3cA^`      Y      l  	                                                                  @        fj      j@         (U^       {(UU       M(UUU      D1       z8i      #1 `Pe=TUUU                                AU        A           `Am`AKmc`A`A        `A        `A        `A        A@@PT                                                        @    1   PPP    ez -UVfr  
U      fr   U      fr(         fr&b         rfr      rfr      rfr      rfr      frFj`         frAz  `      r `      d9/       mA _       ,#1 U        A~      #1 
      4        40@         T#1`      TY      t	%            u        t        t                                           \X`      LUUUT      j   `      C9^5      D97       ^      Tj  @"\VUU H$I$                        AU        `A        `A^ea`A`A        `A        `A        `A        `A        A@PTU                                                                 	 d"2"#1c36ZM9p   $I$ U    pwI$ U_  #  U| -I  UU :   $# UU`    fr  UV      fr(       (1U      #9U       Q5
        ,      M,      lM      M+      R`         1-       C9 	'      t-      4I%P@      M              u            u                                          b `       RxW/       C9U+        J{	         x_U      4     `P\T x$I$                                 A        `A        `A        `A        `A        `A        `A        `A        A@PTU                                                                        	 I	 Iim
b5
RqpSq'Rw/$Nq4IX1P  p\     i -       r                           ,      m	      mL**+      m                  pd9&&&      4	      TM@        m                                /      u  
      u               4  x       U      3 U        _      ^UU      4            a  p  <`'gbTWUU                                        A        `A        `A        `A        `A        `A        `A        A@PTU                                                                                       6e	mc#N7NqI$ID(   @" # `\U       %	       j      H~      tUUU-      WUU       U        ,         t         j         mU\`      U      C1@4      P)	        4	+*      4a  ^      TA  u      d9                                          T      4W      ux^WU      3                              ( XV-N\UUU  H$I$                                        A        `A        `A        `A        `A        A  PT        A@UUU                Jmk{IM   gjUU5/7 UU 4XUU }H   UU I"   i UUUX I$M'                 =U_6`   	 I$6S
irw    
   @\PG \U5	      i 	        iUU      IU
       6        T                   t   \                         7UUU      d9  p      P_      q1*U      A  U      1'      A        )**
      #1`       d9 6      4p\VV      T       T_      4       4            @        gb\        A U       gZ U       GZ U      D9_-  
@ U^\X I$I$                                                AU        A   U        A   U        A   U        A @PU                                        ,o+a ?o,i-UU     (  5         `      )
rUUWT                a?p TXX  	I@a   @IP   @TU@i U5      iUU%      5        7UUU                          7UUUW      7UUU      t                 D1   x      I pW      #1\      A         A         pC9--      P        6UU%      	        6UUU}      &RP        A 		      4                  4            4      3      I   V      A   U      D9@p5               p`                                                                                                 mm, m $ m 01m I$I$ IIUUU      5	      }? \P`1QUUIUU\p (_UU{ XUU5HUU @    UU PU      CA      i5	        W\UU                      j       VU                 x         W\( pW 6557      h      #1			      i*{      ,*+%      #1      )+      	           @       VU      K g      d9		                              3      q   @      D9p4         8?3XX\\deTP      t#1 	%      p      W\Xp#m                                                                        3 I$I'm ae      U5	D9U  n      U`\UX<X$         >cm 5            r@  ?QUWVT   	xe  %U      ( -      CA_/      6(-                   `       z        _   ~Uz  UU:0 WU) (UU(  O$(UU -'I$ U  k2Idi @i(%%      j      i)$`      Q         #1  p      d9%	      	       7UUU      @p\V      d9pV      Ay%      0         I  X      I  '	      4UUU      UUU`            A@      j           p>p?\\\\amPP@@!o6hbUUUd  	5U      9@ x% QUUWT                                                                        6j/6c$#1UU      i1       s\ipWUU `$I$                          -o$6ogjUU      z          ( VT\X ` z%556UU- *      6IU       	            @      A  x      3QVj\U^ ?{8 U5
P$I$(   r   PNw   b  W I$~   U+!R   )Id @@p\      i(	      iUU-      iU_XV      iC9       1'      5	      7WUUU      `X\      d9@p     q(=U      a  U      D9p      A5        UU      5%
       t@        T)@pP    A	                ` y?XXXX                 Fn[m  X`T-UU    XrUU]                                                                     1       @  5FbSWVT
 H$I$                                 6oFnRUU      z       k? XXX\c<c<&Z 	      I%	      k{   `        xUt xU      HY-      fr 5      I_ WX`	 P   d3iIdI@`p     fj       fr W`  & 	eUW      5	      i5%      i`X\            3c97      o**
      7]WUU        `      d9 pQ)AP\+h'L$(u	 ($I8U@@@       	      5	      7]WUU                D1  @wK \V6 	5                @``? XPPP
                        Flm                                                                        a5555      @(  iVT\pI$I'                
Fmm#Wm  0    %	            IjITTVWc<c=gbi %u  xWU   n\UUUX$I$ Fo#e ZEb       frQ 5      fr	%      I: VXp    
IDI$ p@@     ( %      ifrUU]`      fr14      ir	      u      0iTUUU      /1jz'      'R         	         `      7ZhZ       pX#   5) 6'!I(@@pP            4                     @(p\VH$I$  )I\PP      A       pppp? PPPP                                                                                                        )i            I@   ~ U^ IUUV`Id#1UUUV      U        U        (      dA%m `p\
sod9UUUg??I frUUUmG                         oFnRU      &bI=      frZ        fr 	%      	`   @   V\PYI$O$  I%%%%      h      i#9Zx       i1      h      i( @      #1       5	      7WU      T1 `      D9` (&(\! '$p (^      1=/      7WUUU         @; p\W/     D	  IdI`@@@       				      pppp      Apppp4=                                                                                                        vn6b[ ? 	%             @pxI%                         p`@!ZC9TUUU %	    {@@@@  gb	-      ^` ?IUUW\3 I$I$        n#c       Q 
!      frQ	U      frQ   -      frUU      a `z EUWi %	      iUUU-      iUUU`      i#1p         i#1-^       C95	      UU      T         Qp       <? \U         ml  @   @P(5%      	       7UUUA p\W    Mc'     @@@@@       	      p``      pppp?i=                                                                                                                o6hQUUU 	5      #1  `      i(Cp      	                        dA@A     %	          b`|z 	              (p  =?IUUVX/ I$I$kna;c;      Q 		      I)_'	      i#1U`       %b#1       frQUU     fr T6      b/      P         ip\VW      j      0z      b        5%               TI@`p      `%`'(5IB I$I(  @P(V5      o)*

      7WUUU      )`P\&K$	D	  $	      $    0@   .6%%55      t         3 ppppYf                                                                                                                        Fnm H?`n=r;U     i(                               R@@@@      Q      fr p\r \r%      r	%5            `  }gbUUWTnoa;a      Z ))      gb         j      i `      I(      Q/            i`p      h      Hj      C97	                   @`      #1X? XVo	J$I$(   
        @p	P V5      *{         	      A  @ 4X'D T"Mm; $I$   @$         $H$  @@                apppp;_                                                                                                                        
mn x                                    R@@      I?r pVW/=   IWUUI ?      I *+                    \P`7{       r       j      j   @      i(4      iU%               4      iX\VW      j      i#1@`      (             7UWWW      `ppPLIdIXX\\h         $)I   @ ZV      'R        5%      7UWUU `pPXJ$O$        $I$        $H$        PPPP/o6b#1UU       5      6(pp``f=                                                                                                                                 FbFbZU      r                z         U      )               z  @      Fj(C4      fr(  ??frYgker		      r%5            IP@p    UVT\     I %      j      i#1@`      fj       i	             @pP      H      j      tI_      4      555%                XX\\ (4N(TT $I$I @@PP      %                  6*J_(\TV@$I$           $ @$I$                PPPP        	oj	sUUU @AUUWT                                                                                                                        nc     1)U      0      fr#1   	      frFj         fr5UUU      fr U      frpXVU      fr#1$<      rfr?frQ`I$Or -      irUU      z        #1   @      i#1X      j         MiUUU5      QK      (              4      iX\VW      j      j      cA7'                  7U      hb @%`'    ` p V5%      q         6U5      6      GZ @
      $   $I$                                PPPP                Vnm l                                                                                                                 ma;fj5	      frb         rfr      fr1&@       frC9        rfr      rfr      rfr      frC9p@@fr  rW  `$bxWUUJyUUVP      Eb))      rQ  %      r	5U      D9P	      j      iUU5              4      A'`       I        I`r      H      j      ifb   p      dA	            		       ` @`pP]U)a6b@PUU)            %	      7UUU @`pX]U                                                   PPPP                                                                                                                                                 3nYUU      fr1        rfr      rfr      rfr      fr1<@      fr(  	      rfr      rfr      fr#9@           b      /a      %bI?      (#1j{      gb         iUU5      I                          GZp         QUX      iD9U        D9U        i1W      d9	            T      N`_? \TWU        FnU               UU      t          @	 XTWU                                                        PPPP                                                                                                                                         me# <fr5%	      rfr      rfr      rfr      rfr      rfr      fr#9      rfr      rfr%     fr `pXTNm        mb    $ `H(Z?iC977    $iFZ       $	U    $   U    $   U    $   U    $   U    $j       $/fjU    $FZ   U    $FZ   U$d9``_    $  U    $   U    $n   U< @`P^J] UOPm a-' 5%    $   U    $***U    $n   U(@pZ3                 UUU                                         PPPP                                                                                                                                  I$I  FjU5    $frI  U    $frI   U    $frI   U    $frI   Ufr(  W#fr  {!fr1u fr1   UMfr  ^UmC9TUUU                                                                    	   dragon_08             C  C                          ?   ?   ?                                                           *                                      G                           4  F E   B   E    B   B D  B C D B A C B " A B  A " #  "   # . A  - A . @ A - + @ - , @ + ' @ , % @ ' & @ %   )  )  0 )  $ ) 0 / $ 0 ? $ / & $ ? @ & ? 7 5 6 6 4 > = 8 < 7 < 8 3 < 7 6 3 7 2 3 6 ; :  1  : /  1 9 / 1 8 9 1 7 8 1 5 7 1 4 5 1 6 5 4 2 4 1 3 2 1   * ( *  ' * ( , * ' 0  / # !     !                 .  .  - .  * -  + - * , + *   ( ) (  $ ( ) ' ( $ % ' $ & % $  ! " # " !   !                                          	   
  	  
 	                          G                                                                 h                                  8         8                       t        B        B        B        B        B        B        B        B        B        B        B        B        B        B  0B      B        B  $B      B  $B      B        B  $B      B        B  hB      B  HB      B  @B      B  HB      B  <B      ,B  B      B  0B      B  8B      B  $B      B  0B      B  B      B  B      B  8B      B        B        B        B        B        B  XB      B  XB       C   C      B  B       C  XB      B  B      B  B      B  B      B  |B      B  pB      B  XB      B   C      B  B      B  XB      B  \B      B  B      B   A      B        B        A   C      A        PA            C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               C  C            @     ?   C  ?   C  ?    *                                      G                           4  F E   B   E    B   B D  B C D B A C B " A B  A " #  "   # . A  - A . @ A - + @ - , @ + ' @ , % @ ' & @ %   )  )  0 )  $ ) 0 / $ 0 ? $ / & $ ? @ & ? 7 5 6 6 4 > = 8 < 7 < 8 3 < 7 6 3 7 2 3 6 ; :  1  : /  1 9 / 1 8 9 1 7 8 1 5 7 1 4 5 1 6 5 4 2 4 1 3 2 1   * ( *  ' * ( , * ' 0  / # !     !                 .  .  - .  * -  + - * , + *   ( ) (  $ ( ) ' ( $ % ' $ & % $  ! " # " !   !                                          	   
  	  
 	                          G                                                                 h                                  8         8                       t        B        B        B        B        B        B        B        B        B        B        B        B        B        B  0B      B        B  $B      B  $B      B        B  $B      B        B  hB      B  HB      B  @B      B  HB      B  <B      ,B  B      B  0B      B  8B      B  $B      B  0B      B  B      B  B      B  8B      B        B        B        B        B        B  XB      B  XB       C   C      B  B       C  XB      B  B      B  B      B  B      B  |B      B  pB      B  XB      B   C      B  B      B  XB      B  \B      B  B      B   A      B        B        A   C      A        PA            C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               C  C            @     ?   C  ?   C  ?   	           <     <                           I         @        @  t     @    (  P     0    @     @     A    @A    @A    A    A    PA    PA    pA    A     TB    B    B    B    B    B    B    B    B  @  B  A  B  A  4B  8B  B  B  ,B  B  $B  B  A  B  A  B  A  B  A  B  A  B  @  B  @@  B    B  p  B     C      C     lB    lB    B    B    LB    HB    ,B    B    B    A    pA    @    @    @    @     A               x                          PA    A    `A       B    B    B    B    B       B    B    B    B    B    B    B    B       A    A    A     B    B    B    B    B       B    B    B    B    B    B    B    B       @A    PA    A    A    A    `A         |              |      x    x     @  \  @  t   A  x   A  x  PA  t  PA  d  @A  \     tB  T  B  `  B  `  B  T  B  H  xB  H           (    8    <    <    0              B    B    B  $  B  (  B  (   B  $   B                                            B  4B  B  ,B  B  $B  B  B  B  B  B  $B  B  ,B  B  4B     B  DB  B  8B  B  0B  B  (B  B  (B  B  0B  B  <B  B  DB     B   C  B  B  B  B  B  B  B  B  B  pB  B  B  B  B  B  B  B  tB  B  dB  B  \B  B  \B   C  xB   C  B  B   C       B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B     ,  B  0  B  4  B    B    B       B    B    B    B        527a1df2f64778246bff21c428af44d8                                                                                                                                                                            ary occlusion                                   k                 3       k                       k                 ;       k                =       k                >       k                A       k                ?       k                                          m            
      !           Emissive Injection Intensity             R                 !   53BEEF174BEF1930BDA695BB2FC139A3     LPVEmissive Injection Intensity                                   k                 3       k                       k                 ;       k                =       k                >       k                A       k                ?       k                                          k            
                 Occlusion Intensity                             UObjectToolTips 5   PostProcessSettings:LPVDirectionalOcclusionIntensity e   Controls the amount of directional occlusion. Requires LPV. Values very close to 1.0 are recommended                                   k                 3       k                       k                 ;       k                 =       k                 >       k                A       k                ?       k                                          l           