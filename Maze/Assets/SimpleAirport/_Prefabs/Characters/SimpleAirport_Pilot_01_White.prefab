ojectFolder);
					return true;
				}

				if (InAttributeKey == ContentBrowserItemAttributes::ItemIsPluginContent)
				{
					const bool bIsPluginFolder = AssetViewUtils::IsPluginFolder(InFilePath.ToString());
					OutAttributeValue.SetValue(bIsPluginFolder);
					return true;
				}

				return false;
			};

			auto PyItemPreview = [this](const FName InFilePath, const FString& InFilename)
			{
				ExecPythonCommand(*InFilename);
				return true;
			};

			ContentBrowserFileData::FDirectoryActions PyDirectoryActions;
			PyDirectoryActions.PassesFilter.BindLambda(PyItemPassesFilter, false);
			PyDirectoryActions.GetAttribute.BindLambda(GetPyItemAttribute);
			PythonFileConfig.SetDirectoryActions(PyDirectoryActions);

			ContentBrowserFileData::FFileActions PyFileActions;
			PyFileActions.TypeExtension = TEXT("py");
			PyFileActions.TypeName = "Python";
			PyFileActions.TypeDisplayName = LOCTEXT("PythonTypeName", "Python");
			PyFileActions.TypeShortDescription = LOCTEXT("PythonTypeShortDescription", "Python Script");
			PyFileActions.TypeFullDescription = LOCTEXT("PythonTypeFullDescription", "A file used to script the editor using Python");
			PyFileActions.DefaultNewFileName = TEXT("new_python_script");
			PyFileActions.TypeColor = FColor(255, 156, 0);
			PyFileActions.PassesFilter.BindLambda(PyItemPassesFilter, true);
			PyFileActions.GetAttribute.BindLambda(GetPyItemAttribute);
			PyFileActions.Preview.BindLambda(PyItemPreview);
			PythonFileConfig.RegisterFileActions(PyFileActions);
		}

		PythonFileDataSource.Reset(NewObject<UContentBrowserFileDataSource>(GetTransientPackage(), "PythonData"));
		PythonFileDataSource->Initialize("/", PythonFileConfig);

		TArray<FString> RootPaths;
		FPackageName::QueryRootContentPaths(RootPaths);
		for (const FString& RootPath : RootPaths)
		{
			const FString RootFilesystemPath = FPackageName::LongPackageNameToFilename(RootPath);
			PythonFileDataSource->AddFileMount(*(RootPath / TEXT("Python")), RootFilesystemPath / TEXT("Python"));
		}

		{
			FToolMenuOwnerScoped OwnerScoped(this);
			if (UToolMenu* Menu = UToolMenus::Get()->ExtendMenu("ContentBrowser.ItemContextMenu.PythonData"))
			{
				Menu->AddDynamicSection(TEXT("DynamicSection_PythonScriptPlugin"), FNewToolMenuDelegate::CreateRaw(this, &FPythonScriptPlugin::PopulatePythonFileContextMenu));
			}
		}
	}
#endif	// WITH_EDITOR
}

void FPythonScriptPlugin::ShutdownPython()
{
	if (!bInitialized)
	{
		return;
	}

#if WITH_EDITOR
	// Remove the Content Browser integration
	UToolMenus::UnregisterOwner(this);
	PythonFileDataSource.Reset();
#endif	// WITH_EDITOR

	// Notify any external listeners
	OnPythonShutdownDelegate.Broadcast();

	FTicker::GetCoreTicker().RemoveTicker(TickHandle);
	if (ModuleDelayedHandle.IsValid())
	{
		FTicker::GetCoreTicker().RemoveTicker(ModuleDelayedHandle);
	}

	FPyWrapperTypeRegistry::Get().OnModuleDirtied().RemoveAll(this);
	FModuleManager::Get().OnModulesChanged().RemoveAll(this);

	FPackageName::OnContentPathMounted().RemoveAll(this);
	FPackageName::OnContentPathDismounted().RemoveAll(this);
	FCoreUObjectDelegates::OnPackageReloaded.RemoveAll(this);

	if (FAssetRegistryModule* AssetRegistryModule = FModuleManager::GetModulePtr<FAssetRegistryModule>("AssetRegistry"))
	{
		AssetRegistryModule->Get().OnAssetRenamed().RemoveAll(this);
		AssetRegistryModule->Get().OnAssetRemoved().RemoveAll(this);
	}

#if WITH_EDITOR
	FEditorSupportDelegates::PrepareToCleanseEditorObject.RemoveAll(this);
#endif	// WITH_EDITOR

	FPyReferenceCollector::Get().PurgeUnrealGeneratedTypes();

#if WITH_EDITOR
	PyEditor::ShutdownModule();
#endif	// WITH_EDITOR
	PyEngine::ShutdownModule();
	PySlate::ShutdownModule();
	PyCore::ShutdownModule();

	PyUnrealModule.Reset();
	PyDefaultGlobalDict.Reset();
	PyDefaultLocalDict.Reset();
	PyConsoleGlobalDict.Reset();
	PyConsoleLocalDict.Reset();

	ShutdownPyMethodWithClosure();

	Py_Finalize();

	bInitialized = false;
	bHasTicked = false;
}

void FPythonScriptPlugin::RequestStubCodeGeneration()
{
	// Ignore requests made before the fist Tick
	if (!bHasTicked)
	{
		return;
	}

	// Delay 2 seconds before generating as this may be triggered by loading several modules at once
	static const float Delay = 2.0f;

	// If there is an existing pending notification, remove it so that it can be reset
	if (ModuleDelayedHandle.IsValid())
	{
		FTicker::GetCoreTicker().RemoveTicker(ModuleDelayedHandle);
		ModuleDelayedHandle.Reset();
	}

	// Set new tick
	ModuleDelayedHandle = FTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateLambda(
		[this](float DeltaTime)
		{
			QUICK_SCOPE_CYCLE_COUNTER(STAT_FPythonScriptPlugin_ModuleDelayed);

			// Once ticked, the delegate will be removed so reset the handle to indicate that it isn't set.
			ModuleDelayedHandle.Reset();

			// Call the event now that the delay has passed.
			GenerateStubCode();

			// Don't reschedule to run again.
			return false;
		}),
		Delay);
}

void FPythonScriptPlugin::GenerateStubCode()
{
	if (IsDeveloperModeEnabled())
	{
		// Generate stub code if developer mode enabled
		FPyWrapperTypeRegistry::Get().GenerateStubCodeForWrappedTypes();
	}
}

void FPythonScriptPlugin::Tick(const float InDeltaTime)
{
	// If this is our first Tick, handle any post-init logic that should happen once the engine is fully initialized
	if (!bHasTicked)
	{
		bHasTicked = true;

		// Run start-up scripts now
		TArray<FString> PySysPaths;
		{
			FPyScopedGIL GIL;
			PySysPaths = PyUtil::GetSystemPaths();
		}
		for (const FString& PySysPath : PySysPaths)
		{
			const FString PotentialFilePath = PySysPath / TEXT("init_unreal.py");
			if (FPaths::FileExists(PotentialFilePath))
			{
				// Execute these files in the "public" scope, as if their contents had been run directly in the console
				// This allows them to be used to set-up an editor environment for the console
				FPythonCommandEx InitUnrealPythonCommand;
				InitUnrealPythonCommand.FileExecutionScope = EPythonFileExecutionScope::Public;
				RunFile(*PotentialFilePath, *InitUnrealPythonCommand.Command, InitUnrealPythonCommand);
			}
		}
		for (const FString& StartupScript : GetDefault<UPythonScriptPluginSettings>()->StartupScripts)
		{
			ExecPythonCommand(*StartupScript);
		}

		// Notify any external listeners
		OnPythonInitializedDelegate.Broadcast();

#if WITH_EDITOR
		// Activate the Content Browser integration (now that editor subsystems are available)
		if (PythonFileDataSource)
		{
			UContentBrowserDataSubsystem* ContentBrowserData = IContentBrowserDataModule::Get().GetSubsystem();
			ContentBrowserData->ActivateDataSource("PythonData");
		}

		// Register to generate stub code after a short delay
		RequestStubCodeGeneration();
#endif	// WITH_EDITOR
	}

	RemoteExecution->Tick(InDeltaTime);

	FPyWrapperTypeReinstancer::Get().ProcessPending();
}

void FPythonScriptPlugin::SyncRemoteExecutionToSettings()
{
	RemoteExecution->SyncToSettings();
}

void FPythonScriptPlugin::ImportUnrealModule(const TCHAR* InModuleName)
{
	const FString PythonModuleName = FString::Printf(TEXT("unreal_%s"), InModuleName);
	const FString NativeModuleName = FString::Printf(TEXT("_unreal_%s"), InModuleName);

	FPyScopedGIL GIL;

	const TCHAR* ModuleNameToImport = nullptr;
	PyObject* ModuleToReload = nullptr;
	if (PyUtil::IsModuleAvailableForImport(*PythonModuleName))
	{
		// Python modules that are already loaded should be reloaded if we're requested to import them again
		if (!PyUtil::IsModuleImported(*PythonModuleName, &ModuleToReload))
		{
			ModuleNameToImport = *PythonModuleName;
		}
	}
	else if (PyUtil::IsModuleAvailableForImport(*NativeModuleName))
	{
		ModuleNameToImport = *NativeModuleName;
	}

	FPyObjectPtr PyModule;
	if (ModuleToReload)
	{
		PyModule = FPyObjectPtr::StealReference(PyImport_ReloadModule(ModuleToReload));
	}
	else if (ModuleNameToImport)
	{
		PyModule = FPyObjectPtr::StealReference(PyImport_ImportModule(TCHAR_TO_UTF8(ModuleNameToImport)));
	}

	if (PyModule)
	{
		check(PyUnrealModule);
		PyObject* PyUnrealModuleDict = PyModule_GetDict(PyUnrealModule);

		// Hoist every public symbol from this module into the top-level "unreal" module
		{
			PyObject* PyModuleDict = PyModule_GetDict(PyModule);

			PyObject* PyObjKey = nullptr;
			PyObject* PyObjValue = nullptr;
			Py_ssize_t ModuleDictIndex = 0;
			while (PyDict_Next(PyModuleDict, &ModuleDictIndex, &PyObjKey, &PyObjValue))
			{
				if (PyObjKey)
				{
					const FString Key = PyUtil::PyObjectToUEString(PyObjKey);
					if (Key.Len() > 0 && Key[0] != TEXT('_'))
					{
						PyDict_SetItem(PyUnrealModuleDict, PyObjKey, PyObjValue);
					}
				}
			}
		}
	}
	else
	{
		PyUtil::LogPythonError(/*bInteractive*/true);
	}
}

PyObject* FPythonScriptPlugin::EvalString(const TCHAR* InStr, const TCHAR* InContext, const int InMode)
{
	return EvalString(InStr, InContext, InMode, PyConsoleGlobalDict, PyConsoleLocalDict);
}

PyObject* FPythonScriptPlugin::EvalString(const TCHAR* InStr, const TCHAR* InContext, const int InMode, PyObject* InGlobalDict, PyObject* InLocalDict)
{
	PyCompilerFlags *PyCompFlags = nullptr;

	PyArena* PyArena = PyArena_New();
	if (!PyArena)
	{
		return nullptr;
	}

	_mod* PyModule = PyParser_ASTFromString(TCHAR_TO_UTF8(InStr), TCHAR_TO_UTF8(InContext), InMode, PyCompFlags, PyArena);
	if (!PyModule)
	{
		PyArena_Free(PyArena);
		return nullptr;
	}

	typedef TPyPtr<PyCodeObject> PyCodeObjectPtr;
	PyCodeObjectPtr PyCodeObj = PyCodeObjectPtr::StealReference(PyAST_Compile(PyModule, TCHAR_TO_UTF8(InContext), PyCompFlags, PyArena));
	if (!PyCodeObj)
	{
		return nullptr;
	}

	return PyEval_EvalCode((PyUtil::FPyCodeObjectType*)PyCodeObj.Get(), InGlobalDict, InLocalDict);
}

bool FPythonScriptPlugin::RunString(FPythonCommandEx& InOutPythonCommand)
{
	// Execute Python code within this block
	{
		FPyScopedGIL GIL;
		TGuardValue<bool> UnattendedScriptGuard(GIsRunningUnattendedScript, GIsRunningUnattendedScript || EnumHasAnyFlags(InOutPythonCommand.Flags, EPythonCommandFlags::Unattended));

		int PyExecMode = 0;
		switch (InOutPythonCommand.ExecutionMode)
		{
		case EPythonCommandExecutionMode::ExecuteFile:
			PyExecMode = Py_file_input;
			break;
		case EPythonCommandExecutionMode::ExecuteStatement:
			PyExecMode = Py_single_input;
			break;
		case EPythonCommandExecutionMode::EvaluateStatement:
			PyExecMode = Py_eval_input;
			break;
		default:
			checkf(false, TEXT("Invalid EPythonCommandExecutionMode!"));
			break;
		}

		FDelegateHandle LogCaptureHandle = PyCore::GetPythonLogCapture().AddLambda([&InOutPythonCommand](EPythonLogOutputType InLogType, const TCHAR* InLogString) { InOutPythonCommand.LogOutput.Add(FPythonLogOutputEntry{ InLogType, InLogString }); });
		FPyObjectPtr PyResult = FPyObjectPtr::StealReference(EvalString(*InOutPythonCommand.Command, TEXT("<string>"), PyExecMode));
		PyCore::GetPythonLogCapture().Remove(LogCaptureHandle);
		
		if (PyResult)
		{
			InOutPythonCommand.CommandResult = PyUtil::PyObjectToUEStringRepr(PyResult);
		}
		else
		{
			InOutPythonCommand.CommandResult = PyUtil::LogPythonError();
			return false;
		}
	}

	FPyWrapperTypeReinstancer::Get().ProcessPending();
	return true;
}

bool FPythonScriptPlugin::RunFile(const TCHAR* InFile, const TCHAR* InArgs, FPythonCommandEx& InOutPythonCommand)
{
	auto ResolveFilePath = [InFile]() -> FString
	{
		// Favor the CWD
		if (FPaths::FileExists(InFile))
		{
			return FPaths::ConvertRelativePathToFull(InFile);
		}

		// Execute Python code within this block
		{
			FPyScopedGIL GIL;

			// Then test against each system path in order (as Python would)
			const TArray<FString> PySysPaths = PyUtil::GetSystemPaths();
			for (const FString& PySysPath : PySysPaths)
			{
				const FString PotentialFilePath = PySysPath / InFile;
				if (FPaths::FileExists(PotentialFilePath))
				{
					return PotentialFilePath;
				}
			}
		}

		// Didn't find a match... we know this file doesn't exist, but we'll use this path in the error reporting
		return FPaths::ConvertRelativePathToFull(InFile);
	};

	const FString ResolvedFilePath = ResolveFilePath();

	FString FileStr;
	bool bLoaded = FFileHelper::LoadFileToString(FileStr, *ResolvedFilePath);
#if WITH_EDITOR
	if (CmdMenu)
	{
		CmdMenu->OnRunFile(ResolvedFilePath, bLoaded);
	}
#endif // WITH_EDITOR

	if (!bLoaded)
	{
		InOutPythonCommand.CommandResult = FString::Printf(TEXT("Could not load Python file '%s' (resolved from '%s')"), *ResolvedFilePath, InFile);
		UE_LOG(LogPython, Error, TEXT("%s"), *InOutPythonCommand.CommandResult);
		return false;
	}

	// Execute Python code within this block
	double ElapsedSeconds = 0.0;
	{
		FPyScopedGIL GIL;
		TGuardValue<bool> UnattendedScriptGuard(GIsRunningUnattendedScript, GIsRunningUnattendedScript || EnumHasAnyFlags(InOutPythonCommand.Flags, EPythonCommandFlags::Unattended));

		FPyObjectPtr PyFileGlobalDict = PyConsoleGlobalDict;
		FPyObjectPtr PyFileLocalDict = PyConsoleLocalDict;
		if (InOutPythonCommand.FileExecutionScope == EPythonFileExecutionScope::Private)
		{
			PyFileGlobalDict = FPyObjectPtr::StealReference(PyDict_Copy(PyDefaultGlobalDict));
			PyFileLocalDict = PyFileGlobalDict;
		}
		{
			FPyObjectPtr PyResolvedFilePath;
			if (PyConversion::Pythonize(ResolvedFilePath, PyResolvedFilePath.Get(), PyConversion::ESetErrorState::No))
			{
				PyDict_SetItemString(PyFileGlobalDict, "__file__", PyResolvedFilePath);
			}
		}

		FPyObjectPtr PyResult;
		{
			FScopedDurationTimer Timer(ElapsedSeconds);
			FPythonScopedArgv ScopedArgv(InArgs);

			FDelegateHandle LogCaptureHandle = PyCore::GetPythonLogCapture().AddLambda([&InOutPythonCommand](EPythonLogOutputType InLogType, const TCHAR* InLogString) { InOutPythonCommand.LogOutput.Add(FPythonLogOutputEntry{ InLogType, InLogString }); });
			PyResult = FPyObjectPtr::StealReference(EvalString(*FileStr, *ResolvedFilePath, Py_file_input, PyFileGlobalDict, PyFileLocalDict)); // We can't just use PyRun_File here as Python isn't always built against the same version of the CRT as UE4, so we get a crash at the CRT layer
			PyCore::GetPythonLogCapture().Remove(LogCaptureHandle);
		}

		PyDict_DelItemString(PyFileGlobalDict, "__file__");

		if (PyResult)
		{
			InOutPythonCommand.CommandResult = PyUtil::PyObjectToUEStringRepr(PyResult);
		}
		else
		{
			InOutPythonCommand.CommandResult = PyUtil::LogPythonError();
			return false;
		}
	}

	FPyWrapperTypeReinstancer::Get().ProcessPending();

	if (FEngineAnalytics::IsAvailable())
	{
		TArray<FAnalyticsEventAttribute> EventAttributes;
		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("Duration"), ElapsedSeconds));
		FEngineAnalytics::GetProvider().RecordEvent(TEXT("PythonScriptPlugin"), EventAttributes);
	}

	return true;
}

void FPythonScriptPlugin::OnModuleDirtied(FName InModuleName)
{
	ImportUnrealModule(*InModuleName.ToString());
}

void FPythonScriptPlugin::OnModulesChanged(FName InModuleName, EModuleChangeReason InModuleChangeReason)
{
	switch (InModuleChangeReason)
	{
	case EModuleChangeReason::ModuleLoaded:
		FPyWrapperTypeRegistry::Get().GenerateWrappedTypesForModule(InModuleName);
#if WITH_EDITOR
		// Register to generate stub code after a short delay
		RequestStubCodeGeneration();
#endif	// WITH_EDITOR
		break;

	case EModuleChangeReason::ModuleUnloaded:
		FPyWrapperTypeRegistry::Get().OrphanWrappedTypesForModule(InModuleName);
#if WITH_EDITOR
		// Register to generate stub code after a short delay
		RequestStubCodeGeneration();
#endif	// WITH_EDITOR
		break;

	default:
		break;
	}
}

void FPythonScriptPlugin::OnContentPathMounted(const FString& InAssetPath, const FString& InFilesystemPath)
{
	{
		FPyScopedGIL GIL;
		PyUtil::AddSystemPath(FPaths::ConvertRelativePathToFull(InFilesystemPath / TEXT("Python")));
	}

#if WITH_EDITOR
	if (PythonFileDataSource)
	{
		PythonFileDataSource->AddFileMount(*(InAssetPath / TEXT("Python")), InFilesystemPath / TEXT("Python"));
	}
#endif	// WITH_EDITOR
}

void FPythonScriptPlugin::OnContentPathDismounted(const FString& InAssetPath, const FString& InFilesystemPath)
{
	{
		FPyScopedGIL GIL;
		PyUtil::RemoveSystemPath(FPaths::ConvertRelativePathToFull(InFilesystemPath / TEXT("Python")));
	}

#if WITH_EDITOR
	if (PythonFileDataSource)
	{
		PythonFileDataSource->RemoveFileMount(*(InAssetPath / TEXT("Python")));
	}
#endif	// WITH_EDITOR
}

bool FPythonScriptPlugin::IsDeveloperModeEnabled()
{
	return GetDefault<UPythonScriptPluginSettings>()->bDeveloperMode || GetDefault<UPythonScriptPluginUserSettings>()->bDeveloperMode;
}

void FPythonScriptPlugin::OnAssetRenamed(const FAssetData& Data, const FString& OldName)
{
	const FName OldPackageName = *FPackageName::ObjectPathToPackageName(OldName);
	const UObject* AssetPtr = PyGenUtil::GetTypeRegistryType(Data.GetAsset());
	if (AssetPtr)
	{
		// If this asset has an associated Python type, then we need to rename it
		FPyWrapperTypeRegistry& PyWrapperTypeRegistry = FPyWrapperTypeRegistry::Get();
		if (PyWrapperTypeRegistry.HasWrappedTypeForObjectName(OldPackageName))
		{
			PyWrapperTypeRegistry.UpdateGenerateWrappedTypeForRename(OldPackageName, AssetPtr);
			OnAssetUpdated(AssetPtr);
		}
	}
}

void FPythonScriptPlugin::OnAssetRemoved(const FAssetData& Data)
{
	const UObject* AssetPtr = PyGenUtil::GetTypeRegistryType(Data.GetAsset());
	if (AssetPtr)
	{
		// If this asset has an associated Python type, then we need to remove it
		FPyWrapperTypeRegistry& PyWrapperTypeRegistry = FPyWrapperTypeRegistry::Get();
		if (PyWrapperTypeRegistry.HasWrappedTypeForObject(AssetPtr))
		{
			PyWrapperTypeRegistry.RemoveGenerateWrappedTypeForDelete(AssetPtr);
		}
	}
}

void FPythonScriptPlugin::OnAssetReload(const EPackageReloadPhase InPackageReloadPhase, FPackageReloadedEvent* InPackageReloadedEvent)
{
	if (InPackageReloadPhase == EPackageReloadPhase::PostPackageFixup)
	{
		// Get the primary asset in this package
		// Use the new package as it has the correct name
		const UPackage* NewPackage = InPackageReloadedEvent->GetNewPackage();
		const UObject* NewAsset = StaticFindObject(UObject::StaticClass(), (UPackage*)NewPackage, *FPackageName::GetLongPackageAssetName(NewPackage->GetName()));
		OnAssetUpdated(NewAsset);
	}
}

void FPythonScriptPlugin::OnAssetUpdated(const UObject* InObj)
{
	const UObject* AssetPtr = PyGenUtil::GetTypeRegistryType(InObj);
	if (AssetPtr)
	{
		// If this asset has an associated Python type, then we need to re-generate it
		FPyWrapperTypeRegistry& PyWrapperTypeRegistry = FPyWrapperTypeRegistry::Get();
		if (PyWrapperTypeRegistry.HasWrappedTypeForObject(AssetPtr))
		{
			FPyWrapperTypeRegistry::FGeneratedWrappedTypeReferences GeneratedWrappedTypeReferences;
			TSet<FName> DirtyModules;

			PyWrapperTypeRegistry.GenerateWrappedTypeForObject(AssetPtr, GeneratedWrappedTypeReferences, DirtyModules, EPyTypeGenerationFlags::IncludeBlueprintGeneratedTypes | EPyTypeGenerationFlags::OverwriteExisting);

			PyWrapperTypeRegistry.GenerateWrappedTypesForReferences(GeneratedWrappedTypeReferences, DirtyModules);
			PyWrapperTypeRegistry.NotifyModulesDirtied(DirtyModules);
		}
	}
}

#if WITH_EDITOR

void FPythonScriptPlugin::OnPrepareToCleanseEditorObject(UObject* InObject)
{
	FPyReferenceCollector::Get().PurgeUnrealObjectReferences(InObject, true);
}

void FPythonScriptPlugin::PopulatePythonFileContextMenu(UToolMenu* InMenu)
{
	const UContentBrowserDataMenuContext_FileMenu* ContextObject = InMenu->FindContext<UContentBrowserDataMenuContext_FileMenu>();
	checkf(ContextObject, TEXT("Required context UContentBrowserDataMenuContext_FileMenu was missing!"));

	if (!PythonFileDataSource)
	{
		return;
	}

	// Extract the internal file paths that belong to this data source from the full list of selected paths given in the context
	TArray<TSharedRef<const FContentBrowserFileItemDataPayload>> SelectedPythonFiles;
	for (const FContentBrowserItem& SelectedItem : ContextObject->SelectedItems)
	{
		if (const FContentBrowserItemData* ItemDataPtr = SelectedItem.GetPrimaryInternalItem())
		{
			if (TSharedPtr<const FContentBrowserFileItemDataPayload> FilePayload = ContentBrowserFileData::GetFileItemPayload(PythonFileDataSource.Get(), *ItemDataPtr))
			{
				SelectedPythonFiles.Add(FilePayload.ToSharedRef());
			}
		}
	}

	// Only add the file items if we have a file path selected
	if (SelectedPythonFiles.Num() > 0)
	{
		// Run
		{
			FToolMenuSection& Section = InMenu->AddSection("PythonScript", LOCTEXT("PythonScriptMenuHeading", "Python Script"));
			Section.InsertPosition.Position = EToolMenuInsertType::First;

			const FExecuteAction ExecuteRunAction = FExecuteAction::CreateLambda([this, SelectedPythonFiles]()
			{
				for (const TSharedRef<const FContentBrowserFileItemDataPayload>& SelectedPythonFile : SelectedPythonFiles)
				{
					ExecPythonCommand(*SelectedPythonFile->GetFilename());
				}
			});

			Section.AddMenuEntry(
				"RunPythonScript",
				LOCTEXT("RunPythonScript", "Run..."),
				LOCTEXT("RunPythonScriptToolTip", "Run this script."),
				FSlateIcon(),
				FUIAction(ExecuteRunAction)
			);
		}
	}
}

#endif	// WITH_EDITOR

#endif	// WITH_PYTHON

IMPLEMENT_MODULE(FPythonScriptPlugin, PythonScriptPlugin)

#undef LOCTEXT_NAMESPACE
                                                                                                                                                                                                                                                                                                                                                            %>w?≥ßyIJõR‚•Ô^\∂«	À %UnËªÌ◊é*Cs*XÖ“%øäπÃz8dFGÄƒå©Ãœ`ÎF*AÀ“n_~kE˚◊}Ï-_u;°&xΩDú3•∆·4õë—B_¨–√©9 †ÏÑV¶ÙMm∏¯ı¡avî∂∆ÖïÂäqÕiA∑ÇîEã·îÂêxS†—,noÏúÍ˜§ä˘˜ÚÛ”$I“#~;á®oóu5ÍΩ3[Ó¢∫ÁôÁg°Ó1÷™À„¡™@ÃLKXaK˛=b_¡ˆ¥8MEÛU©B’kGª%˘ü‹Ñ?Ù'd9R»oπL%˚ÎÂ~"%Ñv∏õ”ÅBm»d≥ı…ÊEΩÿ–OZlà›‹â˙D {,ä2ExB&Ôvä¿pæ"OJéd,Ë®Ÿ=≠+hû≠/Àç≥z§}ç˝À∑"ç@/B≠ŒêΩó/L ÓpıHö˛+ÆT≠|‘&wÁ≈q™s<QÏì≈G}∑<Eå–SÊv’|B≤ C/	}Yn∫l?˚<;ãﬁ ∆ç◊º[ı¬àsÖoáH,AÈÌÉÍŒanEê6j0ì«ÍŸ”Îiâ_˛:MÚ
)‚;±l_ˆ5®	FÒ|ïd[Æ‰i^±X¨Í™~«¸F"¿∂ÙS	+tßC Â—ÿ≤'sÃ•ìé.óÊ–é\¬«Z'+ÓóÍÈ¸ü\’5oÈ;,ù$e˚¬`Õ¨ıeùõ	ñºé≥gu9πçï°∫ΩÙ˘•≥˚©{JY¢¯}$@HV¨
|}óû(LBÉpΩn√⁄Á˛^sÕuÓG`)Cä¡_ÇÂ≈w
k†`«:©©€*ÕöLˆKëÕ€Z«B»ñU‰\^}t±ÍòˆÕYNN
:^o¨Œ˛:y∞]ÑÄÉª~_MÛÀèπ∑aW®ñ∏^Ò˛Z±`¨¥¿j±ò™aéÉÂ9'o∑=@c∑™U·ôò@…qæRÛD/™ØóÕhlßZ#ˆÏ®QvÙåÓ¥¡˛89´H1ßa<j©Ùÿﬂíã¨%ÚNdÙ[ƒH·Z$$tBñ!µÈn§VÇ1"»é=f'¢–€õ%2o˚öÜø9]‡r£Î}ó¶≤,{Ûää«≤úë»Â[3h¡¥±îØÚçy≤¨∏'ú˘˝„$k›@ñvPºﬂÑ"0	ì¿~πÚ¶™KSÃÊôôóÊD€%bkÜ`kﬁÔÓaÎ÷•‡ÑUûÛ";J<°9≠ë∑ƒXÎ‘√B;≠ªê3|WUF¡™Ú˚ƒn…ÍQpŒ∏ÙÕ¬ÓyÏÚk«*wQ_ˆÊ®¶òç"+¢Jni=◊)óÌÄly8±≥bx·‹éı¶ê>%éCŸh'U]ªGn&…XŸıÅˆUåCπJöQúáÒw«◊"πµqÒ£©Våœ©F√d∂îÿP UñÛ“Ä€≥∏\âπ@ÿ»!®Ç™üñî™Î$ˆ€èi{…‡è±∑”¬ÒYë…ãD	~≥”8˜“Ÿ Cπ±r2ìõYß3Ø3f}Ö√ﬁËÃ—+D‚Æ∑RËïô˛BH´ò à∆ß|c8fM §eVÌ`ÍQ©Üz,8-C6F°±‚ZÄæ|óâÿıªœF¬ö{∆ÏØ√ïK¥¥4Î&∞–SaØ]≥E‡˘+◊IE◊˘ïE—[Wsù<`mx¯W£"ÂÖ∞xUÒöEÛóÿ	3”zûörL5ÄÚ˘˛AUoıuΩÍjA®[£ƒ¬v#$π‡<Åê⁄-◊«SCa6hWBœÇ€ëƒ¥J—ôò0ˆÊñP_˝”Ÿ@+Î˜†R¿YΩLãsn^Í€Ê¿wXÑŒô~:)7_pTâ‡É™òÀs*¨«ˇ’F95ìW é+éÙ[\kâoëZ§ﬂ3ºàÀV’ûÆ<“IaphbÄ¸ºX>Ã@æÙ˚ÙÑ÷üLÖo:lc´‡O>ÀËıEæ∂‚©|§ŸΩÍã[„HôÎ`›QÙkQ‡lä6úTÆq˙É°Ãh9ΩaävS–nUu£Ö2õ&îò∫ØLñ5Os=¿Õ]FI%◊â ‡Ñb˝ì82πe="«ÿJÓé¸öÖƒ0Ï~B“ãÈªÕﬂ∫úÏu%Á~Aèï.5‡˘…èÌ˚“mW§ﬂ/ oÔ'&6/tg˛∂HMDtû˘Qn
`ŒtV¡Uq‘ùﬁá≠nCÏÄTÁ£∂í›∂≠C©ãë.7≤åpK}æéë∫™#_(&È–jTÍı—¬œz¯& +êÄÓt.–!◊o1€iÖﬁÍ5∞CÈ{ø"∆y÷‚ﬂ˙ñÙëj¸iÏu©É.ƒk…Àº¸„…çû—^X¸CÛaJd{¡qw≥œ«q#‘xQˇEO<6êîÜ ]ÇçyV£äy˙iç—Õà≥¢iôm‘«/
=ibË=!ewH÷Í6($w÷ß+≤¬~∂iﬁ€´“Î˛^ù2‹2ÿ◊]~£<(ûÕIﬂX‘^Ç¢¶D2¬%"é•⁄v9=ˆπiÍ·ˇÕoˇ$K˚∑y˛ÑZ™?íô7ÅENñ8‹M$4¸◊6]üÎ+ÈÔK€©Êë°∆\π”c¨êﬁW8p‹•—Åêâv]ñrJy ]æäú.;;çÙº˝cÃWg‡Y´Ìqk’ºNIxÄƒ{j– çÙﬁ∫Ï¶Y‹mŸóˆıêVtKYëUQ'Lè!æU≤9©Îbzt⁄KG¨D˝øÒÉÓÂ`Å|wÖ˜U5#-√ÕJN|˙Ís@ñπ7;&Ë…W»0
(è;ïª\∫
[Òkm≠à©"°ñ˜_◊2„—u%µ&)˛‘7BnDB´Ú≤≤5eÑ∞◊à*ß ˝ƒÜI‰˚‡›nÉ?|v9G¶Êh≥WJ‚Ω†ÒIëvπô. πñ@(Hê±™ñÌÓAj‘ì{ ÒÜyŸJ«~j.\˚3∂±;÷∆çÒ±ëú3Ozp≠áÚ x∂bq~?/»b‘ˇvLÒ∫Pö+‰@@	 —Ï◊Ã‘ﬁ€vF8£¨8◊øπ|†+P–•◊ÌÏ0K õ“∑3&·∞-˜Ö2l~*∞¶‹HáıM»Et≈4CAÇv∞÷â–•+W–¢•I˚
…X‡? ªøÃúàN≠í§.º´ØƒsΩó≈hÈ®°sãO ,%†à‘~éÑA¶ÈÈ‘ß⁄JE{æÚ–˝ΩßÏÇpô¶©7U≥rFÎ›®ú¢5ö¡k	óÈˇN∂Nï· ∞ÉÉß$›M›“Åzÿñúù/OBóƒË∞>1∑^®Ñ<èmwá$≈q¢ÿˇå*∏/≤Û}RËè∏%T£ÍÙ™VΩ3Îøçà0 PYÿ„”Üè5WÔ∆â˙Ñ∂Â(YTóµÀ}ÀQ"Ñ‡q-ıO”ß5∂›}"∑}u≥©¿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Collections.Generic;
using Internal.Runtime.CompilerServices;

namespace System.Globalization
{
    internal partial class CalendarData
    {
        private bool LoadCalendarDataFromSystem(string localeName, CalendarId calendarId)
        {
            Debug.Assert(!GlobalizationMode.Invariant);

            bool ret = true;

            uint useOverrides = this.bUseUserOverrides ? 0 : CAL_NOUSEROVERRIDE;

            //
            // Windows doesn't support some calendars right now, so remap those.
            //
            switch (calendarId)
            {
                case CalendarId.JAPANESELUNISOLAR:    // Data looks like Japanese
                    calendarId = CalendarId.JAPAN;
                    break;
                case CalendarId.JULIAN:               // Data looks like gregorian US
                case CalendarId.CHINESELUNISOLAR:     // Algorithmic, so actual data is irrelevent
                case CalendarId.SAKA:                 // reserved to match Office but not implemented in our code, so data is irrelevent
                case CalendarId.LUNAR_ETO_CHN:        // reserved to match Office but not implemented in our code, so data is irrelevent
                case CalendarId.LUNAR_ETO_KOR:        // reserved to match Office but not implemented in our code, so data is irrelevent
                case CalendarId.LUNAR_ETO_ROKUYOU:    // reserved to match Office but not implemented in our code, so data is irrelevent
                case CalendarId.KOREANLUNISOLAR:      // Algorithmic, so actual data is irrelevent
                case CalendarId.TAIWANLUNISOLAR:      // Algorithmic, so actual data is irrelevent
                    calendarId = CalendarId.GREGORIAN_US;
                    break;
            }

            //
            // Special handling for some special calendar due to OS limitation.
            // This includes calendar like Taiwan calendar, UmAlQura calendar, etc.
            //
            CheckSpecialCalendar(ref calendarId, ref localeName);

            // Numbers
            ret &= CallGetCalendarInfoEx(localeName, calendarId, CAL_ITWODIGITYEARMAX | useOverrides, out this.iTwoDigitYearMax);

            // Strings
            ret &= CallGetCalendarInfoEx(localeName, calendarId, CAL_SCALNAME, out this.sNativeName);
            ret &= CallGetCalendarInfoEx(localeName, calendarId, CAL_SMONTHDAY | useOverrides, out this.sMonthDay);

            // String Arrays
            // Formats
            ret &= CallEnumCalendarInfo(localeName, calendarId, CAL_SSHORTDATE, LOCALE_SSHORTDATE | useOverrides, out this.saShortDates!);
            ret &= CallEnumCalendarInfo(localeName, calendarId, CAL_SLONGDATE, LOCALE_SLONGDATE | useOverrides, out this.saLongDates!);

            // Get the YearMonth pattern.
            ret &= CallEnumCalendarInfo(localeName, calendarId, CAL_SYEARMONTH, LOCALE_SYEARMONTH, out this.saYearMonths!);

            // Day & Month Names
            // These are all single calType entries, 1 per day, so we have to make 7 or 13 calls to collect all the names

            // Day
            // Note that we're off-by-one since managed starts on sunday and windows starts on monday
            ret &= GetCalendarDayInfo(localeName, calendarId, CAL_SDAYNAME7, out this.saDayNames);
            ret &= GetCalendarDayInfo(localeName, calendarId, CAL_SABBREVDAYNAME7, out this.saAbbrevDayNames);

            // Month names
            ret &= GetCalendarMonthInfo(localeName, calendarId, CAL_SMONTHNAME1, out this.saMonthNames);
            ret &= GetCalendarMonthInfo(localeName, calendarId, CAL_SABBREVMONTHNAME1, out this.saAbbrevMonthNames);

            //
            // The following LCTYPE are not supported in some platforms.  If the call fails,
            // don't return a failure.
            //
            GetCalendarDayInfo(localeName, calendarId, CAL_SSHORTESTDAYNAME7, out this.saSuperShortDayNames);

            // Gregorian may have genitive month names
            if (calendarId == CalendarId.GREGORIAN)
            {
                GetCalendarMonthInfo(localeName, calendarId, CAL_SMONTHNAME1 | CAL_RETURN_GENITIVE_NAMES, out this.saMonthGenitiveNames);
                GetCalendarMonthInfo(localeName, calendarId, CAL_SABBREVMONTHNAME1 | CAL_RETURN_GENITIVE_NAMES, out this.saAbbrevMonthGenitiveNames);
            }

            // Calendar Parts Names
            // This doesn't get always get localized names for gregorian (not available in windows < 7)
            // so: eg: coreclr on win < 7 won't get these
            CallEnumCalendarInfo(localeName, calendarId, CAL_SERASTRING, 0, out this.saEraNames!);
            CallEnumCalendarInfo(localeName, calendarId, CAL_SABBREVERASTRING, 0, out this.saAbbrevEraNames!);

            //
            // Calendar Era Info
            // Note that calendar era data (offsets, etc) is hard coded for each calendar since this
            // data is implementation specific and not dynamic (except perhaps Japanese)
            //

            // Clean up the escaping of the formats
            this.saShortDates = CultureData.ReescapeWin32Strings(this.saShortDates)!;
            this.saLongDates = CultureData.ReescapeWin32Strings(this.saLongDates)!;
            this.saYearMonths = CultureData.ReescapeWin32Strings(this.saYearMonths)!;
            this.sMonthDay = CultureData.ReescapeWin32String(this.sMonthDay)!;

            return ret;
        }

        // Get native two digit year max
        internal static int GetTwoDigitYearMax(CalendarId calendarId) =>
            GlobalizationMode.Invariant ? Invariant.iTwoDigitYearMax :
            CallGetCalendarInfoEx(null, calendarId, CAL_ITWODIGITYEARMAX, out int twoDigitYearMax) ? twoDigitYearMax :
            -1;

        // Call native side to figure out which calendars are allowed
        internal static int GetCalendars(string localeName, bool useUserOverride, CalendarId[] calendars)
        {
            Debug.Assert(!GlobalizationMode.Invariant);

            EnumCalendarsData data = default;
            data.userOverride = 0;
            data.calendars = new List<int>();

            // First call GetLocaleInfo if necessary
            if (useUserOverride)
            {
                // They want user overrides, see if the user calendar matches the input calendar
                int userCalendar = CultureData.GetLocaleInfoExInt(localeName, LOCALE_ICALENDARTYPE);

                // If we got a default, then use it as the first calendar
                if (userCalendar != 0)
                {
                    data.userOverride = userCalendar;
                    data.calendars.Add(userCalendar);
                }
            }

            unsafe
            {
                Interop.Kernel32.EnumCalendarInfoExEx(EnumCalendarsCallback, localeName, ENUM_ALL_CALENDARS, null, CAL_ICALINTVALUE, Unsafe.AsPointer(ref data));
            }

            // Copy to the output array
            for (int i = 0; i < Math.Min(calendars.Length, data.calendars.Count); i++)
                calendars[i] = (CalendarId)data.calendars[i];

            // Now we have a list of data, return the count
            return data.calendars.Count;
        }

        private static bool SystemSupportsTaiwaneseCalendar()
        {
            Debug.Assert(!GlobalizationMode.Invariant);

            // Taiwanese calendar get listed as one of the optional zh-TW calendars only when having zh-TW UI
            return CallGetCalendarInfoEx("zh-TW", CalendarId.TAIWAN, CAL_SCALNAME, out string _);
        }

        // PAL Layer ends here

        private const uint CAL_RETURN_NUMBER = 0x20000000;
        private const uint CAL_RETURN_GENITIVE_NAMES = 0x10000000;
        private const uint CAL_NOUSEROVERRIDE = 0x80000000;
        private const uint CAL_SCALNAME = 0x00000002;
        private const uint CAL_SMONTHDAY = 0x00000038;
        private const uint CAL_SSHORTDATE = 0x00000005;
        private const uint CAL_SLONGDATE = 0x00000006;
        private const uint CAL_SYEARMONTH = 0x0000002f;
        private const uint CAL_SDAYNAME7 = 0x0000000d;
        private const uint CAL_SABBREVDAYNAME7 = 0x00000014;
        private const uint CAL_SMONTHNAME1 = 0x00000015;
        private const uint CAL_SABBREVMONTHNAME1 = 0x00000022;
        private const uint CAL_SSHORTESTDAYNAME7 = 0x00000037;
        private const uint CAL_SERASTRING = 0x00000004;
        private const uint CAL_SABBREVERASTRING = 0x00000039;
        private const uint CAL_ICALINTVALUE = 0x00000001;
        private const uint CAL_ITWODIGITYEARMAX = 0x00000030;

        private const uint ENUM_ALL_CALENDARS = 0xffffffff;

        private const uint LOCALE_SSHORTDATE = 0x0000001F;
        private const uint LOCALE_SLONGDATE = 0x00000020;
        private const uint LOCALE_SYEARMONTH = 0x00001006;
        private const uint LOCALE_ICALENDARTYPE = 0x00001009;

        ////////////////////////////////////////////////////////////////////////
        //
        // For calendars like Gregorain US/Taiwan/UmAlQura, they are not available
        // in all OS or all localized versions of OS.
        // If OS does not support these calendars, we will fallback by using the
        // appropriate fallback calendar and locale combination to retrieve data from OS.
        //
        // Parameters:
        //  __deref_inout pCalendarInt:
        //    Pointer to the calendar ID. This will be updated to new fallback calendar ID if needed.
        //  __in_out pLocaleNameStackBuffer
        //    Pointer to the StackSString object which holds the locale name to be checked.
        //    This will be updated to new fallback locale name if needed.
        //
        ////////////////////////////////////////////////////////////////////////
        private static void CheckSpecialCalendar(ref CalendarId calendar, ref string localeName)
        {
            // Gregorian-US isn't always available in the OS, however it is the same for all locales
            switch (calendar)
            {
                case CalendarId.GREGORIAN_US:
                    // See if this works
                    if (!CallGetCalendarInfoEx(localeName, calendar, CAL_SCALNAME, out string _))
                    {
                        // Failed, set it to a locale (fa-IR) that's alway has Gregorian US available in the OS
                        localeName = "fa-IR";
                    }
                    // See if that works
                    if (!CallGetCalendarInfoEx(localeName, calendar, CAL_SCALNAME, out string _))
                    {
                        // Failed again, just use en-US with the gregorian calendar
                        localeName = "en-US";
                        calendar = CalendarId.GREGORIAN;
                    }
                    break;
                case CalendarId.TAIWAN:
                    // Taiwan calendar data is not always in all language version of OS due to Geopolical reasons.
                    // It is only available in zh-TW localized versions of Windows.
                    // Let's check if OS supports it.  If not, fallback to Greogrian localized for Taiwan calendar.
                    if (!SystemSupportsTaiwaneseCalendar())
                    {
                        calendar = CalendarId.GREGORIAN;
                    }
                    break;
            }
        }

        private static bool CallGetCalendarInfoEx(string? localeName, CalendarId calendar, uint calType, out int data)
        {
            return Interop.Kernel32.GetCalendarInfoEx(localeName, (uint)calendar, IntPtr.Zero, calType | CAL_RETURN_NUMBER, IntPtr.Zero, 0, out data) != 0;
        }

        private static unsafe bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, uint calType, out string data)
        {
            const int BUFFER_LENGTH = 80;

            // The maximum size for values returned from GetCalendarInfoEx is 80 characters.
            char* buffer = stackalloc char[BUFFER_LENGTH];

            int ret = Interop.Kernel32.G