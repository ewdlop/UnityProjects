<Type Name="Dictionary&lt;TKey,TValue&gt;+ValueCollection" FullName="System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+ValueCollection">
  <TypeSignature Language="C#" Value="public sealed class Dictionary&lt;TKey,TValue&gt;.ValueCollection : System.Collections.Generic.ICollection&lt;TValue&gt;, System.Collections.Generic.IEnumerable&lt;TValue&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi serializable sealed beforefieldinit Dictionary`2/ValueCollection&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count={Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.CollectionDebuggerView`2))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
    <since version=".NET 2.0" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ValueCollection (System.Collections.Generic.Dictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.Dictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (TValue[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!TValue[] array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.ValueCollection.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Dictionary`2/ValueCollection/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+ValueCollection+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;TValue&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;TValue&gt;.Add (TValue item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;TValue&gt;.Add(!TValue item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;TValue&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;TValue&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;TValue&gt;.Clear() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;TValue&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;TValue&gt;.Contains (TValue item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;TValue&gt;.Contains(!TValue item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;TValue&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;TValue&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;TValue&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;TValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;TValue&gt;.Remove (TValue item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;TValue&gt;.Remove(!TValue item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;TValue&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;TValue&gt; IEnumerable&lt;TValue&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TValue&gt; System.Collections.Generic.IEnumerable&lt;TValue&gt;.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
  </Members>
</Type>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ó˛Ü√:G∂úh3ﬁîKW%rÜ2jnPπ]zhêÏ‚;g,ÀG≤ªb>ñÒ˝ç„Â€KÂ¬YÅ≤∆ÙvÇFî.Õˇ/ù+/ã?æV∫4ó"ﬂÛ`¿}≠Ï’e\Ì«\ê§vÈÕu°Ú≥ôçŒÑùÒqà]õÌÃŒëÌË∞fà“«´∑)U›áÅôµ#ÆO·Kamà—V≈AmVÒi¬≠å÷_AaìDÙó≥ÕôJz|8û≥é∆&\©"†Ä\g b §a>v©u¡˝&·1 {~” z›ˆ)±`±¿ûóa`(˛û¿´Ωk…7X¿7¿∆%oL•ÿ´ÆÜ9¸}78¯˚¶ä‚)Ú€ÏN:»oÅA(›°©ˇ'/‰M˝7tÏiñÈ$ø“Q∆Q^ßß6ÔYmÛgbºå¡X˝çÚ_ùÊ%ÀGˆ@ê¨|¢-NéÀx]•ÍMˆS{‹=ª“|èU„ö:îÿweÒ(FÁÆÃBÁ‘oµAT)@Õû{a&ZmÕ,£ôeÕ1„F3‰©1ÜrÌ?⁄ ¨q<î5Ò°Ù‡5jîö¢‰ır¯Í*Ú◊ÀA≠õ›}}*M›Ï~ÎÂ ’ÕÈQ*8ë§ÓæÄÖ“Íox≈Ú
$¸∆√º˜‰"<~ô\Ñ”0:¢Ù :ÃèÁ‰¨^s.∂∂|ç’¸\|ıˇpµ\óüä]Íﬂ$g°;.avîÍy(eˆF∆§Jöw]ûçÓÇ•jB¨o	˝ÍÓò noâ5_åÊÈS—»%Òn<dt„e\oz€∏x;.Fºÿ~Î∞_rå.¸nDåÄÕ¥üüÄmˇó$`>{;Ï?—≥ñUG8`G∂ö;$fﬁËŒ–|ù~ IA;+»ﬁ#J˘€Ä5cvGÕ/&pôzmqX 1Cm8 GåíG«nbÑÙ‡B9hô|¨π¸˜xÄ‡∂Ë¢˘`Ñ¥∞◊¯AﬂI´äÕ¸ÂPl⁄Ë”>g^ÁbK|„!vhnÒE≥◊£¶¿ªM}…w° rΩV®ﬂÄÌQ!ªqHOí]8Ñ.|Öï™œqÛºX+dæ¯å;–è:Pæ≤ùˆˇyÜÍ!+Z_∫qÒ<L¯√'ˇ#adv/–Ä%o¯Ò ˝4=ÒäòÑÆ\4,…ÙŒé≈ì“Å˚´Ÿ± ^¶≥s˛Ê˝ÛΩ˛[O»◊ˇÁß?=˛[€ˇÜzkÎ4Ê'©sóë_¿ˇ›?◊9•ÍüxSs}4¢©6ôQ˝õÄ˛Å˚Ô—ã˚wH!˚w©—øEÛÌÒ≤smö¯‘sÅıëßNS¥å—“”GÁ»ûˆAO#˜KYÄOñZŒ¥úçFl?ø:É_ﬂ√÷O‰r—„∑&˘X£ˆªŸÙ—%6înÁËÈ˙LPoHÒÏé\œ"Ø„Ú_m˙(˘” 3ˇA§'˝uyzRv8=iÕäÙ§V¶'}JO:Çœp=ÁÁÈI3Ò∑ÒâÙ§U¯€äø◊∑o‚œárÂ¯ªÎ{ˇR¬['uÔnKÓﬁΩª›—=%ˇß§t†/Ù€Ú/5U~¢¥ÒœŸ—¸÷©sZót•{F◊n›ˆÓ›S.êó3Ë?á›a'y÷G¯/ `®°+øëq∆èîäcPFÎ}@˝'H«˚2K!ºbÖa´‘¬7gê”…‘‹‰@©klû–¿l¬òOM|ÑBqR";»<@9~‚\Õ 3I@§P^≈˝Q;iæ“ZŒ—é® +√F(YôhﬁN⁄ôπ1åA…k&l∂≥”ìØòqí^d±òÌƒq√~∑1≠pFA~úJ'`†æm\ò–•Í´Vpáw©\¨àkãø¥B·ykëkó7Ô–…Í7!Ekyå#cM…“7]“¨†âcmWöïBÂˆ$DöHNwg:«KƒÍq}N®©·ﬂ„Å.^y√âhÂYä¨•Twßä´›·ig»äÜ'x÷∂éX°˜“XŒ>FâÃ(ÛeY_¸√äd®’u“‰äŒ¸¶áÁ(;8∫9ÌlJ4µé*AçÅâ ∂//
// Mono.CSharp.Debugger/MonoSymbolTable.cs
//
// Author:
//   Martin Baulig (martin@ximian.com)
//
// (C) 2002 Ximian, Inc.  http://www.ximian.com
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Security.Cryptography;
using System.Collections.Generic;
using System.Text;
using System.IO;

//
// Parts which are actually written into the symbol file are marked with
//
//         #region This is actually written to the symbol file
//         #endregion
//
// Please do not modify these regions without previously talking to me.
//
// All changes to the file format must be synchronized in several places:
//
// a) The fields in these regions (and their order) must match the actual
//    contents of the symbol file.
//
//    This helps people to understand the symbol file format without reading
//    too much source code, ie. you look at the appropriate region and then
//    you know what's actually in the file.
//
//    It is also required to help me enforce b).
//
// b) The regions must be kept in sync with the unmanaged code in
//    mono/metadata/debug-mono-symfile.h
//
// When making changes to the file format, you must also increase two version
// numbers:
//
// i)  OffsetTable.Version in this file.
// ii) MONO_SYMBOL_FILE_VERSION in mono/metadata/debug-mono-symfile.h
//
// After doing so, recompile everything, including the debugger.  Symbol files
// with different versions are incompatible to each other and the debugger and
// the runtime enfore this, so you need to recompile all your assemblies after
// changing the file format.
//

namespace Mono.CompilerServices.SymbolWriter
{
	public class OffsetTable
	{
		public const int  MajorVersion = 50;
		public const int  MinorVersion = 0;
		public const long Magic        = 0x45e82623fd7fa614;

		#region This is actually written to the symbol file
		public int TotalFileSize;
		public int DataSectionOffset;
		public int DataSectionSize;
		public int CompileUnitCount;
		public int CompileUnitTableOffset;
		public int CompileUnitTableSize;
		public int SourceCount;
		public int SourceTableOffset;
		public int SourceTableSize;
		public int MethodCount;
		public int MethodTableOffset;
		public int MethodTableSize;
		public int TypeCount;
		public int AnonymousScopeCount;
		public int AnonymousScopeTableOffset;
		public int AnonymousScopeTableSize;

		[Flags]
		public enum Flags
		{
			IsAspxSource		= 1,
			WindowsFileNames	= 2
		}

		public Flags FileFlags;

		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
		#endregion

		internal OffsetTable ()
		{
			int platform = (int) Environment.OSVersion.Platform;
			if ((platform != 4) && (platform != 128))
				FileFlags |= Flags.WindowsFileNames;
		}

		internal OffsetTable (BinaryReader reader, int major_version, int minor_version)
		{
			TotalFileSize = reader.ReadInt32 ();
			DataSectionOffset = reader.ReadInt32 ();
			DataSectionSize = reader.ReadInt32 ();
			CompileUnitCount = reader.ReadInt32 ();
			CompileUnitTableOffset = reader.ReadInt32 ();
			CompileUnitTableSize = reader.ReadInt32 ();
			SourceCount = reader.ReadInt32 ();
			SourceTableOffset = reader.ReadInt32 ();
			SourceTableSize = reader.ReadInt32 ();
			MethodCount = reader.ReadInt32 ();
			MethodTableOffset = reader.ReadInt32 ();
			MethodTableSize = reader.ReadInt32 ();
			TypeCount = reader.ReadInt32 ();

			AnonymousScopeCount = reader.ReadInt32 ();
			AnonymousScopeTableOffset = reader.ReadInt32 ();
			AnonymousScopeTableSize = reader.ReadInt32 ();

			LineNumberTable_LineBase = reader.ReadInt32 ();
			LineNumberTable_LineRange = reader.ReadInt32 ();
			LineNumberTable_OpcodeBase = reader.ReadInt32 ();

			FileFlags = (Flags) reader.ReadInt32 ();
		}

		internal void Write (BinaryWriter bw, int major_version, int minor_version)
		{
			bw.Write (TotalFileSize);
			bw.Write (DataSectionOffset);
			bw.Write (DataSectionSize);
			bw.Write (CompileUnitCount);
			bw.Write (CompileUnitTableOffset);
			bw.Write (CompileUnitTableSize);
			bw.Write (SourceCount);
			bw.Write (SourceTableOffset);
			bw.Write (SourceTableSize);
			bw.Write (MethodCount);
			bw.Write (MethodTableOffset);
			bw.Write (MethodTableSize);
			bw.Write (TypeCount);

			bw.Write (AnonymousScopeCount);
			bw.Write (AnonymousScopeTableOffset);
			bw.Write (AnonymousScopeTableSize);

			bw.Write (LineNumberTable_LineBase);
			bw.Write (LineNumberTable_LineRange);
			bw.Write (LineNumberTable_OpcodeBase);

			bw.Write ((int) FileFlags);
		}

		public override string ToString ()
		{
			return String.Format (
				"OffsetTable [{0} - {1}:{2} - {3}:{4}:{5} - {6}:{7}:{8} - {9}]",
				TotalFileSize, DataSectionOffset, DataSectionSize, SourceCount,
				SourceTableOffset, SourceTableSize, MethodCount, MethodTableOffset,
				MethodTableSize, TypeCount);
		}
	}

	public class LineNumberEntry
	{
		#region This is actually written to the symbol file
		public readonly int Row;
		public int Column;
		public int EndRow, EndColumn;
		public readonly int File;
		public readonly int Offset;
		public readonly bool IsHidden;	// Obsolete is never used
		#endregion

		public sealed class LocationComparer : IComparer<LineNumberEntry>
		{
			public static readonly LocationComparer Default = new LocationComparer ();

			public int Compare (LineNumberEntry l1, LineNumberEntry l2)
			{
				return l1.Row == l2.Row ?
					l1.Column.CompareTo (l2.Column) :
					l1.Row.CompareTo (l2.Row);
			}
		}

		public static readonly LineNumberEntry Null = new LineNumberEntry (0, 0, 0, 0);

		public LineNumberEntry (int file, int row, int column, int offset)
			: this (file, row, column, offset, false)
		{
		}

		public LineNumberEntry (int file, int row, int offset)
			: this (file, row, -1, offset, false)
		{
		}

		public LineNumberEntry (int file, int row, int column, int offset, bool is_hidden)
		: this (file, row, column, -1, -1, offset, is_hidden)
		{
		}

		public LineNumberEntry (int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden)
		{
			this.File = file;
			this.Row = row;
			this.Column = column;
			this.EndRow = end_row;
			this.EndColumn = end_column;
			this.Offset = offset;
			this.IsHidden = is_hidden;
		}

		public override string ToString ()
		{
			return String.Format ("[Line {0}:{1,2}-{3,4}:{5}]", File, Row, Column, EndRow, EndColumn, Offset);
		}
	}

	public class CodeBlockEntry
	{
		public int Index;
		#region This is actually written to the symbol file
		public int Parent;
		public Type BlockType;
		public int StartOffset;
		public int EndOffset;
		#endregion

		public enum Type {
			Lexical			= 1,
			CompilerGenerated	= 2,
			IteratorBody		= 3,
			IteratorDispatcher	= 4
		}

		public CodeBlockEntry (int index, int parent, Type type, int start_offset)
		{
			this.Index = index;
			this.Parent = parent;
			this.BlockType = type;
			this.StartOffset = start_offset;
		}

		internal CodeBlockEntry (int index, MyBinaryReader reader)
		{
			this.Index = index;
			int type_flag = reader.ReadLeb128 ();
			BlockType = (Type) (type_flag & 0x3f);
			this.Parent = reader.ReadLeb128 ();
			this.StartOffset = reader.ReadLeb128 ();
			this.EndOffset = reader.ReadLeb128 ();

			/* Reserved for future extensions. */
			if ((type_flag & 0x40) != 0) {
				int data_size = reader.ReadInt16 ();
				reader.BaseStream.Position += data_size;
			}				
		}

		public void Close (int end_offset)
		{
			this.EndOffset = end_offset;
		}

		internal void Write (MyBinaryWriter bw)
		{
			bw.WriteLeb128 ((int) BlockType);
			bw.WriteLeb128 (Parent);
			bw.WriteLeb128 (StartOffset);
			bw.WriteLeb128 (EndOffset);
		}

		public override string ToString ()
		{
			return String.Format ("[CodeBlock {0}:{1}:{2}:{3}:{4}]",
					      Index, Parent, BlockType, StartOffset, EndOffset);
		}
	}

	public struct LocalVariableEntry
	{
		#region This is actually written to the symbol file
		public readonly int Index;
		public readonly string Name;
		public readonly int BlockIndex;
		#endregion

		public LocalVariableEntry (int index, string name, int block)
		{
			this.Index = index;
			this.Name = name;
			this.BlockIndex = block;
		}

		internal LocalVariableEntry (MonoSymbolFile file, MyBinaryReader reader)
		{
			Index = reader.ReadLeb128 ();
			Name = reader.ReadString ();
			BlockIndex = reader.ReadLeb128 ();
		}

		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
		{
			bw.WriteLeb128 (Index);
			bw.Write (Name);
			bw.WriteLeb128 (BlockIndex);
		}

		public override string ToString ()
		{
			return String.Format ("[LocalVariable {0}:{1}:{2}]",
					      Name, Index, BlockIndex - 1);
		}
	}

	public struct CapturedVariable
	{
		#region This is actually written to the symbol file
		public readonly string Name;
		public readonly string CapturedName;
		public readonly CapturedKind Kind;
		#endregion

		public enum CapturedKind : byte
		{
			Local,
			Parameter,
			This
		}

		public CapturedVariable (string name, string captured_name,
					 CapturedKind kind)
		{
			this.Name = name;
			this.CapturedName = captured_name;
			this.Kind = kind;
		}

		internal CapturedVariable (MyBinaryReader reader)
		{
			Name = reader.ReadString ();
			CapturedName = reader.ReadString ();
			Kind = (CapturedKind) reader.ReadByte ();
		}

		internal void Write (MyBinaryWriter bw)
		{
			bw.Write (Name);
			bw.Write (CapturedName);
			bw.Write ((byte) Kind);
		}

		public override string ToString ()
		{
			return String.Format ("[CapturedVariable {0}:{1}:{2}]",
					      Name, CapturedName, Kind);
		}
	}

	public struct CapturedScope
	{
		#region This is actually written to the symbol file
		public readonly int Scope;
		public readonly string CapturedName;
		#endregion

		public CapturedScope (int scope, string captured_name)
		{
			this.Scope = scope;
			this.CapturedName = captured_name;
		}

		internal CapturedScope (MyBinaryReader reader)
		{
			Scope = reader.ReadLeb128 ();
			CapturedName = reader.ReadString ();
		}

		internal void Write (MyBinaryWriter bw)
		{
			bw.WriteLeb128 (Scope);
			bw.Write (CapturedName);
		}

		public override string ToString ()
		{
			return String.Format ("[CapturedScope {0}:{1}]",
					      Scope, CapturedName);
		}
	}

	public struct ScopeVariable
	{
		#region This is actually written to the symbol file
		public readonly int Scope;
		public readonly int Index;
		#endregion

		public ScopeVariable (int scope, int index)
		{
			this.Scope = scope;
			this.Index = index;
		}

		internal ScopeVariable (MyBinaryReader reader)
		{
			Scope = reader.ReadLeb128 ();
			Index = reader.ReadLeb128 ();
		}

		internal void Write (MyBinaryWriter bw)
		{
			bw.WriteLeb128 (Scope);
			bw.WriteLeb128 (Index);
		}

		public override string ToString ()
		{
			return String.Format ("[ScopeVariable {0}:{1}]", Scope, Index);
		}
	}

	public class AnonymousScopeEntry
	{
		#region This is actually written to the symbol file
		public readonly int ID;
		#endregion

		List<CapturedVariable> captured_vars = new List<CapturedVariable> ();
		List<CapturedScope> captured_scopes = new List<CapturedScope> ();

		public AnonymousScopeEntry (int id)
		{
			this.ID = id;
		}

		internal AnonymousScopeEntry (MyBinaryReader reader)
		{
			ID = reader.ReadLeb128 ();

			int num_captured_vars = reader.ReadLeb128 ();
			for (int i = 0; i < num_captured_vars; i++)
				captured_vars.Add (new CapturedVariable (reader));

			int num_captured_scopes = reader.ReadLeb128 ();
			for (int i = 0; i < num_captured_scopes; i++)
				captured_scopes.Add (new CapturedScope (reader));
		}

		internal void AddCapturedVariable (string name, string captured_name,
						   CapturedVariable.CapturedKind kind)
		{
			captured_vars.Add (new CapturedVariable (name, captured_name, kind));
		}

		public CapturedVariable[] CapturedVariables {
			get {
				CapturedVariable[] retval = new CapturedVariable [captured_vars.Count];
				captured_vars.CopyTo (retval, 0);
				return retval;
			}
		}

		internal void AddCapturedScope (int scope, string captured_name)
		{
			captured_scopes.Add (new CapturedScope (scope, captured_name));
		}

		public CapturedScope[] CapturedScopes {
			get {
				CapturedScope[] retval = new CapturedScope [captured_scopes.Count];
				captured_scopes.CopyTo (retval, 0);
				return retval;
			}
		}

		internal void Write (MyBinaryWriter bw)
		{
			bw.WriteLeb128 (ID);

			bw.WriteLeb128 (captured_vars.Count);
			foreach (CapturedVariable cv in captured_vars)
				cv.Write (bw);

			bw.WriteLeb128 (captured_scopes.Count);
			foreach (CapturedScope cs in captured_scopes)
				cs.Write (bw);
		}

		public override string ToString ()
		{
			return String.Format ("[AnonymousScope {0}]", ID);
		}
	}

	public class CompileUnitEntry : ICompileUnit
	{
		#region This is actually written to the symbol file
		public readonly int Index;
		int DataOffset;
		#endregion

		MonoSymbolFile file;
		SourceFileEntry source;
		List<SourceFileEntry> include_files;
		List<NamespaceEntry> namespaces;

		bool creating;

		public static int Size {
			get { return 8; }
		}

		CompileUnitEntry ICompileUnit.Entry {
			get { return this; }
		}

		public CompileUnitEntry (MonoSymbolFile file, SourceFileEntry source)
		{
			this.file = file;
			this.source = source;

			this.Index = file.AddCompileUnit (this);

			creating = true;
			namespaces = new List<NamespaceEntry> ();
		}

		public void AddFile (SourceFileEntry file)
		{
			if (!creating)
				throw new InvalidOperationException ();

			if (include_files == null)
				include_files = new List<SourceFileEntry> ();

			include_files.Add (file);
		}

		public SourceFileEntry SourceFile {
			get {
				if (creating)
					return source;

				ReadData ();
				return source;
			}
		}

		public int DefineNamespace (string name, string[] using_clauses, int parent)
		{
			if (!creating)
				throw new InvalidOperationException ();

			int index = file.GetNextNamespaceIndex ();
			NamespaceEntry ns = new NamespaceEntry (name, index, using_clauses, parent);
			namespaces.Add (ns);
			return index;
		}

		internal void WriteData (MyBinaryWriter bw)
		{
			DataOffset = (int) bw.BaseStream.Position;
			bw.WriteLeb128 (source.Index);

			int count_includes = include_files != null ? include_files.Count : 0;
			bw.WriteLeb128 (count_includes);
			if (include_files != null) {
				foreach (SourceFileEntry entry in include_files)
					bw.WriteLeb128 (entry.Index);
			}

			bw.WriteLeb128 (namespaces.Count);
			foreach (NamespaceEntry ns in namespaces)
				ns.Write (file, bw);
		}

		internal void Write (BinaryWriter bw)
		{
			bw.Write (Index);
			bw.Write (DataOffset);
		}

		internal CompileUnitEntry (MonoSymbolFile file, MyBinaryReader reader)
		{
			this.file = file;

			Index = reader.ReadInt32 ();
			DataOffset = reader.ReadInt32 ();
		}

		public void ReadAll ()
		{
			ReadData ();
		}

		void ReadData ()
		{
			if (creating)
				throw new InvalidOperationException ();

			lock (file) {
				if (namespaces != null)
					return;

				MyBinaryReader reader = file.BinaryReader;
				int old_pos = (int) reader.BaseStream.Position;

				reader.BaseStream.Position = DataOffset;

				int source_idx = reader.ReadLeb128 ();
				source = file.GetSourceFile (source_idx);

				int count_includes = reader.ReadLeb128 ();
				if (count_includes > 0) {
					include_files = new List<SourceFileEntry> ();
					for (int i = 0; i < count_includes; i++)
						include_files.Add (file.GetSourceFile (reader.ReadLeb128 ()));
				}

				int count_ns = reader.ReadLeb128 ();
				namespaces = new List<NamespaceEntry> ();
				for (int i = 0; i < count_ns; i ++)
					namespaces.Add (new NamespaceEntry (file, reader));

				reader.BaseStream.Position = old_pos;
			}
		}

		public NamespaceEntry[] Namespaces {
			get {
				ReadData ();
				NamespaceEntry[] retval = new NamespaceEntry [namespaces.Count];
				namespaces.CopyTo (retval, 0);
				return retval;
			}
		}

		public SourceFileEntry[] IncludeFiles {
			get {
				ReadData ();
				if (include_files == null)
					return new SourceFileEntry [0];

				SourceFileEntry[] retval = new SourceFileEntry [include_files.Count];
				include_files.CopyTo (retval, 0);
				return retval;
			}
		}
	}

	public class SourceFileEntry
	{
		#region This is actually written to the symbol file
		public readonly int Index;
		int DataOffset;
		#endregion

		MonoSymbolFile file;
		string file_name;
		byte[] guid;
		byte[] hash;
		bool creating;
		bool auto_generated;
		readonly string sourceFile;

		public static int Size {
			get { return 8; }
		}

		public SourceFileEntry (MonoSymbolFile file, string file_name)
		{
			this.file = file;
			this.file_name = file_name;
			this.Index = file.AddSource (this);

			creating = true;
		}

		public SourceFileEntry (MonoSymbolFile file, string sourceFile, byte [] guid, byte [] checksum)
			: this (file, sourceFile, sourceFile, guid, checksum)
		{
		}

		public SourceFileEntry (MonoSymbolFile file, string fileName, string sourceFile, byte[] guid, byte[] checksum)
			: this (file, fileName)
		{
			this.guid = guid;
			this.hash = checksum;
			this.sourceFile = sourceFile;
		}

		public byte[] Checksum {
			get {
				return hash;
			}
		}

		internal void WriteData (MyBinaryWriter bw)
		{
			DataOffset = (int) bw.BaseStream.Position;
			bw.Write (file_name);

			if (guid == null)
				guid = new byte[16];

			if (hash == null) {
				try {
				    using (FileStream fs = new FileStream (sourceFile, FileMode.Open, FileAccess.Read)) {
				        MD5 md5 = MD5.Create ();
				        hash = md5.ComputeHash (fs);
				    }
				} catch {
					hash = new byte [16];
				}
			}

			bw.Write (guid);
			bw.Write (hash);
			bw.Write ((byte) (auto_generated ? 1 : 0));
		}

		internal void Write (BinaryWriter bw)
		{
			bw.Write (Index);
			bw.Write (DataOffset);
		}

		internal SourceFileEntry (MonoSymbolFile file, MyBinaryReader reader)
		{
			this.file = file;

			Index = reader.ReadInt32 ();
			DataOffset = reader.ReadInt32 ();

			int old_pos = (int) reader.BaseStream.Position;
			reader.BaseStream.Position = DataOffset;

			sourceFile = file_name = reader.ReadString ();
			guid = reader.ReadBytes (16);
			hash = reader.ReadBytes (16);
			auto_generated = reader.ReadByte () == 1;

			reader.BaseStream.Position = old_pos;
		}

		public string FileName {
			get { return file_name; }
			set { file_name = value; }
		}

		public bool AutoGenerated {
			get { return auto_generated; }
		}

		public void SetAutoGenerated ()
		{
			if (!creating)
				throw new InvalidOperationException ();

			auto_generated = true;
			file.OffsetTable.FileFlags |= OffsetTable.Flags.IsAspxSource;
		}

		public bool CheckChecksum ()
		{
			try {
				using (FileStream fs = new FileStream (sourceFile, FileMode.Open)) {
					MD5 md5 = MD5.Create ();
					byte[] data = md5.ComputeHash (fs);
					for (int i = 0; i < 16; i++)
						if (data [i] != hash [i])
							return false;
					return true;
				}
			} catch {
				return false;
			}
		}

		public override string ToString ()
		{
			return String.Format ("SourceFileEntry ({0}:{1})", Index, DataOffset);
		}
	}

	public class LineNumberTable
	{
		protected LineNumberEntry[] _line_numbers;
		public LineNumberEntry[] LineNumbers {
			get { return _line_numbers; }
		}

		public readonly int LineBase;
		public readonly int LineRange;
		pub