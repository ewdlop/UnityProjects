//------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------
namespace System.ServiceModel.Configuration
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime;
    using System.Runtime.Diagnostics;
    using System.Security;
    using System.Security.Permissions;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Diagnostics;

    static class ConfigurationHelpers
    {
        /// Be sure to update UnsafeGetAssociatedBindingCollectionElement if you modify this method
        internal static BindingCollectionElement GetAssociatedBindingCollectionElement(ContextInformation evaluationContext, string bindingCollectionName)
        {
            BindingCollectionElement retVal = null;
            BindingsSection bindingsSection = (BindingsSection)ConfigurationHelpers.GetAssociatedSection(evaluationContext, ConfigurationStrings.BindingsSectionGroupPath);

            if (null != bindingsSection)
            {
                bindingsSection.UpdateBindingSections(evaluationContext);
                try
                {
                    retVal = bindingsSection[bindingCollectionName];
                }
                catch (KeyNotFoundException)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigBindingExtensionNotFound,
                        ConfigurationHelpers.GetBindingsSectionPath(bindingCollectionName))));
                }
                catch (NullReferenceException) // System.Configuration.ConfigurationElement bug
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigBindingExtensionNotFound,
                        ConfigurationHelpers.GetBindingsSectionPath(bindingCollectionName))));
                }
            }

            return retVal;
        }

        // Be sure to update GetAssociatedBindingCollectionElement if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical method UnsafeGetAssociatedSection which elevates.")]
        [SecurityCritical]
        internal static BindingCollectionElement UnsafeGetAssociatedBindingCollectionElement(ContextInformation evaluationContext, string bindingCollectionName)
        {
            BindingCollectionElement retVal = null;
            BindingsSection bindingsSection = (BindingsSection)ConfigurationHelpers.UnsafeGetAssociatedSection(evaluationContext, ConfigurationStrings.BindingsSectionGroupPath);

            if (null != bindingsSection)
            {
                bindingsSection.UpdateBindingSections(evaluationContext);
                try
                {
                    retVal = bindingsSection[bindingCollectionName];
                }
                catch (KeyNotFoundException)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigBindingExtensionNotFound,
                        ConfigurationHelpers.GetBindingsSectionPath(bindingCollectionName))));
                }
                catch (NullReferenceException) // System.Configuration.ConfigurationElement bug
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigBindingExtensionNotFound,
                        ConfigurationHelpers.GetBindingsSectionPath(bindingCollectionName))));
                }
            }

            return retVal;
        }

        /// Be sure to update UnsafeGetAssociatedEndpointCollectionElement if you modify this method
        internal static EndpointCollectionElement GetAssociatedEndpointCollectionElement(ContextInformation evaluationContext, string endpointCollectionName)
        {
            EndpointCollectionElement retVal = null;
            StandardEndpointsSection endpointsSection = (StandardEndpointsSection)ConfigurationHelpers.GetAssociatedSection(evaluationContext, ConfigurationStrings.StandardEndpointsSectionPath);

            if (null != endpointsSection)
            {
                endpointsSection.UpdateEndpointSections(evaluationContext);
                try
                {
                    retVal = (EndpointCollectionElement)endpointsSection[endpointCollectionName];
                }
                catch (KeyNotFoundException)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigEndpointExtensionNotFound,
                        ConfigurationHelpers.GetEndpointsSectionPath(endpointCollectionName))));
                }
                catch (NullReferenceException) // System.Configuration.ConfigurationElement bug
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigEndpointExtensionNotFound,
                        ConfigurationHelpers.GetEndpointsSectionPath(endpointCollectionName))));
                }
            }

            return retVal;
        }

        // Be sure to update GetAssociatedEndpointCollectionElement if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical method UnsafeGetAssociatedSection which elevates.")]
        [SecurityCritical]
        internal static EndpointCollectionElement UnsafeGetAssociatedEndpointCollectionElement(ContextInformation evaluationContext, string endpointCollectionName)
        {
            EndpointCollectionElement retVal = null;
            StandardEndpointsSection endpointsSection = (StandardEndpointsSection)ConfigurationHelpers.UnsafeGetAssociatedSection(evaluationContext, ConfigurationStrings.StandardEndpointsSectionPath);

            if (null != endpointsSection)
            {
                endpointsSection.UpdateEndpointSections(evaluationContext);
                try
                {
                    retVal = (EndpointCollectionElement)endpointsSection[endpointCollectionName];
                }
                catch (KeyNotFoundException)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigEndpointExtensionNotFound,
                        ConfigurationHelpers.GetEndpointsSectionPath(endpointCollectionName))));
                }
                catch (NullReferenceException) // System.Configuration.ConfigurationElement bug
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new ConfigurationErrorsException(SR.GetString(SR.ConfigEndpointExtensionNotFound,
                        ConfigurationHelpers.GetEndpointsSectionPath(endpointCollectionName))));
                }
            }

            return retVal;
        }

        /// Be sure to update UnsafeGetAssociatedSection if you modify this method
        internal static object GetAssociatedSection(ContextInformation evalContext, string sectionPath)
        {
            object retval = null;
            if (evalContext != null)
            {
                retval = evalContext.GetSection(sectionPath);
            }
            else
            {
                retval = AspNetEnvironment.Current.GetConfigurationSection(sectionPath);

                // Trace after call to underlying configuration system to
                // insure that configuration system is initialized
                if (DiagnosticUtility.ShouldTraceVerbose)
                {
                    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.GetConfigurationSection,
                        SR.GetString(SR.TraceCodeGetConfigurationSection),
                        new StringTraceRecord("ConfigurationSection", sectionPath), null, null);
                }
            }
            if (retval == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                    new ConfigurationErrorsException(SR.GetString(SR.ConfigSectionNotFound,
                    sectionPath)));
            }
            return retval;
        }

        // Be sure to update GetAssociatedSection if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical methods which elevate.")]
        [SecurityCritical]
        internal static object UnsafeGetAssociatedSection(ContextInformation evalContext, string sectionPath)
        {
            object retval = null;
            if (evalContext != null)
            {
                retval = UnsafeGetSectionFromContext(evalContext, sectionPath);
            }
            else
            {
                retval = AspNetEnvironment.Current.UnsafeGetConfigurationSection(sectionPath);

                // Trace after call to underlying configuration system to
                // insure that configuration system is initialized
                if (DiagnosticUtility.ShouldTraceVerbose)
                {
                    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.GetConfigurationSection,
                        SR.GetString(SR.TraceCodeGetConfigurationSection),
                        new StringTraceRecord("ConfigurationSection", sectionPath), null, null);
                }
            }
            if (retval == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                    new ConfigurationErrorsException(SR.GetString(SR.ConfigSectionNotFound,
                    sectionPath)));
            }

            return retval;
        }

        /// Be sure to update UnsafeGetBindingCollectionElement if you modify this method
        internal static BindingCollectionElement GetBindingCollectionElement(string bindingCollectionName)
        {
            return GetAssociatedBindingCollectionElement(null, bindingCollectionName);
        }

        // Be sure to update GetBindingCollectionElement if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical method UnsafeGetAssociatedBindingCollectionElement which elevates.")]
        [SecurityCritical]
        internal static BindingCollectionElement UnsafeGetBindingCollectionElement(string bindingCollectionName)
        {
            return UnsafeGetAssociatedBindingCollectionElement(null, bindingCollectionName);
        }

        internal static string GetBindingsSectionPath(string sectionName)
        {
            return string.Concat(ConfigurationStrings.BindingsSectionGroupPath, "/", sectionName);
        }

        internal static string GetEndpointsSectionPath(string sectionName)
        {
            return string.Concat(ConfigurationStrings.StandardEndpointsSectionName, "/", sectionName);
        }

        /// Be sure to update UnsafeGetEndpointCollectionElement if you modify this method
        internal static EndpointCollectionElement GetEndpointCollectionElement(string endpointCollectionName)
        {
            return GetAssociatedEndpointCollectionElement(null, endpointCollectionName);
        }

        // Be sure to update GetEndpointCollectionElement if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical method UnsafeGetAssociatedEndpointCollectionElement which elevates.")]
        [SecurityCritical]
        internal static EndpointCollectionElement UnsafeGetEndpointCollectionElement(string endpointCollectionName)
        {
            return UnsafeGetAssociatedEndpointCollectionElement(null, endpointCollectionName);
        }

        /// Be sure to update UnsafeGetSection if you modify this method
        internal static object GetSection(string sectionPath)
        {
            return GetAssociatedSection(null, sectionPath);
        }

        // Be sure to update GetSection if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical method UnsafeGetAssociatedSection which elevates.")]
        [SecurityCritical]
        internal static object UnsafeGetSection(string sectionPath)
        {
            return UnsafeGetAssociatedSection(null, sectionPath);
        }

        // Be sure to update UnsafeGetSection if you modify this method
        [Fx.Tag.SecurityNote(Critical = "Uses SecurityCritical method UnsafeGetAssociatedSection which elevates.")]
        [SecurityCritical]
        internal static object UnsafeGetSectionNoTrace(string sectionPath)
        {
            object retval = AspNetEnvironment.Current.UnsafeGetConfigurationSection(sectionPath);

            if (retval == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                    new ConfigurationErrorsException(SR.GetString(SR.ConfigSectionNotFound,
                    sectionPath)));
            }

            return retval;
        }

        [Fx.Tag.SecurityNote(Critical = "Asserts ConfigurationPermission in order to fetch config from ContextInformation,"
            + "caller must guard return value.")]
        [SecurityCritical]
        [ConfigurationPermission(SecurityAction.Assert, Unrestricted = true)]
        internal static object UnsafeGetSectionFromContext(ContextInformation evalContext, string sectionPath)
        {
            return evalContext.GetSection(sectionPath);
        }

        internal static string GetSectionPath(string sectionName)
        {
            return string.Concat(ConfigurationStrings.SectionGroupName, "/", sectionName);
        }

        [Fx.Tag.SecurityNote(Critical = "Calls SetIsPresentWithAssert which elevates in order to set a property."
            + "Caller must guard ConfigurationElement parameter, ie only pass 'this'.")]
        [SecurityCritical]
        internal static void SetIsPresent(ConfigurationElement element)
        {
            // Work around for VSW 578830: ConfigurationElements that override DeserializeElement cannot set ElementInformation.IsPresent
            PropertyInfo elementPresent = element.GetType().GetProperty("ElementPresent", BindingFlags.Instance | BindingFlags.NonPublic);
            SetIsPresentWithAssert(elementPresent, element, true);
        }

        [Fx.Tag.SecurityNote(Critical = "Asserts full trust in order to set a private member in the ConfigurationElement."
            + "Caller must guard parameters.")]
        [SecurityCritical]
        [PermissionSet(SecurityAction.Assert, Unrestricted = true)]
        static void SetIsPresentWithAssert(PropertyInfo elementPresent, ConfigurationElement element, bool value)
        {
            elementPresent.SetValue(element, value, null);
        }

        internal static ContextInformation GetEvaluationContext(IConfigurationContextProviderInternal provider)
        {
            if (provider != null)
            {
                try
                {
                    return provider.GetEvaluationContext();
                }
                catch (ConfigurationErrorsException)
                {
                }
            }
            return null;
        }

        [Fx.Tag.SecurityNote(Miscellaneous = "RequiresReview - The return value will be used for a security decision. if in doubt about the return value, "
            + "it is safe to return null (caller will assume the worst case from a security perspective).")]
        internal static ContextInformation GetOriginalEvaluationContext(IConfigurationContextProviderInternal provider)
        {
            if (provider != null)
            {
                // provider may not need this try/catch, but it doesn't hurt to do it
                try
                {
                    return provider.GetOriginalEvaluationContext();
                }
                catch (ConfigurationErrorsException)
                {
                }
            }
            return null;
        }

        internal static void TraceExtensionTypeNotFound(ExtensionElement extensionElement)
        {
            if (DiagnosticUtility.ShouldTraceWarning)
            {
                Dictionary<string, string> values = new Dictionary<string, string>(2);
                values.Add("ExtensionName", extensionElement.Name);
                values.Add("ExtensionType", extensionElement.Type);

                DictionaryTraceRecord traceRecord = new DictionaryTraceRecord(values);
                TraceUtility.TraceEvent(TraceEventType.Warning,
                    TraceCode.ExtensionTypeNotFound,
                    SR.GetString(SR.TraceCodeExtensionTypeNotFound),
                    traceRecord,
                    null,
                    (Exception)null);
            }
        }
    }

    interface IConfigurationContextProviderInternal
    {
        /// <summary>
        /// return the current ContextInformation (the protected property ConfigurationElement.EvaluationContext)
        /// this may throw ConfigurationErrorsException, caller should guard (see ConfigurationHelpers.GetEvaluationContext)
        /// </summary>
        /// <returns>result of ConfigurationElement.EvaluationContext</returns>
        ContextInformation GetEvaluationContext();

        /// <summary>
        /// return the ContextInformation that was present when the ConfigurationElement was first deserialized.
        /// if Reset was called, this will be the value of parent.GetOriginalEvaluationContext()
        /// if Reset was not called, this will be the value of this.GetEvaluationContext()
        /// </summary>
        /// <returns>result of parent's ConfigurationElement.EvaluationContext</returns>
        [Fx.Tag.SecurityNote(Miscellaneous =
            "RequiresReview - the return value will be used for a security decision. if in doubt about the return value, it "
            + "is safe (from a security perspective)  to return null (caller will assume the worst case).")]
        ContextInformation GetOriginalEvaluationContext();
    }

    [Fx.Tag.SecurityNote(Critical = "Stores information used in a security decision.")]
#pragma warning disable 618 // have not moved to the v4 security model yet
    [SecurityCritical(SecurityCriticalScope.Everything)]
#pragma warning restore 618
    struct EvaluationContextHelper
    {
        bool reset;
        ContextInformation inheritedContext;

        internal void OnReset(ConfigurationElement parent)
        {
            this.reset = true;
            this.inheritedContext = ConfigurationHelpers.GetOriginalEvaluationContext(parent as IConfigurationContextProviderInternal);
        }

        internal ContextInformation GetOriginalContext(IConfigurationContextProviderInternal owner)
        {
            if (this.reset)
            {
                // if reset, inherited context is authoritative, even if null
                return this.inheritedContext;
            }
            else
            {
                // otherwise use current
                return ConfigurationHelpers.GetEvaluationContext(owner);
            }
        }
    }
}
                                                        cate\
cate¿
cateæ
cate ·Î
cate ﬂ=
catc”
catc¸
catcΩ
cat_¡
cat_¿
cat_ø
cat_æ
cat_Ω
cat_º
cat_ª
cat_∫
cat_π
cat_∏
cat_∑
cat_∂
cat_µ
cat_¥
cat_≥
cat_≤
cat_±
cat_∞
cat_Ø
cat_Æ
cat_≠
cat_¨
cat_´
cast[2
cast/ˆ
cast/Û
castÔ
castÈ
castÎ|
castÎN
castúˆ
castáÕ
castá√
castá¿
castS„
cast@ò
cast@î
cast@ê
cast//------------------------------------------------------------------------------
// <copyright file="IServerConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Configuration {

    using System.Configuration;
    using System.Collections;
    using System.Globalization;
    using System.Text;
    using System.Web.Util;
    using System.Web.Hosting;
    using System.Web.Caching;
    using Microsoft.Win32;

    // Config functions used by ASP.NET.
    interface IServerConfig {
        // if appHost is null, the site for the current application will be used to map the path -- this is probably what you want
        string     MapPath(IApplicationHost appHost, VirtualPath path);
        string     GetSiteNameFromSiteID(string siteID);
        bool       GetUncUser(IApplicationHost appHost, VirtualPath path, out string username, out string password);
        string[]   GetVirtualSubdirs(VirtualPath path, bool inApp);
        long       GetW3WPMemoryLimitInKB();
    }
}

                                                                                                                                                                                                                                                                                                                                                                                                        âcLãd$ HãÉ·H	¡HâHâXIãD$É‡H	ÿIâD$H«Ñ$‡       Lâ¨$Ë   «Ñ$ÿ      HâﬂHãt$`Hçî$ÿ   Ë    Hã¥$®   HÖˆtLâ˜Ë    Hã\$Iãt$HÉÊ¯Hãl$(tˆuF∑F.HâÒ®tHâÒD  Hã	HÉ·¯ˆA.uÛHãT$@Hâ
HãL$0Hã9HÖˆt#®t7HãÉ‡HÖ¿tÎ*HãD$@Hâ0HãD$0Hã8Î®tÄ    Hã6HÉÊ¯ˆF.uÛHãˇêÄ   IcL$0HãShD H«Ñ$®       HãÉ0  HãL$HãtH¡ÊHpMçt$Mçl$Iã|$8Hâ|$@1…LâÂLç§$®   Lâ‚Ë    Hâ√LâÔHâ∆Ë    HãEHÉ‡¯LâsHãÉ·H	¡HâHâXHãEÉ‡H	ÿHâEH«Ñ$‡       HãD$XHâÑ$Ë   «Ñ$ÿ      HâﬂHãt$@Hçî$ÿ   Ë    Hã¥$®   HÖˆtLâÁË    HãD$(HãL$HLç$IÉƒHãD$0Hã8Hã\$ HãsHÉÊ¯Lãl$Dãt$tˆt	ÎHã6HÉÊ¯ˆF.uÛHãˇêÄ   HcK0IãUhD Aã$=D  π˛ˇ ∫˛  D HãSHÉ‚¯tˆtÎÄ    HãHÉ‚¯ˆB.uÛHâî$ÿ   âå$‡   âÑ$‰   Hãº$H  Hç¥$ÿ   Ë    IãΩ0  HãLâ˛ˇêÄ   IãOHcI0IãUh)D LâˇË    ãk0IãÖ@  HãHhH+H`H¡Èç}∞9œÉ±˜ˇˇIãUhâ˚âÓ˜÷ŒDçI˛@ˆ∆uAâ¯âÔA9ÈuÎPãtÍ4Íâ4⁄DçEHÉ√A9Èt9D)¡Hâﬁf.Ñ     êâˇãl˙,˙â,⁄âﬂãl˙,˙âl⁄HÉ∆ç{HâÛÉ¡˛uÿLãl$È5˜ˇˇHãD$0Hã Dâ·H¡·HHIâOHãC HãL$XHãî$–   HâLIãG HãL$`Hãî$†   HâT∞Dãt$ÈÊˆˇˇf.Ñ     D  EÑˆtãÑ$4  É¿âÑ$4  É¯rÈ˚   E1ˆ∞D
¥$à   Ö˝ÿˇˇIãEhI9EptIâEpIãÖÄ   I9Öà   tIâÖà   IãÖÿ   I9Ö‡   tIâÖ‡   Mãµ   Iã≠¯   L9ıt0LâÛf.Ñ     êHã;HÖˇtË    HÉ√H9›uÍLãl$Mâµ¯   IãÖ  I9Ö  tIâÖ  Ä|$o ï√Hãº$ê   HÖˇtË    âÿHÅƒx  [A\A]A^A_]√Iç◊Hçl’ ÈEŒˇˇË    Hç=    æ   Ë    Hç=    æ   Ë    Hç=    Ë            AVSPHâ˚W¿«G   ø   Ë    Iâ∆HÖ¿uHç=    æ   Ë    Lâ3H«C   I«   HâÿHÉƒ[A^√            AVSPHâ˚W¿H«G    «G   ø   Ë    Iâ∆HÖ¿uHç=    æ   Ë    Lâ3H«C   I«    HâÿHÉƒ[A^√    AVSPHâ˚W¿H«G    «G   ø   Ë    Iâ∆HÖ¿uHç=    æ   Ë    Lâ3H«C   I«    HâÿHÉƒ[A^√    UAWAVAUATSPHâ”Iâ˜Iâ˛HwPHãHãWHçHÉ¡ˇHâ›H˜›H!ÈH)¡Hç41H)¬H9÷v`HÉ√ˇNç$;IÅ¸  r]LâÁË    Iâ«HÖ¿uHç=    æ   Ë    AãFHA;FLÉÆ   IãN@â¿H¡‡Lâ<LâdAÉFHL˚H!ÎÎ|H»I«Mâ>Hâ√ÎnAãNHâ$H¡ÈHÉ˘r±Aº   I”‰LâÁË    Iâ≈HÖ¿Hã$uHç=    æ   Ë    AãNA;NsQIãFâ…Lâ,»AÉFMÏMâfLÎH!ÎIﬂMâ>HâÿHÉƒ[A\A]A^A_]√Iç~@Hçw1“π   Ë    AãFHÈ5ˇˇˇIç~Hçw1“π   Ë    AãNÎï            AWAVATSPãNâ Ä¬ˇÄ˙w%Hâ˚∏   ∂“Hç=    HcóH˙ˇ‚∏Ä   È∂   ∏@   È¨   ∏    È¢   ∏P   Èò   1ˆHâﬂÎpH¡ÈHâ»ÈÖ   HâﬂË    Hã H¡‡ÎtLãvLãf HâﬂLâˆË    Iâ«IÉ«I¡ÔHâﬂLâˆË    â∆Jç>HÉ¡ˇ1“Hâ»H˜ˆH)—IØÃH¡·Hâ»Î)¡ÈHâﬂâŒË    ¡‡ÎHãFLãv HâﬂHâ∆Ë    IØ∆HÉƒ[A\A^A_√                                                                    UAWAVAUATSPIâÙIâ˝HãoH;otIÉ≈A$E Iã] HÉ√Èq  Iã} HâËH)¯Iâ∆I¡˛HÖ¿π   IEŒJç1HâÿH¡Ë<H∏ˇˇˇˇˇˇˇHEÿLÒHBÿHÖ€t"Hâ<$H9√á5  HâﬂH¡ÁË    Iâ«Hã<$ÎE1ˇI¡ÊA$C7HâÍMâ˛H)˙ÑÃ   HÉ¬â÷¡ÓÉ∆HÉÊt1H˜ﬁLâ¯Hâ˘f.Ñ     fê HÉ¡HÉ¿HÉ∆uÏHÉ˙psÎvLâ¯Hâ˘HÉ˙prj1“fD  DD//------------------------------------------------------------------------------
// <copyright file="TdsValueSetter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <owner current="true" primary="true">Microsoft</owner>
// <owner current="true" primary="false">Microsoft</owner>
//------------------------------------------------------------------------------


namespace System.Data.SqlClient {

    using Microsoft.SqlServer.Server;
    using System;
    using System.Data;
    using System.Data.Common;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Text;

    using MSS = Microsoft.SqlServer.Server;

    // TdsValueSetter handles writing a single value out to a TDS stream
    //   This class can easily be extended to handle multiple versions of TDS by sub-classing and virtualizing
    //   methods that have different formats or are not supported in one or the other version.
    internal class TdsValueSetter {
        #region Private fields

        private TdsParserStateObject    _stateObj;      // target to write to
        private SmiMetaData             _metaData;      // metadata describing value
        private bool                    _isPlp;         // should this column be sent in PLP format?
        private bool                    _plpUnknownSent;// did we send initial UNKNOWN_LENGTH marker?
        private Encoder                 _encoder;       // required for chunking character type data
        private SmiMetaData             _variantType;   // required for sql_variant
#if DEBUG
        private int                     _currentOffset; // for chunking, verify that caller is using correct offsets
#endif

        #endregion

        #region Exposed Construct/factory methods

        internal TdsValueSetter(TdsParserStateObject stateObj, SmiMetaData md) {
            _stateObj = stateObj;
            _metaData = md;
            _isPlp = MetaDataUtilsSmi.IsPlpFormat(md);
            _plpUnknownSent = false;
            _encoder = null;
#if DEBUG
            _currentOffset = 0;
#endif
        }

        #endregion

        #region Setters

        // Set value to null
        //  valid for all types
        internal void SetDBNull() {
            Debug.Assert(!_plpUnknownSent, "Setting a column to null that we already stated sending!");
            if (_isPlp) {
                _stateObj.Parser.WriteUnsignedLong(TdsEnums.SQL_PLP_NULL, _stateObj);
            }
            else {
                switch(_metaData.SqlDbType) {
                    case SqlDbType.BigInt:
                    case SqlDbType.Bit:
                    case SqlDbType.DateTime:
                    case SqlDbType.Decimal:
                    case SqlDbType.Float:
                    case SqlDbType.Int:
                    case SqlDbType.Money:
                    case SqlDbType.Real:
                    case SqlDbType.UniqueIdentifier:
                    case SqlDbType.SmallDateTime:
                    case SqlDbType.SmallInt:
                    case SqlDbType.SmallMoney:
                    case SqlDbType.TinyInt:
                    case SqlDbType.Date:
                    case SqlDbType.Time:
                    case SqlDbType.DateTime2:
                    case SqlDbType.DateTimeOffset:
                        _stateObj.WriteByte(TdsEnums.FIXEDNULL);
                        break;
                    case SqlDbType.Binary:
                    case SqlDbType.Char:
                    case SqlDbType.Image:
                    case SqlDbType.NChar:
                    case SqlDbType.NText:
                    case SqlDbType.NVarChar:
                    case SqlDbType.Text:
                    case SqlDbType.Timestamp:
                    case SqlDbType.VarBinary:
                    case SqlDbType.VarChar:
                        _stateObj.Parser.WriteShort(TdsEnums.VARNULL, _stateObj);
                        break;
                    case SqlDbType.Udt:
                    case SqlDbType.Xml:
                        Debug.Assert(false, "PLP-only types shouldn't get to this point. Type: " + _metaData.SqlDbType);
                        break;
                    case SqlDbType.Variant:
                        _stateObj.Parser.WriteInt(TdsEnums.FIXEDNULL, _stateObj);
                        break;
                    case SqlDbType.Structured:
                        Debug.Assert(false, "Not yet implemented.  Not needed until Structured UDTs");
                        break;
                    default:
                        Debug.Assert(false, "Unexpected SqlDbType: " + _metaData.SqlDbType);
                        break;
                }
            }
        }

        //  valid for SqlDbType.Bit
        internal void SetBoolean(Boolean value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetBoolean));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(3, TdsEnums.SQLBIT, 0, _stateObj);
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            if (value) {
                _stateObj.WriteByte(1);
            }
            else {
                _stateObj.WriteByte(0);
            }
        }

        //  valid for SqlDbType.TinyInt
        internal void SetByte(Byte value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetByte));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(3, TdsEnums.SQLINT1, 0, _stateObj);
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            _stateObj.WriteByte(value);
        }

        // Semantics for SetBytes are to modify existing value, not overwrite
        //  Use in combination with SetLength to ensure overwriting when necessary
        // valid for SqlDbTypes: Binary, VarBinary, Image, Udt, Xml
        //      (VarBinary assumed for variants)
        internal int SetBytes(long fieldOffset, byte[] buffer, int bufferOffset, int length) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetBytes));
            CheckSettingOffset(fieldOffset);

            SetBytesNoOffsetHandling(fieldOffset, buffer, bufferOffset, length);
#if DEBUG
            _currentOffset += length;
#endif
            return length;
        }

        private void SetBytesNoOffsetHandling(long fieldOffset, byte[] buffer, int bufferOffset, int length) {
            if (_isPlp) {
                if (!_plpUnknownSent) {
                    _stateObj.Parser.WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN, _stateObj);
                    _plpUnknownSent = true;
                }

                // Write chunk length & chunk
                _stateObj.Parser.WriteInt(length, _stateObj);
                _stateObj.WriteByteArray(buffer, length, bufferOffset);
            }
            else {
                // Non-plp data must be sent in one chunk for now.
#if DEBUG
                Debug.Assert(0 == _currentOffset, "SetBytes doesn't yet support chunking for non-plp data: " + _currentOffset);

#endif
                Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType, _metaData.IsMultiValued).IsLong,
                    "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);

                if (SqlDbType.Variant == _metaData.SqlDbType) {
                    _stateObj.Parser.WriteSqlVariantHeader(4 + length, TdsEnums.SQLBIGVARBINARY, 2, _stateObj);
                }
                _stateObj.Parser.WriteShort(length, _stateObj);
                _stateObj.WriteByteArray(buffer, length, bufferOffset);
            }
        }

        internal void SetBytesLength(long length) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetBytes));
            CheckSettingOffset(length);

            if (0 == length) {
                if (_isPlp) {
                    Debug.Assert(!_plpUnknownSent, "A plpUnknown has already been sent before setting length to zero.");

                    _stateObj.Parser.WriteLong(0, _stateObj);
                    _plpUnknownSent = true;
                }
                else {
                    Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType, _metaData.IsMultiValued).IsLong,
                        "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);

                    if (SqlDbType.Variant == _metaData.SqlDbType) {
                        _stateObj.Parser.WriteSqlVariantHeader(4, TdsEnums.SQLBIGVARBINARY, 2, _stateObj);
                    }
                    _stateObj.Parser.WriteShort(0, _stateObj);
                }
            }
            if (_plpUnknownSent) {
                _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR, _stateObj);
                _plpUnknownSent = false;
            }

#if DEBUG
            //
            _currentOffset = 0;
#endif
        }

        // Semantics for SetChars are to modify existing value, not overwrite
        //  Use in combination with SetLength to ensure overwriting when necessary
        // valid for character types: Char, VarChar, Text, NChar, NVarChar, NText
        //      (NVarChar and global clr collation assumed for variants)
        internal int SetChars(long fieldOffset, char[] buffer, int bufferOffset, int length) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetChars));

            // ANSI types must convert to byte[] because that's the tool we have.
            if (MetaDataUtilsSmi.IsAnsiType(_metaData.SqlDbType)) {
                if (null == _encoder) {
                    _encoder = _stateObj.Parser._defaultEncoding.GetEncoder();
                }
                byte[] bytes = new byte[_encoder.GetByteCount(buffer, bufferOffset, length, false)];
                _encoder.GetBytes(buffer, bufferOffset, length, bytes, 0, false);
                SetBytesNoOffsetHandling(fieldOffset, bytes, 0, bytes.Length);
            }
            else {
                CheckSettingOffset(fieldOffset);

                // Send via PLP format if we can.
                if (_isPlp) {

                    // Handle initial PLP markers
                    if (!_plpUnknownSent) {
                        _stateObj.Parser.WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN, _stateObj);
                        _plpUnknownSent = true;
                    }

                    // Write chunk length
                    _stateObj.Parser.WriteInt(length*ADP.CharSize, _stateObj);
                    _stateObj.Parser.WriteCharArray(buffer, length, bufferOffset, _stateObj);
                }
                else {
                    // Non-plp data must be sent in one chunk for now.
#if DEBUG
                    Debug.Assert(0 == _currentOffset, "SetChars doesn't yet support chunking for non-plp data: " + _currentOffset);
#endif

                    if (SqlDbType.Variant == _metaData.SqlDbType) {
                        _stateObj.Parser.WriteSqlVariantValue(new String(buffer, bufferOffset, length), length, 0, _stateObj);
                    }
                    else {
                        Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType, _metaData.IsMultiValued).IsLong,
                                "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);
                        _stateObj.Parser.WriteShort(length*ADP.CharSize, _stateObj);
                        _stateObj.Parser.WriteCharArray(buffer, length, bufferOffset, _stateObj);
                    }
                }
            }

#if DEBUG
            _currentOffset += length;
#endif
            return length;
        }
        internal void SetCharsLength(long length) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetChars));
            CheckSettingOffset(length);

            if (0 == length) {
                if (_isPlp) {
                    Debug.Assert(!_plpUnknownSent, "A plpUnknown has already been sent before setting length to zero.");

                    _stateObj.Parser.WriteLong(0, _stateObj);
                    _plpUnknownSent = true;
                }
                else {
                    Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType, _metaData.IsMultiValued).IsLong,
                        "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);

                    _stateObj.Parser.WriteShort(0, _stateObj);
                }
            }
            if (_plpUnknownSent) {
                _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR, _stateObj);
                _plpUnknownSent = false;
            }
            _encoder = null;

#if DEBUG
            //
            _currentOffset = 0;
#endif
        }

        // valid for character types: Char, VarChar, Text, NChar, NVarChar, NText
        internal void SetString(string value, int offset, int length) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetString));

            // ANSI types must convert to byte[] because that's the tool we have.
            if (MetaDataUtilsSmi.IsAnsiType(_metaData.SqlDbType)) {
                byte[] bytes;
                // Optimize for common case of writing entire string
                if (offset == 0 && value.Length <= length) {
                    bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);
                }
                else {
                    char[] chars = value.ToCharArray(offset, length);
                    bytes = _stateObj.Parser._defaultEncoding.GetBytes(chars);
                }
                SetBytes(0, bytes, 0, bytes.Length);
                SetBytesLength(bytes.Length);
            }
            else if (SqlDbType.Variant == _metaData.SqlDbType) {
                Debug.Assert(null != _variantType && SqlDbType.NVarChar == _variantType.SqlDbType, "Invalid variant type");

                SqlCollation collation = new SqlCollation();
                collation.LCID = checked((int)_variantType.LocaleId);
                collation.SqlCompareOptions = _variantType.CompareOptions;

                if (length * ADP.CharSize > TdsEnums.TYPE_SIZE_LIMIT) { // send as varchar for length greater than 4000
                    byte[] bytes;
                    // Optimize for common case of writing entire string
                    if (offset == 0 && value.Length <= length) {
                        bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);
                    }
                    else {
                        bytes = _stateObj.Parser._defaultEncoding.GetBytes(value.ToCharArray(offset, length));
                    }
                    _stateObj.Parser.WriteSqlVariantHeader(9 + bytes.Length, TdsEnums.SQLBIGVARCHAR, 7, _stateObj);
                    _stateObj.Parser.WriteUnsignedInt(collation.info, _stateObj); // propbytes: collation.Info
                    _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId
                    _stateObj.Parser.WriteShort(bytes.Length, _stateObj); // propbyte: varlen
                    _stateObj.WriteByteArray(bytes, bytes.Length, 0);
                }
                else {
                    _stateObj.Parser.WriteSqlVariantHeader(9 + length * ADP.CharSize, TdsEnums.SQLNVARCHAR, 7, _stateObj);
                    _stateObj.Parser.WriteUnsignedInt(collation.info, _stateObj); // propbytes: collation.Info
                    _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId
                    _stateObj.Parser.WriteShort(length * ADP.CharSize, _stateObj); // propbyte: varlen
                    _stateObj.Parser.WriteString(value, length, offset, _stateObj);
                }
                _variantType = null;
            }
            else if (_isPlp) {
                // Send the string as a complete PLP chunk.
                _stateObj.Parser.WriteLong(length*ADP.CharSize, _stateObj);  // PLP total length
                _stateObj.Parser.WriteInt(length*ADP.CharSize, _stateObj);   // Chunk length
                _stateObj.Parser.WriteString(value, length, offset, _stateObj);  // Data
                if (length != 0) {
                    _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR, _stateObj); // Terminator
                }
            }
            else {
                _stateObj.Parser.WriteShort(length*ADP.CharSize, _stateObj);
                _stateObj.Parser.WriteString(value, length, offset, _stateObj);
            }
        }

        // valid for SqlDbType.SmallInt
        internal void SetInt16(Int16 value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetInt16));

            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(4, TdsEnums.SQLINT2, 0, _stateObj);
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            _stateObj.Parser.WriteShort(value, _stateObj);
        }

        // valid for SqlDbType.Int
        internal void SetInt32(Int32 value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetInt32));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(6, TdsEnums.SQLINT4, 0, _stateObj);
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            _stateObj.Parser.WriteInt(value, _stateObj);
        }

        // valid for SqlDbType.BigInt, SqlDbType.Money, SqlDbType.SmallMoney
        internal void SetInt64(Int64 value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetInt64));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                if (null == _variantType) {
                    _stateObj.Parser.WriteSqlVariantHeader(10, TdsEnums.SQLINT8, 0, _stateObj);
                    _stateObj.Parser.WriteLong(value, _stateObj);
                }
                else {
                    Debug.Assert(SqlDbType.Money == _variantType.SqlDbType, "Invalid variant type");

                    _stateObj.Parser.WriteSqlVariantHeader(10, TdsEnums.SQLMONEY, 0, _stateObj);
                    _stateObj.Parser.WriteInt((int)(value >> 0x20), _stateObj);
                    _stateObj.Parser.WriteInt((int)value, _stateObj);
                    _variantType = null;
                }
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
                if (SqlDbType.SmallMoney == _metaData.SqlDbType) {
                    _stateObj.Parser.WriteInt((int)value, _stateObj);
                }
                else if (SqlDbType.Money == _metaData.SqlDbType) {
                    _stateObj.Parser.WriteInt((int)(value >> 0x20), _stateObj);
                    _stateObj.Parser.WriteInt((int)value, _stateObj);
                }
                else {
                    _stateObj.Parser.WriteLong(value, _stateObj);
                }
            }
        }

        // valid for SqlDbType.Real
        internal void SetSingle(Single value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetSingle));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(6, TdsEnums.SQLFLT4, 0, _stateObj);
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            _stateObj.Parser.WriteFloat(value, _stateObj);
        }

        // valid for SqlDbType.Float
        internal void SetDouble(Double value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetDouble));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(10, TdsEnums.SQLFLT8, 0, _stateObj);
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            _stateObj.Parser.WriteDouble(value, _stateObj);
        }

        // valid for SqlDbType.Numeric (uses SqlDecimal since Decimal cannot hold full range)
        internal void SetSqlDecimal(SqlDecimal value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetSqlDecimal));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(21, TdsEnums.SQLNUMERICN, 2, _stateObj);
                _stateObj.WriteByte(value.Precision); // propbytes: precision
                _stateObj.WriteByte(value.Scale); // propbytes: scale
                _stateObj.Parser.WriteSqlDecimal(value, _stateObj);
            }
            else {
                _stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength)); // SmiMetaData's length and actual wire format's length are different
                _stateObj.Parser.WriteSqlDecimal(SqlDecimal.ConvertToPrecScale(value, _metaData.Precision, _metaData.Scale), _stateObj);
            }
        }

        // valid for DateTime, SmallDateTime, Date, DateTime2
        internal void SetDateTime(DateTime value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetDateTime));
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.DateTime2))
                {
                    _stateObj.Parser.WriteSqlVariantDateTime2(value, _stateObj);
                }
                else if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.Date))
                {
                    _stateObj.Parser.WriteSqlVariantDate(value, _stateObj);
                }
                else
                {
                    TdsDateTime dt = MetaType.FromDateTime(value, 8);
                    _stateObj.Parser.WriteSqlVariantHeader(10, TdsEnums.SQLDATETIME, 0, _stateObj);
                    _stateObj.Parser.WriteInt(dt.days, _stateObj);
                    _stateObj.Parser.WriteInt(dt.time, _stateObj);
                }

                // Clean the variant metadata to prevent sharing it with next row. 
                // As a reminder, SetVariantType raises an assert if _variantType is not clean
                _variantType = null;
                
            }
            else {
                _stateObj.WriteByte((byte)_metaData.MaxLength);
                if (SqlDbType.SmallDateTime == _metaData.SqlDbType) {
                    TdsDateTime dt = MetaType.FromDateTime(value, (byte)_metaData.MaxLength);
                    Debug.Assert (0 <= dt.days && dt.days <= UInt16.MaxValue, "Invalid DateTime '" + value + "' for SmallDateTime");

                    _stateObj.Parser.WriteShort(dt.days, _stateObj);
                    _stateObj.Parser.WriteShort(dt.time, _stateObj);
                } else if (SqlDbType.DateTime == _metaData.SqlDbType) {
                    TdsDateTime dt = MetaType.FromDateTime(value, (byte)_metaData.MaxLength);
                    _stateObj.Parser.WriteInt(dt.days, _stateObj);
                    _stateObj.Parser.WriteInt(dt.time, _stateObj);
                } else { // date and datetime2
                    int days = value.Subtract(DateTime.MinValue).Days;
                    if (SqlDbType.DateTime2 == _metaData.SqlDbType) {
                        Int64 time = value.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[_metaData.Scale];
                        _stateObj.WriteByteArray(BitConverter.GetBytes(time), (int)_metaData.MaxLength - 3, 0);
                    }
                    _stateObj.WriteByteArray(BitConverter.GetBytes(days), 3, 0);
                }
            }
        }

        // valid for UniqueIdentifier
        internal void SetGuid(Guid value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetGuid));

            byte[] bytes = value.ToByteArray();
            Debug.Assert(SmiMetaData.DefaultUniqueIdentifier.MaxLength == bytes.Length, "Invalid length for guid bytes: " + bytes.Length);

            if (SqlDbType.Variant == _metaData.SqlDbType) {
                _stateObj.Parser.WriteSqlVariantHeader(18, TdsEnums.SQLUNIQUEID, 0, _stateObj);
            }
            else {
                Debug.Assert(_metaData.MaxLength == bytes.Length, "Unexpected uniqueid metadata length: " + _metaData.MaxLength);

                _stateObj.WriteByte((byte)_metaData.MaxLength);
            }
            _stateObj.WriteByteArray(bytes, bytes.Length, 0);
        }

        // valid for SqlDbType.Time
        internal void SetTimeSpan(TimeSpan value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetTime));
            byte scale;
            byte length;
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                scale = SmiMetaData.DefaultTime.Scale;
                length = (byte)SmiMetaData.DefaultTime.MaxLength;
                _stateObj.Parser.WriteSqlVariantHeader(8, TdsEnums.SQLTIME, 1, _stateObj);
                _stateObj.WriteByte(scale); //propbytes: scale
            } else {
                scale = _metaData.Scale;
                length = (byte)_metaData.MaxLength;
                _stateObj.WriteByte(length);
            }
            Int64 time = value.Ticks / TdsEnums.TICKS_FROM_SCALE[scale];
            _stateObj.WriteByteArray(BitConverter.GetBytes(time), length, 0);
        }

        // valid for DateTimeOffset
        internal void SetDateTimeOffset(DateTimeOffset value) {
            Debug.Assert(
                SmiXetterAccessMap.IsSetterAccessValid(_metaData, SmiXetterTypeCode.XetDateTimeOffset));
            byte scale;
            byte length;
            if (SqlDbType.Variant == _metaData.SqlDbType) {
                // VSTFDevDiv #885208 - DateTimeOffset throws ArgumentException for when passing DateTimeOffset value to a sql_variant TVP 
                //                      using a SqlDataRecord or SqlDataReader
                MSS.SmiMetaData dateTimeOffsetMetaData = MSS.SmiMetaData.DefaultDateTimeOffset;
                scale = MetaType.MetaDateTimeOffset.Scale;
                length = (byte)dateTimeOffsetMetaData.MaxLength;
                _stateObj.Parser.WriteSqlVariantHeader(13, TdsEnums.SQLDATETIMEOFFSET, 1, _stateObj);
                _stateObj.WriteByte(scale); //propbytes: scale
            } else {
                scale = _metaData.Scale;
                length = (byte)_metaData.MaxLength;
                _stateObj.WriteByte(length);
            }
            DateTime utcDateTime = value.UtcDateTime;
            Int64 time = utcDateTime.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[scale];
            int days = utcDateTime.Subtract(DateTime.MinValue).Days;
            Int16 offset = (Int16)value.Offset.TotalMinutes;

            _stateObj.WriteByteArray(BitConverter.GetBytes(time), length - 5, 0); // time
            _stateObj.WriteByteArray(BitConverter.GetBytes(days), 3, 0); // date
            _stateObj.WriteByte((byte)(offset & 0xff)); // offset byte 1
            _stateObj.WriteByte((byte)((offset >> 8) & 0xff)); // offset byte 2
        }

        internal void SetVariantType(SmiMetaData value) {
            Debug.Assert(null == _variantType, "Variant type can only be set once");
            Debug.Assert(value != null &&
                (value.SqlDbType == SqlDbType.Money ||
                value.SqlDbType == SqlDbType.NVarChar ||
                value.SqlDbType == SqlDbType.Date ||
                value.SqlDbType == SqlDbType.DateTime ||
                value.SqlDbType == SqlDbType.DateTime2 ||
                value.SqlDbType == SqlDbType.DateTimeOffset ||
                value.SqlDbType == SqlDbType.SmallDateTime
                ), "Invalid variant type");
            _variantType = value;
        }

        #endregion

        #region private methods
        [Conditional("DEBUG")]
        private void CheckSettingOffset(long offset) {
#if DEBUG
            Debug.Assert(offset == _currentOffset, "Invalid offset passed. Should be: " + _currentOffset + ", but was: " + offset);
#endif
        }
        #endregion
    }
}
                                                                        base_addr, __m128i vindex, __m128i mask, const int scale)VPGATHERQQ xmm, vm64x, xmm</summary>
      <param name="source" />
      <param name="baseAddress" />
      <param name="index" />
      <param name="mask" />
      <param name="scale" />
      <exception cref="T:S