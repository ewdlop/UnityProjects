time string beginning at the given parse position. For
     * example, a time text "07/10/96 4:5 PM, PDT" will be parsed into a Date
     * that is equivalent to Date(837039928046).
     * <P>
     * By default, parsing is lenient: If the input is not in the form used by
     * this object's format method but can still be parsed as a date, then the
     * parse succeeds. Clients may insist on strict adherence to the format by
     * calling setLenient(false).
     * @see DateFormat::setLenient(boolean)
     * <P>
     * Note that the normal date formats associated with some calendars - such
     * as the Chinese lunar calendar - do not specify enough fields to enable
     * dates to be parsed unambiguously. In the case of the Chinese lunar
     * calendar, while the year within the current 60-year cycle is specified,
     * the number of such cycles since the start date of the calendar (in the
     * ERA field of the Calendar object) is not normally part of the format,
     * and parsing may assume the wrong era. For cases such as this it is
     * recommended that clients parse using the method
     * parse(const UnicodeString&, Calendar& cal, ParsePosition&)
     * with the Calendar passed in set to the current date, or to a date
     * within the era/cycle that should be assumed if absent in the format.
     *
     * @param text  The date/time string to be parsed into a UDate value.
     * @param pos   On input, the position at which to start parsing; on
     *              output, the position at which parsing terminated, or the
     *              start position if the parse failed.
     * @return      A valid UDate if the input could be parsed.
     * @stable ICU 2.0
     */
    UDate parse( const UnicodeString& text,
                 ParsePosition& pos) const;

    /**
     * Parse a string to produce an object. This methods handles parsing of
     * date/time strings into Formattable objects with UDate types.
     * <P>
     * Before calling, set parse_pos.index to the offset you want to start
     * parsing at in the source. After calling, parse_pos.index is the end of
     * the text you parsed. If error occurs, index is unchanged.
     * <P>
     * When parsing, leading whitespace is discarded (with a successful parse),
     * while trailing whitespace is left as is.
     * <P>
     * See Format::parseObject() for more.
     *
     * @param source    The string to be parsed into an object.
     * @param result    Formattable to be set to the parse result.
     *                  If parse fails, return contents are undefined.
     * @param parse_pos The position to start parsing at. Upon return
     *                  this param is set to the position after the
     *                  last character successfully parsed. If the
     *                  source is not parsed successfully, this param
     *                  will remain unchanged.
     * @stable ICU 2.0
     */
    virtual void parseObject(const UnicodeString& source,
                             Formattable& result,
                             ParsePosition& parse_pos) const;

    /**
     * Create a default date/time formatter that uses the SHORT style for both
     * the date and the time.
     *
     * @return A date/time formatter which the caller owns.
     * @stable ICU 2.0
     */
    static DateFormat* U_EXPORT2 createInstance(void);

    /**
     * Creates a time formatter with the given formatting style for the given
     * locale.
     *
     * @param style     The given formatting style. For example,
     *                  SHORT for "h:mm a" in the US locale. Relative
     *                  time styles are not currently supported.
     * @param aLocale   The given locale.
     * @return          A time formatter which the caller owns.
     * @stable ICU 2.0
     */
    static DateFormat* U_EXPORT2 createTimeInstance(EStyle style = kDefault,
                                          const Locale& aLocale = Locale::getDefault());

    /**
     * Creates a date formatter with the given formatting style for the given
     * const locale.
     *
     * @param style     The given formatting style. For example, SHORT for "M/d/yy" in the
     *                  US locale. As currently implemented, relative date formatting only
     *                  affects a limited range of calendar days before or after the
     *                  current date, based on the CLDR &lt;field type="day"&gt;/&lt;relative&gt; data:
     *                  For example, in English, "Yesterday", "Today", and "Tomorrow".
     *                  Outside of this range, dates are formatted using the corresponding
     *                  non-relative style.
     * @param aLocale   The given locale.
     * @return          A date formatter which the caller owns.
     * @stable ICU 2.0
     */
    static DateFormat* U_EXPORT2 createDateInstance(EStyle style = kDefault,
                                          const Locale& aLocale = Locale::getDefault());

    /**
     * Creates a date/time formatter with the given formatting styles for the
     * given locale.
     *
     * @param dateStyle The given formatting style for the date portion of the result.
     *                  For example, SHORT for "M/d/yy" in the US locale. As currently
     *                  implemented, relative date formatting only affects a limited range
     *                  of calendar days before or after the current date, based on the
     *                  CLDR &lt;field type="day"&gt;/&lt;relative&gt; data: For example, in English,
     *                  "Yesterday", "Today", and "Tomorrow". Outside of this range, dates
     *                  are formatted using the corresponding non-relative style.
     * @param timeStyle The given formatting style for the time portion of the result.
     *                  For example, SHORT for "h:mm a" in the US locale. Relative
     *                  time styles are not currently supported.
     * @param aLocale   The given locale.
     * @return          A date/time formatter which the caller owns.
     * @stable ICU 2.0
     */
    static DateFormat* U_EXPORT2 createDateTimeInstance(EStyle dateStyle = kDefault,
                                              EStyle timeStyle = kDefault,
                                              const Locale& aLocale = Locale::getDefault());

    /**
     * Gets the set of locales for which DateFormats are installed.
     * @param count Filled in with the number of locales in the list that is returned.
     * @return the set of locales for which DateFormats are installed.  The caller
     *  does NOT own this list and must not delete it.
     * @stable ICU 2.0
     */
    static const Locale* U_EXPORT2 getAvailableLocales(int32_t& count);

    /**
     * Returns whether both date/time parsing in the encapsulated Calendar object and DateFormat whitespace &
     * numeric processing is lenient.
     * @stable ICU 2.0
     */
    virtual UBool isLenient(void) const;

    /**
     * Specifies whether date/time parsing is to be lenient.  With
     * lenient parsing, the parser may use heuristics to interpret inputs that
     * do not precisely match this object's format.  Without lenient parsing,
     * inputs must match this object's format more closely.
     * 
     * Note: ICU 53 introduced finer grained control of leniency (and added 
     * new control points) making the preferred method a combination of 
     * setCalendarLenient() & setBooleanAttribute() calls. 
     * This method supports prior functionality but may not support all 
     * future leniency control & behavior of DateFormat. For control of pre 53 leniency,  
     * Calendar and DateFormat whitespace & numeric tolerance, this method is safe to 
     * use. However, mixing leniency control via this method and modification of the 
     * newer attributes via setBooleanAttribute() may produce undesirable 
     * results.
     *
     * @param lenient  True specifies date/time interpretation to be lenient.
     * @see Calendar::setLenient
     * @stable ICU 2.0     
     */
    virtual void setLenient(UBool lenient);


    /* Cannot use #ifndef U_HIDE_DRAFT_API for the following draft method since it is virtual */
    /**
     * Returns whether date/time parsing in the encapsulated Calendar object processing is lenient.
     * @draft ICU 53
     */
    virtual UBool isCalendarLenient(void) const;


    /* Cannot use #ifndef U_HIDE_DRAFT_API for the following draft method since it is virtual */
    /**
     * Specifies whether encapsulated Calendar date/time parsing is to be lenient.  With
     * lenient parsing, the parser may use heuristics to interpret inputs that
     * do not precisely match this object's format.  Without lenient parsing,
     * inputs must match this object's format more closely.
     * @param lenient when true, parsing is lenient
     * @see com.ibm.icu.util.Calendar#setLenient
     * @draft ICU 53
     */
    virtual void setCalendarLenient(UBool lenient);


    /**
     * Gets the calendar associated with this date/time formatter.
     * The calendar is owned by the formatter and must not be modified.
     * Also, the calendar does not reflect the results of a parse operation.
     * To parse to a calendar, use {@link #parse(const UnicodeString&, Calendar& cal, ParsePosition&) const parse(const UnicodeString&, Calendar& cal, ParsePosition&)}
     * @return the calendar associated with this date/time formatter.
     * @stable ICU 2.0
     */
    virtual const Calendar* getCalendar(void) const;

    /**
     * Set the calendar to be used by this date format. Initially, the default
     * calendar for the specified or default locale is used.  The caller should
     * not delete the Calendar object after it is adopted by this call.
     * Adopting a new calendar will change to the default symbols.
     *
     * @param calendarToAdopt    Calendar object to be adopted.
     * @stable ICU 2.0
     */
    virtual void adoptCalendar(Calendar* calendarToAdopt);

    /**
     * Set the calendar to be used by this date format. Initially, the default
     * calendar for the specified or default locale is used.
     *
     * @param newCalendar Calendar object to be set.
     * @stable ICU 2.0
     */
    virtual void setCalendar(const Calendar& newCalendar);


    /**
     * Gets the number formatter which this date/time formatter uses to format
     * and parse the numeric portions of the pattern.
     * @return the number formatter which this date/time formatter uses.
     * @stable ICU 2.0
     */
    virtual const NumberFormat* getNumberFormat(void) const;

    /**
     * Allows you to set the number formatter.  The caller should
     * not delete the NumberFormat object after it is adopted by this call.
     * @param formatToAdopt     NumberFormat object to be adopted.
     * @stable ICU 2.0
     */
    virtual void adoptNumberFormat(NumberFormat* formatToAdopt);

    /**
     * Allows you to set the number formatter.
     * @param newNumberFormat  NumberFormat object to be set.
     * @stable ICU 2.0
     */
    virtual void setNumberFormat(const NumberFormat& newNumberFormat);

    /**
     * Returns a reference to the TimeZone used by this DateFormat's calendar.
     * @return the time zone associated with the calendar of DateFormat.
     * @stable ICU 2.0
     */
    virtual const TimeZone& getTimeZone(void) const;

    /**
     * Sets the time zone for the calendar of this DateFormat object. The caller
     * no longer owns the TimeZone object and should not delete it after this call.
     * @param zoneToAdopt the TimeZone to be adopted.
     * @stable ICU 2.0
     */
    virtual void adoptTimeZone(TimeZone* zoneToAdopt);

    /**
     * Sets the time zone for the calendar of this DateFormat object.
     * @param zone the new time zone.
     * @stable ICU 2.0
     */
    virtual void setTimeZone(const TimeZone& zone);

    /* Cannot use #ifndef U_HIDE_DRAFT_API for the following draft method since it is virtual */
    /**
     * Set a particular UDisplayContext value in the formatter, such as
     * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
     * @param value The UDisplayContext value to set.
     * @param status Input/output status. If at entry this indicates a failure
     *               status, the function will do nothing; otherwise this will be
     *               updated with any new status from the function. 
     * @draft ICU 53
     */
    virtual void setContext(UDisplayContext value, UErrorCode& status);

    /* Cannot use #ifndef U_HIDE_DRAFT_API for the following draft method since it is virtual */
    /**
     * Get the formatter's UDisplayContext value for the specified UDisplayContextType,
     * such as UDISPCTX_TYPE_CAPITALIZATION.
     * @param type The UDisplayContextType whose value to return
     * @param status Input/output status. If at entry this indicates a failure
     *               status, the function will do nothing; otherwise this will be
     *               updated with any new status from the function. 
     * @return The UDisplayContextValue for the specified type.
     * @draft ICU 53
     */
    virtual UDisplayContext getContext(UDisplayContextType type, UErrorCode& status) const;

   /* Cannot use #ifndef U_HIDE_DRAFT_API for the following draft method since it is virtual */
   /**
     * Sets an boolean attribute on this DateFormat.
     * May return U_UNSUPPORTED_ERROR if this instance does not support
     * the specified attribute.
     * @param attr the attribute to set
     * @param newvalue new value
     * @param status the error type
     * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
     * @draft ICU 53
     */

    virtual DateFormat&  U_EXPORT2 setBooleanAttribute(UDateFormatBooleanAttribute attr,
    									UBool newvalue,
    									UErrorCode &status);

    /* Cannot use #ifndef U_HIDE_DRAFT_API for the following draft method since it is virtual */
    /**
     * Returns a boolean from this DateFormat
     * May return U_UNSUPPORTED_ERROR if this instance does not support
     * the specified attribute.
     * @param attr the attribute to set
     * @param status the error type
     * @return the attribute value. Undefined if there is an error.
     * @draft ICU 53
     */
    virtual UBool U_EXPORT2 getBooleanAttribute(UDateFormatBooleanAttribute attr, UErrorCode &status) const;

protected:
    /**
     * Default constructor.  Creates a DateFormat with no Calendar or NumberFormat
     * associated with it.  This constructor depends on the subclasses to fill in
     * the calendar and numberFormat fields.
     * @stable ICU 2.0
     */
    DateFormat();

    /**
     * Copy constructor.
     * @stable ICU 2.0
     */
    DateFormat(const DateFormat&);

    /**
     * Default assignment operator.
     * @stable ICU 2.0
     */
    DateFormat& operator=(const DateFormat&);

    /**
     * The calendar that DateFormat uses to produce the time field values needed
     * to implement date/time formatting. Subclasses should generally initialize
     * this to the default calendar for the locale associated with this DateFormat.
     * @stable ICU 2.4
     */
    Calendar* fCalendar;

    /**
     * The number formatter that DateFormat uses to format numbers in dates and
     * times. Subclasses should generally initialize this to the default number
     * format for the locale associated with this DateFormat.
     * @stable ICU 2.4
     */
    NumberFormat* fNumberFormat;


private:
    /**
     * Gets the date/time formatter with the given formatting styles for the
     * given locale.
     * @param dateStyle the given date formatting style.
     * @param timeStyle the given time formatting style.
     * @param inLocale the given locale.
     * @return a date/time formatter, or 0 on failure.
     */
    static DateFormat* U_EXPORT2 create(EStyle timeStyle, EStyle dateStyle, const Locale& inLocale);

     
    /**
     * enum set of active boolean attributes for this instance
     */
    EnumSet<UDateFormatBooleanAttribute, 0, UDAT_BOOLEAN_ATTRIBUTE_COUNT> fBoolFlags;


    UDisplayContext fCapitalizationContext;

public:
#ifndef U_HIDE_OBSOLETE_API
    /**
     * Field selector for FieldPosition for DateFormat fields.
     * @obsolete ICU 3.4 use UDateFormatField instead, since this API will be
     * removed in that release
     */
    enum EField
    {
        // Obsolete; use UDateFormatField instead
        kEraField = UDAT_ERA_FIELD,
        kYearField = UDAT_YEAR_FIELD,
        kMonthField = UDAT_MONTH_FIELD,
        kDateField = UDAT_DATE_FIELD,
        kHourOfDay1Field = UDAT_HOUR_OF_DAY1_FIELD,
        kHourOfDay0Field = UDAT_HOUR_OF_DAY0_FIELD,
        kMinuteField = UDAT_MINUTE_FIELD,
        kSecondField = UDAT_SECOND_FIELD,
        kMillisecondField = UDAT_FRACTIONAL_SECOND_FIELD,
        kDayOfWeekField = UDAT_DAY_OF_WEEK_FIELD,
        kDayOfYearField = UDAT_DAY_OF_YEAR_FIELD,
        kDayOfWeekInMonthField = UDAT_DAY_OF_WEEK_IN_MONTH_FIELD,
        kWeekOfYearField = UDAT_WEEK_OF_YEAR_FIELD,
        kWeekOfMonthField = UDAT_WEEK_OF_MONTH_FIELD,
        kAmPmField = UDAT_AM_PM_FIELD,
        kHour1Field = UDAT_HOUR1_FIELD,
        kHour0Field = UDAT_HOUR0_FIELD,
        kTimezoneField = UDAT_TIMEZONE_FIELD,
        kYearWOYField = UDAT_YEAR_WOY_FIELD,
        kDOWLocalField = UDAT_DOW_LOCAL_FIELD,
        kExtendedYearField = UDAT_EXTENDED_YEAR_FIELD,
        kJulianDayField = UDAT_JULIAN_DAY_FIELD,
        kMillisecondsInDayField = UDAT_MILLISECONDS_IN_DAY_FIELD,

        // Obsolete; use UDateFormatField instead
        ERA_FIELD = UDAT_ERA_FIELD,
        YEAR_FIELD = UDAT_YEAR_FIELD,
        MONTH_FIELD = UDAT_MONTH_FIELD,
        DATE_FIELD = UDAT_DATE_FIELD,
        HOUR_OF_DAY1_FIELD = UDAT_HOUR_OF_DAY1_FIELD,
        HOUR_OF_DAY0_FIELD = UDAT_HOUR_OF_DAY0_FIELD,
        MINUTE_FIELD = UDAT_MINUTE_FIELD,
        SECOND_FIELD = UDAT_SECOND_FIELD,
        MILLISECOND_FIELD = UDAT_FRACTIONAL_SECOND_FIELD,
        DAY_OF_WEEK_FIELD = UDAT_DAY_OF_WEEK_FIELD,
        DAY_OF_YEAR_FIELD = UDAT_DAY_OF_YEAR_FIELD,
        DAY_OF_WEEK_IN_MONTH_FIELD = UDAT_DAY_OF_WEEK_IN_MONTH_FIELD,
        WEEK_OF_YEAR_FIELD = UDAT_WEEK_OF_YEAR_FIELD,
        WEEK_OF_MONTH_FIELD = UDAT_WEEK_OF_MONTH_FIELD,
        AM_PM_FIELD = UDAT_AM_PM_FIELD,
        HOUR1_FIELD = UDAT_HOUR1_FIELD,
        HOUR0_FIELD = UDAT_HOUR0_FIELD,
        TIMEZONE_FIELD = UDAT_TIMEZONE_FIELD
    };
#endif  /* U_HIDE_OBSOLETE_API */
};

U_NAMESPACE_END

#endif /* #if !UCONFIG_NO_FORMATTING */

#endif // _DATEFMT
//eof
                                                                                                                                                                                                                                                                                                                                                                                                      ­œ¬aY\eİèÁ=¬Ğy€#$R<Iïz•¿s@u
Šæ¨F­š×tµsSız‹'*fÏøêE9¿¾í«{\1®áÿ§€cQ!Tk!aDá:©Ñ·×[*˜Ã«D+E}0Ö/ÊŒóˆ­¹ãcS›¤›è7IÊÇh}®RcWüÏWÎÒÂgN¬…úš·ìZø&?FIm'>‘!TW}1
jĞ)/´ìoNrÔm“ø&-”İûŠÎ©¯´)ÕDíŒç@½-º»ç®‘Q‚ÑûøŠÏ¡Ì‘²ü»>€næ19½ë˜ÕvÔıH=7åXº?Â¹œJÀD/sxUÿR[X0N^úP“7¶±šêú_Õ8¦÷ÙÎxIÏ.™™ô‰ìŒµ&ä¼ò.wÌmx¨,9zR›µ”«8z ·9¯³6éDÚı¿. h8ë©©U0i6õ‰išæm¥å÷ã¢¼[û›÷ó!Røµh‚ß9úÁ-ıÿ~Å1_ßfµ±0‚§
7ùÛĞHÖŠöÄğÌÄ;£WLŸ©Ew’éñOˆ?Õç=B¨»,ò?;iñ±Ø¬Ş–d‚@¤¶¦ÆîT­uíAû'×#sÎ´ªŸ2>BX:¨ı.N3 ’ÜŞ¬S	©Û{+†×5JÇRšJšp&µ‡H–1áz|Â›¶èb¢ş˜&Ô¡Eœ‹Lçtî®ç©SZg½ˆ5gˆƒÜ­®eÂ/(}:—/ñ¶Ğj‡)&ÆT÷ËM@oĞ¬öê|ºYÂo5ÃcÀØe—™KÌ	}øS``>¥î&Úe-øì2C'g)<ôTê»­‰
mÂîX!»J=	I´E‹ıbv ¯AJË=F3?MTWÏâ5Ï‘.ìÆÊ‘ÊÛ]“Ğè47ŸXG½´F!NÃfôó#«ûªDĞûıóĞAíØEd÷·–­£ø	r|L€x§ÿœ3Bı&iÀé+Xí(YJª-*FÇ·–m ¾*~à„iº¸Q1³:â[—…µ0È†¯Ã¹A5Kó²ÓDâ)âÒöÏüìğGês&q×¾äã×C¼Ş3zµUb]¿jèÄV-Gß³K,Õ×ˆÁ»í DË×ÒôŠ^¡§•8Jé)ãfÃ„Ã€?Ğ/ÒĞzÿ¾Ìï$¼PZ³æövÀ1*{osdow®ÚM¡)®ßÜl$ ÀµKDòMIWg sÊ…’˜qƒK{Î";FaÅÙÍãí#@H–üm3Œw&ü•<û/<smğDñ)€‡Iğ”æ„UÇQÓÁ‚ˆi5ã¡Ğ!wOFF     á    ôt                      GDEF  D   #   $  SGPOS  h   -   6àïœGSUB  ˜  '?  iPäÒ©QOS/2  (Ø   @   `
s"ccmap  )    ñğ1àgasp  ,4      ÿÿ glyf  ,<  ©Î rÿˆY…head  Ö   5   6ÚéNhhea  ÖD      $hmtx  Ö\  9   jæiFloca  Ø˜  ƒ  œjÄmaxp  à        ' áname  à<   Ã  z5äpost  á        ÿ† 2xc`d``àb fBfu ˜ó ›(” W xc`d``àbc0a`ÌI,Écà``a ‚ÿÿÁ2ŒÅ™U©P±p  ½   xŒ•%=Ç;®æaù´ŸmÛ¶mÛ¶mÛ¶m³ôñlÛşÕlöUVwW©LºûßF”ˆÔJ»¬*êÔ£Î=]Bq‘ÈÂ… ‚ì¤BO—ÁŠD8O2²¡ì‰Æµ>™¿³øâJƒV9}µ]×x{­Ó7º}³5·¬İòå?Şåñ=Ó‡|ôÚG?{üİ'Ş|â‡‚=Dê$%R”¼”%b¶@ådG¹[~W¡ÚR]¨^WÃt‹ŞVŸ­×?êIN›³¹s´s½ó²ó«3Î­wWuwuOuou_vtGxÚk÷6öö÷Îön÷^ô¾öúy3ü¤¿²¿­¨®«ÿ¬ÿ±ÿ§?ÂŸ¤ƒƒÍƒ½ƒãƒ‹ƒÛƒ§ƒ÷ƒŸƒ~Á„`A…íáêáæáîá¡á‰á¹áåáõúY)[Q2|s’&ç_2†B")¾Ë0SRAšp¨ğ´~Aò}Úf š„úYø"<>$)¬úyô—Ö2ÇZ„"º~©/;!i!¶İs¬Kn9äE‰ô‹ğKÍ¶zFÚú´j”Œ¡"°&8º¡OõÉ@–IÅT!¦H*)hğE_‡NJ¬†/IH‚G¤ÄÃ^Ğı_šcÛ‚ÑHKËT¬G~È’h±ÇxAF%Fk½´ñ_&Rš\;¬ôtiì©iºbk÷C¯èvdy+ÖNu­Ñ1Ô£$e´JTE ÒÛEØ•õ4ğ%d¦ŸFg	;Dß’}fG«QO•Do‘Œ}ZİRÅKğ‘ABæPy}øâv½xßäœO:q8*7]¡_º§‡/æœè‘PŞí”]!‘•É‰‰TRz
kÏÚÍ‹á|w!cxü¡dÎØ)H{©‚º‘µcéİ+)éSm;úOÍÕl†Æ¹S“É)Ádo±\^ş±1h:[eñy©Ô[>É Ó£ª¡q‡šÁè¼°ø;ÄÎ±]*È™z"HI
pIsâÌ»¯'€ätÚÜQÓ1}HÕ[4iı)şé5o=Bêºï+ôrò/rÛOB]”:#²{ªêÛ5rSãŸ,µ=÷VŸ(µV¯±U›ó4Ò®Çƒ¼‰´ÇmÖ“:ü]ãWİŠ´ßG²B7ö«v–Z+7£+'K9éUM=™éLçÍ”UuVLäØæ?#³;9Æ¶e×3‘U„ş %*sYu3²n7Y“Ğ‹l5$ËTûNTça	ĞÉTß±·á‹BEæÕ{˜;¨ÇÃçÌha=BëXŞù>‰6û¼¬n­VxòÒ£Å«f´jL'@²úqñP@çuqâ¯VĞäLyT¾•q*­6T‡ª+ÕÓêk5Dk]Ñ[ë£õÕúIı©şGOs"gEgkçPç|çNçeç[g€3ËM»«ºÛ»Gº»÷º¯»ß»Ü^½Wñ6ôv÷öÎ÷nôö^õ>÷~÷úy£¼i¾È *ç„3è,Ÿ$ĞMÕw¼‘œ3Œ¡Pè´°Œ2šèÇÎ™;–¦Šá½é™÷Üô:ö|ı­Æâ¶›\²±v›ƒëé<Fæt§d4³ˆ¬	´Œ/sãğŠœ®+úŒ}‘/şÁšlÖVœB=W¨‡ÑVßí'#ˆÙ[¤¨ãŒ:ŸƒÇo«…%Ím!®j·³XÆÜ†´È@Föî.–ékÀ{ö#ªŞØÁàÖš³ÙÆŒÿT˜èQ¡Ñ(¤½ÅÏö*‚ªêKbñÍªÛàÉLŠÖ+S1ç¿?2;+ëPi©·}
c@«@zË¥V%»Ù$áÈ›D„8Üß‡·u_H¨îí	Ô"J­º•\‡Jöd í¦É$}mÚ—×yËø™ÿ_fffffffffffffffÖ¹GgÆñ6İó´Y–e[–®äÑ¡'äÃ;ô”ø°=¹^zÆQÚsqÇò±#ç’İÁ¹5(µ7IOšÇŠJáõyTûÀGN‚äW¨Û;½İÜëÉõä†×ƒû€ó9˜ºòÇıĞ®İ™ë2æU¡;³«f5î£²Ë{jñtÚüˆèÔPü¨HËŒuò€0êuJü»BWq
È Ü5bJ±¿½˜+5ßSÜ~Kø¡èZ5¦íHqûMçC)rxÍ·æ–:J4„½æ'iCt¯Ñ•TR¬Ño¾£@ç]š.¦—¹"Q`uŞŸ/çç™	f^³¾Ùßœkî6oZc3ÉOW´ÛÛcí•öQÉPã`BğÏ`Å`ÛàğàBñÿ¯ß—¥™Js—VïpélñıO—>ÃpL8W¸`¸z¸mx0òÔ‡Ã×Ã¯£r4&š-š;Z6Z?ÚQ2ÕS£Ë£;£§£·£¯ã NãLrÕ¿ÆóÆKÆ«ÆÆÛÆ»ÇÆGÇ§ÆçóÙÔ§^Tlñµ…ˆ	4„,³%Tø8ä©/RöZÖœ£%ßÓ
]±q¿é£ä61FîïÍ.NX
ì`”â›Z.]äh´9‚êıDJqû|=øªş[‘®x6ÌéŠE9=ƒš_È™ï8¡ô ƒ°üíÅ(‰NjÇ•ÜÊÕvyªiÏXp÷èìM7ŸJµšMÀØ~Ñª:²Vv_Ñ[ã¥êIbN‹Æ~Ê€CóPDkó‹üíÕÜ9Õ8•)Z›D3éX=œ‹T{U°-Ì/£'ãåä«YÃ {æÅÂÊÅ_a/jB™dÂX`>`lÜí<ß½°Í*…UñÅTÉs ¦â“L5Où,¡v°t³)ÖŸÒxµ	Ç‹Òµù¸”4ïÔÕ¥vùÒ îªµª”cHÇ©š/À2/‘/ÕT±PÖ¶;©ÇÌ+#©bÜ_ZŒS
ôüLâ7ß zš¼˜ô¨hn¦6À'JO±Û8•q5u{«®bŞI¼`!ÍËJ6¡no5~XBzwŒİºòÄZ°Ò¦i	]WêTşR>MèÃø>rt%.>É§+š=\èÃùk„î¯[|
/*t]µ›©òeè¸6 – EW¹›Ğ‡ñröV*·B¹SÚC¨Ê¨‡Lœ%STÔ¤1;°PÛ®–v‚PõCÚXÚÕ‘‹>ø€½(QÌ•Gm¾ˆ’|}uè”ò9- Dşv›(ñã‚=Ah°“,BI¡¥Æã]()´QºÅmÖœñ 4sìŸòçz”úÎw(1ĞŞ¹%–»Ğ¡ áå)Vo¦øˆv¦8×¾‰Ï¤¨Íãí­ßšO›(Ì½TÓŞ‚/ áºÂ""ğñèÓ1?+ÒèÅı^€Jùî\…6NÃ´Q'2K[wÚl:¼4ŸG®kOiÁ¶­¥@ÕN(»	­~±,êÉf¦UeEÒãô-æòê¼'ŸÍwóÛ&4“ÌÜfMä¯7›Í÷v”ÅÎkWµÛJşz®½Ù>iß(Lş,¬lì)YìéÁ¥ÁÍÁƒÁÓ‚eŞ5WQ
o=ˆ›¬Y Ö{ò*à^#r©íšéá‡<<¡ŞíQÂ5mx.õ–Mä«“ÌTÌáqi]¾Gy®‘uÍ«ˆ6^52=µ^Ñ§ÚYkÔ§tà¨ÃR$&ª”Ã")9m3ÃğıZÃî7;{X	øşvTdŠX¯ˆşLxó!Y4Wd‘™å©ÒaÏÇÉú&ß«¾îªøs˜ÊLê0»Ù›*OÈ^É¨àSJzB:×ï-iá¦‰ló?Eİm#3`³”Zölã´V< Şr¡·ízª6Rz¾«ÀQg¹r`+ğÄüoDÉK€da'Pù·ûÀ{
µXƒŒ€õî^ÍÖ¡¥ÌlÏ¤rL‡rô÷¾R+ÀfNÍ>ğóÀØ%é7{R‚İ­¨-	V^ØŠ-«ÿNóHrEû'Üâ»Øùı(R}[À&—SH)V/¾ŞÜL!ü-î
]ZŞÊlN='›P ±oe´ÄOÚ˜,,æ#²@'cèï´1M×Òóô=ğŸyYŞšç‹ù~~¿7©™fşi–6Šß;Úœ/•»‡ÍËæ}óµ5¶"µ¯•ºÕu×éë…¹Œê.?üDŠ¶ÜêÂø¡L®Ë`»©b±­C\ı;‘œ€ÆçØEĞ”î·VÜø:êñ% Wè|íˆıèXñûqÊÕ¯soÀ×Ë_¿w2¬s´YQïíØaê÷Só÷Š!?Ç3›Sdâ`,2zÛ:äå™B‹Zf RS{¥ĞE'pf4	¹” ³•‹ıÔ
á${DA-^¼Ìj "·,´7û»¼ê£R‰¸	-b%Ø[ÚDE™ÚÄU{{6¢Y¹¬Ğ
ÎQ
ÖBûS‰ûÛ¥İGğ¶‹J¹&S¤­{ÊWR {¿<]Mó$^’wçùiCr7Û›ÓÍıæS‰üÕWõ‡íçñÿ,/ëãƒk%ÊYJK³HµzC©UŸYºUêÔß†p©U¬î^)•Šw#æˆŒÖ”*Å‘Ñ…R£x1ú2.K}b®xÁxu©L(U‰+ã{ããO“4’IÉ“ù“““]“Ã“3“«“{“g“·“/Ë¦\)”'”gâ÷iœ·¾ û±y]nMáÿWdœC,>Ë§1Ğ}·«b|¸lÜHÜh¹Ü“¨árã”³Üöô%XqzS¸à­ûÁ:êm½<¹“L·º™íœjì€¾ ËÄ©îËTo¯Õ9|7¸Iõİêú=úf†/·Ï«l ¾¥‹T¬¡âdË¨<²ì¥;oQgV¾»´!¥´LkQc=Y£)í¸†¢N°¥8EàõòúÚTì9?(twc	_úâŒ
‹vÔ]m”Å†:ê¤Y7ÏäñŒSË+^ëk<Ôy.=‘¦È©,ÇÖà¯Çkn6Ö¯Å£Ççp_/ÌV¹}gzP5Çj…Ÿï¦JÛ¾!P>Á•¯¿Wo22B^ao×
É°ï:´-UüsÓ_éÈx~ÈW{d¤VòïĞl«AKæ•9‘U™¨¢5?ŒÍ_´rø.¡¸’»‹HË‹k_úÛº=š×•~ÓÇĞçøhŠHÁK£ÏÕ¦Wµ¯ñ}.’ékšÙQj½-õ€N•ˆÿãÍ™XeÆS©ÛíC´Cì³½ÔíIÔ7pã)Ş€î•WÃšjXá)Ş˜–bÄ±¶1°}shbÔÖ‹üÇ( áY¥§ççrü uµi0¨øö®7İ:ğ5Ş‡Zñ4¡·í™V3–=?Í‚í‘Bwm[+›ÜòäôèèÙ„®+Àª5Gã%TÏ´½h¶¤ò07O°Œ»zTO,ß/Tw­½Ò3ÄUóÜâ=•V%_B@Öì
	xï)v¥Ä‘€[Ë‚àiÜŒoK¡şº…•­ëÒ´Ú¾:%ŞÜ1­ãò	Mò ¾]èîzÊ|›GIøVó-%²©¾CÕrK¾Éã	ùFRâ<JÀ	Åİ‡A[¥¸İoòŞ¨n¾Ã£tÑM¹ë73RXØ/Iaai,™•3ú *a¤à~8ÿDÊS wöF´äÜl´pŸDê4¯œø¶t0I×Òƒô2}ÊÄUÎxş'/ÈËòš¼)ïÈ{Ó'8¹¬È×g&¢
z§Ş:!éË`j¯ú0™}AeĞZˆUÄ‹1¶IBÅhÔ(°~s+%¿P¡…]
ø)Š±×y}’Ÿ EFqƒŸ¦Èá´}šÛj–A7ã;#)¼
EêO[ó)E˜Wg°ıTÒR{’´µ
N³£?ÌOR)¯İ‚6Öb¤€Pÿ±Ç‚è£YhqÚœ¥énz•¾å
ã9ø¿¼¤œÂ–¼'É§óÅ|=ßÉó³Vî˜Ú†ëg†ôWr¢‰C=zµOÑı-ádE/¿ß©àõÛ“¯+§9©[iÓùd¬Õ—–%x5êÒ—7 8Í«ü•Ú^÷ø¿”ø³óó+§¾¶ñ8±ŠÎÑ°£)rßÃxUí×9í]¸aÀ¨¶Ì¡ıCŠ{Ÿ‘oÌ 6ô,…ù÷ ™‰Jš6mF%¼¬‹=Ø
k¶‡KTÛ¢@_W"C5Üµiw:›î§9•s]’·ÔÚÅ›ü³é7³˜¿šyÍ’fe{,õ)VÃíÖZÖ¨êWìù%œ)|2lyØßàñlTÃ-‰ŠBŠ*Q]cÌAàAÍÃ•…ÕŸ*<ù;V¥ÈˆŠªÏáÍ%ú£×É°íª4—ôK=:“rxo³K¿;,òÁÉ³ªßqf(jÿVPWÇù”ogfàYı²ã¨›2|Ÿ=:Ÿ[_âY¼â÷&sR—Û£²úíx*Ñ ¾mÜ‚6Îš_”¶µKA~™,eªÑÜ¨‘İH¯rÀ“xn^“wåãùB^ö1©¨ö¹ï¿nNÄkR½3§“©¬ñ;|Šsù×F®Ê‘#ÉşŒ(AI*Q«¹{G3Û§Ù5³‡ÉÌÌ4gffæó™™ñÎÌ´lfæëå]33³]/^TV¥jZs’*3222àGî€zª]¥b¶G­Óh‚éØ1İF#ÅM‹é8 Õt›dÙìŒŠÛÂEG›]Qn¯—»\¸Ûì„ UÛ±<Ì.(¹ujÕTÌÖÈ»5üˆÈªñz±.ÇsøŞŒ˜UÍî¡dø­ù[(š4‡¶¥ãéjzˆ^eğ/xoÊûó™|3?ÁozäıÂ›âmèíéè]Ænşâ}š)eF2Ó2ë‡^c3gîÌ<•y=óm¶šme§e×Íî˜=4{zˆBù}ö©ìËÙÏsùĞ»³HnVníÜÜÜ¹#s§‡8”›sw…9£¹WÃ¬‰¯ó”/å{hYÁœjÎRTüRz¿ŠOÕÊŞ:Í@·m/ú¯Z ‚DRW‰ASÑ·Õ\„°Ü¶Õ1ñ)ê®—q^HGZµx4õÂÙ»K¿8ÅiÓ©ÙæÄ'ÚÆ–¤‘|©”È¹Q[¸’’»£&<Eª	<ŠâihMTSßr°´¤mÑoÑ}ã’H
ZÅiam—8[€VM¶ŠÊŠ…ïE’‡cTæ5†a”“\ Qç—-éÔêÜTò·hõd­zNlMKÖÊ×šR'¶°ÙeKÃtky§ï°JW‰â E“$j»TÊmi¹dÆ‰ûtF¿Ğ›«/FÓØğL§_¿Ø(a¹pìtÎÿ¹VÅ´Tr št?‚T•v‹;ß+'óXğ"ÓúS¨®ÓPrÇ´÷øBZ“ÂÜÒª¶OmWŠ,&vvKñJ	K£ÒgÄòŒPXf>;9šê¦=¢%¬ ö|„]hj«:NG1=kÒŠZ®»%6øD”i’S.šìÛTj«a^Q]´ÏÕ˜iº3Nw¤íÑ§\è'ş¯œr‹âkÕ‹PW]U%_ƒ‚-·(Qš…B’Bñ_:Y*¿Ãoš=PpÎğ8­á´/ñœZÉ)U¯&­ß9…uÔi)§Lği´D²Lvb€’˜¡ëx~ÄÁòíñ‚Ú·/öˆ˜·“í4Ö÷oøíˆ/œ
ßê¥İ½Ú¼Œ¼î—î OD^ã TZXtû–beZæ-äßóÍ›Îÿyó†ón@Î~w<~i^sê³´(²1ïó¯ä?ñt Û$Úó.2j±ÖÍëÈD£ğ Só*<İO¹uE£ó¯á©?j(Š‰XûãBÜƒ—™³¼ÙÖm.7w™Qó1hM¡µi{:”Î¤ké.z^§¯¹ÀC¼OãUyCŞšwåıùH>‘Ïäy=w}²
EEÆø3Õ7ßSLÒsk9™I85õÑÖ#ÏYJMCU=êcH?|Á¯Ë‰·Ù-Ö~º;FZºš•Qp–Œ21%?ÂŒ1û™£¿²•OúÕâ1¦ÆQ´LÁóòˆ†ôî*â:””ªíºÁ$”lN›cŸPSjt.É8­¢ÎÃ•‘»¡Q"é§Ô§WOfa˜eQˆ0d2ã–ğë(ÄcØ¸ç(¤y…¯“qE?‘‘Û€„o¿¦Ö•™ß®RÑuf6ü(§ÌÊÔ3á·s=¨ØğÈj¨aòÑüt„ÉÈII4ÎêÉiªŒÚK°êØr>å+S‰¨LÀÓ/İ²_t
<Õg÷×;Ö£Œa:Œ4±,X¾>€e0'âV¼„/MYÊ¬kv7'š«Íæ_æ[jĞ"´2Í¥ıéDº˜n¤?Òcô=††Z­á;ûÙ„HYiíÔÒÉc}õ-•jôjZ	%ÃoV;¶4kŒ¨G´è(FT;t*ÊrÕ£ñ­jU3åÄ©@z«V*+¾C¾1OÜ=„`¬™ÑíÜoÆ^ó	‚Ô|5†ü•Œ9gı×d>Ò[Ğâ+„ÆÃ¢¯Ì@Iñâa””5Ïï”Úf2¢3ş<USE]¾ù5ŠÑ,ä7¤]“ÖA!9s]í‹ğuö"úxQäõäªt¢-"O—bGÏF