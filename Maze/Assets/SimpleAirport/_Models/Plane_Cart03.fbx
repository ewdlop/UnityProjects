# RUN: llc -march=x86-64 -run-pass none -o - %s | FileCheck %s
# This test ensures that the MIR parser parses the machine memory operands
# correctly.

--- |

  define i32 @test(i32* %a) {
  entry:
    %b = load i32, i32* %a
    store i32 42, i32* %a
    ret i32 %b
  }

  define void @test2(i32* %"a value") {
  entry2:
    %b = load i32, i32* %"a value"
    %c = add i32 %b, 1
    store i32 %c, i32* %"a value"
    ret void
  }

  define void @test3(i32*) {
  entry3:
    %1 = alloca i32
    %b = load i32, i32* %0
    %c = add i32 %b, 1
    store i32 %c, i32* %1
    ret void
  }

  define i32 @volatile_inc(i32* %x) {
  entry:
    %0 = load volatile i32, i32* %x
    %1 = add i32 %0, 1
    store volatile i32 %1, i32* %x
    ret i32 %1
  }

  define void @non_temporal_store(i32* %a, i32 %b) {
  entry:
    store i32 %b, i32* %a, align 16, !nontemporal !0
    ret void
  }

  !0 = !{i32 1}

  define i32 @invariant_load(i32* %x) {
  entry:
    %v = load i32, i32* %x, !invariant.load !1
    ret i32 %v
  }

  !1 = !{}

  define void @memory_offset(<8 x float>* %vec) {
  entry:
    %v = load <8 x float>, <8 x float>* %vec
    %v2 = insertelement <8 x float> %v, float 0.0, i32 4
    store <8 x float> %v2, <8 x float>* %vec
    ret void
  }

  define void @memory_alignment(<8 x float>* %vec) {
  entry:
    %v = load <8 x float>, <8 x float>* %vec
    %v2 = insertelement <8 x float> %v, float 0.0, i32 4
    store <8 x float> %v2, <8 x float>* %vec
    ret void
  }

  define double @constant_pool_psv(double %a) {
  entry:
    %b = fadd double %a, 3.250000e+00
    ret double %b
  }

  declare x86_fp80 @cosl(x86_fp80) #0

  define x86_fp80 @stack_psv(x86_fp80 %x) {
  entry:
    %y = call x86_fp80 @cosl(x86_fp80 %x) #0
    ret x86_fp80 %y
  }

  attributes #0 = { readonly }

  @G = external global i32

  define i32 @got_psv() {
  entry:
    %a = load i32, i32* @G
    %b = add i32 %a, 1
    ret i32 %b
  }

  @0 = external global i32

  define i32 @global_value() {
  entry:
    %a = load i32, i32* @G
    %b = add i32 %a, 1
    %c = load i32, i32* @0
    %d = add i32 %b, %c
    ret i32 %d
  }

  define i32 @jumptable_psv(i32 %in) {
  entry:
    switch i32 %in, label %def [
      i32 0, label %lbl1
      i32 1, label %lbl2
      i32 2, label %lbl3
      i32 3, label %lbl4
    ]
  def:
    ret i32 0
  lbl1:
    ret i32 1
  lbl2:
    ret i32 2
  lbl3:
    ret i32 4
  lbl4:
    ret i32 8
  }

  %struct.XXH_state64_t = type { i32, i32, i64, i64, i64 }

  @a = common global i32 0, align 4

  define i32 @tbaa_metadata() {
  entry:
    %0 = load i32, i32* @a, align 4, !tbaa !2
    %1 = inttoptr i32 %0 to %struct.XXH_state64_t*
    %total_len2 = bitcast %struct.XXH_state64_t* %1 to i32*
    %2 = load i32, i32* %total_len2, align 4, !tbaa !6
    ret i32 %2
  }

  !2 = !{!3, !3, i64 0}
  !3 = !{!"int", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !3, i64 0}
  !7 = !{!"XXH_state64_t", !3, i64 0, !3, i64 4, !8, i64 8, !8, i64 16, !8, i64 24}
  !8 = !{!"long long", !4, i64 0}

  define void @aa_scope(float* nocapture %a, float* nocapture readonly %c) #1 {
  entry:
    %0 = load float, float* %c, align 4, !alias.scope !9
    %arrayidx.i = getelementptr inbounds float, float* %a, i64 5
    store float %0, float* %arrayidx.i, align 4, !noalias !9
    %1 = load float, float* %c, align 4
    %arrayidx = getelementptr inbounds float, float* %a, i64 7
    store float %1, float* %arrayidx, align 4
    ret void
  }

  attributes #1 = { nounwind uwtable }

  !9 = distinct !{!9, !10, !"some scope"}
  !10 = distinct !{!10, !"some domain"}

  define zeroext i1 @range_metadata(i8* %x) {
  entry:
    %0 = load i8, i8* %x, align 1, !range !11
    %tobool = trunc i8 %0 to i1
    ret i1 %tobool
  }

  !11 = !{i8 0, i8 2}

  %st = type { i32, i32 }

  @values = common global [50 x %st] zeroinitializer, align 16

  define void @gep_value(i64 %d) {
  entry:
    %conv = trunc i64 %d to i32
    store i32 %conv, i32* getelementptr inbounds ([50 x %st], [50 x %st]* @values, i64 0, i64 0, i32 0), align 16
    ret void
  }

  define i8* @undef_value() {
  entry:
    %0 = load i8*, i8** undef, align 8
    ret i8* %0
  }

  define void @dummy0() { ret void }
  define void @dummy1() { ret void }
...
---
name:            test
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi
  ; CHECK:      %eax = MOV32rm %rdi, 1, %noreg, 0, %noreg :: (load 4 from %ir.a)
  ; CHECK-NEXT: MOV32mi killed %rdi, 1, %noreg, 0, %noreg, 42 :: (store 4 into %ir.a)
    %eax = MOV32rm %rdi, 1, _, 0, _ :: (load 4 from %ir.a)
    MOV32mi killed %rdi, 1, _, 0, _, 42 :: (store 4 into %ir.a)
    RETQ %eax
...
---
name:            test2
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry2:
    liveins: %rdi
  ; CHECK: INC32m killed %rdi, 1, %noreg, 0, %noreg, implicit-def dead %eflags :: (store 4 into %ir."a value"), (load 4 from %ir."a value")
    INC32m killed %rdi, 1, _, 0, _, implicit-def dead %eflags :: (store 4 into %ir."a value"), (load 4 from %ir."a value")
    RETQ
...
---
name:            test3
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
frameInfo:
  maxAlignment:    4
stack:
  - { id: 0, offset: -12, size: 4, alignment: 4 }
body: |
  bb.0.entry3:
    liveins: %rdi
  ; Verify that the unnamed local values can be serialized.
  ; CHECK-LABEL: name: test3
  ; CHECK: %eax = MOV32rm killed %rdi, 1, %noreg, 0, %noreg :: (load 4 from %ir.0)
  ; CHECK: MOV32mr %rsp, 1, %noreg, -4, %noreg, killed %eax :: (store 4 into %ir.1)
    %eax = MOV32rm killed %rdi, 1, _, 0, _ :: (load 4 from %ir.0)
    %eax = INC32r killed %eax, implicit-def dead %eflags
    MOV32mr %rsp, 1, _, -4, _, killed %eax :: (store 4 into %ir.1)
    RETQ
...
---
name:            volatile_inc
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi
    ; CHECK: name: volatile_inc
    ; CHECK: %eax = MOV32rm %rdi, 1, %noreg, 0, %noreg :: (volatile load 4 from %ir.x)
    ; CHECK: MOV32mr killed %rdi, 1, %noreg, 0, %noreg, %eax :: (volatile store 4 into %ir.x)
    %eax = MOV32rm %rdi, 1, _, 0, _ :: (volatile load 4 from %ir.x)
    %eax = INC32r killed %eax, implicit-def dead %eflags
    MOV32mr killed %rdi, 1, _, 0, _, %eax :: (volatile store 4 into %ir.x)
    RETQ %eax
...
---
name:            non_temporal_store
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
  - { reg: '%esi' }
body: |
  bb.0.entry:
    liveins: %esi, %rdi
  ; CHECK: name: non_temporal_store
  ; CHECK: MOVNTImr killed %rdi, 1, %noreg, 0, %noreg, killed %esi :: (non-temporal store 4 into %ir.a)
    MOVNTImr killed %rdi, 1, _, 0, _, killed %esi :: (non-temporal store 4 into %ir.a)
    RETQ
...
---
name:            invariant_load
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi
  ; CHECK: name: invariant_load
  ; CHECK: %eax = MOV32rm killed %rdi, 1, %noreg, 0, %noreg :: (invariant load 4 from %ir.x)
    %eax = MOV32rm killed %rdi, 1, _, 0, _ :: (invariant load 4 from %ir.x)
    RETQ %eax
...
---
name:            memory_offset
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi
  ; CHECK: name: memory_offset
  ; CHECK:      %xmm0 = MOVAPSrm %rdi, 1, %noreg, 0, %noreg :: (load 16 from %ir.vec)
  ; CHECK-NEXT: %xmm1 = MOVAPSrm %rdi, 1, %noreg, 16, %noreg :: (load 16 from %ir.vec + 16)
  ; CHECK:      MOVAPSmr %rdi, 1, %noreg, 0, %noreg, killed %xmm0 :: (store 16 into %ir.vec)
  ; CHECK-NEXT: MOVAPSmr killed %rdi, 1, %noreg, 16, %noreg, killed %xmm1 :: (store 16 into %ir.vec + 16)
    %xmm0 = MOVAPSrm %rdi, 1, _, 0, _ :: (load 16 from %ir.vec)
    %xmm1 = MOVAPSrm %rdi, 1, _, 16, _ :: (load 16 from %ir.vec + 16)
    %xmm2 = FsFLD0SS
    %xmm1 = MOVSSrr killed %xmm1, killed %xmm2
    MOVAPSmr %rdi, 1, _, 0, _, killed %xmm0 :: (store 16 into %ir.vec)
    MOVAPSmr killed %rdi, 1, _, 16, _, killed %xmm1 :: (store 16 into %ir.vec + 16)
    RETQ
...
---
name:            memory_alignment
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi
  ; CHECK: name: memory_alignment
  ; CHECK:      %xmm0 = MOVAPSrm %rdi, 1, %noreg, 0, %noreg :: (load 16 from %ir.vec, align 32)
  ; CHECK-NEXT: %xmm1 = MOVAPSrm %rdi, 1, %noreg, 16, %noreg :: (load 16 from %ir.vec + 16, align 32)
  ; CHECK:      MOVAPSmr %rdi, 1, %noreg, 0, %noreg, killed %xmm0 :: (store 16 into %ir.vec, align 32)
  ; CHECK-NEXT: MOVAPSmr killed %rdi, 1, %noreg, 16, %noreg, killed %xmm1 :: (store 16 into %ir.vec + 16, align 32)
    %xmm0 = MOVAPSrm %rdi, 1, _, 0, _ :: (load 16 from %ir.vec, align 32)
    %xmm1 = MOVAPSrm %rdi, 1, _, 16, _ :: (load 16 from %ir.vec + 16, align 32)
    %xmm2 = FsFLD0SS
    %xmm1 = MOVSSrr killed %xmm1, killed %xmm2
    MOVAPSmr %rdi, 1, _, 0, _, killed %xmm0 :: (store 16 into %ir.vec, align 32)
    MOVAPSmr killed %rdi, 1, _, 16, _, killed %xmm1 :: (store 16 into %ir.vec + 16, align 32)
    RETQ
...
---
name:            constant_pool_psv
tracksRegLiveness: true
liveins:
  - { reg: '%xmm0' }
constants:
  - id:          0
    value:       'double 3.250000e+00'
body: |
  bb.0.entry:
    liveins: %xmm0
  ; CHECK: name: constant_pool_psv
  ; CHECK:      %xmm0 = ADDSDrm killed %xmm0, %rip, 1, %noreg, %const.0, %noreg :: (load 8 from constant-pool)
  ; CHECK-NEXT: %xmm0 = ADDSDrm killed %xmm0, %rip, 1, %noreg, %const.0, %noreg :: (load 8 from constant-pool + 8)
    %xmm0 = ADDSDrm killed %xmm0, %rip, 1, _, %const.0, _ :: (load 8 from constant-pool)
    %xmm0 = ADDSDrm killed %xmm0, %rip, 1, _, %const.0, _ :: (load 8 from constant-pool + 8)
    RETQ %xmm0
...
---
name:            stack_psv
tracksRegLiveness: true
frameInfo:
  stackSize:       24
  maxAlignment:    16
  adjustsStack:    true
  hasCalls:        true
  maxCallFrameSize: 16
fixedStack:
  - { id: 0, offset: 0, size: 10, alignment: 16, isImmutable: true, isAliased: false }
body: |
  bb.0.entry:
    %rsp = frame-setup SUB64ri8 %rsp, 24, implicit-def dead %eflags
    CFI_INSTRUCTION def_cfa_offset 32
    LD_F80m %rsp, 1, %noreg, 32, %noreg, implicit-def dead %fpsw
  ; CHECK: name: stack_psv
  ; CHECK: ST_FP80m %rsp, 1, %noreg, 0, %noreg, implicit-def dead %fpsw :: (store 10 into stack, align 16)
    ST_FP80m %rsp, 1, _, 0, _, implicit-def dead %fpsw :: (store 10 into stack, align 16)
    CALL64pcrel32 $cosl, csr_64, implicit %rsp, implicit-def %rsp, implicit-def %fp0
    %rsp = ADD64ri8 %rsp, 24, implicit-def dead %eflags
    RETQ
...
---
name:            got_psv
tracksRegLiveness: true
body: |
  bb.0.entry:
  ; CHECK: name: got_psv
  ; CHECK: %rax = MOV64rm %rip, 1, %noreg, @G, %noreg :: (load 8 from got)
    %rax = MOV64rm %rip, 1, _, @G, _ :: (load 8 from got)
    %eax = MOV32rm killed %rax, 1, _, 0, _
    %eax = INC32r killed %eax, implicit-def dead %eflags
    RETQ %eax
...
---
name:            global_value
tracksRegLiveness: true
body: |
  bb.0.entry:
    %rax = MOV64rm %rip, 1, _, @G, _
  ; CHECK-LABEL: name: global_value
  ; CHECK: %eax = MOV32rm killed %rax, 1, %noreg, 0, %noreg, implicit-def %rax :: (load 4 from @G)
  ; CHECK: %ecx = MOV32rm killed %rcx, 1, %noreg, 0, %noreg, implicit-def %rcx :: (load 4 from @0)
    %eax = MOV32rm killed %rax, 1, _, 0, _, implicit-def %rax :: (load 4 from @G)
    %rcx = MOV64rm %rip, 1, _, @0, _
    %ecx = MOV32rm killed %rcx, 1, _, 0, _, implicit-def %rcx :: (load 4 from @0)
    %eax = LEA64_32r killed %rax, 1, killed %rcx, 1, _
    RETQ %eax
...
---
name:            jumptable_psv
tracksRegLiveness: true
liveins:
  - { reg: '%edi' }
jumpTable:
  kind:          label-difference32
  entries:
    - id:        0
      blocks:    [ '%bb.3.lbl1', '%bb.4.lbl2', '%bb.5.lbl3', '%bb.6.lbl4' ]
body: |
  bb.0.entry:
    successors: %bb.2.def, %bb.1.entry
    liveins: %edi

    %eax = MOV32rr %edi, implicit-def %rax
    CMP32ri8 killed %edi, 3, implicit-def %eflags
    JA_1 %bb.2.def, implicit killed %eflags

  bb.1.entry:
    successors: %bb.3.lbl1, %bb.4.lbl2, %bb.5.lbl3, %bb.6.lbl4
    liveins: %rax

    %rcx = LEA64r %rip, 1, _, %jump-table.0, _
  ; CHECK: name: jumptable_psv
  ; CHECK: %rax = MOVSX64rm32 %rcx, 4, killed %rax, 0, %noreg :: (load 4 from jump-table, align 8)
    %rax = MOVSX64rm32 %rcx, 4, killed %rax, 0, _ :: (load 4 from jump-table, align 8)
    %rax = ADD64rr killed %rax, killed %rcx, implicit-def dead %eflags
    JMP64r killed %rax

  bb.2.def:
    %eax = MOV32r0 implicit-def dead %eflags
    RETQ %eax

  bb.3.lbl1:
    %eax = MOV32ri 1
    RETQ %eax

  bb.4.lbl2:
    %eax = MOV32ri 2
    RETQ %eax

  bb.5.lbl3:
    %eax = MOV32ri 4
    RETQ %eax

  bb.6.lbl4:
    %eax = MOV32ri 8
    RETQ %eax
...
---
name:            tbaa_metadata
tracksRegLiveness: true
body: |
  bb.0.entry:
    %rax = MOV64rm %rip, 1, _, @a, _ :: (load 8 from got)
  ; CHECK-LABEL: name: tbaa_metadata
  ; CHECK:      %eax = MOV32rm killed %rax, 1, %noreg, 0, %noreg, implicit-def %rax :: (load 4 from @a, !tbaa !2)
  ; CHECK-NEXT: %eax = MOV32rm killed %rax, 1, %noreg, 0, %noreg :: (load 4 from %ir.total_len2, !tbaa !6)
    %eax = MOV32rm killed %rax, 1, _, 0, _, implicit-def %rax :: (load 4 from @a, !tbaa !2)
    %eax = MOV32rm killed %rax, 1, _, 0, _ :: (load 4 from %ir.total_len2, !tbaa !6)
    RETQ %eax
...
---
name:            aa_scope
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
  - { reg: '%rsi' }
body: |
  bb.0.entry:
    liveins: %rdi, %rsi
  ; CHECK-LABEL: name: aa_scope
  ; CHECK: %xmm0 = MOVSSrm %rsi, 1, %noreg, 0, %noreg :: (load 4 from %ir.c, !alias.scope !9)
    %xmm0 = MOVSSrm %rsi, 1, _, 0, _ :: (load 4 from %ir.c, !alias.scope !9)
  ; CHECK-NEXT: MOVSSmr %rdi, 1, %noreg, 20, %noreg, killed %xmm0 :: (store 4 into %ir.arrayidx.i, !noalias !9)
    MOVSSmr %rdi, 1, _, 20, _, killed %xmm0 :: (store 4 into %ir.arrayidx.i, !noalias !9)
    %xmm0 = MOVSSrm killed %rsi, 1, _, 0, _ :: (load 4 from %ir.c)
    MOVSSmr killed %rdi, 1, _, 28, _, killed %xmm0 :: (store 4 into %ir.arrayidx)
    RETQ
...
---
name:            range_metadata
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi
  ; CHECK-LABEL: name: range_metadata
  ; CHECK: %al = MOV8rm killed %rdi, 1, %noreg, 0, %noreg :: (load 1 from %ir.x, !range !11)
    %al = MOV8rm killed %rdi, 1, _, 0, _ :: (load 1 from %ir.x, !range !11)
    RETQ %al
...
---
name:            gep_value
tracksRegLiveness: true
liveins:
  - { reg: '%rdi' }
body: |
  bb.0.entry:
    liveins: %rdi

    %rax = MOV64rm %rip, 1, _, @values, _ :: (load 8 from got)
  ; CHECK-LABEL: gep_value
  ; CHECK: MOV32mr killed %rax, 1, %noreg, 0, %noreg, %edi, implicit killed %rdi :: (store 4 into `i32* getelementptr inbounds ([50 x %st], [50 x %st]* @values, i64 0, i64 0, i32 0)`, align 16)
    MOV32mr killed %rax, 1, _, 0, _, %edi, implicit killed %rdi :: (store 4 into `i32* getelementptr inbounds ([50 x %st], [50 x %st]* @values, i64 0, i64 0, i32 0)`, align 16)
    RETQ
...
---
name:            undef_value
tracksRegLiveness: true
body: |
  bb.0.entry:
  ; CHECK-LABEL: name: undef_value
  ; CHECK: %rax = MOV64rm undef %rax, 1, %noreg, 0, %noreg :: (load 8 from `i8** undef`)
    %rax = MOV64rm undef %rax, 1, _, 0, _ :: (load 8 from `i8** undef`)
    RETQ %rax
...
---
# Test memory operand without associated value.
# CHECK-LABEL: name: dummy0
# CHECK: %rax = MOV64rm undef %rax, 1, %noreg, 0, %noreg :: (load 8)
name: dummy0
tracksRegLiveness: true
body: |
  bb.0:
    %rax = MOV64rm undef %rax, 1, _, 0, _ :: (load 8)
    RETQ %rax
...
---
# Test parsing of stack references in machine memory operands.
# CHECK-LABEL: name: dummy1
# CHECK: %rax = MOV64rm %rsp, 1, %noreg, 0, %noreg :: (load 8 from %stack.0)
name: dummy1
tracksRegLiveness: true
stack:
  - { id: 0, size: 4, alignment: 4 }
body: |
  bb.0:
    %rax = MOV64rm %rsp, 1, _, 0, _ :: (load 8 from %stack.0)
    RETQ %rax

...
                                    //---------------------------------------------------------------------
// <copyright file="CqlBlock.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// @owner Microsoft
// @backupOwner Microsoft
//---------------------------------------------------------------------

using System.Linq;
using System.Data.Common.CommandTrees;
using System.Data.Common.CommandTrees.ExpressionBuilder;
using System.Data.Common.Utils;
using System.Collections.Generic;
using System.Data.Mapping.ViewGeneration.Structures;
using System.Collections.ObjectModel;
using System.Text;
using System.Diagnostics;

namespace System.Data.Mapping.ViewGeneration.CqlGeneration
{
    /// <summary>
    /// A class that holds an expression of the form "(SELECT .. FROM .. WHERE) AS alias".
    /// Essentially, it allows generating Cql query in a localized manner, i.e., all global decisions about nulls, constants,
    /// case statements, etc have already been made.
    /// </summary>
    internal abstract class CqlBlock : InternalBase
    {
        /// <summary>
        /// Initializes a <see cref="CqlBlock"/> with the SELECT (<paramref name="slotInfos"/>), FROM (<paramref name="children"/>), 
        /// WHERE (<paramref name="whereClause"/>), AS (<paramref name="blockAliasNum"/>).
        /// </summary>
        protected CqlBlock(SlotInfo[] slotInfos, List<CqlBlock> children, BoolExpression whereClause, CqlIdentifiers identifiers, int blockAliasNum)
        {
            m_slots = new ReadOnlyCollection<SlotInfo>(slotInfos);
            m_children = new ReadOnlyCollection<CqlBlock>(children);
            m_whereClause = whereClause;
            m_blockAlias = identifiers.GetBlockAlias(blockAliasNum);
        }

        #region Fields
        /// <summary>
        /// Essentially, SELECT. May be replaced with another collection after block construction.
        /// </summary>
        private ReadOnlyCollection<SlotInfo> m_slots;
        /// <summary>
        /// FROM inputs.
        /// </summary>
        private readonly ReadOnlyCollection<CqlBlock> m_children;
        /// <summary>
        /// WHERER.
        /// </summary>
        private readonly BoolExpression m_whereClause;
        /// <summary>
        /// Alias of the whole block for cql generation.
        /// </summary>
        private readonly string m_blockAlias;
        /// <summary>
        /// See <see cref="JoinTreeContext"/> for more info.
        /// </summary>
        private JoinTreeContext m_joinTreeContext;
        #endregion

        #region Properties
        /// <summary>
        /// Returns all the slots for this block (SELECT).
        /// </summary>
        internal ReadOnlyCollection<SlotInfo> Slots
        {
            get { return m_slots; }
            set { m_slots = value; }
        }

        /// <summary>
        /// Returns all the child (input) blocks of this block (FROM).
        /// </summary>
        protected ReadOnlyCollection<CqlBlock> Children
        {
            get { return m_children; }
        }

        /// <summary>
        /// Returns the where clause of this block (WHERE).
        /// </summary>
        protected BoolExpression WhereClause
        {
            get { return m_whereClause; }
        }

        /// <summary>
        /// Returns an alias for this block that can be used for "AS".
        /// </summary>
        internal string CqlAlias
        {
            get { return m_blockAlias; }
        }
        #endregion

        #region Abstract Methods
        /// <summary>
        /// Returns a string corresponding to the eSQL representation of this block (and its children below).
        /// </summary>
        internal abstract StringBuilder AsEsql(StringBuilder builder, bool isTopLevel, int indentLevel);

        /// <summary>
        /// Returns a string corresponding to the CQT representation of this block (and its children below).
        /// </summary>
        internal abstract DbExpression AsCqt(bool isTopLevel);
        #endregion

        #region Methods
        /// <summary>
        /// For the given <paramref name="slotNum"/> creates a <see cref="QualifiedSlot"/> qualified with <see cref="CqlAlias"/> of the current block:
        /// "<see cref="CqlAlias"/>.slot_alias"
        /// </summary>
        internal QualifiedSlot QualifySlotWithBlockAlias(int slotNum)
        {
            Debug.Assert(this.IsProjected(slotNum), StringUtil.FormatInvariant("Slot {0} that is to be qualified with the block alias is not projected in this block", slotNum));
            var slotInfo = m_slots[slotNum];
            return new QualifiedSlot(this, slotInfo.SlotValue);
        }

        internal ProjectedSlot SlotValue(int slotNum)
        {
            Debug.Assert(slotNum < m_slots.Count, "Slotnum too high");
            return m_slots[slotNum].SlotValue;
        }

        internal MemberPath MemberPath(int slotNum)
        {
            Debug.Assert(slotNum < m_slots.Count, "Slotnum too high");
            return m_slots[slotNum].OutputMember;
        }

        /// <summary>
        /// Returns true iff <paramref name="slotNum"/> is being projected by this block.
        /// </summary>
        internal bool IsProjected(int slotNum)
        {
            Debug.Assert(slotNum < m_slots.Count, "Slotnum too high");
            return m_slots[slotNum].IsProjected;
        }

        /// <summary>
        /// Generates "A, B, C, ..." for all the slots in the block.
        /// </summary>
        protected void GenerateProjectionEsql(StringBuilder builder, string blockAlias, bool addNewLineAfterEachSlot, int indentLevel, bool isTopLevel)
        {
            bool isFirst = true;
            foreach (SlotInfo slotInfo in Slots)
            {
                if (false == slotInfo.IsRequiredByParent)
                {
                    // Ignore slots that are not needed
                    continue;
                }
                if (isFirst == false)
                {
                    builder.Append(", ");
                }

                if (addNewLineAfterEachSlot)
                {
                    StringUtil.IndentNewLine(builder, indentLevel + 1);
                }

                slotInfo.AsEsql(builder, blockAlias, indentLevel);

                // Print the field alias for complex expressions that don't produce default alias.
                // Don't print alias for qualified fields as they reproduce their alias.
                // Don't print alias if it's a top level query using SELECT VALUE.
                if (!isTopLevel && (!(slotInfo.SlotValue is QualifiedSlot) || slotInfo.IsEnforcedNotNull))
                {
                    builder.Append(" AS ")
                           .Append(slotInfo.CqlFieldAlias);
                }
                isFirst = false;
            }
            if (addNewLineAfterEachSlot)
            {
                StringUtil.IndentNewLine(builder, indentLevel);
            }
        }

        /// <summary>
        /// Generates "NewRow(A, B, C, ...)" for all the slots in the block.
        /// If <paramref name="isTopLevel"/>=true then generates "A" for the only slot that is marked as <see cref="SlotInfo.IsRequiredByParent"/>.
        /// </summary>
        protected DbExpression GenerateProjectionCqt(DbExpression row, bool isTopLevel)
        {
            if (isTopLevel)
            {
                Debug.Assert(this.Slots.Where(slot => slot.IsRequiredByParent).Count() == 1, "Top level projection must project only one slot.");
                return this.Slots.Where(slot => slot.IsRequiredByParent).Single().AsCqt(row);
            }
            else
            {
                return DbExpressionBuilder.NewRow(
                    this.Slots.Where(slot => slot.IsRequiredByParent).Select(slot => new KeyValuePair<string, DbExpression>(slot.CqlFieldAlias, slot.AsCqt(row))));
            }
        }

        /// <summary>
        /// Initializes context positioning in the join tree that owns the <see cref="CqlBlock"/>.
        /// For more info see <see cref="JoinTreeContext"/>.
        /// </summary>
        internal void SetJoinTreeContext(IList<string> parentQualifiers, string leafQualifier)
        {
            Debug.Assert(m_joinTreeContext == null, "Join tree context is already set.");
            m_joinTreeContext = new JoinTreeContext(parentQualifiers, leafQualifier);
        }

        /// <summary>
        /// Searches the input <paramref name="row"/> for the property that represents the current <see cref="CqlBlock"/>.
        /// In all cases except JOIN, the <paramref name="row"/> is returned as is.
        /// In case of JOIN, <paramref name="row"/>.JoinVarX.JoinVarY...blockVar is returned.
        /// See <see cref="SetJoinTreeContext"/> for more info.
        /// </summary>
        internal DbExpression GetInput(DbExpression row)
        {
            return m_joinTreeContext != null ? m_joinTreeContext.FindInput(row) : row;
        }

        internal override void ToCompactString(StringBuilder builder)
        {
            for (int i = 0; i < m_slots.Count; i++)
            {
                StringUtil.FormatStringBuilder(builder, "{0}: ", i);
                m_slots[i].ToCompactString(builder);
                builder.Append(' ');
            }
            m_whereClause.ToCompactString(builder);
        }
        #endregion

        #region JoinTreeContext
        /// <summary>
        /// The class represents a position of a <see cref="CqlBlock"/> in a join tree.
        /// It is expected that the join tree is left-recursive (not balanced) and looks like this:
        /// 
        ///                     ___J___
        ///                    /       \
        ///                 L3/         \R3
        ///                  /           \
        ///               __J__           \
        ///              /     \           \
        ///           L2/       \R2         \
        ///            /         \           \
        ///          _J_          \           \
        ///         /   \          \           \
        ///      L1/     \R1        \           \
        ///       /       \          \           \
        /// CqlBlock1   CqlBlock2   CqlBlock3   CqlBlock4
        /// 
        /// Example of <see cref="JoinTreeContext"/>s for the <see cref="CqlBlock"/>s:
        /// block#   m_parentQualifiers   m_indexInParentQualifiers   m_leafQualifier    FindInput(row) = ...
        ///   1          (L2, L3)                    0                      L1             row.(L3.L2).L1
        ///   2          (L2, L3)                    0                      R1             row.(L3.L2).R1
        ///   3          (L2, L3)                    1                      R2             row.(L3).R2
        ///   4          (L2, L3)                    2                      R3             row.().R3
        /// 
        /// </summary>
        private sealed class JoinTreeContext
        {
            internal JoinTreeContext(IList<string> parentQualifiers, string leafQualifier)
            {
                Debug.Assert(parentQualifiers != null, "parentQualifiers != null");
                Debug.Assert(leafQualifier != null, "leafQualifier != null");

                m_parentQualifiers = parentQualifiers;
                m_indexInParentQualifiers = parentQualifiers.Count;
                m_leafQualifier = leafQualifier;
            }

            private readonly IList<string> m_parentQualifiers;
            private readonly int m_indexInParentQualifiers;
            private readonly string m_leafQualifier;

            internal DbExpression FindInput(DbExpression row)
            {
                DbExpression cqt = row;
                for (int i = m_parentQualifiers.Count - 1; i >= m_indexInParentQualifiers; --i)
                {
                    cqt = cqt.Property(m_parentQualifiers[i]);
                }
                return cqt.Property(m_leafQualifier);
            }
        }
        #endregion
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          out to be unequal, which affects the result of the comparison. See the <format type="text/html"><a href="#Equality">Testing for equality</a></format> section for more information about comparing two <see cref="T:System.Single" /> values. </para>
          </block>
          <para>You can also call the <see cref="M:System.Single.IsNaN(System.Single)" />, <see cref="M:System.Single.IsInfinity(System.Single)" />, <see cref="M:System.Single.IsPositiveInfinity(System.Single)" />, and <see cref="M:System.Single.IsNegativeInfinity(System.Single)" /> methods to test for these special values.</para>
        </item>
        <item>
          <para>Mathematical operations. Common arithmetic operations such as addition, subtraction, multiplication, and division are implemented by language compilers and Common Intermediate Language (CIL) instructions rather than by <see cref="T:System.Single" /> methods. If the other operand in a mathematical operation is a <see cref="T:System.Double" />, the <see cref="T:System.Single" /> is converted to a <see cref="T:System.Double" /> before performing the operation, and the result of the operation is also a <see cref="T:System.Double" /> value. If the other operand is an integral type, it is converted to a <see cref="T:System.Single" /> before performing the operation, and the result of the operation is also a <see cref="T:System.Single" /> value. </para>
          <para>You can perform other mathematical operations by calling static (Shared in Visual Basic) methods in the <see cref="T:System.Math" /> class. These include additional methods commonly used for arithmetic (such as <see cref="M:System.Math.Abs(System.Double)" />, <see cref="M:System.Math.Sign(System.Double)" />, and <see cref="M:System.Math.Sqrt(System.Double)" />), geometry (such as <see cref="M:System.Math.Cos(System.Double)" /> and <see cref="M:System.Math.Sin(System.Double)" />), and calculus (such as <see cref="M:System.Math.Log(System.Double)" />).  In all cases, the <see cref="T:System.Single" /> value is converted to a <see cref="T:System.Double" />. </para>
          <para>You can also manipulate the individual bits in a <see cref="T:System.Single" /> value. The <see cref="M:System.BitConverter.GetBytes(System.Single)" /> method returns its bit pattern in a byte array.  By passing that byte array to the <see cref="M:System.BitConverter.ToInt32(System.Byte[],System.Int32)" /> method, you can also preserve the <see cref="T:System.Single" /> value's bit pattern in a 32-bit integer. </para>
        </item>
        <item>
          <para>Rounding. Rounding is often used as a technique for reducing the impact of differences between values caused by problems of floating-point representation and precision. You can round a <see cref="T:System.Single" /> value by calling the <see cref="M:System.Math.Round(System.Double)" /> method. However, note  that the <see cref="T:System.Single" /> value is converted to a <see cref="T:System.Double" /> before the method is called, and the conversion can involve a loss of precision. </para>
        </item>
        <item>
          <para>Formatting. You can convert a <see cref="T:System.Single" /> value to its string representation by calling the <see cref="M:System.Single.ToString" /> method or by using the <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite formatting</a></format> feature. For information about how format strings control the string representation of floating-point values, see the <format type="text/html"><a href="580e57eb-ac47-4ffd-bccd-3a1637c2f467"; RUN: llc -march=hexagon -mcpu=hexagonv5 < %s | FileCheck %s

; Check that store is post-incremented.
; CHECK: r{{[0-9]+:[0-9]+}} = vasrw(r{{[0-9]+:[0-9]+}},r{{[0-9]+}})
; CHECK: r{{[0-9]+:[0-9]+}} = vaslw(r{{[0-9]+:[0-9]+}},r{{[0-9]+}})
target datalayout = "e-p:32:32:32-i64:64:64-i32:32:32-i16:16:16-i1:32:32-f64:64:64-f32:32:32-v64:64:64-v32:32:32-a0:0-n16:32"
target triple = "hexagon"

define void @foo(i32* nocapture %buf, i32* nocapture %dest, i32 %offset, i32 %oddBlock, i32 %gb) #0 {
entry:
  %0 = load i32, i32* %buf, align 4, !tbaa !0
  %shr = ashr i32 %0, %gb
  store i32 %shr, i32* %buf, align 4, !tbaa !0
  %not.tobool = icmp eq i32 %oddBlock, 0
  %1 = sub i32 %offset, %oddBlock
  %2 = zext i1 %not.tobool to i32
  %3 = and i32 %1, 7
  %4 = add i32 %2, %3
  %5 = add i32 %4, 8
  %p_sub8 = sub nsw i32 31, %gb
  %6 = insertelement <2 x i32> undef, i32 %p_sub8, i32 0
  %7 = insertelement <2 x i32> %6, i32 %p_sub8, i32 1
  %8 = bitcast <2 x i32> %7 to i64
  %9 = tail call i64 @llvm.hexagon.S2.asl.i.vw(i64 %8, i32 1)
  %10 = bitcast i64 %9 to <2 x i32>
  %11 = tail call i64 @llvm.hexagon.A2.combinew(i32 -1, i32 -1)
  %12 = bitcast i64 %11 to <2 x i32>
  %sub12p_vec = add <2 x i32> %10, %12
  %p_22 = add i32 %4, 64
  %p_d.018 = getelementptr i32, i32* %dest, i32 %4
  %p_d.01823 = getelementptr i32, i32* %dest, i32 %p_22
  %p_25 = add i32 %4, 72
  %p_arrayidx14 = getelementptr i32, i32* %dest, i32 %5
  %p_arrayidx1426 = getelementptr i32, i32* %dest, i32 %p_25
  %_p_scalar_ = load i32, i32* %p_d.018, align 4
  %_p_vec_ = insertelement <2 x i32> undef, i32 %_p_scalar_, i32 0
  %_p_scalar_27 = load i32, i32* %p_d.01823, align 4
  %_p_vec_28 = insertelement <2 x i32> %_p_vec_, i32 %_p_scalar_27, i32 1
  %13 = bitcast <2 x i32> %_p_vec_28 to i64
  %14 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %13, i32 31)
  %15 = bitcast i64 %14 to <2 x i32>
  %shr9p_vec = ashr <2 x i32> %_p_vec_28, %7
  %xorp_vec = xor <2 x i32> %15, %sub12p_vec
  %16 = bitcast <2 x i32> %shr9p_vec to i64
  %17 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %14, i64 %16)
  %18 = bitcast <2 x i32> %xorp_vec to i64
  %19 = tail call i64 @llvm.hexagon.C2.vmux(i32 %17, i64 %13, i64 %18)
  %20 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %19, i32 %gb)
  %21 = bitcast i64 %20 to <2 x i32>
  %22 = extractelement <2 x i32> %21, i32 0
  store i32 %22, i32* %p_arrayidx14, align 4
  %23 = extractelement <2 x i32> %21, i32 1
  store i32 %23, i32* %p_arrayidx1426, align 4
  store i32 %22, i32* %p_d.018, align 4
  store i32 %23, i32* %p_d.01823, align 4
  %p_21.1 = add i32 %4, 128
  %p_22.1 = add i32 %4, 192
  %p_d.018.1 = getelementptr i32, i32* %dest, i32 %p_21.1
  %p_d.01823.1 = getelementptr i32, i32* %dest, i32 %p_22.1
  %p_24.1 = add i32 %4, 136
  %p_25.1 = add i32 %4, 200
  %p_arrayidx14.1 = getelementptr i32, i32* %dest, i32 %p_24.1
  %p_arrayidx1426.1 = getelementptr i32, i32* %dest, i32 %p_25.1
  %_p_scalar_.1 = load i32, i32* %p_d.018.1, align 4
  %_p_vec_.1 = insertelement <2 x i32> undef, i32 %_p_scalar_.1, i32 0
  %_p_scalar_27.1 = load i32, i32* %p_d.01823.1, align 4
  %_p_vec_28.1 = insertelement <2 x i32> %_p_vec_.1, i32 %_p_scalar_27.1, i32 1
  %24 = bitcast <2 x i32> %_p_vec_28.1 to i64
  %25 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %24, i32 31)
  %26 = bitcast i64 %25 to <2 x i32>
  %shr9p_vec.1 = ashr <2 x i32> %_p_vec_28.1, %7
  %xorp_vec.1 = xor <2 x i32> %26, %sub12p_vec
  %27 = bitcast <2 x i32> %shr9p_vec.1 to i64
  %28 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %25, i64 %27)
  %29 = bitcast <2 x i32> %xorp_vec.1 to i64
  %30 = tail call i64 @llvm.hexagon.C2.vmux(i32 %28, i64 %24, i64 %29)
  %31 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %30, i32 %gb)
  %32 = bitcast i64 %31 to <2 x i32>
  %33 = extractelement <2 x i32> %32, i32 0
  store i32 %33, i32* %p_arrayidx14.1, align 4
  %34 = extractelement <2 x i32> %32, i32 1
  store i32 %34, i32* %p_arrayidx1426.1, align 4
  store i32 %33, i32* %p_d.018.1, align 4
  store i32 %34, i32* %p_d.01823.1, align 4
  %p_21.2 = add i32 %4, 256
  %p_22.2 = add i32 %4, 320
  %p_d.018.2 = getelementptr i32, i32* %dest, i32 %p_21.2
  %p_d.01823.2 = getelementptr i32, i32* %dest, i32 %p_22.2
  %p_24.2 = add i32 %4, 264
  %p_25.2 = add i32 %4, 328
  %p_arrayidx14.2 = getelementptr i32, i32* %dest, i32 %p_24.2
  %p_arrayidx1426.2 = getelementptr i32, i32* %dest, i32 %p_25.2
  %_p_scalar_.2 = load i32, i32* %p_d.018.2, align 4
  %_p_vec_.2 = insertelement <2 x i32> undef, i32 %_p_scalar_.2, i32 0
  %_p_scalar_27.2 = load i32, i32* %p_d.01823.2, align 4
  %_p_vec_28.2 = insertelement <2 x i32> %_p_vec_.2, i32 %_p_scalar_27.2, i32 1
  %35 = bitcast <2 x i32> %_p_vec_28.2 to i64
  %36 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %35, i32 31)
  %37 = bitcast i64 %36 to <2 x i32>
  %shr9p_vec.2 = ashr <2 x i32> %_p_vec_28.2, %7
  %xorp_vec.2 = xor <2 x i32> %37, %sub12p_vec
  %38 = bitcast <2 x i32> %shr9p_vec.2 to i64
  %39 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %36, i64 %38)
  %40 = bitcast <2 x i32> %xorp_vec.2 to i64
  %41 = tail call i64 @llvm.hexagon.C2.vmux(i32 %39, i64 %35, i64 %40)
  %42 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %41, i32 %gb)
  %43 = bitcast i64 %42 to <2 x i32>
  %44 = extractelement <2 x i32> %43, i32 0
  store i32 %44, i32* %p_arrayidx14.2, align 4
  %45 = extractelement <2 x i32> %43, i32 1
  store i32 %45, i32* %p_arrayidx1426.2, align 4
  store i32 %44, i32* %p_d.018.2, align 4
  store i32 %45, i32* %p_d.01823.2, align 4
  %p_21.3 = add i32 %4, 384
  %p_22.3 = add i32 %4, 448
  %p_d.018.3 = getelementptr i32, i32* %dest, i32 %p_21.3
  %p_d.01823.3 = getelementptr i32, i32* %dest, i32 %p_22.3
  %p_24.3 = add i32 %4, 392
  %p_25.3 = add i32 %4, 456
  %p_arrayidx14.3 = getelementptr i32, i32* %dest, i32 %p_24.3
  %p_arrayidx1426.3 = getelementptr i32, i32* %dest, i32 %p_25.3
  %_p_scalar_.3 = load i32, i32* %p_d.018.3, align 4
  %_p_vec_.3 = insertelement <2 x i32> undef, i32 %_p_scalar_.3, i32 0
  %_p_scalar_27.3 = load i32, i32* %p_d.01823.3, align 4
  %_p_vec_28.3 = insertelement <2 x i32> %_p_vec_.3, i32 %_p_scalar_27.3, i32 1
  %46 = bitcast <2 x i32> %_p_vec_28.3 to i64
  %47 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %46, i32 31)
  %48 = bitcast i64 %47 to <2 x i32>
  %shr9p_vec.3 = ashr <2 x i32> %_p_vec_28.3, %7
  %xorp_vec.3 = xor <2 x i32> %48, %sub12p_vec
  %49 = bitcast <2 x i32> %shr9p_vec.3 to i64
  %50 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %47, i64 %49)
  %51 = bitcast <2 x i32> %xorp_vec.3 to i64
  %52 = tail call i64 @llvm.hexagon.C2.vmux(i32 %50, i64 %46, i64 %51)
  %53 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %52, i32 %gb)
  %54 = bitcast i64 %53 to <2 x i32>
  %55 = extractelement <2 x i32> %54, i32 0
  store i32 %55, i32* %p_arrayidx14.3, align 4
  %56 = extractelement <2 x i32> %54, i32 1
  store i32 %56, i32* %p_arrayidx1426.3, align 4
  store i32 %55, i32* %p_d.018.3, align 4
  store i32 %56, i32* %p_d.01823.3, align 4
  %p_21.4 = add i32 %4, 512
  %p_22.4 = add i32 %4, 576
  %p_d.018.4 = getelementptr i32, i32* %dest, i32 %p_21.4
  %p_d.01823.4 = getelementptr i32, i32* %dest, i32 %p_22.4
  %p_24.4 = add i32 %4, 520
  %p_25.4 = add i32 %4, 584
  %p_arrayidx14.4 = getelementptr i32, i32* %dest, i32 %p_24.4
  %p_arrayidx1426.4 = getelementptr i32, i32* %dest, i32 %p_25.4
  %_p_scalar_.4 = load i32, i32* %p_d.018.4, align 4
  %_p_vec_.4 = insertelement <2 x i32> undef, i32 %_p_scalar_.4, i32 0
  %_p_scalar_27.4 = load i32, i32* %p_d.01823.4, align 4
  %_p_vec_28.4 = insertelement <2 x i32> %_p_vec_.4, i32 %_p_scalar_27.4, i32 1
  %57 = bitcast <2 x i32> %_p_vec_28.4 to i64
  %58 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %57, i32 31)
  %59 = bitcast i64 %58 to <2 x i32>
  %shr9p_vec.4 = ashr <2 x i32> %_p_vec_28.4, %7
  %xorp_vec.4 = xor <2 x i32> %59, %sub12p_vec
  %60 = bitcast <2 x i32> %shr9p_vec.4 to i64
  %61 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %58, i64 %60)
  %62 = bitcast <2 x i32> %xorp_vec.4 to i64
  %63 = tail call i64 @llvm.hexagon.C2.vmux(i32 %61, i64 %57, i64 %62)
  %64 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %63, i32 %gb)
  %65 = bitcast i64 %64 to <2 x i32>
  %66 = extractelement <2 x i32> %65, i32 0
  store i32 %66, i32* %p_arrayidx14.4, align 4
  %67 = extractelement <2 x i32> %65, i32 1
  store i32 %67, i32* %p_arrayidx1426.4, align 4
  store i32 %66, i32* %p_d.018.4, align 4
  store i32 %67, i32* %p_d.01823.4, align 4
  %p_21.5 = add i32 %4, 640
  %p_22.5 = add i32 %4, 704
  %p_d.018.5 = getelementptr i32, i32* %dest, i32 %p_21.5
  %p_d.01823.5 = getelementptr i32, i32* %dest, i32 %p_22.5
  %p_24.5 = add i32 %4, 648
  %p_25.5 = add i32 %4, 712
  %p_arrayidx14.5 = getelementptr i32, i32* %dest, i32 %p_24.5
  %p_arrayidx1426.5 = getelementptr i32, i32* %dest, i32 %p_25.5
  %_p_scalar_.5 = load i32, i32* %p_d.018.5, align 4
  %_p_vec_.5 = insertelement <2 x i32> undef, i32 %_p_scalar_.5, i32 0
  %_p_scalar_27.5 = load i32, i32* %p_d.01823.5, align 4
  %_p_vec_28.5 = insertelement <2 x i32> %_p_vec_.5, i32 %_p_scalar_27.5, i32 1
  %68 = bitcast <2 x i32> %_p_vec_28.5 to i64
  %69 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %68, i32 31)
  %70 = bitcast i64 %69 to <2 x i32>
  %shr9p_vec.5 = ashr <2 x i32> %_p_vec_28.5, %7
  %xorp_vec.5 = xor <2 x i32> %70, %sub12p_vec
  %71 = bitcast <2 x i32> %shr9p_vec.5 to i64
  %72 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %69, i64 %71)
  %73 = bitcast <2 x i32> %xorp_vec.5 to i64
  %74 = tail call i64 @llvm.hexagon.C2.vmux(i32 %72, i64 %68, i64 %73)
  %75 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %74, i32 %gb)
  %76 = bitcast i64 %75 to <2 x i32>
  %77 = extractelement <2 x i32> %76, i32 0
  store i32 %77, i32* %p_arrayidx14.5, align 4
  %78 = extractelement <2 x i32> %76, i32 1
  store i32 %78, i32* %p_arrayidx1426.5, align 4
  store i32 %77, i32* %p_d.018.5, align 4
  store i32 %78, i32* %p_d.01823.5, align 4
  %p_21.6 = add i32 %4, 768
  %p_22.6 = add i32 %4, 832
  %p_d.018.6 = getelementptr i32, i32* %dest, i32 %p_21.6
  %p_d.01823.6 = getelementptr i32, i32* %dest, i32 %p_22.6
  %p_24.6 = add i32 %4, 776
  %p_25.6 = add i32 %4, 840
  %p_arrayidx14.6 = getelementptr i32, i32* %dest, i32 %p_24.6
  %p_arrayidx1426.6 = getelementptr i32, i32* %dest, i32 %p_25.6
  %_p_scalar_.6 = load i32, i32* %p_d.018.6, align 4
  %_p_vec_.6 = insertelement <2 x i32> undef, i32 %_p_scalar_.6, i32 0
  %_p_scalar_27.6 = load i32, i32* %p_d.01823.6, align 4
  %_p_vec_28.6 = insertelement <2 x i32> %_p_vec_.6, i32 %_p_scalar_27.6, i32 1
  %79 = bitcast <2 x i32> %_p_vec_28.6 to i64
  %80 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %79, i32 31)
  %81 = bitcast i64 %80 to <2 x i32>
  %shr9p_vec.6 = ashr <2 x i32> %_p_vec_28.6, %7
  %xorp_vec.6 = xor <2 x i32> %81, %sub12p_vec
  %82 = bitcast <2 x i32> %shr9p_vec.6 to i64
  %83 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %80, i64 %82)
  %84 = bitcast <2 x i32> %xorp_vec.6 to i64
  %85 = tail call i64 @llvm.hexagon.C2.vmux(i32 %83, i64 %79, i64 %84)
  %86 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %85, i32 %gb)
  %87 = bitcast i64 %86 to <2 x i32>
  %88 = extractelement <2 x i32> %87, i32 0
  store i32 %88, i32* %p_arrayidx14.6, align 4
  %89 = extractelement <2 x i32> %87, i32 1
  store i32 %89, i32* %p_arrayidx1426.6, align 4
  store i32 %88, i32* %p_d.018.6, align 4
  store i32 %89, i32* %p_d.01823.6, align 4
  %p_21.7 = add i32 %4, 896
  %p_22.7 = add i32 %4, 960
  %p_d.018.7 = getelementptr i32, i32* %dest, i32 %p_21.7
  %p_d.01823.7 = getelementptr i32, i32* %dest, i32 %p_22.7
  %p_24.7 = add i32 %4, 904
  %p_25.7 = add i32 %4, 968
  %p_arrayidx14.7 = getelementptr i32, i32* %dest, i32 %p_24.7
  %p_arrayidx1426.7 = getelementptr i32, i32* %dest, i32 %p_25.7
  %_p_scalar_.7 = load i32, i32* %p_d.018.7, align 4
  %_p_vec_.7 = insertelement <2 x i32> undef, i32 %_p_scalar_.7, i32 0
  %_p_scalar_27.7 = load i32, i32* %p_d.01823.7, align 4
  %_p_vec_28.7 = insertelement <2 x i32> %_p_vec_.7, i32 %_p_scalar_27.7, i32 1
  %90 = bitcast <2 x i32> %_p_vec_28.7 to i64
  %91 = tail call i64 @llvm.hexagon.S2.asr.i.vw(i64 %90, i32 31)
  %92 = bitcast i64 %91 to <2 x i32>
  %shr9p_vec.7 = ashr <2 x i32> %_p_vec_28.7, %7
  %xorp_vec.7 = xor <2 x i32> %92, %sub12p_vec
  %93 = bitcast <2 x i32> %shr9p_vec.7 to i64
  %94 = tail call i32 @llvm.hexagon.A2.vcmpweq(i64 %91, i64 %93)
  %95 = bitcast <2 x i32> %xorp_vec.7 to i64
  %96 = tail call i64 @llvm.hexagon.C2.vmux(i32 %94, i64 %90, i64 %95)
  %97 = tail call i64 @llvm.hexagon.S2.asl.r.vw(i64 %96, i32 %gb)
  %98 = bitcast i64 %97 to <2 x i32>
  %99 = extractelement <2 x i32> %98, i32 0
  store i32 %99, i32* %p_arrayidx14.7, align 4
  %100 = extractelement <2 x i32> %98, i32 1
  store i32 %100, i32* %p_arrayidx1426.7, align 4
  store i32 %99, i32* %p_d.018.7, align 4
  store i32 %100, i32* %p_d.01823.7, align 4
  ret void
}

declare i64 @llvm.hexagon.S2.asr.i.vw(i64, i32) #1

declare i64 @llvm.hexagon.S2.asl.i.vw(i64, i32) #1

declare i64 @llvm.hexagon.A2.combinew(i32, i32) #1

declare i32 @llvm.hexagon.A2.vcmpweq(i64, i64) #1

declare i64 @llvm.hexagon.C2.vmux(i32, i64, i64) #1

declare i64 @llvm.hexagon.S2.asl.r.vw(i64, i32) #1

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone }

!0 = !{!"int", !1}
!1 = !{!"omnipotent char", !2}
!2 = !{!"Simple C/C++ TBAA"}
                                                                           print dialog. This can normally be done through
      <gui style="menuitem">Print</gui> in the menu or using the
      <keyseq><key>Ctrl</key><key>P</key></keyseq> keyboard shortcut.</p>
    </item>
    <item>
      <p>Click the <gui>Properties‚Ä¶</gui> button </p>
      <p>In the <gui>Orientation</gui> drop-down list, make sure that
      <gui>Landscape</gui> is selected.</p>
      <p>Click <gui>OK</gui> to go back to the print dialog.</p>
    </item>
    <item>
      <p>Under <gui>Range and Copies</gui>, choose <gui>Pages</gui>.</p>
      <p>Êåâ‰∏ãÈù¢ÁöÑÈ°∫Â∫èËæìÂÖ•È°µÊï∞(n Ë°®Á§∫ÊÄªÁöÑÈ°µÊï∞ÔºåÂ∫îÂΩìÊòØ4ÁöÑÂÄçÊï∞)Ôºö</p>
      <p>n, 1, 2, n-1, n-2, 3, 4, n-3, n-4, 5, 6, n-5, n-6, 7, 8, n-7, n-8, 9, 10, n-9, n-10, 11, 12, n-11‚Ä¶</p>
      <p>‚Ä¶Áõ¥Âà∞ÊÇ®ËæìÂÆåÊâÄÊúâÈ°µ„ÄÇ</p>
    <note>
      <p>‰æãÂ¶ÇÔºö</p>
      <p>4È°µÂ∞èÂÜåÂ≠êÔºöËæìÂÖ• <input>4,1,2,3</input></p>
      <p>8È°µÂ∞èÂÜåÂ≠êÔºöËæìÂÖ• <input>8,1,2,7,6,3,4,5</input></p>
      <p>12È°µÂ∞èÂÜåÂ≠êÔºöËæìÂÖ• <input>12,1,2,11,10,3,4,9,8,5,6,7</input></p>
      <p>16È°µÂ∞èÂÜåÂ≠êÔºöËæìÂÖ• <input>16,1,2,15,14,3,4,13,12,5,6,11,10,7,8,9</input></p>
      <p>20È°µÂ∞èÂÜåÂ≠êÔºöËæìÂÖ• <input>20,1,2,19,18,3,4,17,16,5,6,15,14,7,8,13,12,9,10,11</input></p>
     </note>
    </item>
    <item>
      <p>Choose the <gui>Page Layout</gui> tab.</p>
      <p>Under <gui>Layout</gui>, select <gui>Brochure</gui>.</p>
      <p>Under <gui>Page Sides</gui>, in the <gui>Include</gui> drop-down list,
      select <gui>Front sides / right pages</gui>.</p>
    </item>
    <item>
      <p>ÁÇπÂáª<gui>ÊâìÂç∞</gui>ÊåâÈíÆ„ÄÇ</p>
    </item>
    <item>
      <p>ÊâìÂç∞Âá∫Êù•‰ª•ÂêéÔºåÊääÁ∫∏ÁøªËøáÊù•ÁÑ∂ÂêéÂÜçÊîæÂõûÂà∞ÊâìÂç∞Êú∫‰∏ä„ÄÇ</p>
    </item>
    <item>
      <p>Open the print dialog. This can normally be done through
      <gui style="menuitem">Print</gui> in the menu or using the
      <keyseq><key>Ctrl</key><key>P</key></keyseq> keyboard shortcut.</p>
    </item>
    <item>
      <p>Choose the <gui>Page Layout</gui> tab.</p>
      <p>Under <gui>Page Sides</gui>, in the <gui>Include</gui> drop-down list,
      select <gui>Back sides / left pages</gui>.</p>
    </item>
    <item>
      <p>ÁÇπÂáª<gui>ÊâìÂç∞</gui>ÊåâÈíÆ„ÄÇ</p>
    </item>
  </steps>

</page>
                                                                                                                                                                                                                                                                                                                                                                     â      (               2020.2.1f1 ˛ˇˇˇ      ˇˇföÜ!Î5ò9›4Q¡ÛB   Ì          7  Äˇˇˇˇ     Ä            ¶ Ä≤ Ä                      E Ä                   ﬁ  Ä#          Ä           . Ä,          Ä           5   a Ä                   ﬁ  Ä#          Ä           . Ä,          Ä           Ü Är Ä                   ﬁ  Ä#      	    Ä           . Ä,      
    Ä           H Ä´ Äˇˇˇˇ   Ä          1  Ä1  Äˇˇˇˇ   @           ﬁ  Ä Ä                  Q  Äj  Ä                  Ò  ÄJ   ˇˇˇˇ    ¿           1  Ä1  Äˇˇˇˇ    Ä            ﬁ  Ä Ä                     Äj  Äˇˇˇˇ    Ä            \   õ  Äˇˇˇˇ    Ä            H Är   ˇˇˇˇ    Ä           1  Ä1  Äˇˇˇˇ   @            ﬁ  Ä Ä                   Q  Äj  Ä                   H Äw   ˇˇˇˇ    Ä           1  Ä1  Äˇˇˇˇ   @            ﬁ  Ä Ä                   Q  Äj  Ä                   H ÄÄ   ˇˇˇˇ    Ä           1  Ä1  Äˇˇˇˇ   @            ﬁ  Ä Ä                   Q  Äj  Ä                   y Ä
 Ä                     ﬁ  Ä#      !    Ä           . Ä,      "    Ä            ÄÖ   ˇˇˇˇ#   @          1  Ä1  Äˇˇˇˇ$               ﬁ  Ä Ä   %               . Äj  Ä   &               ’ Äì   ˇˇˇˇ'    Ä           1  Ä1  Äˇˇˇˇ(    ¿            ﬁ  Ä Ä   )                  Äj  Äˇˇˇˇ*    Ä            H Äõ  Äˇˇˇˇ+    Ä           1  Ä1  Äˇˇˇˇ,   @            ﬁ  Ä Ä   -                Q  Äj  Ä   .                y Ä
 Ä   /                 ﬁ  Ä#      0    Ä           . Ä,      1    Ä             Äß      2    @            æ Ä∂      3    @            ﬁ  Ä#      4    Ä           . Ä,      5    Ä           H Äª   ˇˇˇˇ6   Ä           1  Ä1  Äˇˇˇˇ7   @            ﬁ  Ä Ä   8                Q  Äj  Ä   9                H Ä∆   ˇˇˇˇ:   Ä           1  Ä1  Äˇˇˇˇ;   @            ﬁ  Ä Ä   <                Q  Äj  Ä   =                H Äÿ   ˇˇˇˇ>   Ä           1  Ä1  Äˇˇˇˇ?   @            ﬁ  Ä Ä   @                Q  Äj  Ä   A              MonoImporter PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_ExternalObjects SourceAssetIdentifier type assembly name m_UsedFileIDs m_DefaultReferences executionOrder icon m_UserData m_AssetBundleName m_AssetBundleVariant     s    ˇˇ£GÒ◊‹èZ56†:!@i¡J*   Å       Ä7  Äˇˇˇˇ     Ä            ¶ Ä≤ Ä                       E Ä                   ﬁ  Ä          Ä           . Ä          Ä           (   a Ä                   ﬁ  Ä          Ä           . Ä          Ä           Ü Är Ä                   ﬁ  Ä      	    Ä           . Ä      
    Ä           H Ä´ Äˇˇˇˇ   Ä          1  Ä1  Äˇˇˇˇ   @           ﬁ  Ä Ä                  Q  Äj  Ä                  H ÄÍ Äˇˇˇˇ   Ä           1  Ä1  Äˇˇˇˇ   @            ﬁ  Ä Ä                   Q  Äj  Ä                   Ò  Ä=   ˇˇˇˇ   Ä           1  Ä1  Äˇˇˇˇ   Ä            ﬁ  Ä Ä                    Äj  Äˇˇˇˇ   Ä            H Äõ  Äˇˇˇˇ   Ä           1  Ä1  Äˇˇˇˇ   @            ﬁ  Ä Ä                   Q  Äj  Ä                   y Ä
 Ä                   ﬁ  Ä          Ä           . Ä          Ä           y ÄQ                       ﬁ  Ä          Ä           . Ä           Ä           ﬁ  ÄX      !                H Äi   ˇˇˇˇ"   Ä           1  Ä1  Äˇˇˇˇ#   @            ﬁ  Ä Ä   $                Q  Äj  Ä   %                H Äu   ˇˇˇˇ&   Ä           1  Ä1  Äˇˇˇˇ'   @            ﬁ  Ä Ä   (                Q  Äj  Ä   )              PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_DefaultReferences m_Icon m_ExecutionOrder m_ClassName m_Namespace                       \       ‡yØ     `       »                                                                                                                                            ‡yØ                                                                                    CollabSetting   Z  // using UnityEditor;
// using UnityEditor.SettingsManagement;
// using UnityEngine;
//
// namespace Unity.Cloud.Collaborate.Settings
// {
//     internal class CollabSetting<T> : UserSetting<T>
//     {
//         public CollabSetting(string key, T value, SettingsScope scope = SettingsScope.Project)
//             : base(CollabSettingsManager.instance, key, value, scope)
//         {}
//
//         CollabSetting(UnityEditor.SettingsManagement.Settings settings, string key, T value, SettingsScope scope = SettingsScope.Project)
//             : base(settings, key, value, scope) { }
//     }
// }
                         CollabSetting                                                                                                                                                                                                                               a_256_cfb128         OBJ_camellia,44L

#define SN_camellia_128_cfb1            "CAMELLIA-128-CFB1"
#define LN_camellia_128_cfb1            "camellia-128-cfb1"
#define NID_camellia_128_cfb1           760

#define SN_camellia_192_cfb1            "CAMELLIA-192-CFB1"
#define LN_camellia_192_cfb1            "camellia-192-cfb1"
#define NID_camellia_192_cfb1           761

#define SN_camellia_256_cfb1            "CAMELLIA-256-CFB1"
#define LN_camellia_256_cfb1            "camellia-256-cfb1"
#define NID_camellia_256_cfb1           762

#define SN_camellia_128_cfb8            "CAMELLIA-128-CFB8"
#define LN_camellia_128_cfb8            "camellia-128-cfb8"
#define NID_camellia_128_cfb8           763

#define SN_camellia_192_cfb8            "CAMELLIA-192-CFB8"
#define LN_camellia_192_cfb8            "camellia-192-cfb8"
#define NID_camellia_192_cfb8           764

#define SN_camellia_256_cfb8            "CAMELLIA-256-CFB8"
#define LN_camellia_256_cfb8            "camellia-256-cfb8"
#define NID_camellia_256_cfb8           765

#define SN_kisa         "KISA"
#define LN_kisa         "kisa"
#define NID_kisa                773
#define OBJ_kisa                OBJ_member_body,410L,200004L

#define SN_seed_ecb             "SEED-ECB"
#define LN_seed_ecb             "seed-ecb"
#define NID_seed_ecb            776
#define OBJ_seed_ecb            OBJ_kisa,1L,3L

#define SN_seed_cbc             "SEED-CBC"
#define LN_seed_cbc             "seed-cbc"
#define NID_seed_cbc            777
#define OBJ_seed_cbc            OBJ_kisa,1L,4L

#define SN_seed_cfb128          "SEED-CFB"
#define LN_seed_cfb128          "seed-cfb"
#define NID_seed_cfb128         779
#define OBJ_seed_cfb128         OBJ_kisa,1L,5L

#define SN_seed_ofb128          "SEED-OFB"
#define LN_seed_ofb128          "seed-ofb"
#define NID_seed_ofb128         778
#define OBJ_seed_ofb128         OBJ_kisa,1L,6L

#define SN_hmac         "HMAC"
#define LN_hmac 