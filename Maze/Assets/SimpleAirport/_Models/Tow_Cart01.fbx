// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RemotingProxy.cs
**
**
** Purpose: Defines the general purpose remoting proxy
**
**
===========================================================*/
namespace System.Runtime.Remoting.Proxies {
    using System.Threading;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Channels;
    using System;
    using MethodInfo = System.Reflection.MethodInfo;
    using MethodBase = System.Reflection.MethodBase;
    using System.Globalization;
    // Remoting proxy
    [System.Security.SecurityCritical]  // auto-generated
    internal class RemotingProxy : RealProxy, IRemotingTypeInfo 
    {
        // Static Fields
        private static MethodInfo _getTypeMethod = typeof(System.Object).GetMethod("GetType");
        private static MethodInfo _getHashCodeMethod = typeof(System.Object).GetMethod("GetHashCode");

        private static RuntimeType s_typeofObject = (RuntimeType)typeof(System.Object);
        private static RuntimeType s_typeofMarshalByRefObject = (RuntimeType)typeof(System.MarshalByRefObject);

        //*******************WARNING******************************************
        // If you change the names of these fields then change the corresponding
        // names in remoting.cpp 
        //********************************************************************        
        private ConstructorCallMessage _ccm;
        private int _ctorThread;
            

        // Constructor
        public RemotingProxy(Type serverType)        
        : base(serverType) 
        {            
        }

        private RemotingProxy()
        {
            // Prevent anyone from creating a blank instance of a proxy
            // without the underlying server type
        }

        internal int CtorThread
        {
            get
            {
                return _ctorThread;
            }
            set
            {
                //NOTE : the assert below is correct for activated objects. 
                //But for a connected object (where new XXX() does a Connect()
                //the InternalActivate codepath may execute twice .. since
                //we would be returning the same proxy for multiple calls to
                //new XXX() & JIT would try to execute the default .ctor on
                //the returned proxy. 
                
                //BCLDebug.Assert(_ctorThread == 0, "ctorThread already set??");
                _ctorThread = value;
            }
        }

        // This is used when a TP is called with SyncProcessMessage
        internal static IMessage CallProcessMessage(IMessageSink ms, 
                                                    IMessage reqMsg, 
                                                    ArrayWithSize proxySinks,
                                                    Thread currentThread,
                                                    Context currentContext,
                                                    bool bSkippingContextChain)
        {                   
            // Notify Dynamic Sinks: CALL starting          
            if (proxySinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                            reqMsg, 
                                            proxySinks, 
                                            true,   // bCliSide
                                            true,   // bStart
                                            false); // bAsync
            }

            bool bHasDynamicSinks = false;
            if (bSkippingContextChain)
            {
                // this would have been done in the client context terminator sink
                bHasDynamicSinks = 
                    currentContext.NotifyDynamicSinks(reqMsg, 
                        true,   // bCliSide
                        true,   // bStart
                        false,  // bAsync
                        true);  // bNotifyGlobals 
   
                ChannelServices.NotifyProfiler(reqMsg, RemotingProfilerEvent.ClientSend);
            }
            
            if (ms == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Proxy_NoChannelSink"));                    
            }

            IMessage retMsg = ms.SyncProcessMessage(reqMsg);

            if (bSkippingContextChain)
            {
                // this would have been done in the client context terminator sink
                ChannelServices.NotifyProfiler(retMsg, RemotingProfilerEvent.ClientReceive);

                if (bHasDynamicSinks)
                {
                    currentContext.NotifyDynamicSinks(
                        retMsg, 
                        true,   // bCliSide
                        false,   // bStart
                        false,  // bAsync
                        true);  // bNotifyGlobals  
                }
            }            

            IMethodReturnMessage mrm = retMsg as IMethodReturnMessage;
            if (retMsg == null || mrm == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Message_BadType"));                    
            }

            // notify DynamicSinks: CALL returned
            if (proxySinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                            retMsg, 
                                            proxySinks, 
                                            true,   // bCliSide
                                            false,  // bStart
                                            false); // bAsync
            }

           
            return retMsg;
        }

        // Implement Invoke
        [System.Security.SecurityCritical]
        public override IMessage Invoke(IMessage reqMsg) 
        {
            // Dispatch based on whether its a constructor call
            // or a method call

            IConstructionCallMessage ccm = reqMsg as IConstructionCallMessage;        
            
            if(ccm != null)
            {
                // Activate
                return InternalActivate(ccm);
            }
            else
            {
                // Handle regular method calls

                // Check that the initialization has completed
                if(!Initialized)
                {
                    // This covers the case where an object may call out
                    // on another object passing its "this" pointer during its
                    // .ctor. 
                    // The other object attempting to call on the this pointer
                    // (in x-context case) would be calling on a proxy not
                    // marked fully initialized. 
                    // <



                    // Let the original constructor thread go through but 
                    // throw for other threads. 
                    if (CtorThread == Thread.CurrentThread.GetHashCode())
                    {
                        ServerIdentity srvId = IdentityObject as ServerIdentity;
                        BCLDebug.Assert(
                            srvId != null
                            && 
                            ((ServerIdentity)IdentityObject).ServerContext != null,
                            "Wrap may associate with wrong context!");

                        // If we are here, the server object passed itself 
                        // out to another x-context object during the .ctor
                        // That guy is calling us back. Let us call Wrap() 
                        // earlier than usual so that envoy & channel sinks
                        // get set up!
                        // <



                        RemotingServices.Wrap( 
                            (ContextBoundObject) this.UnwrappedServerObject);

                    }
                    else
                    {
                        // Throw an exception to indicate that we are 
                        // calling on a proxy while the constructor call 
                        // is still running.
                        throw new RemotingException(Environment.GetResourceString("Remoting_Proxy_InvalidCall"));
                    }
                    
                }
                
                // Dispatch
                int callType = Message.Sync;
                Message msg = reqMsg as Message;
                if (msg != null)
                {
                    callType = msg.GetCallType(); 
                }                
                
                return InternalInvoke((IMethodCallMessage)reqMsg, false, callType);
            }
            
        } // Invoke
        

        // This is called for all remoted calls on a TP except Ctors
        // The method called may be Sync, Async or OneWay(special case of Async)
        // In the Async case we come here for both BeginInvoke & EndInvoke
        internal virtual IMessage InternalInvoke(
            IMethodCallMessage reqMcmMsg, bool useDispatchMessage, int callType)
        {
            Message reqMsg = reqMcmMsg as Message;            
            if ((reqMsg == null) && (callType != Message.Sync))
            {
                // Only the synchronous call type is supported for messages that
                //   aren't of type Message.               
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Proxy_InvalidCallType"));
            }
        
            IMessage retMsg = null;
            Thread currentThread = Thread.CurrentThread;

            // pick up call context from the thread
            LogicalCallContext cctx = currentThread.GetMutableExecutionContext().LogicalCallContext;

            Identity idObj = IdentityObject;
            ServerIdentity serverID = idObj as ServerIdentity;
            if ((null != serverID) && idObj.IsFullyDisconnected())
            {
                throw new ArgumentException(
                   Environment.GetResourceString("Remoting_ServerObjectNotFound", reqMcmMsg.Uri));
            }

            // Short-circuit calls to Object::GetType and Object::GetHashCode
            MethodBase mb = reqMcmMsg.MethodBase;
            if(_getTypeMethod == mb)
            {
                // Time to load the true type of the remote object....
                Type t = GetProxiedType();
                return new ReturnMessage(t, null, 0, cctx, reqMcmMsg);
            }

            if (_getHashCodeMethod == mb)
            {
                int hashCode = idObj.GetHashCode();
                return new ReturnMessage(hashCode, null, 0, cctx, reqMcmMsg);
            }

            // check for channel sink
            if (idObj.ChannelSink == null)
            {
                IMessageSink chnlSink = null;
                IMessageSink envoySink = null;
                // If channelSink is null try to Create them again
                // the objref should be correctly fixed up at this point
                if(!idObj.ObjectRef.IsObjRefLite())
                {
                    RemotingServices.CreateEnvoyAndChannelSinks(null, idObj.ObjectRef, out chnlSink, out envoySink);
                }
                else
                {
                    RemotingServices.CreateEnvoyAndChannelSinks(idObj.ObjURI, null, out chnlSink, out envoySink);
                }
                // Set the envoy and channel sinks in a thread safe manner
                RemotingServices.SetEnvoyAndChannelSinks(idObj, chnlSink, envoySink);

                // If the channel sink is still null then throw
                if(idObj.ChannelSink == null)
                {
                    throw new RemotingException(
                        Environment.GetResourceString("Remoting_Proxy_NoChannelSink"));
                }
            }

            // Set the identity in the message object
            IInternalMessage iim = (IInternalMessage)reqMcmMsg;
            iim.IdentityObject = idObj;

            if (null != serverID)
            {
                Message.DebugOut("Setting serveridentity on message \n");
                iim.ServerIdentityObject = serverID;
                    
            }
            else
            {
                // We need to set the URI only for identities that 
                // are not the server identities. The uri is used to
                // dispatch methods for objects outside the appdomain.
                // Inside the appdomain (xcontext case) we dispatch 
                // by getting the server object from the server identity.
               iim.SetURI(idObj.URI);
            }       

            Message.DebugOut("InternalInvoke. Dispatching based on class type\n");
            AsyncResult ar = null;
            switch (callType)
            {
            case Message.Sync:
                Message.DebugOut("RemotingProxy.Invoke Call: SyncProcessMsg\n");
                BCLDebug.Assert(!useDispatchMessage,"!useDispatchMessage");                
                bool bSkipContextChain = false;
                Context currentContext = currentThread.GetCurrentContextInternal();
                IMessageSink nextSink = idObj.EnvoyChain;

                // if we are in the default context, there can be no 
                // client context chain, so we can skip the intermediate 
                // calls if there are no envoy sinks

                if (currentContext.IsDefaultContext)
                {
                    if (nextSink is EnvoyTerminatorSink)
                    {
                        bSkipContextChain = true;

                        // jump directly to the channel sink
                        nextSink = idObj.ChannelSink;
                    }
                }

                retMsg = CallProcessMessage(nextSink,
                                            reqMcmMsg, 
                                            idObj.ProxySideDynamicSinks,
                                            currentThread,
                                            currentContext,
                                            bSkipContextChain);

                break;

            case Message.BeginAsync:
            case Message.BeginAsync | Message.OneWay:                                        
                // For async calls we clone the call context from the thread
                // This is a limited clone (we dont deep copy the user data)
                cctx = (LogicalCallContext) cctx.Clone(); 
                iim.SetCallContext(cctx);  
                
                ar = new AsyncResult(reqMsg);
              
                InternalInvokeAsync(ar, reqMsg, useDispatchMessage, callType);

                Message.DebugOut("Propagate out params for BeginAsync\n");
                retMsg = new ReturnMessage(ar, null, 0, null/*cctx*/, reqMsg);
                break;

            case Message.OneWay:
                // For async calls we clone the call context from the thread
                // This is a limited clone (we dont deep copy the user data)
                cctx = (LogicalCallContext) cctx.Clone();
                iim.SetCallContext(cctx);
                InternalInvokeAsync(null, reqMsg, useDispatchMessage, callType);
                retMsg = new ReturnMessage(null, null, 0, null/*cctx*/, reqMcmMsg);
                break;

            case (Message.EndAsync | Message.OneWay):
                retMsg = new ReturnMessage(null, null, 0, null/*cctx*/, reqMcmMsg);
                break;

            case Message.EndAsync:
                // For endAsync, we merge back the returned callContext
                // into the thread's callContext
                retMsg = RealProxy.EndInvokeHelper(reqMsg, true);
                break;
            }
            
            return retMsg;
        }


        // This is called from InternalInvoke above when someone makes an
        // Async (or a one way) call on a TP
        internal void InternalInvokeAsync(IMessageSink ar,  Message reqMsg, 
            bool useDispatchMessage, int callType)
        {
            IMessageCtrl cc = null;
            Identity idObj = IdentityObject;
            ServerIdentity serverID = idObj as ServerIdentity;
            MethodCall cpyMsg= new MethodCall(reqMsg);
            IInternalMessage iim = ((IInternalMessage)cpyMsg);

            // Set the identity in the message object
            iim.IdentityObject = idObj;
            if (null != serverID)
            {
                Message.DebugOut("Setting SrvID on deser msg\n");
                iim.ServerIdentityObject = serverID;                    
            }

            if (useDispatchMessage)
            {
                Message.DebugOut(
                    "RemotingProxy.Invoke: Calling AsyncDispatchMessage\n");

                BCLDebug.Assert(ar != null,"ar != null");
                BCLDebug.Assert( (callType & Message.BeginAsync) != 0,
                                "BeginAsync flag not set!");

                Message.DebugOut("Calling AsynDispatchMessage \n");
                cc = ChannelServices.AsyncDispatchMessage(
                                        cpyMsg, 
                                        ((callType & Message.OneWay) != 0) 
                                        ? null : ar);
            }
            else if (null != idObj.EnvoyChain)
            {
                Message.DebugOut("RemotingProxy.Invoke: Calling AsyncProcessMsg on the envoy chain\n");

                cc = idObj.EnvoyChain.AsyncProcessMessage(
                                        cpyMsg, 
                                        ((callType & Message.OneWay) != 0) 
                                        ? null : ar);
            }
            else
            {
                // Channel sink cannot be null since it is the last sink in
                // the client context
                // Assert if Invoke is called without a channel sink
                BCLDebug.Assert(false, "How did we get here?");
                
                throw new InvalidOperationException(
                    Environment.GetResourceString("Remoting_Proxy_InvalidState"));
            }

            if ((callType & Message.BeginAsync) != 0)
            {

                if ((callType & Message.OneWay) != 0)
                {
                    ar.SyncProcessMessage(null);
                }
            }
        }

        // New method for activators.
        
        // This gets called during remoting intercepted activation when 
        // JIT tries to run a constructor on a TP (which remoting gave it
        // in place of an actual uninitialized instance of the expected type)
        private IConstructionReturnMessage InternalActivate(IConstructionCallMessage ctorMsg)
        {
            // Remember the hashcode of the constructor thread.
            CtorThread = Thread.CurrentThread.GetHashCode();

            IConstructionReturnMessage ctorRetMsg = ActivationServices.Activate(this, ctorMsg);

            // Set the flag to indicate that the object is initialized
            // Note: this assert is not valid for WKOs
            //BCLDebug.Assert(!Initialized, "Proxy marked as initialized before activation call completed");
            Initialized = true;

            return ctorRetMsg;
        }

        // Invoke for case where call is in the same context as the server object
        // (This special static method is used for AsyncDelegate-s ... this is called
        // directly from the EE)
        private static void Invoke(Object NotUsed, ref MessageData msgData)
        {
            Message m = new Message();
            m.InitFields(msgData);

            Object thisPtr = m.GetThisPtr();
            Delegate d;
            if ((d = thisPtr as Delegate) != null)
            {
                // <

                RemotingProxy rp = (RemotingProxy)
                    RemotingServices.GetRealProxy(d.Target);

                if (rp != null)
                {
                    rp.InternalInvoke(m, true, m.GetCallType());
                }
                else
                {
                    int callType = m.GetCallType();       
                    AsyncResult ar;
                    switch (callType)
                    {
                    case Message.BeginAsync:
                    case Message.BeginAsync | Message.OneWay:
                        // pick up call context from the thread
                        m.Properties[Message.CallContextKey] =
                            Thread.CurrentThread.GetMutableExecutionContext().LogicalCallContext.Clone();
                        ar = new AsyncResult(m);
                        AgileAsyncWorkerItem  workItem = 
                            new AgileAsyncWorkerItem(
                                    m, 
                                    ((callType & Message.OneWay) != 0) ? 
                                        null : ar, d.Target);

                        ThreadPool.QueueUserWorkItem(
                            new WaitCallback(
                                    AgileAsyncWorkerItem.ThreadPoolCallBack),
                            workItem);

                        if ((callType & Message.OneWay) != 0)
                        {
                            ar.SyncProcessMessage(null);
                        }
                        m.PropagateOutParameters(null, ar);
                        break;
                    case (Message.EndAsync | Message.OneWay):
                        return;

                    case Message.EndAsync:
                        // This will also merge back the call context
                        // onto the thread that called EndAsync
                        RealProxy.EndInvokeHelper(m, false);
                        break;
                    default:
                        BCLDebug.Assert(
                            false, 
                            "Should never be here. Sync delegate code for agile object ended up in remoting");
                        break;
                    }
                }
            }
            else
            {
                // Static invoke called with incorrect this pointer ...
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));                    
            }
        }

        internal ConstructorCallMessage ConstructorMessage
        {
            get
            {
                return _ccm;
            }

            set
            {
                _ccm = value;
            }
        }

        //
        // IRemotingTypeInfo interface
        //

        // Obtain the fully qualified name of the type that the proxy represents
        public String TypeName 
        {
            [System.Security.SecurityCritical]
            get
            {
                return GetProxiedType().FullName;
            }

            [System.Security.SecurityCritical]
            set
            {
                throw new NotSupportedException();
            }
        }

        // interop methods
        [System.Security.SecurityCritical]
        public override IntPtr GetCOMIUnknown(bool fIsBeingMarshalled)
        {
            IntPtr pUnk = IntPtr.Zero;
            Object otp = GetTransparentProxy();            
            bool fIsXProcess = RemotingServices.IsObjectOutOfProcess(otp);
            if (fIsXProcess)
            {
                // we are in a different process
                if (fIsBeingMarshalled)
                {
                    // we need to go to the server to get the real IUnknown
                    pUnk =  MarshalByRefObject.GetComIUnknown((MarshalByRefObject)otp);
                }
                else
                {
                    // create an IUnknown here
                    pUnk =  MarshalByRefObject.GetComIUnknown((MarshalByRefObject)otp);    
                }
            }
            else
            {
                bool fIsXAppDomain = RemotingServices.IsObjectOutOfAppDomain(otp);
                // we are in the same proces, ask the object for its IUnknown
                if (fIsXAppDomain)
                {
                    // do an appdomain switch
                    pUnk = ((MarshalByRefObject)otp).GetComIUnknown(fIsBeingMarshalled);
                }
                else
                {    
                    // otherwise go ahead and create a CCW here
                    pUnk = MarshalByRefObject.GetComIUnknown((MarshalByRefObject)otp);
                }
            }

            return pUnk;
        }

        [System.Security.SecurityCritical]
        public override void SetCOMIUnknown(IntPtr i)
        {
            // for now ignore this
        }

        // Check whether we can cast the transparent proxy to the given type
        [System.Security.SecurityCritical]
        public bool CanCastTo(Type castType, Object o)
        {
            if (castType == null)
                throw new ArgumentNullException("castType");

            RuntimeType rtType = castType as RuntimeType;
            if (rtType == null)
                throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"));

            bool fCastOK = false;

            // The identity should be non-null
            BCLDebug.Assert(null != IdentityObject,"null != IdentityObject");

            Message.DebugOut("CheckCast for identity " + IdentityObject.GetType());

            if ((rtType == s_typeofObject) ||
                (rtType == s_typeofMarshalByRefObject))
            {
                return true;
            }

            // Get the objref of the proxy
            ObjRef oRef = IdentityObject.ObjectRef;

            // If the object ref is non-null then check against the type info
            // stored in the it
            if (null != oRef)
            {
                Object oTP = GetTransparentProxy();

                // Check that there is a matching type in the server object 
                // hierarchy represented in the objref                                      
                Message.DebugOut("Calling CanCastTo for type " + rtType);
                IRemotingTypeInfo typeInfo = oRef.TypeInfo;
                if(null != typeInfo)
                {
                    fCastOK = typeInfo.CanCastTo(rtType, oTP);
                    if (!fCastOK && typeInfo.GetType()==typeof(TypeInfo) && oRef.IsWellKnown() )
                    {
                        fCastOK = CanCastToWK(rtType);
                    }
                }                                
                else
                {
                    if (oRef.IsObjRefLite())
                    {
                        // we should do a dynamic cast across the network
                        fCastOK = MarshalByRefObject.CanCastToXmlTypeHelper(rtType, (MarshalByRefObject)o);  
                    }
                }
            }
            // This is a well known object which does not have a backing ObjRef
            else
            {
                fCastOK = CanCastToWK(rtType);
            }
            return fCastOK;
        }

        // WellKnown proxies we always allow casts to interfaces, and allow 
        // casting down a single branch in the type hierarchy (both are on good
        // faith. The calls are failed on server side if a bogus cast is done)
        bool CanCastToWK(Type castType)
        {
            Message.DebugOut( "CheckCast for well known objects and type " + castType);
            bool fCastOK = false;
            // Check whether the type to which we want to cast is
            // compatible with the current type
            if(castType.IsClass)
            {
                fCastOK = GetProxiedType().IsAssignableFrom(castType);
            }
            else
            {
                // NOTE: we are coming here also for x-context proxies
                // when unmanaged code cannot determine if the cast is not
                // okay <
                if (!(IdentityObject is ServerIdentity))
                {
                    BCLDebug.Assert(
                        IdentityObject.URI != null,
                        "Bad WellKnown ID");
                    // Always allow interface casts to succeed. If the 
                    // interface is not supported by the well known object
                    // then we will throw an exception when the interface
                    // is invoked.
                    fCastOK = true;
                }
            }
            
            return fCastOK;
        }        
    }


    internal class AgileAsyncWorkerItem
    {
        private IMethodCallMessage _message;
        private AsyncResult        _ar;
        private Object             _target;

        [System.Security.SecurityCritical]  // auto-generated
        public AgileAsyncWorkerItem(IMethodCallMessage message, AsyncResult ar, Object target)
        {
            _message = new MethodCall(message);
            _ar = ar;
            _target = target;
        }

        [System.Security.SecurityCritical]  // auto-generated
        public static void ThreadPoolCallBack(Object o)
        {
            ((AgileAsyncWorkerItem) o).DoAsyncCall();
        }


        [System.Security.SecurityCritical]  // auto-generated
        public void DoAsyncCall()
        {
            (new StackBuilderSink(_target)).AsyncProcessMessage(_message, _ar);
        }
    }

}
                                                                                                                                                                                                                                                                                                                                                                 4û(    ©ú(    ¯’=   3/™°ü‡÷ Ä            , < l d s - m 0 - i n i t - i n - l o o p . l l `      5û(    ©ú(    `÷=   3/™°ü‡÷               " < l d s - o q a p - c r a s h . l l   `      5û(    ©ú(    ¿÷=   3/™°ü‡÷              " < l d s - o q a p - c r a s h . l l   `      5û(    ©ú(     ◊=   3/™°ü‡÷ Ä            " < l d s - o q a p - c r a s h . l l   h      6û(    ©ú(    Ä◊=   DV™°ü‡÷               & < l d s - o u t p u t - q u e u e . l l       h      6û(    ©ú(    Ë◊=   DV™°ü‡÷              & < l d s - o u t p u t - q u e u e . l l       h      6û(    ©ú(    Pÿ=   DV™°ü‡÷ Ä            & < l d s - o u t p u t - q u e u e . l l       X      7û(    ©ú(    ∏ÿ=   DV™°ü‡÷                < l d s - s i z e . l l       X      7û(    ©ú(    Ÿ=   DV™°ü‡÷               < l d s - s i z e . l l       X      7û(    ©ú(    hŸ=   DV™°ü‡÷ Ä             < l d s - s i z e . l l       p      8û(    ©ú(    ¿Ÿ=   DV™°ü‡÷               . < l d s - z e r o - i n i t i a l i z e r . l l       p      8û(    ©ú(    0⁄=   DV™°ü‡÷              . < l d s - z e r o - i n i t i a l i z e r . l l       p      8û(    ©ú(    †⁄=   DV™°ü‡÷ Ä            . < l d s - z e r o - i n i t i a l i z e r . l l       Ä      9û(    ©ú(    €=   DV™°ü‡÷               > < l e g a l i z e d a g - b u g - e x p a n d - s e t c c . l l       Ä      9û(    ©ú(    ê€=   DV™°ü‡÷              > < l e g a l i z e d a g - b u g - e x p a n d - s e t c c . l l       Ä      9û(    ©ú(    ‹=   DV™°ü‡÷ Ä            > < l e g a l i z e d a g - b u g - e x p a n d - s e t c c . l l       `      :û(    ©ú(    ê‹=   K}™°ü‡÷               $ < l i m i t - c o a l e s c e . m i r `      :û(    ©ú(    ‹=   K}™°ü‡÷              $ < l i m i t - c o a l e s c e . m i r `      :û(    ©ú(    P›=   K}™°ü‡÷ Ä            $ < l i m i t - c o a l e s c e . m i r X      ;û(    ©ú(    ∞›=   K}™°ü‡÷                < l i t . l o c a l . c f g   X      ;û(    ©ú(    ﬁ=   K}™°ü‡÷               < l i t . l o c a l . c f g   X      ;û(    ©ú(    `ﬁ=   K}™°ü‡÷ Ä             < l i t . l o c a l . c f g   X      <û(    ©ú(    ∏ﬁ=   \§™°ü‡÷                < l i t e r a l s . l l       X      <û(    ©ú(    ﬂ=   \§™°ü‡÷               < l i t e r a l s . l l       X      <û(    ©ú(    hﬂ=   \§™°ü‡÷ Ä             < l i t e r a l s . l l                                                                       <?xml version="1.0" encoding="utf-8"?>
<Type Name="ExpressionEditorSheet" FullName="System.Web.UI.Design.ExpressionEditorSheet">
  <TypeSignature Language="C#" Value="public abstract class ExpressionEditorSheet" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <since version=".NET 2.0" />
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>A custom expression editor sheet lets a developer set properties on a custom expression at design-time. Control property values can be set using expression strings; the expression strings are evaluated at run time by an expression builder and at design time by an expression editor.</para>
      <para>When you browse the <see cref="P:System.Web.UI.Design.HtmlControlDesigner.Expressions" /> property for a control in the design-time properties grid, the visual designer displays a dialog box to set expressions that provide the value for a control property. You can select the expression type based on a list of expression prefixes. When you select an expression prefix from the list, the visual designer uses the associated <see cref="T:System.Web.UI.Design.ExpressionEditor" /> and <see cref="T:System.Web.UI.Design.ExpressionEditorSheet" /> objects to evaluate and convert the expression string based on the syntax for that type of expression. The visual designer uses expression editor sheet properties to prompt for one or more strings that combine into the custom expression string. </para>
      <para>Typically, to supply a new expression type at design time, you define a unique expression prefix and provide custom <see cref="T:System.Web.Compilation.ExpressionBuilder" /> and <see cref="T:System.Web.UI.Design.ExpressionEditor" /> implementations. Optionally, you can provide a custom <see cref="T:System.Web.UI.Design.ExpressionEditorSheet" /> implementation that defines properties that are used to form the expression. To associate an expression prefix with an expression builder and an expression editor, apply the <see cref="T:System.Web.Compilation.ExpressionEditorAttribute" /> attribute and an <see cref="T:System.Web.Compilation.ExpressionPrefixAttribute" /> attribute to the custom <see cref="T:System.Web.Configuration.ExpressionBuilder" /> class, and then configure the expression prefix for an expression builder in the expressionBuilders element in the Web configuration file.</para>
      <para>The default implementation of the <see cref="M:System.Web.UI.Design.ExpressionEditor.GetExpressionEditorSheet(System.String,System.IServiceProvider)" /> method returns a basic editor sheet, which uses a single input string to form the expression. Custom expression editors that are derived from the <see cref="T:System.Web.UI.Design.ExpressionEditor" /> can override the <see cref="M:System.Web.UI.Design.ExpressionEditor.GetExpressionEditorSheet(System.String,System.IServiceProvider)" /> method to return a custom editor sheet implementation. Typically, a custom editor sheet contains multiple properties that are used to build the expression string. The <see cref="M:System.Web.UI.Design.ExpressionEditorSheet.GetExpression" /> method returns the resulting expression string based on the current expression properties.</para>
      <para>For example, the <see cref="T:System.Web.UI.Design.ResourceExpressionEditor" /> class derives from the <see cref="T:System.Web.UI.Design.ExpressionEditor" /> class and provides an implementation for evaluating and associating a resource string reference with a control property at design time. The <see cref="T:System.Web.Compilation.ResourceExpressionBuilder" /> class is associated with the expression prefix Resources and the <see cref="T:System.Web.UI.Design.ResourceExpressionEditor" /> implementation. The <see cref="M:System.Web.UI.Design.ResourceExpressionEditor.GetExpressionEditorSheet(System.String,System.IServiceProvider)" /> method returns a <see cref="T:System.Web.UI.Design.ResourceExpressionEditorSheet" />, which defines the individual properties that form a resource reference expression.</para>
      <para>When you inherit from the <see cref="T:System.Web.UI.Design.ExpressionEditorSheet" /> class, you must override the following members: </para>
      <list type="bullet">
        <item>
          <para>The <see cref="M:System.Web.UI.Design.ExpressionEditor.GetExpressionEditorSheet(System.String,System.IServiceProvider)" /> method to return a custom editor sheet implementation. </para>
        </item>
        <item>
          <para>The <see cref="M:System.Web.UI.Design.ExpressionEditorSheet.#ctor(System.IServiceProvider)" /> constructor to implement custom initialization actions for your expression editor sheet implementation.</para>
        </item>
      </list>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents a design-time editor sheet for a custom expression. This class must be inherited.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ExpressionEditorSheet (IServiceProvider serviceProvider);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Because the <see cref="T:System.Web.UI.Design.ExpressionEditorSheet" /> class is abstract, you cannot create an instance of an <see cref="T:System.Web.UI.Design.ExpressionEditorSheet" /> directly using the <see cref="M:System.Web.UI.Design.ExpressionEditorSheet.#ctor(System.IServiceProvider)" /> constructor.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Web.UI.Design.ExpressionEditorSheet" /> class.</para>
        </summary>
        <param name="serviceProvider">
          <attribution license="cc4" from="Microsoft" modified="false" />A service provider implementation supplied by the designer host, used to obtain additional design-time services.</param>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetExpression">
      <MemberSignature Language="C#" Value="public abstract string GetExpression ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A custom expression editor sheet contains design-time settings for multiple expression properties, which are combined to form an expression string. Control property values can be set using expression strings; the expression strings are evaluated at run time by an expression builder.</para>
          <para>The <see cref="M:System.Web.UI.Design.ExpressionEditorSheet.GetExpression" /> method returns an expression string that is built from the current expression properties. The visual designer allows you to set the expression sheet properties, and then calls the <see cref="M:System.Web.UI.Design.ExpressionEditorSheet.GetExpression" /> method to get the expression string and set the control property value.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, returns the expression string that is formed by the expression editor sheet property values.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The custom expression string for the current property values.</para>
        </returns>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public virtual bool IsValid { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This base implementation always returns true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the expression string is valid.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="ServiceProvider">
      <MemberSignature Language="C#" Value="public IServiceProvider ServiceProvider { get; }" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="M:System.Web.UI.Design.ExpressionEditorSheet.#ctor(System.IServiceProvider)" /> constructor to set the <see cref="P:System.Web.UI.Design.ExpressionEditorSheet.ServiceProvider" /> implementation for a custom expression editor sheet.</para>
          <para>The <see cref="P:System.Web.UI.Design.ExpressionEditorSheet.ServiceProvider" /> property can be used to access services that are provided by the designer host. For example, call the <see cref="M:System.IServiceProvider.GetService(System.Type)" /> method with the <see cref="T:System.Web.UI.Design.IWebApplication" /> interface to access project items, documents, or configuration file details that are provided through the visual designer.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the service provider implementation that is used by the expression editor sheet.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
</Type>                                                                                                                                                                                                                           m‰Røzå:É«(:Ävê∏=”[˝Å·*ªﬁ¥&~°^€’M‚äÂ≈0≈yxÿ⁄ „/Ï9„€=£O”	M∏Y/	!†^’§måƒÄ‚n«	â®¿z1ÒêÅÀ"∞êÎN˝«!¿FCÜ∆úO~µâBkaèƒA&¿Do˘≠6ÃLn)ﬂ`l`—·˘:ÛH=C©¨ãÑ„ßËèñ•Xp}/UÚ=Ô ñK“4≥ºã¬ﬂΩ&x—P/W!U¥∫eB›¢ñÙº˛†&Èù€‰∞oﬂÒÊ‘¸ıZcÿœöí»ÄgùHf≠ß'˜–Éâ∏ÑÃ{∆≥˚•h¥ÏÑ^£Áƒˆ«ƒgHºª¸»_DTCé(ﬁ4e;jGµ¥\@°Œpü“µÌÉÈ±[Äå;Ëù•˙ˇ?Q“7{gäƒÏ«±∆à}å ?˙˘q§Ëtß›ÈﬁQJ®Â$q»‚åÈle≥ÙÂåWŸäs‡˜{IÏFHéH√?4m˜ˆå¥∑W$ír≤9ü÷Iy˝\≈@ﬂÈ0ˆT{˜˘ï9≈Ä¢z¿⁄%Eñì˜‡aPKx
∫Oí‘íıœ1Ñ_Ÿ«7r‹øé⁄Q√XXı‚æ∞6c…A´ﬁÆpëiaÀ™+âƒàW&◊HrZ(æ*±DT⁄ó@¶—ûc∫be’ﬁ3Gãj˙ê¶ù(È«∏ûJ©mµ˙}∫û‰4—s-Üß~Åà©U⁄%ãˇ¥G≤Qñ¯∆ºÀJú<âØ ‚ÄlÃ⁄@ÚP≤cù’Æl¸è!i;‡7ï∆∞⁄¡âîØî	¶c†´˚ßÜ0Û÷™p'ƒÊÆ 3kH p+Ór1.û≥⁄·EÛ•Pîìë6NBù‹é'µk˚3°auõ£°ÀºµÒyîπn[°"∫á[-Á/Z˘ﬂ≥ıNümÃú5(˘•èΩ
VqlÚç@ß}|œÒVgÕÂ˛7†∫∞;18‡¥~Õu˘U‡˙ú<Ño◊áD‡≥F]iFD¨_°~…õ˚⁄[NDz¸Ωá§
ÜJ‡¢5,2#§aÎJ"≥	&¸"Ä4•Ü¬°ÜÉ˚ø±›¸Õ´'Û'$º£|f‰€ª∂˙
ﬂ}“DÀÓºS2—πŒ—F¨?ØµúÎ4úS5uΩ„sƒ‚≈ŒÈ√#‡∑{äXÖ7n°`˛ÀÜ˘B VÿYŸó]ÀJ è˛›ÒÑŸ(Œ3¥qÿY˝<±»¥ä0_‹uÔ¨PNçﬁû)C°ˇ.Eù[“Ü ∫√vB&\e,ËV:'I)Ó8¨Eyç£Ñw.Z¨==&ñ'Íg$MK¶EI§Ω∫&iË„≥âWg®ÌnÄ*InNh¸Ey¸÷π^x§˛@r.$nØ=kØ//------------------------------------------------------------------------------
// <copyright file="GacUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.Configuration {
    using System.Web.Configuration;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;

    /*
    class for installing ASP.BrowserCapabilitiesFactory into gac
    */
    internal sealed class GacUtil : IGac {


        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public void GacInstall(string assemblyPath) {

#if !FEATURE_PAL
            IAssemblyCache ac = null;
            int hr = NativeMethods.CreateAssemblyCache(out ac, 0);
            if (0 == hr) hr = ac.InstallAssembly(0, assemblyPath, IntPtr.Zero);
#else // !FEATURE_PAL
            int hr = -1;
            try
            {
                Process gacutilprocess = new System.Diagnostics.Process();
                if (gacutilprocess != null)
                {
                    gacutilprocess.StartInfo.CreateNoWindow = true;
#if PLATFORM_UNIX
                    gacutilprocess.StartInfo.FileName = "gacutil";
#else
                    gacutilprocess.StartInfo.FileName = "gacutil.exe";
#endif
                    gacutilprocess.StartInfo.UseShellExecute = false;
                    gacutilprocess.StartInfo.Arguments = "/i " + assemblyPath;
                    gacutilprocess.Start();
                    while (!gacutilprocess.HasExited)
                    {
                        Thread.Sleep(250);
                    }
                    hr = gacutilprocess.ExitCode;
                }
            }
            catch (Exception)
            {
                hr = -1;
            }
#endif // FEATURE_PAL

            if (0 != hr) {
                throw new Ex