r
    if (0 == description.compare(gGreaterGreaterThan, 2) ||
        0 == description.compare(gGreaterGreaterGreaterThan, 3) ||
        _ruleSet == getRuleSet()) {
        byDigits = TRUE;
        if (0 == description.compare(gGreaterGreaterGreaterThan, 3)) {
            useSpaces = FALSE;
        }
    } else {
        // cast away const
        ((NFRuleSet*)getRuleSet())->makeIntoFractionRuleSet();
    }
}

//-----------------------------------------------------------------------
// formatting
//-----------------------------------------------------------------------

/**
 * If in "by digits" mode, fills in the substitution one decimal digit
 * at a time using the rule set containing this substitution.
 * Otherwise, uses the superclass function.
 * @param number The number being formatted
 * @param toInsertInto The string to insert the result of formatting
 * the substitution into
 * @param pos The position of the owning rule's rule text in
 * toInsertInto
 */
void
FractionalPartSubstitution::doSubstitution(double number, UnicodeString& toInsertInto, int32_t _pos) const
{
  // if we're not in "byDigits" mode, just use the inherited
  // doSubstitution() routine
  if (!byDigits) {
    NFSubstitution::doSubstitution(number, toInsertInto, _pos);

    // if we're in "byDigits" mode, transform the value into an integer
    // by moving the decimal point eight places to the right and
    // pulling digits off the right one at a time, formatting each digit
    // as an integer using this substitution's owning rule set
    // (this is slower, but more accurate, than doing it from the
    // other end)
  } else {
    //          int32_t numberToFormat = (int32_t)uprv_round(transformNumber(number) * uprv_pow(10, kMaxDecimalDigits));
    //          // this flag keeps us from formatting trailing zeros.  It starts
    //          // out false because we're pulling from the right, and switches
    //          // to true the first time we encounter a non-zero digit
    //          UBool doZeros = FALSE;
    //          for (int32_t i = 0; i < kMaxDecimalDigits; i++) {
    //              int64_t digit = numberToFormat % 10;
    //              if (digit != 0 || doZeros) {
    //                  if (doZeros && useSpaces) {
    //                      toInsertInto.insert(_pos + getPos(), gSpace);
    //                  }
    //                  doZeros = TRUE;
    //                  getRuleSet()->format(digit, toInsertInto, _pos + getPos());
    //              }
    //              numberToFormat /= 10;
    //          }

    DigitList dl;
    dl.set(number);
    dl.roundFixedPoint(20);     // round to 20 fraction digits.
    dl.reduce();                // Removes any trailing zeros.
    
    UBool pad = FALSE;
    for (int32_t didx = dl.getCount()-1; didx>=dl.getDecimalAt(); didx--) {
      // Loop iterates over fraction digits, starting with the LSD.
      //   include both real digits from the number, and zeros
      //   to the left of the MSD but to the right of the decimal point.
      if (pad && useSpaces) {
        toInsertInto.insert(_pos + getPos(), gSpace);
      } else {
        pad = TRUE;
      }
      int64_t digit = didx>=0 ? dl.getDigit(didx) - '0' : 0;
      getRuleSet()->format(digit, toInsertInto, _pos + getPos());
    }

    if (!pad) {
      // hack around lack of precision in digitlist. if we would end up with
      // "foo point" make sure we add a " zero" to the end.
      getRuleSet()->format((int64_t)0, toInsertInto, _pos + getPos());
    }
  }
}

//-----------------------------------------------------------------------
// parsing
//-----------------------------------------------------------------------

/**
 * If in "by digits" mode, parses the string as if it were a string
 * of individual digits; otherwise, uses the superclass function.
 * @param text The string to parse
 * @param parsePosition Ignored on entry, but updated on exit to point
 * to the first unmatched character
 * @param baseValue The partial parse result prior to entering this
 * function
 * @param upperBound Only consider rules with base values lower than
 * this when filling in the substitution
 * @param lenientParse If true, try matching the text as numerals if
 * matching as words doesn't work
 * @return If the match was successful, the current partial parse
 * result; otherwise new Long(0).  The result is either a Long or
 * a Double.
 */

UBool
FractionalPartSubstitution::doParse(const UnicodeString& text,
                ParsePosition& parsePosition,
                double baseValue,
                double /*upperBound*/,
                UBool lenientParse,
                Formattable& resVal) const
{
    // if we're not in byDigits mode, we can just use the inherited
    // doParse()
    if (!byDigits) {
        return NFSubstitution::doParse(text, parsePosition, baseValue, 0, lenientParse, resVal);

        // if we ARE in byDigits mode, parse the text one digit at a time
        // using this substitution's owning rule set (we do this by setting
        // upperBound to 10 when calling doParse() ) until we reach
        // nonmatching text
    } else {
        UnicodeString workText(text);
        ParsePosition workPos(1);
        double result = 0;
        int32_t digit;
//          double p10 = 0.1;

        DigitList dl;
        NumberFormat* fmt = NULL;
        while (workText.length() > 0 && workPos.getIndex() != 0) {
            workPos.setIndex(0);
            Formattable temp;
            getRuleSet()->parse(workText, workPos, 10, temp);
            UErrorCode status = U_ZERO_ERROR;
            digit = temp.getLong(status);
//            digit = temp.getType() == Formattable::kLong ?
//               temp.getLong() :
//            (int32_t)temp.getDouble();

            if (lenientParse && workPos.getIndex() == 0) {
                if (!fmt) {
                    status = U_ZERO_ERROR;
                    fmt = NumberFormat::createInstance(status);
                    if (U_FAILURE(status)) {
                        delete fmt;
                        fmt = NULL;
                    }
                }
                if (fmt) {
                    fmt->parse(workText, temp, workPos);
                    digit = temp.getLong(status);
                }
            }

            if (workPos.getIndex() != 0) {
                dl.append((char)('0' + digit));
//                  result += digit * p10;
//                  p10 /= 10;
                parsePosition.setIndex(parsePosition.getIndex() + workPos.getIndex());
                workText.removeBetween(0, workPos.getIndex());
                while (workText.length() > 0 && workText.charAt(0) == gSpace) {
                    workText.removeBetween(0, 1);
                    parsePosition.setIndex(parsePosition.getIndex() + 1);
                }
            }
        }
        delete fmt;

        result = dl.getCount() == 0 ? 0 : dl.getDouble();
        result = composeRuleValue(result, baseValue);
        resVal.setDouble(result);
        return TRUE;
    }
}

UBool
FractionalPartSubstitution::operator==(const NFSubstitution& rhs) const
{
  return NFSubstitution::operator==(rhs) &&
  ((const FractionalPartSubstitution*)&rhs)->byDigits == byDigits;
}

UOBJECT_DEFINE_RTTI_IMPLEMENTATION(FractionalPartSubstitution)


//===================================================================
// AbsoluteValueSubstitution
//===================================================================

UOBJECT_DEFINE_RTTI_IMPLEMENTATION(AbsoluteValueSubstitution)

//===================================================================
// NumeratorSubstitution
//===================================================================

void
NumeratorSubstitution::doSubstitution(double number, UnicodeString& toInsertInto, int32_t apos) const {
    // perform a transformation on the number being formatted that
    // is dependent on the type of substitution this is

    double numberToFormat = transformNumber(number);
    int64_t longNF = util64_fromDouble(numberToFormat);

    const NFRuleSet* aruleSet = getRuleSet();
    if (withZeros && aruleSet != NULL) {
        // if there are leading zeros in the decimal expansion then emit them
        int64_t nf =longNF;
        int32_t len = toInsertInto.length();
        while ((nf *= 10) < denominator) {
            toInsertInto.insert(apos + getPos(), gSpace);
            aruleSet->format((int64_t)0, toInsertInto, apos + getPos());
        }
        apos += toInsertInto.length() - len;
    }

    // if the result is an integer, from here on out we work in integer
    // space (saving time and memory and preserving accuracy)
    if (numberToFormat == longNF && aruleSet != NULL) {
        aruleSet->format(longNF, toInsertInto, apos + getPos());

        // if the result isn't an integer, then call either our rule set's
        // format() method or our DecimalFormat's format() method to
        // format the result
    } else {
        if (aruleSet != NULL) {
            aruleSet->format(numberToFormat, toInsertInto, apos + getPos());
        } else {
            UErrorCode status = U_ZERO_ERROR;
            UnicodeString temp;
            getNumberFormat()->format(numberToFormat, temp, status);
            toInsertInto.insert(apos + getPos(), temp);
        }
    }
}

UBool 
NumeratorSubstitution::doParse(const UnicodeString& text, 
                               ParsePosition& parsePosition,
                               double baseValue,
                               double upperBound,
                               UBool /*lenientParse*/,
                               Formattable& result) const
{
    // we don't have to do anything special to do the parsing here,
    // but we have to turn lenient parsing off-- if we leave it on,
    // it SERIOUSLY messes up the algorithm

    // if withZeros is true, we need to count the zeros
    // and use that to adjust the parse result
    UErrorCode status = U_ZERO_ERROR;
    int32_t zeroCount = 0;
    UnicodeString workText(text);

    if (withZeros) {
        ParsePosition workPos(1);
        Formattable temp;

        while (workText.length() > 0 && workPos.getIndex() != 0) {
            workPos.setIndex(0);
            getRuleSet()->parse(workText, workPos, 1, temp); // parse zero or nothing at all
            if (workPos.getIndex() == 0) {
                // we failed, either there were no more zeros, or the number was formatted with digits
                // either way, we're done
                break;
            }

            ++zeroCount;
            parsePosition.setIndex(parsePosition.getIndex() + workPos.getIndex());
            workText.remove(0, workPos.getIndex());
            while (workText.length() > 0 && workText.charAt(0) == gSpace) {
                workText.remove(0, 1);
                parsePosition.setIndex(parsePosition.getIndex() + 1);
            }
        }

        workText = text;
        workText.remove(0, (int32_t)parsePosition.getIndex());
        parsePosition.setIndex(0);
    }

    // we've parsed off the zeros, now let's parse the rest from our current position
    NFSubstitution::doParse(workText, parsePosition, withZeros ? 1 : baseValue, upperBound, FALSE, result);

    if (withZeros) {
        // any base value will do in this case.  is there a way to
        // force this to not bother trying all the base values?

        // compute the 'effective' base and prescale the value down
        int64_t n = result.getLong(status); // force conversion!
        int64_t d = 1;
        int32_t pow = 0;
        while (d <= n) {
            d *= 10;
            ++pow;
        }
        // now add the zeros
        while (zeroCount > 0) {
            d *= 10;
            --zeroCount;
        }
        // d is now our true denominator
        result.setDouble((double)n/(double)d);
    }

    return TRUE;
}

UBool
NumeratorSubstitution::operator==(const NFSubstitution& rhs) const
{
    return NFSubstitution::operator==(rhs) &&
        denominator == ((const NumeratorSubstitution*)&rhs)->denominator;
}

UOBJECT_DEFINE_RTTI_IMPLEMENTATION(NumeratorSubstitution)

const UChar NumeratorSubstitution::LTLT[] = { 0x003c, 0x003c };
        
//===================================================================
// NullSubstitution
//===================================================================

UOBJECT_DEFINE_RTTI_IMPLEMENTATION(NullSubstitution)

U_NAMESPACE_END

/* U_HAVE_RBNF */
#endif

     ­|	ÆÎEá÷GÀÉ£Q²¸$áë¾XÚwY×âˆµ—7;Æ”§ms$PÇ•¦×2U‰Íf—&
iª÷ S“¹^øê3)kZnW¶‡$D»˜çû3KA :è¥ËşZàtZeÇËÕÍÚìÆÉˆ«¸'(§ï 	ßFËåO´–÷Ó8xSVÜ8³œÒ÷Åí)İ§ú2u8”DÛ«$ !ºĞ¸O.	F“#÷Œ^ˆÛ´ı)Öcªc™€……0Z9êÊ)¸¦€ÉÔ^p’n|fUŸñ<vñuœJúyë½-›ÒÍ÷“à¼œÈŞşªuWTH«{´ T·÷T'ÙOòGZt É ¿å•ù9lËE5F’–×gnQšœvûOY…Ú`‡w­Á:îˆÈ£oè*ëØwV(6‹Æ^iîétæ?lÑHƒ9½¶Ë|²‘rSÚ„âŠ«€gH¶ôI#Ü"•3vÚ¨È“©l†ö[F-(,²Œ’‘ĞÄí2_O™é¨py6ˆ¤<Æd]ÿ<ÜG§—¦=³qÃ	ÿ„@¾nßbAÎü·š]ı)0÷ËÊ,`)¦Dôá^áÜË»IŸÜÕÄ-“ş†½‚ cWò‡¹ÍŠ7ÿEú¢Ç‰ÓÊ‰k8ädİÚˆÓò;²YÂ'ëh4§¿ŞËüa Î”mH#<Í•~Úòb³Bï~õœñtµ
rã£Y´mx`ô :Ï*—ûı ê{ßaDı‚ÀÚe¸Rd’]ønˆ0v9O‘ğ¡m\ˆÅºNÅÒ*¨`‰ÔÙ]ª6ô“;ÑÌdî35…'—ùÀïÂcpa}yã¡ùzIÌe6Y&EÚïî0}–´XB“‚ls ñ#&(œè”‡©¼9+M>+?'àöhGá]Cd
²8=d©mûì¡+ûê‡b?6±˜¤ÌÀæ£ÀSê‘2üã‚ké™d¯cŸñ6éX!†©7İ÷6@³T&SZÚ<Ø2j£Ih“ŞßññsRñ†‘A™¼­Â“í—ÅdØâü_Sã'²VP6ù³oìÃ³šË!ÈHV*”°?(C[E‰õ9â5¾PÃ£ªò5„ –^‡Ş@‡‚†¡ÈDB…±3×XüU•œaÄl9ÿÔ=áHXCQU`y8×öšrSY]»·êÚúŸ„#<¹ÒW½¶ä³ª´á.C6y€–ŠĞƒ_5&…qMáØf½ñ¦³©èƒŸ?¤ÊğÌñxO‰hpÎÖğGî3iÎ)óÏ³îaô"äõ¸‚b;…’Fy~ì³ìJ±h\›	[®PŠ|ğBRŠYZÊ&â§ûÀv=éèŒ}:oò{c–Ø"ùŠ¨Ñ×¸Ğ,5Y›ÓäöUY÷·b1Ršèz}	Û Ã³U\<¦špbŠÕótˆ¥AàåIIEa”é›LM«Z‘^ÆóõQqã-0à„Ëje‹‰Yñ/ı€©²†;7ßC”ÛSÿ—^ZªûŸ£hi¯!* ğÔ¾Vƒ9}8›Š3	º.Å¸I4ßR¾·‡5&&Bìñş²ÆŒoÌ`‰Ü”Êd‹æ*%Õqï‡¥8ÜÙt-J	o&Ó„üêúœªæìŠ‰²Ï×8T_È×AÏ
înªU¥aHßÛêAi·)N£ÑÎ À›Á98_çŒ$sd ‚BV6«%Œ€)úøà æC ıÖıÔDÌPÁ‡Fû1š!á,‰f…w‡åH	d=!ÊnLs)I‘íÚ¡±D†–8À²ÀT{~§FZqäÇƒ‡Äë;¼K,` ì-; A9Á<ãnÌ¸xÂÅ'ßU“îûE‡K ²4÷‹ís-oî¸ïÎÃãü›öQéµÖ±šëN×Ğ@ß#Djj‰ÅçÅ÷aY¸šÔ.ú×1v¢hšhï8æ uRz¯Ú|åe„ü²såªä­Ğj®šéùz?‚/!WÉHÍ°á	ÉÏr]è…ä+k=§ÄÖVHÿ*Û» 'mÌ"y7-×<»Áåt«…íW –v;Úî²Ÿ\w *ƒY37šGÖÏ8^í|Z;ÛÀãb§±í\IguœÈ|.{/üä E¿Ï!+’,iEğüW¶,“¤ƒ´»D|EÛEå’nò~şUf"7Ğ%ú­Ú¹ØÉ$´¥ÃÎ«•\ù:#pÚ´Æ+å–ŸĞ›ø©côM”¡%œñr!IÚçHr‡¼šıN©ªÂ’xf]T „J»åwÁaıƒmó…<0(í7*fl\JÜ÷b/·H[¨‡™ıµİˆ>(ÍçòüÔø×<X
3ê1|ÜMPÆ‰£¤6&³½Á¿˜CNş8ãßææMüNk`9ã”¤‚á­%+Ü!1bcÇ5¿Êü¦˜º¶µÌbŠÿ.ÆVTR)ƒVôz´ñœïV• 7Æ:œdÁ@†wÊQĞ k¼)œ‚e,õí,ıÛğcK¦ÄĞmÉM zL’t€d¯º-A±0C”›Ò’I[ j*q">ÂnÏX{ÏnŞUZ×3=@çæ¬¦¸—Æ‘í‰¶øx¡œø–™ësTAã[M5,§èäâ?Ğhw‹İôrºŞD‹};‘–:V`kSO{·/’{eÀ$D¯¤‰yñã!*²5+xëo~‰«ˆQq—p¦wÄ%*¬_¯–z{,P…ÛUB9´¿KrÿùÇ.• ˆ{i÷pı‰îu#:`Ò¤‡=ÊTI²í>9Î¬‹ej€núp>1xã”~ûåÍ±rŒß1B »ªè¤Ò¯~Ã³¹8#5, æ¾aº´)v66İ#ğ°@n«¾[¼°}Ä+‚~)öA¤@"–İ“—.	ÃªJ)×Çß†‹=N¸Oe |?ªMøP"mˆ“×Û°›vºİ’şç\G u—›Üs­ßØ¤²—Õò6ê¼³µêßñ'ÀzPCÎ¸>ÚÍ[*mROKë¯˜sAT„I4ThÒŒä÷íÄ9âğóIÕõ6ë{äq5§L6Â±XxÜëÒ	¯5~kÉ°}cA¨*m‰hG”Øøâ^õ
xò¬Fs¾~‘O¥©| ÉLt÷@Y®€K»¤>a„#º: –‹Ü\ÈµT¾dHØrt›Í²!‹›óy¦~ŞÌÍš©V–gAß))ª¡Ù-ÿm¬…ë,ëK Wîµl@»©RyEõÎÚf_®Ç@w¸#3‘ók©"@jtñÑ6É7>^ÏYêRÅyœAH`B]¡~)Ó©uÛã!o¼‹‰ıúY,pÇ ÕkpÂŒ£Èˆ¤í$Ÿse™"ÁC´5—+Œ–á‚
IÙeÓ)¡Çd%äWãcê•Íé„>òÈ@_iqšHìôˆÎ&9Ä—íƒ:«6ªdqËàà=§ÀÉ	ÿÈ»ö+O;@ÃÌàkËdL>?–­À\zÌî+OIôå¨ºŸÇ/HÕˆ36%â"õ'Ğb‰S(ºŒÙZÊÊÿ½×™¤¹‡Ş	 \!ÓïásÜB¼•º®Úm’Ëå±3ĞğAú¶'v¿O(à1ê
´ˆ¥@J
‘ålætáßU°qdÔ$÷J=SG¯ü	,ûàİ7SsÌ¼o¾M‰Ø!tw°Çc+úœÉÉ©Ğ”®WcÄë(”åÛ’Â*t`ms!ûê¤>ßóG*^?Œ«‹r‰Pú#ìmaºÅ#'¦)Š1BByê‚!îÿÔî&ü®tä ´p’cX}FÎãMé¹º8Q	}=£“„&¢¯ESö‡abØıëûÖU2ÊvzÎjÕE iìÇ ÊXÌ*l·ÉM°Üª
0†f©N¢ıÉ‚L ÚŠÔ?xø«\îÒÍ…k5åúºëy<¶™ü·v^Ô®Ù*ğÜz\quä#=³:’7+¾ññ1"­õ	íF(A‡ß{…“ZÿÕI‚$Ä26îşËº©/Z¸u´ ÉQ sô3»3±óæŠ½¢¹·wÜÕ%?dë8ğÑ9pi²,›©&@­	»ÑMÔ6¬ì/¦¿M<’'éî5ª±+CKÂâ²l|»¸ne*~UéÓ”V>œ¬²Á… ã,ºÍ…ÏĞ†zÎUÃÄıÕN%a`•®ÊG!©Tn2²€7Ì”‡5˜{a™ÚqöO=§t|º=…TMù‚2I‚†1©ã›nq¨ØêÅèlHÚæÀŒ˜˜f@¯)®HÉ|à7œ-uãŒåØ›È¼1‡ TÚ õ
û´ ±à¨ØÿÊœ˜-ì@˜ôş{k!DŒr¢Ù©NaG™”G³.*T´ÜÎOqµ¥fLJóÄïj}Vlj„¯Há·jHrv	(é /y±ş>y6Õ®Å¾–”ûÉ©‰}iÎÛ´0„E.~ñ(2ÂÁ›::ñ]Õêİ¨›Œv!ùäšÃö²ÿ@ o«­¶-ÅÜÚ6ZÜ´eß—¦–0Œµ`­'¿ÀØ_i¼”ßı%//*)Á³ t,oÆÈå:Pí´cN„~©µzŸÕ>¶ÒÈß,Ç ¯Ÿi KfìØd$¡Îsşì¹èôï¾€·çJ†T3rõÇ§ÿÿtY©8‚¹5gµK8»~gÒÓwòb¯qIuë×Ñ<‡N¬iu»k,àefÅ|ö&ß‘MZ       ÿÿ  ¸       @                                   €   º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       PE  L LÁœ        à " 0  
         ª(       @                           €          @…                           X(  O    @                     `     <(                                                               H           .text   °       
                    `.rsrc      @                    @  @.reloc      `                    @  B                Œ(      H     P   l  	               ¼'  €                                   BSJB         v4.0.30319     l   Ô  #~  @  Ğ  #Strings         #US      #GUID   $  H  #Blob         T  ‰    ú3                                ğ      W 6 i   ¥ o  á  ‚  Ÿ  V k  6I ŠI ¾I x Å x = ¿    +       	 0  0 ! 0 ) 0 1 0 9 0 A 0 I 0 Q 0 Y 0 a 0 i 0 y 0  0 ' s !.  f.  o.  ‚. # À. + À. 3 â. ; â. C ï. K À. S . [ !. c &  Æ €            $ ¤              4                 Ü            ş Ü	          Ü	          Ü	         ”Ü	    DuplexClientBase`1 DuplexChannelFactory`1 <Module> mscorlib UnverifiableCodeAttribute DebuggableAttribute AssemblyTitleAttribute AssemblyFileVersionAttribute AssemblyInformationalVersionAttribute SecurityPermissionAttribute AssemblyDescriptionAttribute CallbackBehaviorAttribute AssemblyDefaultAliasAttribute CompilationRelaxationsAttribute AssemblyProductAttribute AssemblyCopyrightAttribute ReferenceAssemblyAttribute AssemblyCompanyAttribute RuntimeCompatibilityAttribute System.ServiceModel System.ServiceModel.Duplex.dll SecurityAction System.Reflection .ctor System.Diagnostics System.Runtime.CompilerServices DebuggingModes System.Security.Permissions InstanceContext System.ServiceModel.Duplex System.Security      —,Cz¨C—Ô’»}‰•  	     9·z\V4à‰€  $  €  ”      $  RSA1     ÑúWÄ®Ùğ£.„ª®ıéèıjì‡ûvlƒL™’²;çšÙÕÜÁİšÒ6!r<ù€•ÄáwÆwO)è2’êìäè!À¥ïèñd\L“Á«™(]b,ªe,úÖ=t]o-åñ~^¯Ä–=&ŠCe mÀ“4MZÒ“€.€„System.Security.Permissions.SecurityPermissionAttribute, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089TSkipVerification       Xamarin, Inc.  = 8Copyright (c) 2013 Xamarin Inc. (http://www.xamarin.com)  ! System.ServiceModel.Http.dll   4.0.0.0  ( #Mono Common Language Infrastructure             TWrapNonExceptionThrows                                                                                                                                                              €(          š(                          Œ(            _CorDllMain mscoree.dll     ÿ%                                                                                                                                                                                                                                                                                                                                                                       €                  0  €                   H   X@  4          44   V S _ V E R S I O N _ I N F O     ½ïş                 ?                         D    V a r F i l e I n f o     $    T r a n s l a t i o n       °”   S t r i n g F i l e I n f o   p   0 0 0 0 0 4 b 0   R   C o m m e n t s   S y s t e m . S e r v i c e M o d e l . H t t p . d l l     <   C o m p a n y N a m e     X a m a r i n ,   I n c .   b   F i l e D e s c r i p t i o n     S y s t e m . S e r v i c e M o d e l . H t t p . d l l     0   F i l e V e r s i o n     4 . 0 . 0 . 0   ^   I n t e r n a l N a m e   S y s t e m . S e r v i c e M o d e l . D u p l e x . d l l     – 9  L e g a l C o p y r i g h t   C o p y r i g h t   ( c )   2 0 1 3   X a m a r i n   I n c .   ( h t t p : / / w w w . x a m a r i n . c o m )     f   O r i g i n a l F i l e n a m e   S y s t e m . S e r v i c e M o d e l . D u p l e x . d l l     h $  P r o d u c t N a m e     M o n o   C o m m o n   L a n g u a g e   I n f r a s t r u c t u r e   4   P r o d u c t V e r s i o n   4 . 0 . 0 . 0   8   A s s e m b l y   V e r s i o n   4 . 0 . 0 . 0                                                                                                                                                                                                                                                                                                                                                                                              ¬8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Áí  ?   Ãí  ¬Çÿÿ?   Äí  (¡  <  ¿í  O >  Äí  ?   Æí  ÆÇÿÿ?   Éí  %¡  <  Äí  O >  Éí  ?   Ëí  ZÈÿÿ?   Ìí  &¡  <  Çí  O >  Ìí  ?   Îí  tÈÿÿ?   Ïí  #¡  <  Êí  O >  Ïí  ?   Ñí  #¡  <  Ìí  O >  Ñí  ?   Óí  #¡  <  Îí  O >  Óí  ?   Õí  øÈÿÿ?   Øí   ¡  <  Óí  O >  Øí  ?   Úí  õÈÿÿ?   İí  ¡  <  Øí  O >  İí  ?   ßí  Éÿÿ?   âí  ¡  <  İí  O >  âí  ?   äí  =Éÿÿ?   çí  ¡  <  âí  O >  çí  ?   éí  UÉÿÿ?   ìí  ¡  <  çí  O >  ìí  ?   îí  hÉÿÿ?   ñí  ¡  <  ìí  O >  ñí  ?   óí  ŒÉÿÿ?   öí  ¡  <  ñí  O >  öí  ?   øí  KÊÿÿ?   ûí  ¡  <  öí  O >  ûí  ?   ıí  aÊÿÿ?    î  ¡  <  ûí  O >   î  ?   î  YËÿÿ?   î  ÏËÿÿ?   î  Ìÿÿ?   î  eÍÿÿ?   î  ¹Îÿÿ?   î  ¡  <  î  O >  î  ?   î  õÎÿÿ?   î  ¡  <  î  O >  î  ?   î  ûÎÿÿ?   î  ¡  <  î  O >  î  ?   î  ¡  <  î  O >  î  ?   î  ¡  <  î  O >  î  ?   î  ¡  <  î  O >  î  ?   !î  ¡  <  î  O >  !î  ?   #î  ÿ   <  î  O >  #î  ?   %î  ÿ   <   î  O >  %î  ?   'î  ¡  <  "î  O >  'î  =  %î  >  %î  =  î  >  %î  ?   %î  î  =  î  >  "î  ?   "î  î  =  õí  >  î  ?   î  î  =  äí  >  î  ?   î  î  =  Óí  >  î  ?   î  î  ?   î  Ü   <  î  O >  î  ?    î  ,Ïÿÿ?   !î  Û   <  î  O >  !î  ?   #î  5Ïÿÿ?   &î  Ø   <  !î  O >  &î  ?   (î  ÈÏÿÿ?   )î  Ù   <  $î  O >  )î  ?   +î  áÏÿÿ?   .î  Ö   <  )î  O >  .î  