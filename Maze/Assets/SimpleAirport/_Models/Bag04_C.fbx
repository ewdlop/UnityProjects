    FieldPosition& pos,
                                  UErrorCode& status) const;



    /**
     * Initialize interval patterns locale to this formatter
     *
     * This code is a bit complicated since
     * 1. the interval patterns saved in resource bundle files are interval
     *    patterns based on date or time only.
     *    It does not have interval patterns based on both date and time.
     *    Interval patterns on both date and time are algorithm generated.
     *
     *    For example, it has interval patterns on skeleton "dMy" and "hm",
     *    but it does not have interval patterns on skeleton "dMyhm".
     *
     *    The rule to generate interval patterns for both date and time skeleton are
     *    1) when the year, month, or day differs, concatenate the two original
     *    expressions with a separator between,
     *    For example, interval pattern from "Jan 10, 2007 10:10 am"
     *    to "Jan 11, 2007 10:10am" is
     *    "Jan 10, 2007 10:10 am - Jan 11, 2007 10:10am"
     *
     *    2) otherwise, present the date followed by the range expression
     *    for the time.
     *    For example, interval pattern from "Jan 10, 2007 10:10 am"
     *    to "Jan 10, 2007 11:10am" is
     *    "Jan 10, 2007 10:10 am - 11:10am"
     *
     * 2. even a pattern does not request a certain calendar field,
     *    the interval pattern needs to include such field if such fields are
     *    different between 2 dates.
     *    For example, a pattern/skeleton is "hm", but the interval pattern
     *    includes year, month, and date when year, month, and date differs.
     *
     *
     * @param status    output param set to success/failure code on exit
     */
    void initializePattern(UErrorCode& status);



    /**
     * Set fall back interval pattern given a calendar field,
     * a skeleton, and a date time pattern generator.
     * @param field      the largest different calendar field
     * @param skeleton   a skeleton
     * @param status     output param set to success/failure code on exit
     */
    void setFallbackPattern(UCalendarDateFields field,
                            const UnicodeString& skeleton,
                            UErrorCode& status);



    /**
     * get separated date and time skeleton from a combined skeleton.
     *
     * The difference between date skeleton and normalizedDateSkeleton are:
     * 1. both 'y' and 'd' are appeared only once in normalizeDateSkeleton
     * 2. 'E' and 'EE' are normalized into 'EEE'
     * 3. 'MM' is normalized into 'M'
     *
     ** the difference between time skeleton and normalizedTimeSkeleton are:
     * 1. both 'H' and 'h' are normalized as 'h' in normalized time skeleton,
     * 2. 'a' is omitted in normalized time skeleton.
     * 3. there is only one appearance for 'h', 'm','v', 'z' in normalized time
     *    skeleton
     *
     *
     *  @param skeleton               given combined skeleton.
     *  @param date                   Output parameter for date only skeleton.
     *  @param normalizedDate         Output parameter for normalized date only
     *
     *  @param time                   Output parameter for time only skeleton.
     *  @param normalizedTime         Output parameter for normalized time only
     *                                skeleton.
     *
     */
    static void  U_EXPORT2 getDateTimeSkeleton(const UnicodeString& skeleton,
                                    UnicodeString& date,
                                    UnicodeString& normalizedDate,
                                    UnicodeString& time,
                                    UnicodeString& normalizedTime);



    /**
     * Generate date or time interval pattern from resource,
     * and set them into the interval pattern locale to this formatter.
     *
     * It needs to handle the following:
     * 1. need to adjust field width.
     *    For example, the interval patterns saved in DateIntervalInfo
     *    includes "dMMMy", but not "dMMMMy".
     *    Need to get interval patterns for dMMMMy from dMMMy.
     *    Another example, the interval patterns saved in DateIntervalInfo
     *    includes "hmv", but not "hmz".
     *    Need to get interval patterns for "hmz' from 'hmv'
     *
     * 2. there might be no pattern for 'y' differ for skeleton "Md",
     *    in order to get interval patterns for 'y' differ,
     *    need to look for it from skeleton 'yMd'
     *
     * @param dateSkeleton   normalized date skeleton
     * @param timeSkeleton   normalized time skeleton
     * @return               whether the resource is found for the skeleton.
     *                       TRUE if interval pattern found for the skeleton,
     *                       FALSE otherwise.
     */
    UBool setSeparateDateTimePtn(const UnicodeString& dateSkeleton,
                                 const UnicodeString& timeSkeleton);




    /**
     * Generate interval pattern from existing resource
     *
     * It not only save the interval patterns,
     * but also return the extended skeleton and its best match skeleton.
     *
     * @param field           largest different calendar field
     * @param skeleton        skeleton
     * @param bestSkeleton    the best match skeleton which has interval pattern
     *                        defined in resource
     * @param differenceInfo  the difference between skeleton and best skeleton
     *         0 means the best matched skeleton is the same as input skeleton
     *         1 means the fields are the same, but field width are different
     *         2 means the only difference between fields are v/z,
     *        -1 means there are other fields difference
     *
     * @param extendedSkeleton      extended skeleton
     * @param extendedBestSkeleton  extended best match skeleton
     * @return                      whether the interval pattern is found
     *                              through extending skeleton or not.
     *                              TRUE if interval pattern is found by
     *                              extending skeleton, FALSE otherwise.
     */
    UBool setIntervalPattern(UCalendarDateFields field,
                             const UnicodeString* skeleton,
                             const UnicodeString* bestSkeleton,
                             int8_t differenceInfo,
                             UnicodeString* extendedSkeleton = NULL,
                             UnicodeString* extendedBestSkeleton = NULL);

    /**
     * Adjust field width in best match interval pattern to match
     * the field width in input skeleton.
     *
     * TODO (xji) make a general solution
     * The adjusting rule can be:
     * 1. always adjust
     * 2. never adjust
     * 3. default adjust, which means adjust according to the following rules
     * 3.1 always adjust string, such as MMM and MMMM
     * 3.2 never adjust between string and numeric, such as MM and MMM
     * 3.3 always adjust year
     * 3.4 do not adjust 'd', 'h', or 'm' if h presents
     * 3.5 do not adjust 'M' if it is numeric(?)
     *
     * Since date interval format is well-formed format,
     * date and time skeletons are normalized previously,
     * till this stage, the adjust here is only "adjust strings, such as MMM
     * and MMMM, EEE and EEEE.
     *
     * @param inputSkeleton            the input skeleton
     * @param bestMatchSkeleton        the best match skeleton
     * @param bestMatchIntervalPattern the best match interval pattern
     * @param differenceInfo           the difference between 2 skeletons
     *                                 1 means only field width differs
     *                                 2 means v/z exchange
     * @param adjustedIntervalPattern  adjusted interval pattern
     */
    static void U_EXPORT2 adjustFieldWidth(
                            const UnicodeString& inputSkeleton,
                            const UnicodeString& bestMatchSkeleton,
                            const UnicodeString& bestMatchIntervalPattern,
                            int8_t differenceInfo,
                            UnicodeString& adjustedIntervalPattern);

    /**
     * Concat a single date pattern with a time interval pattern,
     * set it into the intervalPatterns, while field is time field.
     * This is used to handle time interval patterns on skeleton with
     * both time and date. Present the date followed by
     * the range expression for the time.
     * @param format         date and time format
     * @param formatLen      format string length
     * @param datePattern    date pattern
     * @param field          time calendar field: AM_PM, HOUR, MINUTE
     * @param status         output param set to success/failure code on exit
     */
    void concatSingleDate2TimeInterval(const UChar* format,
                                       int32_t formatLen,
                                       const UnicodeString& datePattern,
                                       UCalendarDateFields field,
                                       UErrorCode& status);

    /**
     * check whether a calendar field present in a skeleton.
     * @param field      calendar field need to check
     * @param skeleton   given skeleton on which to check the calendar field
     * @return           true if field present in a skeleton.
     */
    static UBool U_EXPORT2 fieldExistsInSkeleton(UCalendarDateFields field,
                                                 const UnicodeString& skeleton);


    /**
     * Split interval patterns into 2 part.
     * @param intervalPattern  interval pattern
     * @return the index in interval pattern which split the pattern into 2 part
     */
    static int32_t  U_EXPORT2 splitPatternInto2Part(const UnicodeString& intervalPattern);


    /**
     * Break interval patterns as 2 part and save them into pattern info.
     * @param field            calendar field
     * @param intervalPattern  interval pattern
     */
    void setIntervalPattern(UCalendarDateFields field,
                            const UnicodeString& intervalPattern);


    /**
     * Break interval patterns as 2 part and save them into pattern info.
     * @param field            calendar field
     * @param intervalPattern  interval pattern
     * @param laterDateFirst   whether later date appear first in interval pattern
     */
    void setIntervalPattern(UCalendarDateFields field,
                            const UnicodeString& intervalPattern,
                            UBool laterDateFirst);


    /**
     * Set pattern information.
     *
     * @param field            calendar field
     * @param firstPart        the first part in interval pattern
     * @param secondPart       the second part in interval pattern
     * @param laterDateFirst   whether the first date in intervalPattern
     *                         is earlier date or later date
     */
    void setPatternInfo(UCalendarDateFields field,
                        const UnicodeString* firstPart,
                        const UnicodeString* secondPart,
                        UBool laterDateFirst);


    // from calendar field to pattern letter
    static const UChar fgCalendarFieldToPatternLetter[];


    /**
     * The interval patterns for this locale.
     */
    DateIntervalInfo*     fInfo;

    /**
     * The DateFormat object used to format single pattern
     */
    SimpleDateFormat*     fDateFormat;

    /**
     * The 2 calendars with the from and to date.
     * could re-use the calendar in fDateFormat,
     * but keeping 2 calendars make it clear and clean.
     */
    Calendar* fFromCalendar;
    Calendar* fToCalendar;

    /**
     * Date time pattern generator
     */
    DateTimePatternGenerator* fDtpng;

    /**
     * Following are interval information relavent (locale) to this formatter.
     */
    UnicodeString fSkeleton;
    PatternInfo fIntervalPatterns[DateIntervalInfo::kIPI_MAX_INDEX];
};

inline UBool
DateIntervalFormat::operator!=(const Format& other) const  {
    return !operator==(other);
}

U_NAMESPACE_END

#endif /* #if !UCONFIG_NO_FORMATTING */

#endif // _DTITVFMT_H__
//eof
                                                                                                                                                                                                                                                                                                                                                            4o%D:F'n)* h8eԱ:oֈVNx|yP>H ,cGfv dBpFd	ʷ٬y˛5e/Q@m$9|Ga_O)2ziN-4KdHC!!|:Q$B;5o(]DlbȚi!>=oh5Q˨Cbe`sp'	x'Q[d#Ymq'v;]g`yIz\0$	HkX)=.DClt]?*핶1DJAL`T;fD5 ^yDaDҖXs	3rw|GhًQбFuUaLpڻZ$F,Wf.zc9-Eypz#2ANkو.f &Ҳ}Lի;[),$`GׄZofWj)D$63S.1eյ!%`%<q :>8:`fO5|HVn=~:IkCZ2P7#u$8l<Ll3|k2h
H>b$19oLͼ<ms$>6 K/ir]oryDo*oN>@LMmF78_KR45oF!^x3#޿iT9W`~]dm~O
6Lp*|O3=3aW:>%BhIwca2>gY5A?^2Jy'N;ir*[ƛHM{ԦyUaaSoh!>_ P{k8ZȠmPumu.	kg.n.#miP#F09To/&lF$ɑJByʄZWQYe!gfs'5j6YІkhȘ&|͖Btr`Z (	:<?WZk}pwg	>!oWfJ\Zگ'#ô
c&TP!5RsXJ'a2-^{;yhUҼwAgBYG	cnƏVeI1\--.A!뚐fd[w]~7
zqLbCDAC*YTAu  v{SV)fPF Bzݤsb%a<0-<01x)Ӏj1QX+5bX]\.^58".fJ2~5%$}w#$|aq!aA3vp ;?=	:Er@`
_pϩ7II&~R62BicBDNi >bRClU<(Df8ЪA'?f;sWѩO륞vEAćN Λ=q~_7}lZI0m(
 Unm;6o5>Zs{: %t.FRuk=1&!p'yYxn8KQg?ԑ2?Gbzw8 y>9)獚vHql'Sנ-q0TA,\-6]VuЏ"^=@hj&	GUf>3!7h{"+OkW:e;}q#RH}2e@&B`Qr2[bpͭt3y5LHc%n9?R6s{k^ۥqh9;~tϖ;ޡ}%FUх[{ӵǯ0vO	1.(9/O05{r{ u6B4<Vljnk PQ1x_03obGJ8pGӴ"h]pnԄTW
"oFƏLkuЇg_tDtc0jy>=٥UUs.u\-MW$ľS,H?[|k.^
OZG;*C0!0vI0ݷWzj;,w~$Ht~[$Bdqp|⃋'uK9;6)9ngɜ[
{#شq-؉eNM{(1|B,Lfp4q!?q'
Z2s8+\GƶEu%d, }Xz3*]Vp'aiِP˫~юzc8R>ZlbG=\)|zf1J	.i2oZ _ِ6Q0w)7WkӠr}~ty>NlǛqBCYyMosS6( m</wkfd㫉7%*foZ׹k*_ŐZ\ 4m'ڃU,BKMч<j(
BXdpᜡΪ8|x~Q&@Ämc3Q>T_kb-{
B?ځu9:S<J
5pL8].9D2|GO +9`yXkڪƍ!-TNNP9M@OU/Eyn6g''
!cpW{җ[!Ѓ+B|BJ
Y$66A@'KVT1&+tK"t%xub@ h2[/MVFUz@/[Y$ÝbOkX4( ;aEBFN^C{xHQ^Gl{ 9+;4~<]bvo·31( =?9Gꑍ@$_|,~@␿r;6?Ey%mp5i<%b2BLSM˚[a4f%}ߌRj	'y%D&dsFha_v.yve6j 1RO* LSzuԌOyaV}e[*\&.2A@^%ύ2qcp&tCћEkL'k~:
߇YƦe4iil"_:©RX2]\@@$f@z,P?wviƛ@ΕR J];y
';ӧ$?	~Y0=vx؏Y2OA<Ǟ>>P'BٍU=ifIYpU:0NH;ru!W
Wg%VPNG

   IHDR  V     )-   	pHYs       
OiCCPPhotoshop ICC profile  xڝSgTS=BKKoR RB&*!	J!QEEȠQ,
!{kּ>H3Q5B.@
$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbϫp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GLϒ	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.Tʳ?  D*A,`6B$BB
dr`)B(Ͱ*`/@4Qhp.U=pa(	Aa!ڈbX#!H$ ɈQ"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6Ыhڏ>C03l0.B8,	c˱"VcϱwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +ȅ3![
b@qS(RjJ4e2AURݨT5ZBRQ4u9̓IKhhitݕNWGwǈg(gwLӋT071oUX**|
J&*/TުUUT^S}FU3S	ԖUPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSSݧ
M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caaᄑ<FFi\$mmƣ&&!&KMMRM);L;L֙͢5=12כ߷`ZxZ,eIZYnZ9YXUZ]F%ֻNNgðɶۮm}agbgŮ}}=Z~sr:V:ޚΜ?}/gX3)iSGggs󈋉K.>.ȽJtq]zۯ6iܟ4)Y3sCQ?0k߬~OCOg#/c/Wװwa>>r><72Y_7ȷOo_C#dz %gA[z|!?:eAAA!h쐭!ΑiP~aa~'W?pX15wCsDDDޛg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
yg"/6шC\*NH*Mz쑼5y$3,幄'LLݛ:v m2=:1qB!Mggfvˬen/kY-
BTZ(*geWf͉9+̳ې7ᒶKW-X潬j9<qy
+V<*mOW~&zMk^ʂkU
}]OX/Yߵa>(xoʿܔĹdff-[nڴVE/(ۻC<e;?TTTT6ݵan{4[>ɾUUMfeI?m]Nmq#׹=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTiӓgό}~.`ۢ{cjotE;;\tWW:_mt<Oǻ\kz{f7y՞9=ݽzo~r'˻w'O_@AC݇?[jwGCˆ8>99?rCd&ˮ/~јѡ򗓿m|x31^VwwO| (hSЧc3-    cHRM  z%        u0  `  :  o_F  IDATxw`E?W;@(7APHbW׊++((EzWz!K.v\r{-vݙy;<Իwo`Q\\LlllQQQoXyQEo߶m@@@@@@@@@@@+A	wj(	dff&	LYYY9Mq:տ$	_I]VT@@*#Tƶ*FQL&&	UUk$3,(JPXXx>Q!/I$ѴiSFcФ/Tyz#VvۗҪu+"##elZ?UQ a)6t\ѐd	U	'PȇZ'7MQf.ǏRAdl6<941Ϥez:Qa/fذStO|.PJ$d2i޿\5vOGU$ɥ\:mWUyVݧoU%Ϫ~-PժwP%%߿;vdge#,j䪸ԴTZtFѻG7X0eU;Bu'U'1kTRC՝.5 U^#y$nFxxWbXm2Y՝.+H`xU۞fbӜSESvh(N F'F>::-[ryvZt:y,hAjxRe2i6NY JTUq#U!eq&pT]TjeXHxuPSh>˯xr/07si)rv'g'$2]-SUmƅ,9	U-@Ulep_U;UU(ĪlݺhzAii)	L&JJJJ@@%U &dRUfl{syM&VNk/2)THae%ܢ&U@T6+_qjNb%0 ir1YyZϯd܉YՇIA$b&FvO˔W2J݈u˕ n/	f~a|R%4b!|/**bӦMlْ!&&&)ZAB"Wj%F}x4VSiEPl6GNuNTXqWyy꣟
3ȍ1_,+N$)_J f"_{s*PjÍ`In#vt/9ɋC+bB;}*Ӳ}B+\p)eU[ܧ|(!5tOv"4i^Ǩ7RQQ!H VkahN6Nl6ņh-W#(f(,-';];1?<5r ;QZ+X*OR	m*CrZ$4kWI.W%,IA<U}ҾjRj#r2ITqN@uw8,6URCs>Q>ԩ. ! GPZAj eWB͆\Pl6ժ!V^Nah,$&&DaI)wRfv2*SY{(_Z#7nHIFNǧ/<BltϾo鑇$٫$睋,K<b4A&픘x)1pExH?W޺Nǥa@D_dbڍYUUHk+PRjF0j9Ov?s|A+TyJTiRɗGQi5r*tysQtNrlV+ΊbaZPl֪EU/XJthOLѻnfﻙ޼a<}M̜婉7q/0t3bz4y.bWty26ϫ>}(!Rm%pl$v"ofT{dTb(ѷG6+ңS;pq1|جg:W\4ZmqfHVW4WBp.W5Tw)Wk=]*? 4'֝
j,F+UfAfbXY+Q\V.;IZ$&&@~~wB./ٷf_XLar3NxU%YSbX> <%#KZx^x^XmZ4)E+Ͼjqn|%4KiJ|,]gdm3^gE|y8=Lb\,SfΡKtnm;y00wwTUeߡ;+bҮwnϝ׏UT3_Xa?>e8EŴhŝ]N/,Khgщ%kӹ],eւev&IX-q9+߽Pf%=9=<?S@yx{֯3.r+g`عd'vbu</:u:]'$SZxoNv+7bցTAZ	4֛0*%EUP;OZZ'ѲY<V+zLvܩ-҉ -5m;a˿Xm6wq1J-Y87\6&,X{<D`gd?<r14ߎ,|oDE3y$D~v 2S9CÌ=6K%m[6tZgFƭ}^:QC`DFegm~ȈpzwRAR\4/>z/	1|l=O{	1Q|ՏWPQY۟|p^x6YRd*1w'յ#s-g-XJlJ'!ڼc7K@9mV)IUjjRYɖ$&ݺk/<n4jbwٕgv6kl[,Xl.͂8o<mʪ?Eu-?U!`ŪXV[Q}V@UQhByy9:UOaQFc8&c=`(XVb"/,vZ"*]=MWa86?-;vWY2`۟`	?}C͜0q}<bIq\6<Z~6 ڵJ'pdlN8ڶn{쫇쿖okvNof_ϞDFd?,Ynaf>~ۯNi| .<K~{/3r  _f;AOJNS^^_ȓ8jFf:ӈ$T
>gF9*fsޓѢ9ryTJKM.tJt
)<Exs:숃jjX?T