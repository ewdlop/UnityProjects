  * Returns offset from GMT(UTC) in milliseconds for the given ISO 8601 style
     * (extended format) time zone string. When the given string is not an ISO 8601 time
     * zone string, this method sets the current position as the error index
     * to <code>ParsePosition pos</code> and returns 0.
     * @param text the text contains ISO 8601 style time zone string (e.g. "-08:00", "Z")
     *      at the position.
     * @param pos the position, non-negative error index will be set on failure.
     * @param extendedOnly TRUE if parsing the text as ISO 8601 extended offset format (e.g. "-08:00"),
     *      or FALSE to evaluate the text as basic format.
     * @param hasDigitOffset receiving if the parsed zone string contains offset digits.
     * @return the offset from GMT(UTC) in milliseconds for the given ISO 8601 style
     *      time zone string.
     */
    int32_t parseOffsetISO8601(const UnicodeString& text, ParsePosition& pos, UBool extendedOnly,
        UBool* hasDigitOffset = NULL) const;

    /**
     * Appends localized digits to the buffer.
     * This code assumes that the input number is 0 - 59
     * @param buf the target buffer
     * @param n the integer number
     * @param minDigits the minimum digits width
     */
    void appendOffsetDigits(UnicodeString& buf, int32_t n, uint8_t minDigits) const;

    /**
     * Returns offset from GMT(UTC) in milliseconds for the given localized GMT
     * offset format string. When the given string cannot be parsed, this method
     * sets the current position as the error index to <code>ParsePosition pos</code>
     * and returns 0.
     * @param text the text contains a localized GMT offset string at the position.
     * @param pos the position, non-negative error index will be set on failure.
     * @param isShort true if this parser to try the short format first
     * @param hasDigitOffset receiving if the parsed zone string contains offset digits.
     * @return the offset from GMT(UTC) in milliseconds for the given localized GMT
     *      offset format string.
     */
    int32_t parseOffsetLocalizedGMT(const UnicodeString& text, ParsePosition& pos,
        UBool isShort, UBool* hasDigitOffset) const;

    /**
     * Parse localized GMT format generated by the patter used by this formatter, except
     * GMT Zero format.
     * @param text the input text
     * @param start the start index
     * @param isShort true if the short localized format is parsed.
     * @param parsedLen receives the parsed length
     * @return the parsed offset in milliseconds
     */
    int32_t parseOffsetLocalizedGMTPattern(const UnicodeString& text, int32_t start,
        UBool isShort, int32_t& parsedLen) const;

    /**
     * Parses localized GMT offset fields into offset.
     * @param text the input text
     * @param start the start index
     * @param isShort true if this is a short format - currently not used
     * @param parsedLen the parsed length, or 0 on failure.
     * @return the parsed offset in milliseconds.
     */
    int32_t parseOffsetFields(const UnicodeString& text, int32_t start, UBool isShort, int32_t& parsedLen) const;

    /**
     * Parse localized GMT offset fields with the given pattern.
     * @param text the input text
     * @param start the start index
     * @param pattenItems the pattern (already itemized)
     * @param forceSingleHourDigit true if hours field is parsed as a single digit
     * @param hour receives the hour offset field
     * @param min receives the minute offset field
     * @param sec receives the second offset field
     * @return the parsed length
     */
    int32_t parseOffsetFieldsWithPattern(const UnicodeString& text, int32_t start,
        UVector* patternItems, UBool forceSingleHourDigit, int32_t& hour, int32_t& min, int32_t& sec) const;

    /**
     * Parses abutting localized GMT offset fields (such as 0800) into offset.
     * @param text the input text
     * @param start the start index
     * @param parsedLen the parsed length, or 0 on failure
     * @return the parsed offset in milliseconds.
     */
    int32_t parseAbuttingOffsetFields(const UnicodeString& text, int32_t start, int32_t& parsedLen) const;

    /**
     * Parses the input text using the default format patterns (e.g. "UTC{0}").
     * @param text the input text
     * @param start the start index
     * @param parsedLen the parsed length, or 0 on failure
     * @return the parsed offset in milliseconds.
     */
    int32_t parseOffsetDefaultLocalizedGMT(const UnicodeString& text, int start, int32_t& parsedLen) const;

    /**
     * Parses the input GMT offset fields with the default offset pattern.
     * @param text the input text
     * @param start the start index
     * @param separator the separator character, e.g. ':'
     * @param parsedLen the parsed length, or 0 on failure.
     * @return the parsed offset in milliseconds.
     */
    int32_t parseDefaultOffsetFields(const UnicodeString& text, int32_t start, UChar separator,
        int32_t& parsedLen) const;

    /**
     * Reads an offset field value. This method will stop parsing when
     * 1) number of digits reaches <code>maxDigits</code>
     * 2) just before already parsed number exceeds <code>maxVal</code>
     *
     * @param text the text
     * @param start the start offset
     * @param minDigits the minimum number of required digits
     * @param maxDigits the maximum number of digits
     * @param minVal the minimum value
     * @param maxVal the maximum value
     * @param parsedLen the actual parsed length.
     * @return the integer value parsed
     */
    int32_t parseOffsetFieldWithLocalizedDigits(const UnicodeString& text, int32_t start,
        uint8_t minDigits, uint8_t maxDigits, uint16_t minVal, uint16_t maxVal, int32_t& parsedLen) const;

    /**
     * Reads a single decimal digit, either localized digits used by this object
     * or any Unicode numeric character.
     * @param text the text
     * @param start the start index
     * @param len the actual length read from the text
     * the start index is not a decimal number.
     * @return the integer value of the parsed digit, or -1 on failure.
     */
    int32_t parseSingleLocalizedDigit(const UnicodeString& text, int32_t start, int32_t& len) const;

    /**
     * Formats offset using ASCII digits. The input offset range must be
     * within +/-24 hours (exclusive).
     * @param offset The offset
     * @param sep The field separator character or 0 if not required
     * @param minFields The minimum fields
     * @param maxFields The maximum fields
     * @return The offset string
     */
    static UnicodeString& formatOffsetWithAsciiDigits(int32_t offset, UChar sep,
        OffsetFields minFields, OffsetFields maxFields, UnicodeString& result);

    /**
     * Parses offset represented by contiguous ASCII digits.
     * <p>
     * Note: This method expects the input position is already at the start of
     * ASCII digits and does not parse sign (+/-).
     * @param text The text contains a sequence of ASCII digits
     * @param pos The parse position
     * @param minFields The minimum Fields to be parsed
     * @param maxFields The maximum Fields to be parsed
     * @param fixedHourWidth true if hours field must be width of 2
     * @return Parsed offset, 0 or positive number.
     */
    static int32_t parseAbuttingAsciiOffsetFields(const UnicodeString& text, ParsePosition& pos,
        OffsetFields minFields, OffsetFields maxFields, UBool fixedHourWidth);

    /**
     * Parses offset represented by ASCII digits and separators.
     * <p>
     * Note: This method expects the input position is already at the start of
     * ASCII digits and does not parse sign (+/-).
     * @param text The text
     * @param pos The parse position
     * @param sep The separator character
     * @param minFields The minimum Fields to be parsed
     * @param maxFields The maximum Fields to be parsed
     * @return Parsed offset, 0 or positive number.
     */
    static int32_t parseAsciiOffsetFields(const UnicodeString& text, ParsePosition& pos, UChar sep,
        OffsetFields minFields, OffsetFields maxFields);

    /**
     * Unquotes the message format style pattern.
     * @param pattern the pattern
     * @param result receive the unquoted pattern.
     * @return A reference to result.
     */
    static UnicodeString& unquote(const UnicodeString& pattern, UnicodeString& result);

    /**
     * Initialize localized GMT format offset hour/min/sec patterns.
     * This method parses patterns into optimized run-time format.
     * @param status receives the status.
     */
    void initGMTOffsetPatterns(UErrorCode& status);

    /**
     * Check if there are any GMT format offset patterns without
     * any separators between hours field and minutes field and update
     * fAbuttingOffsetHoursAndMinutes field. This method must be called
     * after all patterns are parsed into pattern items.
     */
    void checkAbuttingHoursAndMinutes();

    /**
     * Creates an instance of TimeZone for the given offset
     * @param offset the offset
     * @return A TimeZone with the given offset
     */
    TimeZone* createTimeZoneForOffset(int32_t offset) const;

    /**
     * Returns the time type for the given name type
     * @param nameType the name type
     * @return the time type (unknown/standard/daylight)
     */
    static UTimeZoneFormatTimeType getTimeType(UTimeZoneNameType nameType);

    /**
     * Returns the time zone ID of a match at the specified index within
     * the MatchInfoCollection.
     * @param matches the collection of matches
     * @param idx the index withing matches
     * @param tzID receives the resolved time zone ID
     * @return a reference to tzID.
     */
    UnicodeString& getTimeZoneID(const TimeZoneNames::MatchInfoCollection* matches, int32_t idx, UnicodeString& tzID) const;


    /**
     * Parse a zone ID.
     * @param text the text contains a time zone ID string at the position.
     * @param pos the position
     * @param tzID receives the zone ID
     * @return a reference to tzID
     */
    UnicodeString& parseZoneID(const UnicodeString& text, ParsePosition& pos, UnicodeString& tzID) const;

    /**
     * Parse a short zone ID.
     * @param text the text contains a short time zone ID string at the position.
     * @param pos the position
     * @param tzID receives the short zone ID
     * @return a reference to tzID
     */
    UnicodeString& parseShortZoneID(const UnicodeString& text, ParsePosition& pos, UnicodeString& tzID) const;

    /**
     * Parse an exemplar location string.
     * @param text the text contains an exemplar location string at the position.
     * @param pos the position.
     * @param tzID receives the time zone ID
     * @return a reference to tzID
     */
    UnicodeString& parseExemplarLocation(const UnicodeString& text, ParsePosition& pos, UnicodeString& tzID) const;
};

U_NAMESPACE_END

#endif /* !UCONFIG_NO_FORMATTING */
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ‰]B[×Æ²O å¡|¬¡²µË§‚*æÉ¢”h«jÁ$@Ş*¥ø_+š¢}›Ÿ-‹ÏÄ;ÚñäÜø4À“6k€u¬Ê7ˆÕ~Ã áüu8/ Ş“Îµká¦¾;D‡ôĞ*ùåÏ°Í4}iİ±)P—ò(£˜í…ê²ùŠDÊ¶/ÜB×Ş ¶"÷—^‘îU£ù»Ï@kUİi†¬ ¸ı¡lïıqª`FX—V:€I0‚‡WjôÓ‘Ÿå$>h:=›6”“ÕM)‹2PLn…‚¾_a­AÔ—ìıV[Ëìñâ7[¨´^Ê„" 7YRx\ROQ³ıeeoy	±;®?¹¯Òä:…“*æÛ<ˆ>oÌöhYú›Aös`Şß{–ñ,õ÷Jt®ÂÃ[`'ª‡nŸŞL>¾¤ L'œœ‹ÛòUü¦ñ¡¨†È·± ·Bzc`Sô\®“¸İ#1|Æ RFŸÿ.?u1L}?^5‘®ÂüN£"¥‹§|” †°‰w÷oæxÄ3RÂ³Å2{Ì\Êôg€Ê>EÊñ‚´û­¸²éK²æàåz½((´û#/ÉŸ1h çş£UÃó^â¯QaF†·d+Çq6jeÄ¸ñ’çº‹(‡,«P¦e½¾ZNGmÀ~dK”<Type Name="Type2Message" FullName="Mono.Security.Protocol.Ntlm.Type2Message">
  <TypeSignature Language="C#" Value="public class Type2Message : Mono.Security.Protocol.Ntlm.MessageBase" Maintainer="auto" />
  <AssemblyInfo>
    <AssemblyName>Mono.Security</AssemblyName>
    <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 79 15 99 77 D2 D0 3A 8E 6B EA 7A 2E 74 E8 D1 AF CC 93 E8 85 19 74 95 2B B4 80 A1 2C 91 34 47 4D 04 06 24 47 C3 7E 0E 68 C0 80 53 6F CF 3C 3F BE 2F F9 C9 79 CE 99 84 75 E5 06 E8 CE 82 DD 5B 0F 35 0D C1 0E 93 BF 2E EE CF 87 4B 24 77 0C 50 81 DB EA 74 47 FD DA FA 27 7B 22 DE 47 D6 FF EA 44 96 74 A4 F9 FC CF 84 D1 50 69 08 93 80 28 4D BD D3 5F 46 CD FF 12 A1 BD 78 E4 EF 00 65 D0 16 DF]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the <link location="node:gtk-sharp/programming/threads">Gtk# Thread Programming</link> for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>Mono.Security.Protocol.Ntlm.MessageBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>A Type2 message is used by a server to return a nonce (a random value) as a challenge to the client to negotiate the challenge/response parameters (flags). </summary>
    <remarks>To be added</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Type2Message ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>Construct an empty Type2Message instance.</summary>
        <remarks>This constructor is used on the server side to construct a Type2 message to be sent to the client.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Type2Message (byte[] message);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="message" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">an array of bytes containing the Type2 message to decode.</param>
        <summary>Construct an Type2Message instance with the specified message.</summary>
        <remarks>This constructor is used on the client side to decode a Type2 message received from the server. </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Decode">
      <MemberSignature Language="C#" Value="protected override void Decode (byte[] message);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">an array of bytes containing the message to decode.</param>
        <summary>Decode the specified binrary message.</summary>
        <remarks>To be added</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Type2Message ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Return the binary message.</summary>
        <returns>an array of bytes containing the constructed message.</returns>
        <remarks>To be added</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Nonce">
      <MemberSignature Language="C#" Value="public byte[] Nonce { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A random value, choosed by the server, to by used as the challenge by the client.</summary>
        <value>an array of 8 random bytes.</value>
        <remarks>The random data is generated using the default random number generator, <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
</Type>
                                                                                                                                            ÊT€—ÈR9yµÍ_µ¹JË<é5>ßHpÆ‚V2Ä·±Ì¬}lkî¹_<ÀÍDiÕ~fæşFk[ì—‡ºõÛh?úİìMÁ Ôj~êÌ"
L€w;Ï—ó[¢ñ`XÒ2JÔiQS’»RO¢ÛşÆWôWî‹2æ…Œ=}"!ÌUóÆdÜì`õEgÎÊZg)œ¼^Kª¸Õş4îiVŞ‹Ò]ûî†>¢Ö™Møà}zï°{Ó#ÎvÕ¢3ÛÈ'ºÿÉÁ¶šËù =Zı		Ëş÷§óTVt]íŒHOÑÿ2$à~Òöc¢9<BÕHìmÁ&ÙëA}›Ûş®‚é¦GÁ®µÄ>Uw<ÌkDÆŒÓ\Ç~ì“ù÷U(yşÇjÅWG°4B; L¥uí|O»Á÷÷³½/Úïêş–-`<lİIYvóÚ$¨¬¨ÀOKÖ··¤?¯Û6áwvqäˆÉ4û+ÇÊ‡z).h­¶şÊû‚íO÷PÁT23™P¿„ºåÔQA^=äÃõïª}¥I0.áÅÉŠ‘\¢ğF2ÿÂ²Ø—q¸|†ÁDH„ã˜WKÂÓP¡iÃæè€ˆjâÂL×//!ÇÀÀg#x53W¿¬’ë0|¹HJßrƒ/« †±‡„»{°«©WEH{·íŞ÷¡êİ¼ªìè}NësóÉñ’õŞWÓ 9®Gt¢Öë«dY–¼ã,ÌŸ?Öy*C®ù /€Š1–uİ˜´K1½Në}!eç§š6Çâ»qÎñßğ¥D¸´ÉRD°Ûfsæ›Eÿ»s/;¡q´&}0šfwÀ½¤ÔêÀ¥—ˆ;A¯¢zhj-fm–aÂï4ó¯^jûÚ(X¦b ^À:'ê$.—1 ÂÚîİ#†Cİ›—8_($IUú€ü«À½c5‚Éƒú8Ü»#‹~kÕ:5Û@z¹’4ÁèÕ¯1òGH‰2ïT›Üª+;Ìï‘êôß|Ÿå/¨s¹ \¡kÕ˜ph˜ÚĞQıâƒ%å;«dÏ¸êcÀù2<°e}˜{àx¦BSİÊ³ÌKMÇÒ2‰Å[‡,Ì'ƒ£úG²ÿĞcó39_¡ÜCüúıÓT¢ÿä,TŸ7ˆ¬Ô6ö¾ìÓJ¬T¡ÁÅHñ*[)Öåû+"PjxåŒP8?RlËo) YÇ™qêfDOcˆÑ“¥î±|Fûp±>ƒÆm5$¡¬	¼ÌûúÊÊ6;\³ë`™˜Ñóß¦vôÚĞ–"³¹®Ç%‹H—·43ëğÑ8÷jğˆ+õ*Nı&·Ù ñ|GæMıG½TÉÈÉ=½ceÂÕMâöÁß«/“ßû‰p©ƒqw%–|ù'†=xÃò´T.óœ7/ï|>ØË'S(ù{§aw[(Ğ.¾·Z“J¢œ\mz¨{Hé«şˆ#ÜàZxpVæ}Şàøˆf/¸\6P$èTÃ ¸Véº`A’ŒÁK¸ê+å!“=ˆø•~aÿLDu¦<M<À"Ø§	T²(¾Á°Òtå¼A‡OÛ»Õ1Á˜ÇÛmDF£ØN«¥ü:¼2	0énÜKn`OÜ.2ØĞTFÖ·3å0•\x¿›Pÿ:D‰³ÂÚ°¥ÏkŞ¢º£nc|fÑâşïpÜëaOôš#’'*›”¿)ğòÈŒdŞLX¥Úl1lËsXÁRJÍıwYò5xv“Q;kü”`õ‡Íôã‰şD
æ·aâ­$Ò	t5Göm¿ï%szÓ[LªŒZé§øBŸk ğFcÒ$Œ)kô&>3ß¯f¦<vtÿ gvù–…_Â}´ÿ¨rJ~O~J”BLU0 Pª\àP´Å™>š¦mÛÉo	±V¨¡¥NÉ©e•ÒŸR(uçŒC‘Ó¹·ÿ¥¡¡/µ—ÈJ±Í$¢è£0ƒ»ak–¨ñHnş
¡-Ÿ‰Ó\ï¿ì «”k.W8‰	CW26©ë³ÄÓXvîîrK!:àj¶)›$zÈ`,b;éç¿º±·±~A6è ¡œy&ŸDñ¾˜{gIrB­‹¨ÈuğE`ƒ
’y`œ¸ÁoÕÍG¿™{ŒãfWÀ¶^Ó» oChÌ`úD±Y`-ÖÀ,ÔW1fAYú-ò¨¿† ±×\@L0§›zåÖóìóGil³Ö5Ás…CmğçAFƒAoôëÓPjt×C †‚·:(¯V‚ŞCCg¤¼ÿ¯
£¼˜Ş D›f=
ña›^nèûÈª]‘O