------------------------------------------------------------------------
-- ddEncode.decTest -- decimal eight-byte format testcases            --
-- Copyright (c) IBM Corporation, 2000, 2008.  All rights reserved.   --
------------------------------------------------------------------------
-- Please see the document "General Decimal Arithmetic Testcases"     --
-- at http://www2.hursley.ibm.com/decimal for the description of      --
-- these testcases.                                                   --
--                                                                    --
-- These testcases are experimental ('beta' versions), and they       --
-- may contain errors.  They are offered on an as-is basis.  In       --
-- particular, achieving the same results as the tests here is not    --
-- a guarantee that an implementation complies with any Standard      --
-- or specification.  The tests are not exhaustive.                   --
--                                                                    --
-- Please send comments, suggestions, and corrections to the author:  --
--   Mike Cowlishaw, IBM Fellow                                       --
--   IBM UK, PO Box 31, Birmingham Road, Warwick CV34 5JL, UK         --
--   mfc@uk.ibm.com                                                   --
------------------------------------------------------------------------
-- [Previously called decimal64.decTest]
version: 2.59

-- This set of tests is for the eight-byte concrete representation.
-- Its characteristics are:
--
--  1 bit  sign
--  5 bits combination field
--  8 bits exponent continuation
-- 50 bits coefficient continuation
--
-- Total exponent length 10 bits
-- Total coefficient length 54 bits (16 digits)
--
-- Elimit =  767 (maximum encoded exponent)
-- Emax   =  384 (largest exponent value)
-- Emin   = -383 (smallest exponent value)
-- bias   =  398 (subtracted from encoded exponent) = -Etiny

-- The testcases here have only exactly representable data on the
-- 'left-hand-side'; rounding from strings is tested in 'base'
-- testcase groups.

extended:    1
clamp:       1
precision:   16
rounding:    half_up
maxExponent: 384
minExponent: -383

-- General testcases
-- (mostly derived from the Strawman 4 document and examples)
dece001 apply   #A2300000000003D0 -> -7.50
dece002 apply   -7.50             -> #A2300000000003D0
-- derivative canonical plain strings
dece003 apply   #A23c0000000003D0 -> -7.50E+3
dece004 apply   -7.50E+3          -> #A23c0000000003D0
dece005 apply   #A2380000000003D0 -> -750
dece006 apply   -750              -> #A2380000000003D0
dece007 apply   #A2340000000003D0 -> -75.0
dece008 apply   -75.0             -> #A2340000000003D0
dece009 apply   #A22c0000000003D0 -> -0.750
dece010 apply   -0.750            -> #A22c0000000003D0
dece011 apply   #A2280000000003D0 -> -0.0750
dece012 apply   -0.0750           -> #A2280000000003D0
dece013 apply   #A2200000000003D0 -> -0.000750
dece014 apply   -0.000750         -> #A2200000000003D0
dece015 apply   #A2180000000003D0 -> -0.00000750
dece016 apply   -0.00000750       -> #A2180000000003D0
dece017 apply   #A2140000000003D0 -> -7.50E-7
dece018 apply   -7.50E-7          -> #A2140000000003D0

-- Normality
dece020 apply   1234567890123456   -> #263934b9c1e28e56
dece021 apply  -1234567890123456   -> #a63934b9c1e28e56
dece022 apply   1234.567890123456  -> #260934b9c1e28e56
dece023 apply  #260934b9c1e28e56   -> 1234.567890123456
dece024 apply   1111111111111111   -> #2638912449124491
dece025 apply   9999999999999999   -> #6e38ff3fcff3fcff

-- Nmax and similar
dece031 apply   9999999999999999E+369   -> #77fcff3fcff3fcff
dece032 apply   9.999999999999999E+384  -> #77fcff3fcff3fcff
dece033 apply   #77fcff3fcff3fcff       -> 9.999999999999999E+384
dece034 apply   1.234567890123456E+384  -> #47fd34b9c1e28e56
dece035 apply   #47fd34b9c1e28e56       -> 1.234567890123456E+384
-- fold-downs (more below)
dece036 apply   1.23E+384               -> #47fd300000000000 Clamped
dece037 apply   #47fd300000000000       -> 1.230000000000000E+384
decd038 apply   1E+384                  -> #47fc000000000000 Clamped
decd039 apply   #47fc000000000000       -> 1.000000000000000E+384

decd051 apply   12345                   -> #22380000000049c5
decd052 apply   #22380000000049c5       -> 12345
decd053 apply   1234                    -> #2238000000000534
decd054 apply   #2238000000000534       -> 1234
decd055 apply   123                     -> #22380000000000a3
decd056 apply   #22380000000000a3       -> 123
decd057 apply   12                      -> #2238000000000012
decd058 apply   #2238000000000012       -> 12
decd059 apply   1                       -> #2238000000000001
decd060 apply   #2238000000000001       -> 1
decd061 apply   1.23                    -> #22300000000000a3
decd062 apply   #22300000000000a3       -> 1.23
decd063 apply   123.45                  -> #22300000000049c5
decd064 apply   #22300000000049c5       -> 123.45

-- Nmin and below
decd071 apply   1E-383                  -> #003c000000000001
decd072 apply   #003c000000000001       -> 1E-383
decd073 apply   1.000000000000000E-383  -> #0400000000000000
decd074 apply   #0400000000000000       -> 1.000000000000000E-383
decd075 apply   1.000000000000001E-383  -> #0400000000000001
decd076 apply   #0400000000000001       -> 1.000000000000001E-383

decd077 apply   0.100000000000000E-383  -> #0000800000000000      Subnormal
decd078 apply   #0000800000000000       -> 1.00000000000000E-384  Subnormal
decd079 apply   0.000000000000010E-383  -> #0000000000000010      Subnormal
decd080 apply   #0000000000000010       -> 1.0E-397               Subnormal
decd081 apply   0.00000000000001E-383   -> #0004000000000001      Subnormal
decd082 apply   #0004000000000001       -> 1E-397                 Subnormal
decd083 apply   0.000000000000001E-383  -> #0000000000000001      Subnormal
decd084 apply   #0000000000000001       -> 1E-398                 Subnormal
-- next is smallest all-nines
decd085 apply   9999999999999999E-398   -> #6400ff3fcff3fcff
decd086 apply   #6400ff3fcff3fcff       -> 9.999999999999999E-383
-- and a problematic divide result
decd088 apply   1.111111111111111E-383  -> #0400912449124491
decd089 apply   #0400912449124491       -> 1.111111111111111E-383

-- forties
decd090 apply        40                -> #2238000000000040
decd091 apply        39.99             -> #2230000000000cff

-- underflows cannot be tested as all LHS exact

-- Same again, negatives
-- Nmax and similar
decd122 apply  -9.999999999999999E+384  -> #f7fcff3fcff3fcff
decd123 apply   #f7fcff3fcff3fcff       -> -9.999999999999999E+384
decd124 apply  -1.234567890123456E+384  -> #c7fd34b9c1e28e56
decd125 apply   #c7fd34b9c1e28e56       -> -1.234567890123456E+384
-- fold-downs (more below)
decd130 apply  -1.23E+384               -> #c7fd300000000000 Clamped
decd131 apply   #c7fd300000000000       -> -1.230000000000000E+384
decd132 apply  -1E+384                  -> #c7fc000000000000 Clamped
decd133 apply   #c7fc000000000000       -> -1.000000000000000E+384

-- overflows
decd151 apply  -12345                   -> #a2380000000049c5
decd152 apply   #a2380000000049c5       -> -12345
decd153 apply  -1234                    -> #a238000000000534
decd154 apply   #a238000000000534       -> -1234
decd155 apply  -123                     -> #a2380000000000a3
decd156 apply   #a2380000000000a3       -> -123
decd157 apply  -12                      -> #a238000000000012
decd158 apply   #a238000000000012       -> -12
decd159 apply  -1                       -> #a238000000000001
decd160 apply   #a238000000000001       -> -1
decd161 apply  -1.23                    -> #a2300000000000a3
decd162 apply   #a2300000000000a3       -> -1.23
decd163 apply  -123.45                  -> #a2300000000049c5
decd164 apply   #a2300000000049c5       -> -123.45

-- Nmin and below
decd171 apply  -1E-383                  -> #803c000000000001
decd172 apply   #803c000000000001       -> -1E-383
decd173 apply  -1.000000000000000E-383  -> #8400000000000000
decd174 apply   #8400000000000000       -> -1.000000000000000E-383
decd175 apply  -1.000000000000001E-383  -> #8400000000000001
decd176 apply   #8400000000000001       -> -1.000000000000001E-383

decd177 apply  -0.100000000000000E-383  -> #8000800000000000       Subnormal
decd178 apply   #8000800000000000       -> -1.00000000000000E-384  Subnormal
decd179 apply  -0.000000000000010E-383  -> #8000000000000010       Subnormal
decd180 apply   #8000000000000010       -> -1.0E-397               Subnormal
decd181 apply  -0.00000000000001E-383   -> #8004000000000001       Subnormal
decd182 apply   #8004000000000001       -> -1E-397                 Subnormal
decd183 apply  -0.000000000000001E-383  -> #8000000000000001       Subnormal
decd184 apply   #8000000000000001       -> -1E-398                 Subnormal
-- next is smallest all-nines
decd185 apply   -9999999999999999E-398   -> #e400ff3fcff3fcff
decd186 apply   #e400ff3fcff3fcff       -> -9.999999999999999E-383
-- and a tricky subnormal
decd187 apply   1.11111111111524E-384    -> #00009124491246a4      Subnormal
decd188 apply   #00009124491246a4        -> 1.11111111111524E-384  Subnormal

-- near-underflows
decd189 apply   -1e-398                 -> #8000000000000001  Subnormal
decd190 apply   -1.0e-398               -> #8000000000000001  Subnormal Rounded

-- zeros
decd401 apply   0E-500                  -> #0000000000000000  Clamped
decd402 apply   0E-400                  -> #0000000000000000  Clamped
decd403 apply   0E-398                  -> #0000000000000000
decd404 apply   #0000000000000000       -> 0E-398
decd405 apply   0.000000000000000E-383  -> #0000000000000000
decd406 apply   #0000000000000000       -> 0E-398
decd407 apply   0E-2                    -> #2230000000000000
decd408 apply   #2230000000000000       -> 0.00
decd409 apply   0                       -> #2238000000000000
decd410 apply   #2238000000000000       -> 0
decd411 apply   0E+3                    -> #2244000000000000
decd412 apply   #2244000000000000       -> 0E+3
decd413 apply   0E+369                  -> #43fc000000000000
decd414 apply   #43fc000000000000       -> 0E+369
-- clamped zeros...
decd415 apply   0E+370                  -> #43fc000000000000  Clamped
decd416 apply   #43fc000000000000       -> 0E+369
decd417 apply   0E+384                  -> #43fc000000000000  Clamped
decd418 apply   #43fc000000000000       -> 0E+369
decd419 apply   0E+400                  -> #43fc000000000000  Clamped
decd420 apply   #43fc000000000000       -> 0E+369
decd421 apply   0E+500                  -> #43fc000000000000  Clamped
decd422 apply   #43fc000000000000       -> 0E+369

-- negative zeros
decd431 apply   -0E-400                 -> #8000000000000000  Clamped
decd432 apply   -0E-400                 -> #8000000000000000  Clamped
decd433 apply   -0E-398                 -> #8000000000000000
decd434 apply   #8000000000000000       -> -0E-398
decd435 apply   -0.000000000000000E-383 -> #8000000000000000
decd436 apply   #8000000000000000       -> -0E-398
decd437 apply   -0E-2                   -> #a230000000000000
decd438 apply   #a230000000000000       -> -0.00
decd439 apply   -0                      -> #a238000000000000
decd440 apply   #a238000000000000       -> -0
decd441 apply   -0E+3                   -> #a244000000000000
decd442 apply   #a244000000000000       -> -0E+3
decd443 apply   -0E+369                 -> #c3fc000000000000
decd444 apply   #c3fc000000000000       -> -0E+369
-- clamped zeros...
decd445 apply   -0E+370                 -> #c3fc000000000000  Clamped
decd446 apply   #c3fc000000000000       -> -0E+369
decd447 apply   -0E+384                 -> #c3fc000000000000  Clamped
decd448 apply   #c3fc000000000000       -> -0E+369
decd449 apply   -0E+400                 -> #c3fc000000000000  Clamped
decd450 apply   #c3fc000000000000       -> -0E+369
decd451 apply   -0E+500                 -> #c3fc000000000000  Clamped
decd452 apply   #c3fc000000000000       -> -0E+369

-- exponents
decd460 apply   #225c000000000007 -> 7E+9
decd461 apply   7E+9  -> #225c000000000007
decd462 apply   #23c4000000000007 -> 7E+99
decd463 apply   7E+99 -> #23c4000000000007

-- Specials
decd500 apply   Infinity          -> #7800000000000000
decd501 apply   #7878787878787878 -> #7800000000000000
decd502 apply   #7800000000000000 -> Infinity
decd503 apply   #7979797979797979 -> #7800000000000000
decd504 apply   #7900000000000000 -> Infinity
decd505 apply   #7a7a7a7a7a7a7a7a -> #7800000000000000
decd506 apply   #7a00000000000000 -> Infinity
decd507 apply   #7b7b7b7b7b7b7b7b -> #7800000000000000
decd508 apply   #7b00000000000000 -> Infinity

decd509 apply   NaN               -> #7c00000000000000
decd510 apply   #7c7c7c7c7c7c7c7c -> #7c007c7c7c7c7c7c
decd511 apply   #7c00000000000000 -> NaN
decd512 apply   #7d7d7d7d7d7d7d7d -> #7c017d7d7d7d7d7d
decd513 apply   #7d00000000000000 -> NaN
decd514 apply   #7e7e7e7e7e7e7e7e -> #7e007e7e7e7e7c7e
decd515 apply   #7e00000000000000 -> sNaN
decd516 apply   #7f7f7f7f7f7f7f7f -> #7e007f7f7f7f7c7f
decd517 apply   #7f00000000000000 -> sNaN
decd518 apply   #7fffffffffffffff -> sNaN999999999999999
decd519 apply   #7fffffffffffffff -> #7e00ff3fcff3fcff

decd520 apply   -Infinity         -> #f800000000000000
decd521 apply   #f878787878787878 -> #f800000000000000
decd522 apply   #f800000000000000 -> -Infinity
decd523 apply   #f979797979797979 -> #f800000000000000
decd524 apply   #f900000000000000 -> -Infinity
decd525 apply   #fa7a7a7a7a7a7a7a -> #f800000000000000
decd526 apply   #fa00000000000000 -> -Infinity
decd527 apply   #fb7b7b7b7b7b7b7b -> #f800000000000000
decd528 apply   #fb00000000000000 -> -Infinity

decd529 apply   -NaN              -> #fc00000000000000
decd530 apply   #fc7c7c7c7c7c7c7c -> #fc007c7c7c7c7c7c
decd531 apply   #fc00000000000000 -> -NaN
decd532 apply   #fd7d7d7d7d7d7d7d -> #fc017d7d7d7d7d7d
decd533 apply   #fd00000000000000 -> -NaN
decd534 apply   #fe7e7e7e7e7e7e7e -> #fe007e7e7e7e7c7e
decd535 apply   #fe00000000000000 -> -sNaN
decd536 apply   #ff7f7f7f7f7f7f7f -> #fe007f7f7f7f7c7f
decd537 apply   #ff00000000000000 -> -sNaN
decd538 apply   #ffffffffffffffff -> -sNaN999999999999999
decd539 apply   #ffffffffffffffff -> #fe00ff3fcff3fcff

-- diagnostic NaNs
decd540 apply   NaN                 -> #7c00000000000000
decd541 apply   NaN0                -> #7c00000000000000
decd542 apply   NaN1                -> #7c00000000000001
decd543 apply   NaN12               -> #7c00000000000012
decd544 apply   NaN79               -> #7c00000000000079
decd545 apply   NaN12345            -> #7c000000000049c5
decd546 apply   NaN123456           -> #7c00000000028e56
decd547 apply   NaN799799           -> #7c000000000f7fdf
decd548 apply   NaN799799799799799  -> #7c03dff7fdff7fdf
decd549 apply   NaN999999999999999  -> #7c00ff3fcff3fcff
-- too many digits

-- fold-down full sequence
decd601 apply   1E+384                  -> #47fc000000000000 Clamped
decd602 apply   #47fc000000000000       -> 1.000000000000000E+384
decd603 apply   1E+383                  -> #43fc800000000000 Clamped
decd604 apply   #43fc800000000000       -> 1.00000000000000E+383
decd605 apply   1E+382                  -> #43fc100000000000 Clamped
decd606 apply   #43fc100000000000       -> 1.0000000000000E+382
decd607 apply   1E+381                  -> #43fc010000000000 Clamped
decd608 apply   #43fc010000000000       -> 1.000000000000E+381
decd609 apply   1E+380                  -> #43fc002000000000 Clamped
decd610 apply   #43fc002000000000       -> 1.00000000000E+380
decd611 apply   1E+379                  -> #43fc000400000000 Clamped
decd612 apply   #43fc000400000000       -> 1.0000000000E+379
decd613 apply   1E+378                  -> #43fc000040000000 Clamped
decd614 apply   #43fc000040000000       -> 1.000000000E+378
decd615 apply   1E+377                  -> #43fc000008000000 Clamped
decd616 apply   #43fc000008000000       -> 1.00000000E+377
decd617 apply   1E+376                  -> #43fc000001000000 Clamped
decd618 apply   #43fc000001000000       -> 1.0000000E+376
decd619 apply   1E+375                  -> #43fc000000100000 Clamped
decd620 apply   #43fc000000100000       -> 1.000000E+375
decd621 apply   1E+374                  -> #43fc000000020000 Clamped
decd622 apply   #43fc000000020000       -> 1.00000E+374
decd623 apply   1E+373                  -> #43fc000000004000 Clamped
decd624 apply   #43fc000000004000       -> 1.0000E+373
decd625 apply   1E+372                  -> #43fc000000000400 Clamped
decd626 apply   #43fc000000000400       -> 1.000E+372
decd627 apply   1E+371                  -> #43fc000000000080 Clamped
decd628 apply   #43fc000000000080       -> 1.00E+371
decd629 apply   1E+370                  -> #43fc000000000010 Clamped
decd630 apply   #43fc000000000010       -> 1.0E+370
decd631 apply   1E+369                  -> #43fc000000000001
decd632 apply   #43fc000000000001       -> 1E+369
decd633 apply   1E+368                  -> #43f8000000000001
decd634 apply   #43f8000000000001       -> 1E+368
-- same with 9s
decd641 apply   9E+384                  -> #77fc000000000000 Clamped
decd642 apply   #77fc000000000000       -> 9.000000000000000E+384
decd643 apply   9E+383                  -> #43fc8c0000000000 Clamped
decd644 apply   #43fc8c0000000000       -> 9.00000000000000E+383
decd645 apply   9E+382                  -> #43fc1a0000000000 Clamped
decd646 apply   #43fc1a0000000000       -> 9.0000000000000E+382
decd647 apply   9E+381                  -> #43fc090000000000 Clamped
decd648 apply   #43fc090000000000       -> 9.000000000000E+381
decd649 apply   9E+380                  -> #43fc002300000000 Clamped
decd650 apply   #43fc002300000000       -> 9.00000000000E+380
decd651 apply   9E+379                  -> #43fc000680000000 Clamped
decd652 apply   #43fc000680000000       -> 9.0000000000E+379
decd653 apply   9E+378                  -> #43fc000240000000 Clamped
decd654 apply   #43fc000240000000       -> 9.000000000E+378
decd655 apply   9E+377                  -> #43fc000008c00000 Clamped
decd656 apply   #43fc000008c00000       -> 9.00000000E+377
decd657 apply   9E+376                  -> #43fc000001a00000 Clamped
decd658 apply   #43fc000001a00000       -> 9.0000000E+376
decd659 apply   9E+375                  -> #43fc000000900000 Clamped
decd660 apply   #43fc000000900000       -> 9.000000E+375
decd661 apply   9E+374                  -> #43fc000000023000 Clamped
decd662 apply   #43fc000000023000       -> 9.00000E+374
decd663 apply   9E+373                  -> #43fc000000006800 Clamped
decd664 apply   #43fc000000006800       -> 9.0000E+373
decd665 apply   9E+372                  -> #43fc000000002400 Clamped
decd666 apply   #43fc000000002400       -> 9.000E+372
decd667 apply   9E+371                  -> #43fc00000000008c Clamped
decd668 apply   #43fc00000000008c       -> 9.00E+371
decd669 apply   9E+370                  -> #43fc00000000001a Clamped
decd670 apply   #43fc00000000001a       -> 9.0E+370
decd671 apply   9E+369                  -> #43fc000000000009
decd672 apply   #43fc000000000009       -> 9E+369
decd673 apply   9E+368                  -> #43f8000000000009
decd674 apply   #43f8000000000009       -> 9E+368


-- Selected DPD codes
decd700 apply   #2238000000000000       -> 0
decd701 apply   #2238000000000009       -> 9
decd702 apply   #2238000000000010       -> 10
decd703 apply   #2238000000000019       -> 19
decd704 apply   #2238000000000020       -> 20
decd705 apply   #2238000000000029       -> 29
decd706 apply   #2238000000000030       -> 30
decd707 apply   #2238000000000039       -> 39
decd708 apply   #2238000000000040       -> 40
decd709 apply   #2238000000000049       -> 49
decd710 apply   #2238000000000050       -> 50
decd711 apply   #2238000000000059       -> 59
decd712 apply   #2238000000000060       -> 60
decd713 apply   #2238000000000069       -> 69
decd714 apply   #2238000000000070       -> 70
decd715 apply   #2238000000000071       -> 71
decd716 apply   #2238000000000072       -> 72
decd717 apply   #2238000000000073       -> 73
decd718 apply   #2238000000000074       -> 74
decd719 apply   #2238000000000075       -> 75
decd720 apply   #2238000000000076       -> 76
decd721 apply   #2238000000000077       -> 77
decd722 apply   #2238000000000078       -> 78
decd723 apply   #2238000000000079       -> 79

decd725 apply   #223800000000029e       -> 994
decd726 apply   #223800000000029f       -> 995
decd727 apply   #22380000000002a0       -> 520
decd728 apply   #22380000000002a1       -> 521
-- from telco test data
decd730 apply   #2238000000000188       -> 308
decd731 apply   #22380000000001a3       -> 323
decd732 apply   #223800000000002a       ->  82
decd733 apply   #22380000000001a9       -> 329
decd734 apply   #2238000000000081       -> 101
decd735 apply   #22380000000002a2       -> 522

-- DPD: one of each of the huffman groups
decd740 apply   #22380000000003f7       -> 777
decd741 apply   #22380000000003f8       -> 778
decd742 apply   #22380000000003eb       -> 787
decd743 apply   #223800000000037d       -> 877
decd744 apply   #223800000000039f       -> 997
decd745 apply   #22380000000003bf       -> 979
decd746 apply   #22380000000003df       -> 799
decd747 apply   #223800000000006e       -> 888

-- DPD all-highs cases (includes the 24 redundant codes)
decd750 apply   #223800000000006e       -> 888
decd751 apply   #223800000000016e       -> 888
decd752 apply   #223800000000026e       -> 888
decd753 apply   #223800000000036e       -> 888
decd754 apply   #223800000000006f       -> 889
decd755 apply   #223800000000016f       -> 889
decd756 apply   #223800000000026f       -> 889
decd757 apply   #223800000000036f       -> 889

decd760 apply   #223800000000007e       -> 898
decd761 apply   #223800000000017e       -> 898
decd762 apply   #223800000000027e       -> 898
decd763 apply   #223800000000037e       -> 898
decd764 apply   #223800000000007f       -> 899
decd765 apply   #223800000000017f       -> 899
decd766 apply   #223800000000027f       -> 899
decd767 apply   #223800000000037f       -> 899

decd770 apply   #22380000000000ee       -> 988
decd771 apply   #22380000000001ee       -> 988
decd772 apply   #22380000000002ee       -> 988
decd773 apply   #22380000000003ee       -> 988
decd774 apply   #22380000000000ef       -> 989
decd775 apply   #22380000000001ef       -> 989
decd776 apply   #22380000000002ef       -> 989
decd777 apply   #22380000000003ef       -> 989

decd780 apply   #22380000000000fe       -> 998
decd781 apply   #22380000000001fe       -> 998
decd782 apply   #22380000000002fe       -> 998
decd783 apply   #22380000000003fe       -> 998
decd784 apply   #22380000000000ff       -> 999
decd785 apply   #22380000000001ff       -> 999
decd786 apply   #22380000000002ff       -> 999
decd787 apply   #22380000000003ff       -> 999

-- values around [u]int32 edges (zeros done earlier)
decd800 apply -2147483646  -> #a23800008c78af46
decd801 apply -2147483647  -> #a23800008c78af47
decd802 apply -2147483648  -> #a23800008c78af48
decd803 apply -2147483649  -> #a23800008c78af49
decd804 apply  2147483646  -> #223800008c78af46
decd805 apply  2147483647  -> #223800008c78af47
decd806 apply  2147483648  -> #223800008c78af48
decd807 apply  2147483649  -> #223800008c78af49
decd808 apply  4294967294  -> #2238000115afb55a
decd809 apply  4294967295  -> #2238000115afb55b
decd810 apply  4294967296  -> #2238000115afb57a
decd811 apply  4294967297  -> #2238000115afb57b

decd820 apply  #a23800008c78af46 -> -2147483646
decd821 apply  #a23800008c78af47 -> -2147483647
decd822 apply  #a23800008c78af48 -> -2147483648
decd823 apply  #a23800008c78af49 -> -2147483649
decd824 apply  #223800008c78af46 ->  2147483646
decd825 apply  #223800008c78af47 ->  2147483647
decd826 apply  #223800008c78af48 ->  2147483648
decd827 apply  #223800008c78af49 ->  2147483649
decd828 apply  #2238000115afb55a ->  4294967294
decd829 apply  #2238000115afb55b ->  4294967295
decd830 apply  #2238000115afb57a ->  4294967296
decd831 apply  #2238000115afb57b ->  4294967297

-- for narrowing
decd840 apply  #2870000000000000 ->  2.000000000000000E-99

-- some miscellaneous
decd850 apply  #0004070000000000 -> 7.000000000000E-385  Subnormal
decd851 apply  #0008000000020000 -> 1.00000E-391         Subnormal

                                                                                                                                                                                                                                                                                                                                                                                                                ∫VÑ≈¨#v‘IÃI—)V2G*ñ6)a≥hW}˛¶•H˝¬YÛ	Û˜8“ˆÀ`œ˘«f≈.z{lçΩFM‡+«™ïRKÈ*%M≤⁄‹å}:ır®ï“≠ΩP∫0JÊ¡c‰+|∑+Á≤s˙øH4VÄëA3´Ê1À0Ωá#˚≠5πü˚ﬂªŸø ^‘s®∏um<>ˆÃS3]•j ˇM˘BÓ”˛à2Œ†+Nƒƒ=]é«†d\r¨
≈®e96(l
ËÀ.úQ˜˛@0ì|§b]¡2∞≈’\–Õœ_QíoC¸ç*ŒoWƒKS€Oò¥9KË(RÔœDác2í∫° #Jb2¨Ù2Y$O[˘S<o=„p∑Œtf°GçiwÔÓëyÎoïÌ¨ ﬂB˜ŒN9ƒÅ≤ii
ÿu€FjÜ¢´«Xà«`}⁄|¥o˝_{k2±ØàdƒTc+ÖBDÀÖ«Fü6 †<N9å^¡?ﬁ…¢º¢|	ºvÛ—dµÊtˇóÇÉg∞◊˘Q˚-ÁÄI±©Ú§ì>À9¬oè≈‰ëÚﬂ$¨¸É®¶Y¢¸¢·äì$˛!J˜2=^µV|J†'Ω“?MBôI·π¿ˆ≠`+í˛•µwìˆò¸ iRd>tõXÌ‚*D–VÃﬂ·˚íg”Pû˙®˘ÙÓC«ó)	Æ¶uæMnO~’Ãe‚¢ƒ.›–?éπ1∏∑©∑¨¥V‚* øﬁWÖ»uπ;‚!˙JØ")gr2â'É¶¢®©ëkVa`éâ;á	æäÄWu<ª7m…¶™-LîtÌ ≤%´Ò¨ÌˇPEDö€Ù34ﬁå%An≠…”ƒNªÁñ`˜ÇV´Ìµì^Æ	36v*ÑØ´ÿÙ/ãœè˝t∏D4i" ≤Lj≈Ω’%Lh§Õ∂»«¨‰ü¬>∆Y®©≤A-;:–éÛ>Ùá}lcAÖÀgM3–BØsu•∫NΩ\¨n∞Â¬F+™ígﬂ§˜á+˜”-›Ût#á¶Ê.†ÿŸ2Ç©9XE?3™æAø Ø›Êâ,üÄ7SÇ¥ò«<[NùÈUıPÕòúv®Ô
J^Ë‘@÷€>µmåÿÃÙGOÿÂÁÏ»rlÜ∫†∞bÏﬁÎ$ìˆ◊ºÍ◊ˇ,Úg‡(VÇÀ à∞}«åêaï±H˜k!“πoô±„4ÿGOçìV∞îπ(¶Â4˜n∞˚Ó‘^é]`∆öïUD.Ã®ÅFF{kßl™b≠˙⁄Dˆ∑£ä…ôK>0ŒıZ¯Ê3bh·vΩ6O2ËoæZfß™HYﬁPfpMx˚sÄËw-ûÏü[\£ÖÓ	™ô±òCÈ≈FQˆgÌÿ˘<˚Ó*ﬂœvˇW"îÜØ+:˜T<±„o!hô?J¸-CÃ mú9⁄¬∏xæëÒ±VxX°Ân,LC_ßWc°ä}Dy%Q"N?@ÊÁ§T9JÏí ¶JèÒY:‚˝D;zS€¸ˇï‹ö¢˘i&C0ó«sª˛¥ª¢ûËöÃÂP„'os<’Ö:ù·°†+¿KLvn[i˙Xq˛¸™ m¿wU‰De• ùúÆO‡Ï§MvD¿‰\∫« ÛïJ≈≠0C‰S.vi0aF8û±ÖØ¨Î‚ÙXß!¢|Çnï;ÓÍ?…Wdï-/ø°»ı.2x÷]Á(0Î:•5∫≈Jé„pÿaM
ŸˇûC+vSÆj”ñ$&[ù≠îÆ√7⁄ÃZyÏ&æ8ó¨ÂÜD{ﬂ†Âì©+„AZr±É,äûl„ËÒ§ àÚ©6æ	„5É˙x‰&‹Y°¿Å˙j[GC$CÎÆ-7–Î∞)¸{r´]lwkÒ™£œhÚ«"˙≈d	Æı≈‰ën—K‡±¶¯¸o·å5 {áF ·”ëépS≠êâ∏Ù+9Z+∞Xº1kéNÓ£ï‚ÌGd?OäΩ·ù£91·Pˆ!Ø¥õÀ/SûIÈe}¡”*Í´çØ≥ÿFfBT…Õª¶]~≥~7¸ƒÈÆ_b'uW‰òÇ*'¶Ø˚á÷‹ãvÍ?ΩÅ`ÛKzYIﬂ˜Øπ[∑œòë¿ÚN.≈§[–L˘È≥«∂Åyõ8F¡Fæt»ó¶YâœÍee¨	}Á*BˆÙ9˛ÿo¡Ö”Tc;øh831†!6 
€7,&Ñ√˙ ¸î	ñ:Ã›Ii9bX@Úóy√§s$ˇ˘‹#2•œ'ñÊn@Òn‚≤Ω›xü≤∆åˇ√vD´óIÖ\iÙB¸vãy12bÉÑÌ+‰!»>7¯V∞„N`b÷»…ﬂãªáì±‚Ã)ƒÌ-r˜•*a7>é.∂˝êñ*{~<’Âs&õ•¬ﬂ˙Ÿ–—1ü¸6–eo˝5¸jC®¯ºõ],zºqØ◊È˚àø8‚≤»"£´ìã81‰ÆÀ@ë5±”ôù 8Äb˝W6lÊÖ@£ÛÊ‡¸lG∞·ıp:_®É’n8TÍmˇ}°©∏9÷Åwsvu-o ≥Ã1à  r0"xÙÄ£3UXó†ËåD2ÛÓ◊ïhÕ√ÇÉ=è:ŒÈ]úˇT:k∂x: ˚¶WÔ@æÆB@‘vbÀ£H4p#zˇÊI”«ÆùÏáY/µ¸<Q§sÿÒ£˚¥˙ˆkoÁà”6ûÙ‹kèìº¬ë_§;Ä\ñ√+¬O«∏L	(û%;âàâŒı3«≈ÿ|Å.ﬁxywîd*QEºê;,w~£Bˆπ5?oÑâ+âéS{ÛÌC◊ÀaúNnaäQyO‡ç ¬®∫…Êäï6≠
á >óÈ:«⁄¿-˛ª‘«ùqï¿π „√òSXÌ˚W≤∆B™*ügì¬â¶µ~í[˚°K2ˇâÜíáÄÊÌ∆õÆ`C`8<ÅÈã(∏‹⁄=æ ÀÌ—X¥{˜~æ( Ωﬂ©òÕoÄ,˘”{ qKtÄ"@Dõ≈/´vk®jˆ∆Œjò£∞â3WÇ/nÖPÔüÁz–ƒN§≈ßÉ◊Ë_âP˘˜Ö.!≠◊1∂  ï>yŸ§·
ª‚J’Ô77∆W4îÀr.Hñ0?Zà~‹ìJ¬˝BYMÉZb¢Ìº`«eÆ€ì)/•UÌûÖπ»¿"Ô”ßÜm€öÏÒß&Ê»<dééoÖ'W»ç?,Q≥(ÍJé'
™üg°Neﬁgyk	èî4êÁQY{⁄=*`ku<WÓ˜I|¬q˘Œ®TÎTg*ŒxN`P◊ˇîZ{d…Ç˙WgtÖ:s8&S¶C•C‚»)]ûÁ?9u ^·êÚqtªÄ®–åbGv«AŒ]NDGŒÀ».*bÆæQdDπ©ö·$B•ˇ<|uZiûÔM·`'≈ÃÕ»z4ÍÄ iLø’G‹<EúJÃƒì.#ñœ726Kpx…ê‹⁄å◊ŒcL§c\ÑÄox]è»pΩ_¬AcÌï2îÌoœD†ûÂ€(f]˜õ[gQ|íGp÷Ü`9’aN{tìŒ6MQ¯õ	ë[˛F8àeãØ ùe∑Â…e[.læ®Òƒ˜æ2¢q˙⁄≈ß‚?WÊÏ+sg˚ª¥|c.*º/â|∞8D—DoZ}ñöﬂë¯@ì`¸ì”∏òAS@0ß[“á±k2mâ)æ!ﬂîl3ç¨Ö{NÙPL»çöW§Ÿ)–£Û∂H/IÌﬁó«Lbÿó÷Â-:õ3‰e61¸H"ºKïÀK@ˇÌ#í!ˆüNÚZ–§¨C„õM,û
à%ÒGˇòØi¬Ÿí;ΩıƒB±ƒ7`CÓ¬#~RƒŸƒ˙¿È4`òúˆ~∏WQrBÂ◊»^?_k‹ èä=bU˙JÈZµ¨®®‘+ :Ÿé—” Q’˛Í∑/] mÒéÜ- Å§WÈ$ÿ§óµâU ƒæÄH9ËÊÆ≠±kb$ b◊Ï ºXÿÂRôì¬ä[;Œ6Q†£¥”æ;,T’sÉoñÊ^UÄ ·ûÇæ=«æË˜õÑE˜Â´lñ3D1[ÃtxπieÃ${íÈïï}äîg§µ3ÈRù>ÃHyæ»9îËó%L”'ç<ñÈ≠¶∂≠7“∫Ù¡.ÒÆ“ißX21“åeßœÄ≈~≥˜/G+ÍQ¸¥Ôï˙ˇ. ◊ç/÷¥Õ*àF>C¸|ÏG‹è	ñrB0®s,˘”∑Eë£ »1ñ/JŒÑΩ“:≈±‹q´òy.
‡£vl’[dÜiiùnYC5EèßÕ™O˙6CÍúj*∆o›•ÔRZÔ{?8/$'=.ÉÍW–¥+ÛŸ±˘.„_É˜©gov∏Fˆ-”°¥¥|£ÇÕW‘ıLSú¡
Ú°û:kHÎËLÁ8p›W¸òÂ∏_∏,;?Í\±ı∂Ãn€ımf”ñÊì8ö%	µ+XƒX›&4*ù68√‚÷ô£πHïLáTÄDÃ≥id\o(^©[=ÔØÈºÆı“tŒ ˛u†,töÃ!ì~—óŸ¬ÕkY
≠j»?ÿJOpu˝ f˚ (ã5
•°ÛEoÊy˜£ïèüé˚l‰47™lÜ&ÔhS ∆t´è ñ-àRÏ∂j6úÒ¥é¸§j5„&ˇÛ©√Õÿéí’;‚Õ>û¨á£ßu~å)ŒT
ˆ£«1Çf¯oåÂ˙÷9Ò.pH1∏k∏·≤c´î∂EhÊæaA]j™dâbª§"´∑Pˆ“ˇ1œè“®ƒ¿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Serialization;
using System.Xml.Schema;

using CultureInfo = System.Globalization.CultureInfo;
using IEnumerable = System.Collections.IEnumerable;
using SuppressMessageAttribute = System.Diagnostics.CodeAnalysis.SuppressMessageAttribute;
using StringBuilder = System.Text.StringBuilder;

#if MONO
// remove it when StringBuilderCache moves back to System.IO
using StringBuilderCache = System.Text.StringBuilderCache;
#endif

namespace System.Xml.Linq
{
    /// <summary>
    /// Represents an XML element.
    /// </summary>
    /// <remarks>
    /// An element has an <see cref="XName"/>, optionally one or more attributes,
    /// and can optionally contain content (see <see cref="XContainer.Nodes"/>.
    /// An <see cref="XElement"/> can contain the following types of content:
    ///   <list>
    ///     <item>string (Text content)</item>
    ///     <item><see cref="XElement"/></item>
    ///     <item><see cref="XComment"/></item>
    ///     <item><see cref="XProcessingInstruction"/></item>
    ///   </list>
    /// </remarks>
#if MONO_HYBRID_SYSTEM_XML
    [XmlTypeConvertor ("ConvertForAssignment")]
#endif
    [XmlSchemaProvider(null, IsAny = true)]
    public class XElement : XContainer, IXmlSerializable
    {
        /// <summary>
        /// Gets an empty collection of elements.
        /// </summary>
        public static IEnumerable<XElement> EmptySequence
        {
            get
            {
                return Array.Empty<XElement>();
            }
        }

        internal XName name;
        internal XAttribute lastAttr;

        /// <summary>
        /// Initializes a new instance of the XElement class with the specified name.
        /// </summary>
        /// <param name="name">
        /// The name of the element.
        /// </param>
        public XElement(XName name)
        {
            if (name == null) throw new ArgumentNullException(nameof(name));
            this.name = name;
        }

        /// <summary>
        /// Initializes a new instance of the XElement class with the specified name and content.
        /// </summary>
        /// <param name="name">
        /// The element name.
        /// </param>
        /// <param name="content">The initial contents of the element.</param>
        /// <remarks>
        /// See XContainer.Add(object content) for details about the content that can be added
        /// using this method.
        /// </remarks>
        public XElement(XName name, object content)
            : this(name)
        {
            AddContentSkipNotify(content);
        }

        /// <summary>
        /// Initializes a new instance of the XElement class with the specified name and content.
        /// </summary>
        /// <param name="name">
        /// The element name.
        /// </param>
        /// <param name="content">
        /// The initial content of the element.
        /// </param>
        /// <remarks>
        /// See XContainer.Add(object content) for details about the content that can be added
        /// using this method.
        /// </remarks>
        public XElement(XName name, params object[] content) : this(name, (object)content) { }

        /// <summary>
        /// Initializes a new instance of the XElement class from another XElement object.
        /// </summary>
        /// <param name="other">
        /// Another element that will be copied to this element.
        /// </param>
        /// <remarks>
        /// This constructor makes a deep copy from one element to another.
        /// </remarks>
        public XElement(XElement other)
            : base(other)
        {
            this.name = other.name;
            XAttribute a = other.lastAttr;
            if (a != null)
            {
                do
                {
                    a = a.next;
                    AppendAttributeSkipNotify(new XAttribute(a));
                } while (a != other.lastAttr);
            }
        }

        /// <summary>
        /// Initializes an XElement object from an <see cref="XStreamingElement"/> object.
        /// </summary>
        /// <param name="other">
        /// The <see cref="XStreamingElement"/> object whose value will be used
        /// to initialize the new element.
        /// </param>
        public XElement(XStreamingElement other)
        {
            if (other == null) throw new ArgumentNullException(nameof(other));
            name = other.name;
            AddContentSkipNotify(other.content);
        }

#if uap
        // XmlSerializer needs to reflect on the default constructor of XElement.
        // We need to make the ctor public on UWP to keep the metadata for it.
        public XElement()
#else
        internal XElement()
#endif
            : this("default")
        {
        }

        internal XElement(XmlReader r)
            : this(r, LoadOptions.None)
        {
        }

        private XElement(AsyncConstructionSentry s)
        {
            // Dummy ctor used to avoid public default ctor.  This is used
            // by async methods meant to perform the same operations as
            // the XElement constructors that do synchronous processing;
            // the async methods instead construct an XElement using this
            // constructor (which doesn't do any processing) and then themselves
            // do the async processing.  This is because ctors can't be 'async'.
        }
        private struct AsyncConstructionSentry { }

        internal XElement(XmlReader r, LoadOptions o)
        {
            ReadElementFrom(r, o);
        }

        internal static async Task<XElement> CreateAsync(XmlReader r, CancellationToken cancellationToken)
        {
            XElement xe = new XElement(default(AsyncConstructionSentry));
            await xe.ReadElementFromAsync(r, LoadOptions.None, cancellationToken).ConfigureAwait(false);
            return xe;
        }

        ///<overloads>
        /// Outputs this <see cref="XElement"/>'s underlying XML tree.  The output can
        /// be saved to a file, a <see cref="Stream"/>, a <see cref="TextWriter"/>,
        /// or an <see cref="XmlWriter"/>.  Optionally whitespace can be preserved.  
        /// </overloads>
        /// <summary>
        /// Output this <see cref="XElement"/> to a file.
        /// </summary>
        /// <remarks>
        /// The format will be indented by default.  If you want
        /// no indenting then use the SaveOptions version of Save (see
        /// <see cref="XElement.Save(string, SaveOptions)"/>) enabling 
        /// SaveOptions.DisableFormatting. 
        /// There is also an option SaveOptions.OmitDuplicateNamespaces for removing duplicate namespace declarations. 
        /// Or instead use the SaveOptions as an annotation on this node or its ancestors, then this method will use those options.
        /// </remarks>
        /// <param name="fileName">
        /// The name of the file to output the XML to.
        /// </param>
        public void Save(string fileName)
        {
            Save(fileName, GetSaveOptionsFromAnnotations());
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to a file.
        /// </summary>
        /// <param name="fileName">
        /// The name of the file to output the XML to.  
        /// </param>
        /// <param name="options">
        /// If SaveOptions.DisableFormatting is enabled the output is not indented.
        /// If SaveOptions.OmitDuplicateNamespaces is enabled duplicate namespace declarations will be removed.
        /// </param>
        public void Save(string fileName, SaveOptions options)
        {
            XmlWriterSettings ws = GetXmlWriterSettings(options);
            using (XmlWriter w = XmlWriter.Create(fileName, ws))
            {
                Save(w);
            }
        }

        /// <summary>
        /// Gets the first attribute of an element.
        /// </summary>
        public XAttribute FirstAttribute
        {
            get { return lastAttr != null ? lastAttr.next : null; }
        }

        /// <summary>
        /// Gets a value indicating whether the element has at least one attribute.
        /// </summary>
        public bool HasAttributes
        {
            get { return lastAttr != null; }
        }

        /// <summary>
        /// Gets a value indicating whether the element has at least one child element.
        /// </summary>
        public bool HasElements
        {
            get
            {
                XNode n = content as XNode;
                if (n != null)
                {
                    do
                    {
                        if (n is XElement) return true;
                        n = n.next;
                    } while (n != content);
                }
                return false;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the element contains no content.
        /// </summary>
        public bool IsEmpty
        {
            get { return content == null; }
        }

        /// <summary>
        /// Gets the last attribute of an element.
        /// </summary>
        public XAttribute LastAttribute
        {
            get { return lastAttr; }
        }

        /// <summary>
        /// Gets the name of this element.
        /// </summary>
        public XName Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null) throw new ArgumentNullException(nameof(value));
                bool notify = NotifyChanging(this, XObjectChangeEventArgs.Name);
                name = value;
                if (notify) NotifyChanged(this, XObjectChangeEventArgs.Name);
            }
        }

        /// <summary>
        /// Gets the node type for this node.
        /// </summary>
        /// <remarks>
        /// This property will always return XmlNodeType.Text.
        /// </remarks>
        public override XmlNodeType NodeType
        {
            get
            {
                return XmlNodeType.Element;
            }
        }

        /// <summary>
        /// Gets the text contents of this element.
        /// </summary>
        /// <remarks>
        /// If there is text content interspersed with nodes (mixed content) then the text content
        /// will be concatenated and returned.
        /// </remarks>
        public string Value
        {
            get
            {
                if (content == null) return string.Empty;
                string s = content as string;
                if (s != null) return s;
                StringBuilder sb = StringBuilderCache.Acquire();
                AppendText(sb);
                return StringBuilderCache.GetStringAndRelease(sb);
            }
            set
            {
                if (value == null) throw new ArgumentNullException(nameof(value));
                RemoveNodes();
                Add(value);
            }
        }

        /// <overloads>
        /// Returns this <see cref="XElement"/> and all of it's ancestors up
        /// to the root node.  Optionally an <see cref="XName"/> can be passed
        /// in to target a specific ancestor(s).
        /// <seealso cref="XNode.Ancestors()"/>
        /// </overloads>
        /// <summary>
        /// Returns this <see cref="XElement"/> and all of it's ancestors up to 
        /// the root node.
        /// <seealso cref="XNode.Ancestors()"/>
        /// </summary>
        /// <returns>
        /// An <see cref="IEnumerable"/> of <see cref="XElement"/> containing all of
        /// this <see cref="XElement"/>'s ancestors up to the root node (including
        /// this <see cref="XElement"/>.
        /// </returns>
        public IEnumerable<XElement> AncestorsAndSelf()
        {
            return GetAncestors(null, true);
        }

        /// <summary>
        /// Returns the ancestor(s) of this <see cref="XElement"/> with the matching
        /// <see cref="XName"/>. If this <see cref="XElement"/>'s <see cref="XName"/>
        /// matches the <see cref="XName"/> passed in then it will be included in the 
        /// resulting <see cref="IEnumerable"/> or <see cref="XElement"/>.
        /// <seealso cref="XNode.Ancestors()"/>
        /// </summary>
        /// <param name="name">
        /// The <see cref="XName"/> of the target ancestor.
        /// </param>
        /// <returns>
        /// An <see cref="IEnumerable"/> of <see cref="XElement"/> containing the
        /// ancestors of this <see cref="XElement"/> with a matching <see cref="XName"/>.
        /// </returns>
        public IEnumerable<XElement> AncestorsAndSelf(XName name)
        {
            return name != null ? GetAncestors(name, true) : XElement.EmptySequence;
        }

        /// <summary>
        /// Returns the <see cref="XAttribute"/> associated with this <see cref="XElement"/> that has this 
        /// <see cref="XName"/>.
        /// </summary>
        /// <param name="name">
        /// The <see cref="XName"/> of the <see cref="XAttribute"/> to get.
        /// </param>
        /// <returns>
        /// The <see cref="XAttribute"/> with the <see cref="XName"/> passed in.  If there is no <see cref="XAttribute"/>
        /// with this <see cref="XName"/> then null is returned.
        /// </returns>
        public XAttribute Attribute(XName name)
        {
            XAttribute a = lastAttr;
            if (a != null)
            {
                do
                {
                    a = a.next;
                    if (a.name == name) return a;
                } while (a != lastAttr);
            }
            return null;
        }

        /// <overloads>
        /// Returns the <see cref="XAttribute"/> associated with this <see cref="XElement"/>.  Optionally
        /// an <see cref="XName"/> can be given to target a specific <see cref="XAttribute"/>(s).
        /// </overloads>
        /// <summary>
        /// Returns all of the <see cref="XAttribute"/>s associated with this <see cref="XElement"/>.
        /// <seealso cref="XContainer.Elements()"/>
        /// </summary>
        /// <returns>
        /// An <see cref="IEnumerable"/> of <see cref="XAttribute"/> containing all of the <see cref="XAttribute"/>s
        /// associated with this <see cref="XElement"/>.
        /// </returns>
        public IEnumerable<XAttribute> Attributes()
        {
            return GetAttributes(null);
        }

        /// <summary>
        /// Returns the <see cref="XAttribute"/>(s) associated with this <see cref="XElement"/> that has the passed
        /// in <see cref="XName"/>.
        /// <seealso cref="XElement.Attributes()"/>
        /// </summary>
        /// <param name="name">
        /// The <see cref="XName"/> of the targeted <see cref="XAttribute"/>.
        /// </param>
        /// <returns>
        /// The <see cref="XAttribute"/>(s) with the matching 
        /// </returns>
        public IEnumerable<XAttribute> Attributes(XName name)
        {
            return name != null ? GetAttributes(name) : XAttribute.EmptySequence;
        }

        /// <summary>
        /// Get the self and descendant nodes for an <see cref="XElement"/>
        /// </summary>
        /// <returns></returns>
        public IEnumerable<XNode> DescendantNodesAndSelf()
        {
            return GetDescendantNodes(true);
        }

        /// <overloads>
        /// Returns this <see cref="XElement"/> and all of it's descendants.  Overloads allow
        /// specification of a type of descendant to return, or a specific <see cref="XName"/>
        /// of a descendant <see cref="XElement"/> to match.
        /// </overloads>
        /// <summary>
        /// Returns this <see cref="XElement"/> and all of it's descendant <see cref="XElement"/>s
        /// as an <see cref="IEnumerable"/> of <see cref="XElement"/>.
        /// <seealso cref="XElement.DescendantsAndSelf()"/>
        /// </summary>
        /// <returns>
        /// An <see cref="IEnumerable"/> of <see cref="XElement"/> containing this <see cref="XElement"/>
        /// and all of it's descendants.
        /// </returns>
        public IEnumerable<XElement> DescendantsAndSelf()
        {
            return GetDescendants(null, true);
        }

        /// <summary>
        /// Returns the descendants of this <see cref="XElement"/> that have a matching <see cref="XName"/>
        /// to the one passed in, including, potentially, this <see cref="XElement"/>.
        /// <seealso cref="XElement.DescendantsAndSelf(XName)"/>
        /// </summary>
        /// <param name="name">
        /// The <see cref="XName"/> of the descendant <see cref="XElement"/> that is being targeted.
        /// </param>
        /// <returns>
        /// An <see cref="IEnumerable"/> of <see cref="XElement"/> containing all of the descendant
        /// <see cref="XElement"/>s that have this <see cref="XName"/>.
        /// </returns>
        public IEnumerable<XElement> DescendantsAndSelf(XName name)
        {
            return name != null ? GetDescendants(name, true) : XElement.EmptySequence;
        }

        /// <summary>
        /// Returns the default <see cref="XNamespace"/> of an <see cref="XElement"/> 
        /// </summary>
        public XNamespace GetDefaultNamespace()
        {
            string namespaceName = GetNamespaceOfPrefixInScope("xmlns", null);
            return namespaceName != null ? XNamespace.Get(namespaceName) : XNamespace.None;
        }

        /// <summary>
        /// Get the namespace associated with a particular prefix for this <see cref="XElement"/> 
        /// in its document context. 
        /// </summary>
        /// <param name="prefix">The namespace prefix to look up</param>
        /// <returns>An <see cref="XNamespace"/> for the namespace bound to the prefix</returns>
        public XNamespace GetNamespaceOfPrefix(string prefix)
        {
            if (prefix == null) throw new ArgumentNullException(nameof(prefix));
            if (prefix.Length == 0) throw new ArgumentException(SR.Format(SR.Argument_InvalidPrefix, prefix));
            if (prefix == "xmlns") return XNamespace.Xmlns;
            string namespaceName = GetNamespaceOfPrefixInScope(prefix, null);
            if (namespaceName != null) return XNamespace.Get(namespaceName);
            if (prefix == "xml") return XNamespace.Xml;
            return null;
        }

        /// <summary>
        /// Get the prefix associated with a namespace for an element in its context.
        /// </summary>
        /// <param name="ns">The <see cref="XNamespace"/> for which to get a prefix</param>
        /// <returns>The namespace prefix string</returns>
        public string GetPrefixOfNamespace(XNamespace ns)
        {
            if (ns == null) throw new ArgumentNullException(nameof(ns));
            string namespaceName = ns.NamespaceName;
            bool hasInScopeNamespace = false;
            XElement e = this;
            do
            {
                XAttribute a = e.lastAttr;
                if (a != null)
                {
                    bool hasLocalNamespace = false;
                    do
                    {
                        a = a.next;
                        if (a.IsNamespaceDeclaration)
                        {
                            if (a.Value == namespaceName)
                            {
                                if (a.Name.NamespaceName.Length != 0 &&
                                    (!hasInScopeNamespace ||
                                     GetNamespaceOfPrefixInScope(a.Name.LocalName, e) == null))
                                {
                                    return a.Name.LocalName;
                                }
                            }
                            hasLocalNamespace = true;
                        }
                    }
                    while (a != e.lastAttr);
                    hasInScopeNamespace |= hasLocalNamespace;
                }
                e = e.parent as XElement;
            }
            while (e != null);
            if ((object)namespaceName == (object)XNamespace.xmlPrefixNamespace)
            {
                if (!hasInScopeNamespace || GetNamespaceOfPrefixInScope("xml", null) == null) return "xml";
            }
            else if ((object)namespaceName == (object)XNamespace.xmlnsPrefixNamespace)
            {
                return "xmlns";
            }
            return null;
        }

        /// <overloads>
        /// The Load method provides multiple strategies for creating a new 
        /// <see cref="XElement"/> and initializing it from a data source containing
        /// raw XML.  Load from a file (passing in a URI to the file), an
        /// <see cref="Stream"/>, a <see cref="TextReader"/>, or an
        /// <see cref="XmlReader"/>.  Note:  Use <see cref="XDocument.Parse(string)"/>
        /// to create an <see cref="XDocument"/> from a string containing XML.
        /// <seealso cref="XDocument.Load(string)" />
        /// <seealso cref="XElement.Parse(string)"/>
        /// </overloads>
        /// <summary>
        /// Create a new <see cref="XElement"/> based on the contents of the file 
        /// referenced by the URI parameter passed in.  Note: Use 
        /// <see cref="XElement.Parse(string)"/> to create an <see cref="XElement"/> from
        /// a string containing XML.
        /// <seealso cref="XmlReader.Create(string)"/>
        /// <seealso cref="XElement.Parse(string)"/>
        /// <seealso cref="XDocument.Parse(string)"/>
        /// </summary>
        /// <remarks>
        /// This method uses the <see cref="XmlReader.Create(string)"/> method to create
        /// an <see cref="XmlReader"/> to read the raw XML into the underlying
        /// XML tree.
        /// </remarks>
        /// <param name="uri">
        /// A URI string referencing the file to load into a new <see cref="XElement"/>.
        /// </param>
        /// <returns>
        /// An <see cref="XElement"/> initialized with the contents of the file referenced
        /// in the passed in uri parameter.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings", Justification = "Back-compat with System.Xml.")]
        public static XElement Load(string uri)
        {
            return Load(uri, LoadOptions.None);
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> based on the contents of the file 
        /// referenced by the URI parameter passed in.  Optionally, whitespace can be preserved.  
        /// <see cref="XmlReader.Create(string)"/>
        /// <seealso cref="XDocument.Load(string, LoadOptions)"/> 
        /// </summary>
        /// <remarks>
        /// This method uses the <see cref="XmlReader.Create(string)"/> method to create
        /// an <see cref="XmlReader"/> to read the raw XML into an underlying
        /// XML tree. If LoadOptions.PreserveWhitespace is enabled then
        /// the <see cref="XmlReaderSettings"/> property <see cref="XmlReaderSettings.IgnoreWhitespace"/>
        /// is set to false.
        /// </remarks>
        /// <param name="uri">
        /// A string representing the URI of the file to be loaded into a new <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <returns>
        /// An <see cref="XElement"/> initialized with the contents of the file referenced
        /// in the passed uri parameter.  If LoadOptions.PreserveWhitespace is enabled then
        /// significant whitespace will be preserved.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings", Justification = "Back-compat with System.Xml.")]
        public static XElement Load(string uri, LoadOptions options)
        {
            XmlReaderSettings rs = GetXmlReaderSettings(options);
            using (XmlReader r = XmlReader.Create(uri, rs))
            {
                return Load(r, options);
            }
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> and initialize its underlying XML tree using
        /// the passed <see cref="Stream"/> parameter.  
        /// </summary>
        /// <param name="stream">
        /// A <see cref="Stream"/> containing the raw XML to read into the newly
        /// created <see cref="XElement"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed in
        /// <see cref="Stream"/>.
        /// </returns>
        public static XElement Load(Stream stream)
        {
            return Load(stream, LoadOptions.None);
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> and initialize its underlying XML tree using
        /// the passed <see cref="Stream"/> parameter.  Optionally whitespace handling
        /// can be preserved.
        /// </summary>
        /// <remarks>
        /// If LoadOptions.PreserveWhitespace is enabled then
        /// the <see cref="XmlReaderSettings"/> property <see cref="XmlReaderSettings.IgnoreWhitespace"/>
        /// is set to false.
        /// </remarks>
        /// <param name="stream">
        /// A <see cref="Stream"/> containing the raw XML to read into the newly
        /// created <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed in
        /// <see cref="Stream"/>.
        /// </returns>
        public static XElement Load(Stream stream, LoadOptions options)
        {
            XmlReaderSettings rs = GetXmlReaderSettings(options);
            using (XmlReader r = XmlReader.Create(stream, rs))
            {
                return Load(r, options);
            }
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> and initialize its underlying XML tree using
        /// the passed <see cref="Stream"/> parameter.  Optionally whitespace handling
        /// can be preserved.
        /// </summary>
        /// <remarks>
        /// If LoadOptions.PreserveWhitespace is enabled then
        /// the <see cref="XmlReaderSettings"/> property <see cref="XmlReaderSettings.IgnoreWhitespace"/>
        /// is set to false.
        /// </remarks>
        /// <param name="stream">
        /// A <see cref="Stream"/> containing the raw XML to read into the newly
        /// created <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <param name="cancellationToken">
        /// A cancellation token.</param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed in
        /// <see cref="Stream"/>.
        /// </returns>
        public static async Task<XElement> LoadAsync(Stream stream, LoadOptions options, CancellationToken cancellationToken)
        {
            XmlReaderSettings rs = GetXmlReaderSettings(options);

            rs.Async = true;

            using (XmlReader r = XmlReader.Create(stream, rs))
            {
                return await LoadAsync(r, options, cancellationToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> and initialize its underlying XML tree using
        /// the passed <see cref="TextReader"/> parameter.  
        /// </summary>
        /// <param name="textReader">
        /// A <see cref="TextReader"/> containing the raw XML to read into the newly
        /// created <see cref="XElement"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed in
        /// <see cref="TextReader"/>.
        /// </returns>
        public static XElement Load(TextReader textReader)
        {
            return Load(textReader, LoadOptions.None);
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> and initialize its underlying XML tree using
        /// the passed <see cref="TextReader"/> parameter.  Optionally whitespace handling
        /// can be preserved.
        /// </summary>
        /// <remarks>
        /// If LoadOptions.PreserveWhitespace is enabled then
        /// the <see cref="XmlReaderSettings"/> property <see cref="XmlReaderSettings.IgnoreWhitespace"/>
        /// is set to false.
        /// </remarks>
        /// <param name="textReader">
        /// A <see cref="TextReader"/> containing the raw XML to read into the newly
        /// created <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed in
        /// <see cref="TextReader"/>.
        /// </returns>
        public static XElement Load(TextReader textReader, LoadOptions options)
        {
            XmlReaderSettings rs = GetXmlReaderSettings(options);
            using (XmlReader r = XmlReader.Create(textReader, rs))
            {
                return Load(r, options);
            }
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> and initialize its underlying XML tree using
        /// the passed <see cref="TextReader"/> parameter.  Optionally whitespace handling
        /// can be preserved.
        /// </summary>
        /// <remarks>
        /// If LoadOptions.PreserveWhitespace is enabled then
        /// the <see cref="XmlReaderSettings"/> property <see cref="XmlReaderSettings.IgnoreWhitespace"/>
        /// is set to false.
        /// </remarks>
        /// <param name="textReader">
        /// A <see cref="TextReader"/> containing the raw XML to read into the newly
        /// created <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <param name="cancellationToken">
        /// A cancellation token.</param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed in
        /// <see cref="TextReader"/>.
        /// </returns>
        public static async Task<XElement> LoadAsync(TextReader textReader, LoadOptions options, CancellationToken cancellationToken)
        {
            XmlReaderSettings rs = GetXmlReaderSettings(options);

            rs.Async = true;

            using (XmlReader r = XmlReader.Create(textReader, rs))
            {
                return await LoadAsync(r, options, cancellationToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> containing the contents of the
        /// passed in <see cref="XmlReader"/>.
        /// </summary>
        /// <param name="reader">
        /// An <see cref="XmlReader"/> containing the XML to be read into the new
        /// <see cref="XElement"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed
        /// in <see cref="XmlReader"/>.
        /// </returns>
        public static XElement Load(XmlReader reader)
        {
            return Load(reader, LoadOptions.None);
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> containing the contents of the
        /// passed in <see cref="XmlReader"/>.
        /// </summary>
        /// <param name="reader">
        /// An <see cref="XmlReader"/> containing the XML to be read into the new
        /// <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed
        /// in <see cref="XmlReader"/>.
        /// </returns>
        public static XElement Load(XmlReader reader, LoadOptions options)
        {
            if (reader == null) throw new ArgumentNullException(nameof(reader));
            if (reader.MoveToContent() != XmlNodeType.Element) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ExpectedNodeType, XmlNodeType.Element, reader.NodeType));
            XElement e = new XElement(reader, options);
            reader.MoveToContent();
            if (!reader.EOF) throw new InvalidOperationException(SR.InvalidOperation_ExpectedEndOfFile);
            return e;
        }

        /// <summary>
        /// Create a new <see cref="XElement"/> containing the contents of the
        /// passed in <see cref="XmlReader"/>.
        /// </summary>
        /// <param name="reader">
        /// An <see cref="XmlReader"/> containing the XML to be read into the new
        /// <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <param name="cancellationToken">
        /// A cancellation token.</param>
        /// <returns>
        /// A new <see cref="XElement"/> containing the contents of the passed
        /// in <see cref="XmlReader"/>.
        /// </returns>
        public static Task<XElement> LoadAsync(XmlReader reader, LoadOptions options, CancellationToken cancellationToken)
        {
            if (reader == null)
                throw new ArgumentNullException(nameof(reader));
            if (cancellationToken.IsCancellationRequested)
                return Task.FromCanceled<XElement>(cancellationToken);
            return LoadAsyncInternal(reader, options, cancellationToken);
        }

        private static async Task<XElement> LoadAsyncInternal(XmlReader reader, LoadOptions options, CancellationToken cancellationToken)
        {
            if (await reader.MoveToContentAsync().ConfigureAwait(false) != XmlNodeType.Element) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ExpectedNodeType, XmlNodeType.Element, reader.NodeType));

            XElement e = new XElement(new AsyncConstructionSentry());
            await e.ReadElementFromAsync(reader, options, cancellationToken).ConfigureAwait(false);

            cancellationToken.ThrowIfCancellationRequested();
            await reader.MoveToContentAsync().ConfigureAwait(false);

            if (!reader.EOF) throw new InvalidOperationException(SR.InvalidOperation_ExpectedEndOfFile);
            return e;
        }

        /// <overloads>
        /// Parses a string containing XML into an <see cref="XElement"/>.  Optionally
        /// whitespace can be preserved.
        /// </overloads>
        /// <summary>
        /// Parses a string containing XML into an <see cref="XElement"/>.  
        /// </summary>
        /// <remarks>
        /// The XML must contain only one root node.
        /// </remarks>
        /// <param name="text">
        /// A string containing the XML to parse into an <see cref="XElement"/>.
        /// </param>
        /// <returns>
        /// An <see cref="XElement"/> created from the XML string passed in.
        /// </returns>
        public static XElement Parse(string text)
        {
            return Parse(text, LoadOptions.None);
        }

        /// <summary>
        /// Parses a string containing XML into an <see cref="XElement"/> and optionally
        /// preserves the Whitespace. See <see cref="XmlReaderSettings.IgnoreWhitespace"/>.
        /// </summary>
        /// <remarks>
        /// <list>
        /// <item>The XML must contain only one root node.</item>
        /// <item>
        /// If LoadOptions.PreserveWhitespace is enabled the underlying 
        /// <see cref="XmlReaderSettings"/>'
        /// property <see cref="XmlReaderSettings.IgnoreWhitespace"/> will be set to false.
        /// </item>
        /// </list>
        /// </remarks>
        /// <param name="text">
        /// A string containing the XML to parse into an <see cref="XElement"/>.
        /// </param>
        /// <param name="options">
        /// A set of <see cref="LoadOptions"/>.
        /// </param>
        /// <returns>
        /// An <see cref="XElement"/> created from the XML string passed in.
        /// </returns>
        public static XElement Parse(string text, LoadOptions options)
        {
            using (StringReader sr = new StringReader(text))
            {
                XmlReaderSettings rs = GetXmlReaderSettings(options);
                using (XmlReader r = XmlReader.Create(sr, rs))
                {
                    return Load(r, options);
                }
            }
        }

        /// <summary>
        /// Removes content and attributes from this <see cref="XElement"/>.
        /// <seealso cref="XElement.RemoveAttributes"/>
        /// <seealso cref="XContainer.RemoveNodes"/>
        /// </summary>
        public void RemoveAll()
        {
            RemoveAttributes();
            RemoveNodes();
        }

        /// <summary>
        /// Removes that attributes of this <see cref="XElement"/>.
        /// <seealso cref="XElement.RemoveAll"/>
        /// <seealso cref="XElement.RemoveAttributes"/>
        /// </summary>
        public void RemoveAttributes()
        {
            if (SkipNotify())
            {
                RemoveAttributesSkipNotify();
                return;
            }
            while (lastAttr != null)
            {
                XAttribute a = lastAttr.next;
                NotifyChanging(a, XObjectChangeEventArgs.Remove);
                if (lastAttr == null || a != lastAttr.next) throw new InvalidOperationException(SR.InvalidOperation_ExternalCode);
                if (a != lastAttr)
                {
                    lastAttr.next = a.next;
                }
                else
                {
                    lastAttr = null;
                }
                a.parent = null;
                a.next = null;
                NotifyChanged(a, XObjectChangeEventArgs.Remove);
            }
        }

        /// <overloads>
        /// Replaces the child nodes and the attributes of this element with the
        /// specified content. The content can be simple content, a collection of
        /// content objects, a parameter list of content objects, or null.
        /// </overloads>
        /// <summary>
        /// Replaces the children nodes and the attributes of this element with the specified content.
        /// </summary>
        /// <param name="content">
        /// The content that will replace the child nodes and attributes of this element.
        /// </param>
        /// <remarks>
        /// See XContainer.Add(object content) for details about the content that can be added
        /// using this method.
        /// </remarks>
        public void ReplaceAll(object content)
        {
            content = GetContentSnapshot(content);
            RemoveAll();
            Add(content);
        }

        /// <summary>
        /// Replaces the children nodes and the attributes of this element with the specified content.
        /// </summary>
        /// <param name="content">
        /// A parameter list of content objects.
        /// </param>
        /// <remarks>
        /// See XContainer.Add(object content) for details about the content that can be added
        /// using this method.
        /// </remarks>
        public void ReplaceAll(params object[] content)
        {
            ReplaceAll((object)content);
        }

        /// <overloads>
        /// Replaces the attributes of this element with the specified content.
        /// The content can be simple content, a collection of
        /// content objects, a parameter list of content objects, or null.
        /// </overloads>
        /// <summary>
        /// Replaces the attributes of this element with the specified content.
        /// </summary>
        /// <param name="content">
        /// The content that will replace the attributes of this element.
        /// </param>
        /// <remarks>
        /// See XContainer.Add(object content) for details about the content that can be added
        /// using this method.
        /// </remarks>
        public void ReplaceAttributes(object content)
        {
            content = GetContentSnapshot(content);
            RemoveAttributes();
            Add(content);
        }

        /// <summary>
        /// Replaces the attributes of this element with the specified content.
        /// </summary>
        /// <param name="content">
        /// A parameter list of content objects.
        /// </param>
        /// <remarks>
        /// See XContainer.Add(object content) for details about the content that can be added
        /// using this method.
        /// </remarks>
        public void ReplaceAttributes(params object[] content)
        {
            ReplaceAttributes((object)content);
        }


        /// <summary>
        /// Output this <see cref="XElement"/> to the passed in <see cref="Stream"/>.
        /// </summary>
        /// <remarks>
        /// The format will be indented by default.  If you want
        /// no indenting then use the SaveOptions version of Save (see
        /// <see cref="XElement.Save(Stream, SaveOptions)"/>) enabling 
        /// SaveOptions.DisableFormatting.
        /// There is also an option SaveOptions.OmitDuplicateNamespaces for removing duplicate namespace declarations. 
        /// Or instead use the SaveOptions as an annotation on this node or its ancestors, then this method will use those options.
        /// </remarks>
        /// <param name="stream">
        /// The <see cref="Stream"/> to output this <see cref="XElement"/> to.
        /// </param>
        public void Save(Stream stream)
        {
            Save(stream, GetSaveOptionsFromAnnotations());
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">
        /// The <see cref="Stream"/> to output the XML to.  
        /// </param>
        /// <param name="options">
        /// If SaveOptions.DisableFormatting is enabled the output is not indented.
        /// If SaveOptions.OmitDuplicateNamespaces is enabled duplicate namespace declarations will be removed.
        /// </param>
        public void Save(Stream stream, SaveOptions options)
        {
            XmlWriterSettings ws = GetXmlWriterSettings(options);
            using (XmlWriter w = XmlWriter.Create(stream, ws))
            {
                Save(w);
            }
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">
        /// The <see cref="Stream"/> to output the XML to.  
        /// </param>
        /// <param name="options">
        /// If SaveOptions.DisableFormatting is enabled the output is not indented.
        /// If SaveOptions.OmitDuplicateNamespaces is enabled duplicate namespace declarations will be removed.
        /// </param>
        /// <param name="cancellationToken">A cancellation token.</param>
        public async Task SaveAsync(Stream stream, SaveOptions options, CancellationToken cancellationToken)
        {
            XmlWriterSettings ws = GetXmlWriterSettings(options);

            ws.Async = true;

            using (XmlWriter w = XmlWriter.Create(stream, ws))
            {
                await SaveAsync(w, cancellationToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to the passed in <see cref="TextWriter"/>.
        /// </summary>
        /// <remarks>
        /// The format will be indented by default.  If you want
        /// no indenting then use the SaveOptions version of Save (see
        /// <see cref="XElement.Save(TextWriter, SaveOptions)"/>) enabling 
        /// SaveOptions.DisableFormatting.
        /// There is also an option SaveOptions.OmitDuplicateNamespaces for removing duplicate namespace declarations. 
        /// Or instead use the SaveOptions as an annotation on this node or its ancestors, then this method will use those options.
        /// </remarks>
        /// <param name="textWriter">
        /// The <see cref="TextWriter"/> to output this <see cref="XElement"/> to.
        /// </param>
        public void Save(TextWriter textWriter)
        {
            Save(textWriter, GetSaveOptionsFromAnnotations());
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to a <see cref="TextWriter"/>.
        /// </summary>
        /// <param name="textWriter">
        /// The <see cref="TextWriter"/> to output the XML to.  
        /// </param>
        /// <param name="options">
        /// If SaveOptions.DisableFormatting is enabled the output is not indented.
        /// If SaveOptions.OmitDuplicateNamespaces is enabled duplicate namespace declarations will be removed.
        /// </param>
        public void Save(TextWriter textWriter, SaveOptions options)
        {
            XmlWriterSettings ws = GetXmlWriterSettings(options);
            using (XmlWriter w = XmlWriter.Create(textWriter, ws))
            {
                Save(w);
            }
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to a <see cref="TextWriter"/>.
        /// </summary>
        /// <param name="textWriter">
        /// The <see cref="TextWriter"/> to output the XML to.  
        /// </param>
        /// <param name="options">
        /// If SaveOptions.DisableFormatting is enabled the output is not indented.
        /// If SaveOptions.OmitDuplicateNamespaces is enabled duplicate namespace declarations will be removed.
        /// </param>
        /// <param name="cancellationToken">A cancellation token.</param>
        public async Task SaveAsync(TextWriter textWriter, SaveOptions options, CancellationToken cancellationToken)
        {
            XmlWriterSettings ws = GetXmlWriterSettings(options);

            ws.Async = true;

            using (XmlWriter w = XmlWriter.Create(textWriter, ws))
            {
                await SaveAsync(w, cancellationToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to an <see cref="XmlWriter"/>.
        /// </summary>
        /// <param name="writer">
        /// The <see cref="XmlWriter"/> to output the XML to.
        /// </param>
        public void Save(XmlWriter writer)
        {
            if (writer == null) throw new ArgumentNullException(nameof(writer));
            writer.WriteStartDocument();
            WriteTo(writer);
            writer.WriteEndDocument();
        }

        /// <summary>
        /// Output this <see cref="XElement"/> to an <see cref="XmlWriter"/>.
        /// </summary>
        /// <param name="writer">
        /// The <see cref="XmlWriter"/> to output the XML to.
        /// </param>
        /// <param name="cancellationToken">A cancellation token.</param>
        public Task SaveAsync(XmlWriter writer, CancellationToken cancellationToken)
        {
            if (writer == null)
                throw new ArgumentNullException(nameof(writer));
            if (cancellationToken.IsCancellationRequested)
                return Task.FromCanceled(cancellationToken);
            return SaveAsyncInternal(writer, cancellationToken);
        }

        private async Task SaveAsyncInternal(XmlWriter writer, CancellationToken cancellationToken)
        {
            await writer.WriteStartDocumentAsync().ConfigureAwait(false);

            await WriteToAsync(writer, cancellationToken).ConfigureAwait(false);

            cancellationToken.ThrowIfCancellationRequested();
            await writer.WriteEndDocumentAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Sets the value of an attribute. The value is assigned to the attribute with the given
        /// name. If no attribute with the given name exists, a new attribute is added. If the
        /// value is null, the attribute with the given name, if any, is deleted.
        /// <seealso cref="XAttribute.SetValue"/>
        /// <seealso cref="XElement.SetElementValue"/>
        /// <seealso cref="XElement.SetValue"/>
        /// </summary>
        /// <param name="name">
        /// The name of the attribute whose value to change.
        /// </param>
        /// <param name="value">
        /// The value to assign to the attribute. The attribute is deleted if the value is null.
        /// Otherwise, the value is converted to its string representation and assigned to the
        /// <see cref="Value"/> property of the attribute.
        /// </param>
        /// <exception cref="ArgumentException">
        /// Thrown if the value is an instance of <see cref="XObject"/>.
        /// </exception>
        public void SetAttributeValue(XName name, object value)
        {
            XAttribute a = Attribute(name);
            if (value == null)
            {
                if (a != null) RemoveAttribute(a);
            }
            else
            {
                if (a != null)
                {
                    a.Value = GetStringValue(value);
                }
                else
                {
                    AppendAttribute(new XAttribute(name, value));
                }
            }
        }

        /// <summary>
        /// Sets the value of a child element. The value is assigned to the first child element
        /// with the given name. If no child element with the given name exists, a new child
        /// element is added. If the value is null, the first child element with the given name,
        /// if any, is deleted.
        /// <seealso cref="XAttribute.SetValue"/>
        /// <seealso cref="XElement.SetAttributeValue"/>
        /// <seealso cref="XElement.SetValue"/>
        /// </summary>
        /// <param name="name">
        /// The name of the child element whose value to change.
        /// </param>
        /// <param name="value">
        /// The value to assign to the child element. The child element is deleted if the value
        /// is null. Otherwise, the value is converted to its string representation and assigned
        /// to the <see cref="Value"/> property of the child element.
        /// </param>
        /// <exception cref="ArgumentException">
        /// Thrown if the value is an instance of <see cref="XObject"/>.
        /// </exception>
        public void SetElementValue(XName name, object value)
        {
            XElement e = Element(name);
            if (value == null)
            {
                if (e != null) RemoveNode(e);
            }
            else
            {
                if (e != null)
                {
                    e.Value = GetStringValue(value);
                }
                else
                {
                    AddNode(new XElement(name, GetStringValue(value)));
                }
            }
        }

        /// <summary>
        /// Sets the value of this element.
        /// <seealso cref="XAttribute.SetValue"/>
        /// <seealso cref="XElement.SetAttributeValue"/>
        /// <seealso cref="XElement.SetElementValue"/>
        /// </summary>
        /// <param name="value">
        /// The value to assign to this element. The value is converted to its string representation
        /// and assigned to the <see cref="Value"/> property.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the specified value is null.
        /// </exception>
        public void SetValue(object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            Value = GetStringValue(value);
        }

        /// <summary>
        /// Write this <see cref="XElement"/> to the passed in <see cref="XmlWriter"/>.
        /// </summary>
        /// <param name="writer">
        /// The <see cref="XmlWriter"/> to write this <see cref="XElement"/> to.
        /// </param>
        public override void WriteTo(XmlWriter writer)
        {
            if (writer == null) throw new ArgumentNullException(nameof(writer));
            new ElementWriter(writer).WriteElement(this);
        }

        /// <summary>
        /// Write this <see cref="XElement"/> to the passed in <see cref="XmlTextWriter"/>.
        /// </summary>
        /// <param name="writer">
        /// The <see cref="XmlTextWriter"/> to write this <see cref="XElement"/> to.
        /// </param>
        /// <param name="cancellationToken">A cancellation token.</param>
        public override Task WriteToAsync(XmlWriter writer, CancellationToken cancellationToken)
        {
            if (writer == null)
                throw new ArgumentNullException(nameof(writer));
            if (cancellationToken.IsCancellationRequested)
                return Task.FromCanceled(cancellationToken);
            return new ElementWriter(writer).WriteElementAsync(this, cancellationToken);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="string"/>.
        /// </summary>
        /// <remarks>
        /// If the <see cref="XElement"/> is a subtree (an <see cref="XElement"/>
        /// that has <see cref="XElement"/> children.  The concatenated string
        /// value of all of the <see cref="XElement"/>'s text and descendants
        /// text is returned.
        /// </remarks>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to a string.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="string"/>.
        /// </returns>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator string (XElement element)
        {
            if (element == null) return null;
            return element.Value;
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="bool"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="bool"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="bool"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the element does not contain a valid boolean value.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator bool (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToBoolean(element.Value.ToLowerInvariant());
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="bool"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="bool"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="bool"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the element does not contain a valid boolean value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator bool? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToBoolean(element.Value.ToLowerInvariant());
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="int"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="int"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="int"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the element does not contain a valid integer value.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator int (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToInt32(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="int"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="int"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="int"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid integer value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator int? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToInt32(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="uint"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="uint"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="uint"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid unsigned integer value.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator uint (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToUInt32(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="uint"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="uint"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="uint"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid unsigned integer value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator uint? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToUInt32(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="long"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="long"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="long"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the element does not contain a valid long integer value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator long (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToInt64(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="long"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="long"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="long"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid long integer value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator long? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToInt64(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="ulong"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="ulong"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="ulong"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid unsigned long integer value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator ulong (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToUInt64(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="ulong"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="ulong"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="ulong"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid unsigned long integer value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator ulong? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToUInt64(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="float"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="float"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="float"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid float value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator float (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToSingle(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="float"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="float"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="float"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid float value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator float? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToSingle(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="double"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="double"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="double"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid double value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator double (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToDouble(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="double"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="double"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="double"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid double value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator double? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToDouble(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="decimal"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="decimal"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="decimal"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid decimal value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>        
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator decimal (XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToDecimal(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="decimal"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="decimal"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="decimal"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid decimal value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator decimal? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToDecimal(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="DateTime"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="DateTime"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="DateTime"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid <see cref="DateTime"/> value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>        
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator DateTime(XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return DateTime.Parse(element.Value, CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.RoundtripKind);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="DateTime"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="DateTime"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="DateTime"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid <see cref="DateTime"/> value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator DateTime? (XElement element)
        {
            if (element == null) return null;
            return DateTime.Parse(element.Value, CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.RoundtripKind);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="DateTimeOffset"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="DateTimeOffset"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="DateTimeOffset"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid <see cref="DateTimeOffset"/> value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>        
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator DateTimeOffset(XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToDateTimeOffset(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="DateTimeOffset"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="DateTimeOffset"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="DateTimeOffset"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid <see cref="DateTimeOffset"/> value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator DateTimeOffset? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToDateTimeOffset(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="TimeSpan"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="TimeSpan"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="TimeSpan"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid <see cref="TimeSpan"/> value.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator TimeSpan(XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToTimeSpan(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="TimeSpan"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="TimeSpan"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="TimeSpan"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid <see cref="TimeSpan"/> value.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator TimeSpan? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToTimeSpan(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to a <see cref="Guid"/>.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="Guid"/>.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="Guid"/>.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid guid.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the specified element is null.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator Guid(XElement element)
        {
            if (element == null) throw new ArgumentNullException(nameof(element));
            return XmlConvert.ToGuid(element.Value);
        }

        /// <summary>
        /// Cast the value of this <see cref="XElement"/> to an <see cref="Guid"/>?.
        /// </summary>
        /// <param name="element">
        /// The <see cref="XElement"/> to cast to <see cref="Guid"/>?.
        /// </param>
        /// <returns>
        /// The content of this <see cref="XElement"/> as a <see cref="Guid"/>?.
        /// </returns>
        /// <exception cref="System.FormatException">
        /// Thrown if the specified element does not contain a valid guid.
        /// </exception>
        [CLSCompliant(false)]
        [SuppressMessage("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates", Justification = "Operator marked with CLSCompliant(false).")]
        public static explicit operator Guid? (XElement element)
        {
            if (element == null) return null;
            return XmlConvert.ToGuid(element.Value);
        }

#if MONO_HYBRID_SYSTEM_XML
        static object ConvertForAssignment (object value)
        {
            var node = value as XmlNode;
            if (node == null)
                return value;
            var doc = new XmlDocument ();
            doc.AppendChild (doc.ImportNode (node, true));
            return XElement.Parse (doc.InnerXml);
        }
#endif

        /// <summary>
        /// This method is obsolete for the IXmlSerializable contract.
        /// </summary>
        XmlSchema IXmlSerializable.GetSchema()
        {
            return null;
        }

        /// <summary>
        /// Generates a <see cref="XElement"/> from its XML representation.
        /// </summary>
        /// <param name="reader">
        /// The <see cref="XmlReader"/> stream from which the <see cref="XElement"/>
        /// is deserialized.
        /// </param>
        void IXmlSerializable.ReadXml(XmlReader reader)
        {
            if (reader == null) throw new ArgumentNullException(nameof(reader));
            if (parent != null || annotations != null || content != null || lastAttr != null) throw new InvalidOperationException(SR.InvalidOperation_DeserializeInstance);
            if (reader.MoveToContent() != XmlNodeType.Element) throw new InvalidOperationException(SR.Format(SR.InvalidOperation_ExpectedNodeType, XmlNodeType.Element, reader.NodeType));
            ReadElementFrom(reader, LoadOptions.None);
        }

        /// <summary>
        /// Converts a <see cref="XElement"/> into its XML representation.
        /// </summary>
        /// <param name="writer">
        /// The <see cref="XmlWriter"/> stream to which the <see cref="XElement"/>
        /// is serialized.
        /// </param>
        void IXmlSerializable.WriteXml(XmlWriter writer)
        {
            WriteTo(writer);
        }

        internal override void AddAttribute(XAttribute a)
        {
            if (Attribute(a.Name) != null) throw new InvalidOperationException(SR.InvalidOperation_DuplicateAttribute);
            if (a.parent != null) a = new XAttribute(a);
            AppendAttribute(a);
        }

        internal override void AddAttributeSkipNotify(XAttribute a)
        {
            if (Attribute(a.Name) != null) throw new InvalidOperationException(SR.InvalidOperation_DuplicateAttribute);
            if (a.parent != null) a = new XAttribute(a);
            AppendAttributeSkipNotify(a);
        }

        internal void AppendAttribute(XAttribute a)
        {
            bool notify = NotifyChanging(a, XObjectChangeEventArgs