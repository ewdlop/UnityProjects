// Copyright Epic Games, Inc. All Rights Reserved.

#include "AzureSpatialAnchorsAndroidInterop.h"

// AzureSpatialAnchorsNDK.hpp includes AzureSpatialAnchorsLibrary_Exports.h.  Both are autogenerated and could change with 
// ASA version updates, so I don't want to edit them.
// Unfortunately  uses #if but locale (included by ostream, included by ssstream) uses #ifdef which
// leaves us confused as to whether __APPLE__, etc are 'true' or 'false'. 
// What we will do, therfore, is set the defines as AzureSpatialAnchorsLibrary_Exports.h needs them, and include it, then set them
// back.

#ifdef __APPLE__
#error AzureSpatialAnchorsAndroidInterop.cpp is being compiled with __APPLE__ set. This is unexpected and the define wranging below will be wrong so fail now.
#endif
#ifdef _WIN32
#error AzureSpatialAnchorsAndroidInterop.cpp is being compiled with _WIN32 set. This is unexpected and the define wranging below will be wrong so fail now.
#endif
#if __ANDROID__ != 1
#error AzureSpatialAnchorsAndroidInterop.cpp is being compiled with __ANDROID__ != 1. This is unexpected so fail now.
#endif
#define __APPLE__ 0
#define _WIN32 0
extern "C" {
#include <AzureSpatialAnchorsLibrary_Exports.h>
}
#undef _WIN32
#undef __APPLE__
#include "AzureSpatialAnchorsNDK.hpp"

#include <memory>
#include <sstream>
#include <string>
#include "ARBlueprintLibrary.h"
#include "GoogleARCoreFunctionLibrary.h"
#include "Async/Async.h"

using namespace Microsoft::Azure::SpatialAnchors;

DEFINE_LOG_CATEGORY(LogAzureSpatialAnchorsAndroidInterop);

TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> FAzureSpatialAnchorsAndroidInterop::Create(
	AnchorLocatedCallbackPtr AnchorLocatedCallback,
	LocateAnchorsCompletedCallbackPtr LocateAnchorsCompletedCallback,
	SessionUpdatedCallbackPtr SessionUpdatedCallback)
{
	struct SharedFAzureSpatialAnchorsAndroidInterop : public FAzureSpatialAnchorsAndroidInterop {};
	TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> Output = MakeShareable( new SharedFAzureSpatialAnchorsAndroidInterop());
	Output->SetWeakThis(Output);
	Output->SetCallbacks(AnchorLocatedCallback, LocateAnchorsCompletedCallback, SessionUpdatedCallback);
	return Output;
}

FAzureSpatialAnchorsAndroidInterop::FAzureSpatialAnchorsAndroidInterop()
{
}


FAzureSpatialAnchorsAndroidInterop::~FAzureSpatialAnchorsAndroidInterop()
{
}

void FAzureSpatialAnchorsAndroidInterop::SetCallbacks(
	AnchorLocatedCallbackPtr AnchorLocated,
	LocateAnchorsCompletedCallbackPtr LocateAnchorsCompleted,
	SessionUpdatedCallbackPtr SessionUpdated)
{
	this->AnchorLocatedCallback = AnchorLocated;
	this->LocateAnchorsCompletedCallback = LocateAnchorsCompleted;
	this->SessionUpdatedCallback = SessionUpdated;
}

bool FAzureSpatialAnchorsAndroidInterop::CreateSession()
{
	if (UARBlueprintLibrary::GetARSessionStatus().Status != EARSessionStatus::Running)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Failed to create an Azure Spatial Anchors session, no AR Session was found to be running"));
		return false;
	}

	if (Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Creating an Azure Spatial Anchors session when a session already existed"));
	}

    UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Creating an Azure Spatial Anchors session"));
	auto TempARSystem = TSharedPtr<FARSupportInterface, ESPMode::ThreadSafe>{ StaticCastSharedPtr<FXRTrackingSystemBase>(GEngine->XRSystem)->GetARCompositionComponent() };
    if (TempARSystem.IsValid())
    {
        UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors located a valid AR System"));    
		auto TempSession = std::make_shared<CloudSpatialAnchorSession>();
        void* SessionHandle = TempARSystem->GetARSessionRawPointer();
		if (SessionHandle != nullptr)
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors obtained a valid session handle"));
			TempSession->Session(static_cast<ArSession*>(SessionHandle));

			ErrorToken = TempSession->Error([](auto&&, auto&& Args)
			{
				auto errorCode = static_cast<int>(Args->ErrorCode());
				auto errorMessage = Args->ErrorMessage();
				UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors Session Encountered an error, ErrorCode: %d ErrorMessage:%s"), errorCode, UTF8_TO_TCHAR(errorMessage.c_str()));
			});

			TWeakPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> WeakSelf = WeakThis;
			AnchorLocatedToken = TempSession->AnchorLocated([WeakSelf](auto&&, auto&& Args)
			{
				AsyncTask(
					ENamedThreads::GameThread,
					[WeakSelf, Args]() {
					if (TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> SharedSelf = WeakSelf.Pin())
					{
						SharedSelf->OnAnchorLocated(Args);
					}
				});
			});

			LocateAnchorsCompletedToken = TempSession->LocateAnchorsCompleted([WeakSelf](auto&&, auto&& Args)
			{
				if (TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> SharedSelf = WeakSelf.Pin())
				{
					SharedSelf->LocateAnchorsCompletedCallback(Args->Watcher()->Identifier(), Args->Cancelled());
				}
			});

			OnLogDebugToken = TempSession->OnLogDebug([](auto&&, auto&& Args)
			{
				auto Message = Args->Message();
				UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors: %s"), UTF8_TO_TCHAR(Message.c_str()));
			});

			SessionUpdatedToken = TempSession->SessionUpdated([WeakSelf](auto&&, auto&& Args)
			{
				auto status = Args->Status();
				if (status != nullptr)
				{
					if (status->UserFeedback() != SessionUserFeedback::None)
					{
						UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors Session Updated: %s"), *SessionUserFeedbackToString(status->UserFeedback()));
					}

					if (TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe>SharedSelf = WeakSelf.Pin())
					{
						SharedSelf->SessionUpdatedCallback(status->ReadyForCreateProgress(), status->RecommendedForCreateProgress(), status->SessionCreateHash(), status->SessionLocateHash(), static_cast<int32>(status->UserFeedback()));
					}
				}
			});

			ARSystem = TempARSystem;
			Session = TempSession;
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors session successfully created"));
			return true;
		}
		else
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to obtain a valid session handle"));
			return false;
		}
    }
	else
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to find a valid AR System"));
	}

    return false;
}

void FAzureSpatialAnchorsAndroidInterop::DestroySession()
{
	if (!Session)
	{
		return;
	}

	StopSession();

	Session->Error(ErrorToken);
	Session->AnchorLocated(AnchorLocatedToken);
	Session->LocateAnchorsCompleted(LocateAnchorsCompletedToken);
	Session->OnLogDebug(OnLogDebugToken);
	Session->SessionUpdated(SessionUpdatedToken);
	Session = nullptr;

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors destroyed a session"));
}

void FAzureSpatialAnchorsAndroidInterop::GetAccessTokenWithAccountKeyAsync(const FString& AccountKey, IAzureSpatialAnchors::Callback_Result_String Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", L"");
		return;
	}

	Session->GetAccessTokenWithAccountKeyAsync(TCHAR_TO_UTF8(*AccountKey), [Callback](Status status, const std::string& token)
	{
		std::wstringstream string;
		if (status != Status::OK)
		{
			string << L"Failed to obtain access token from account key: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), L"");
			return;
		}

		string << token.c_str();
		Callback(EAzureSpatialAnchorsResult::Success, L"", string.str().c_str());
	});
}

void FAzureSpatialAnchorsAndroidInterop::GetAccessTokenWithAuthenticationTokenAsync(const FString& AuthenticationToken, IAzureSpatialAnchors::Callback_Result_String Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", L"");
		return;
	}

	Session->GetAccessTokenWithAuthenticationTokenAsync(TCHAR_TO_UTF8(*AuthenticationToken), [Callback](Status status, const std::string& token)
	{
		std::wstringstream string;
		if (status != Status::OK)
		{
			string << L"Failed to obtain access token from authentication token: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), L"");
			return;
		}

		string << token.c_str();
		Callback(EAzureSpatialAnchorsResult::Success, L"", string.str().c_str());
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::StartSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to start session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Attempting to start Azure Spatial Anchors session"));
	Session->Start();
	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors succesfully started a session"));
	bSessionRunning = true;
	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::UpdateSession()
{
	if (Session != nullptr &&
		ARSystem.IsValid() &&
		bSessionRunning)
	{
		if (UARBlueprintLibrary::GetARSessionStatus().Status != EARSessionStatus::Running)
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("AR Session was stopped before azure spatial anchors session was cleaned up."));
			return;
		}

		void* frameHandle = ARSystem->GetGameThreadARFrameRawPointer();
		if (frameHandle != nullptr)
		{
			Session->ProcessFrame(static_cast<ArFrame*>(frameHandle));
		}
		else
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors was unable to obtain a frame handle, failed to update the session"));
		}
	}
}

void FAzureSpatialAnchorsAndroidInterop::StopSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Azure Spatial Anchors failed to stop session, session was null"));
		return;
	}

	if (CurrentWatcher)
	{
		CurrentWatcher->Stop();
		CurrentWatcher = nullptr;
	}

	LocalAnchorMap.Empty();

	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		CloudAnchorMap.Empty();
	}

	Session->Stop();
	bSessionRunning = false;
	
	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors stopped a session"));
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::ResetSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Azure Spatial Anchors failed to reset session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	Session->Reset();
	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::DisposeSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Azure Spatial Anchors failed to dispose session, session was null"));
		return;
	}

	Session->Dispose();
	Session = nullptr;
}

void FAzureSpatialAnchorsAndroidInterop::GetSessionStatusAsync(IAzureSpatialAnchors::Callback_Result_SessionStatus Callback)
{
	FAzureSpatialAnchorsSessionStatus SessionStatus;

	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", SessionStatus);
		return;
	}

	if (!bSessionRunning)
	{
		Callback(EAzureSpatialAnchorsResult::NotStarted, L"", SessionStatus);
		return;
	}

	Session->GetSessionStatusAsync([Callback](Microsoft::Azure::SpatialAnchors::Status status, const std::shared_ptr<Microsoft::Azure::SpatialAnchors::SessionStatus>& sessionStatus)
	{
		FAzureSpatialAnchorsSessionStatus SessionStatus;

		if (status != Status::OK)
		{
			std::wstringstream string;
			string << L"Failed to obtain session status: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), SessionStatus);
			return;
		}

		SessionStatus.ReadyForCreateProgress = sessionStatus->ReadyForCreateProgress();
		SessionStatus.RecommendedForCreateProgress = sessionStatus->RecommendedForCreateProgress();
		SessionStatus.SessionCreateHash = sessionStatus->SessionCreateHash();
		SessionStatus.SessionLocateHash = sessionStatus->SessionLocateHash();
		SessionStatus.feedback = static_cast<EAzureSpatialAnchorsSessionUserFeedback>(sessionStatus->UserFeedback());

		Callback(EAzureSpatialAnchorsResult::Success, L"", SessionStatus);
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::ConstructAnchor(UARPin* InARPin, IAzureSpatialAnchors::CloudAnchorID& OutCloudAnchorID)
{
	OutCloudAnchorID = IAzureSpatialAnchors::CloudAnchorID_Invalid;
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an AzureCloudSpatialAnchor when no session is running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}

	if (!InARPin)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Provided ARPin was null"));
		return EAzureSpatialAnchorsResult::FailNoARPin;
	}

	auto NativeAnchor = static_cast<ArAnchor*>(InARPin->GetNativeResource());
	if (!NativeAnchor)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Provided ARPin did not have a valid associated ArAnchor, Azure Spatial Anchors was unable to create a cloud anchor"));
		return EAzureSpatialAnchorsResult::FailNoLocalAnchor;
	}

	UAzureCloudSpatialAnchor* OutCloudAnchor = NewObject<UAzureCloudSpatialAnchor>();
	OutCloudAnchor->ARPin = InARPin;
	OutCloudAnchor->CloudAnchorID = GetNextID();
	LocalAnchorMap.Add(OutCloudAnchor->CloudAnchorID, OutCloudAnchor);

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor = std::make_shared<CloudSpatialAnchor>();
	CloudAnchor->LocalAnchor(NativeAnchor);

	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		CloudAnchorMap.Add(OutCloudAnchor->CloudAnchorID, CloudAnchor);
	}

	OutCloudAnchorID = OutCloudAnchor->CloudAnchorID;
	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::CreateAnchorAsync(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Azure Spatial Anchors session has not been started/does not exist");
		return;
	}

	if (LocalAnchorMap.Contains(InCloudAnchorID) == 0)
	{
		Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor was not known to plugin");
		return;
	}

	auto LocalAnchor = LocalAnchorMap[InCloudAnchorID];

	if (!LocalAnchor->ARPin)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoAnchor, L"Provided ARPin was null");
		return;
	}

	auto arAnchor = static_cast<ArAnchor*>(LocalAnchor->ARPin->GetNativeResource());
	if (!arAnchor)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoLocalAnchor, L"Provided ARPin did not have a valid associated ArAnchor, Azure Spatial Anchors was unable to create a cloud anchor");
		return;
	}

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor was not known to plugin");
			return;
		}

		CloudAnchor = CloudAnchorMap[InCloudAnchorID];
	}

	CloudAnchor->LocalAnchor(arAnchor);

	Session->CreateAnchorAsync(CloudAnchor, [Callback](Status status) {
		if (status != Status::OK)
		{
			std::wstringstream string;
			string << L"Failed to create azure spatial anchor: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

void FAzureSpatialAnchorsAndroidInterop::DeleteAnchorAsync(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Azure Spatial Anchors session has not been started/does not exist");
		return;
	}

	std::shared_ptr<CloudSpatialAnchor> Anchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor was not known to plugin");
			return;
		}

		Anchor = CloudAnchorMap[InCloudAnchorID];
	}

	if (Anchor->Identifier().empty())
	{
		// Anchor only existed locally
		ClearAnchorData(InCloudAnchorID);
		Callback(EAzureSpatialAnchorsResult::Success, L"");
		return;
	}

	TWeakPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> WeakSelf = WeakThis;
	Session->DeleteAnchorAsync(Anchor, [Callback, InCloudAnchorID, WeakSelf](Status status) {
		if (status != Status::OK) {
			std::wstringstream string;
			string << L"Failed to delete azure spatial anchor: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		if (auto SharedSelf = WeakSelf.Pin())
		{
			SharedSelf->ClearAnchorData(InCloudAnchorID);
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::CreateWatcher(const FAzureSpatialAnchorsLocateCriteria& InLocateCriteria, float InWorldToMetersScale, IAzureSpatialAnchors::WatcherID& OutWatcherIdentifier, FString& OutErrorString)
{
	OutErrorString = FString{};
	OutWatcherIdentifier = InvalidWatcherIdentifier;

	if (!Session ||
		!bSessionRunning)
	{
		OutErrorString = TEXT("Attempted to create a watcher when no Azure Spatial Anchor session was running");
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	if (CurrentWatcher)
	{
		OutErrorString = TEXT("Attempted to create a watcher when a watcher already exists. Only one watcher is supported at a time");
		return EAzureSpatialAnchorsResult::FailSeeErrorString;
	}

	std::shared_ptr<CloudSpatialAnchor> NearAnchor;
	if (InLocateCriteria.NearAnchor != nullptr)
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InLocateCriteria.NearAnchor->CloudAnchorID))
		{
			OutErrorString = TEXT("Provided near anchor has not been saved/associated with the Azure Spatial Anchor service");
			return EAzureSpatialAnchorsResult::FailBadCloudAnchorIdentifier;
		}

		NearAnchor = CloudAnchorMap[InLocateCriteria.NearAnchor->CloudAnchorID];
	}

	std::shared_ptr<AnchorLocateCriteria> CloudAnchorLocateCriteria = std::make_shared<AnchorLocateCriteria>();
	CloudAnchorLocateCriteria->BypassCache(InLocateCriteria.bBypassCache);
	CloudAnchorLocateCriteria->RequestedCategories(static_cast<AnchorDataCategory>(InLocateCriteria.RequestedCategories));
	CloudAnchorLocateCriteria->Strategy(static_cast<LocateStrategy>(InLocateCriteria.Strategy));

	std::vector<std::string> Identifiers;
	for (FString Identifier : InLocateCriteria.Identifiers)
	{
		Identifiers.push_back(std::string(TCHAR_TO_UTF8(*Identifier)));
	}
	CloudAnchorLocateCriteria->Identifiers(Identifiers);

	if (NearAnchor != nullptr)
	{
		std::shared_ptr<NearAnchorCriteria> AnchorCriteria = std::make_shared<NearAnchorCriteria>();
		AnchorCriteria->SourceAnchor(NearAnchor);
		AnchorCriteria->DistanceInMeters(InLocateCriteria.NearAnchorDistance / 100.0f); // Convert from cm to m
		AnchorCriteria->MaxResultCount(InLocateCriteria.NearAnchorMaxResultCount);
		CloudAnchorLocateCriteria->NearAnchor(AnchorCriteria);
	}

	if (InLocateCriteria.bSearchNearDevice)
	{
		std::shared_ptr<NearDeviceCriteria> DeviceCriteria = std::make_shared<NearDeviceCriteria>();
		DeviceCriteria->DistanceInMeters(InLocateCriteria.NearDeviceDistance / 100.0f); // Convert from cm to m
		DeviceCriteria->MaxResultCount(InLocateCriteria.NearDeviceMaxResultCount);
		CloudAnchorLocateCriteria->NearDevice(DeviceCriteria);
	}

	CurrentWatcher = Session->CreateWatcher(CloudAnchorLocateCriteria);
	OutWatcherIdentifier = CurrentWatcher->Identifier();
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetActiveWatchers(TArray<IAzureSpatialAnchors::WatcherID>& OutWatcherIDs)
{
	OutWatcherIDs.Empty();
	if (CurrentWatcher != nullptr)
	{
		OutWatcherIDs.Add(CurrentWatcher->Identifier());
	}

	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::GetAnchorPropertiesAsync(const FString& InCloudAnchorIdentifier, IAzureSpatialAnchors::Callback_Result_CloudAnchorID Callback)
{
	if (!Session ||
		!bSessionRunning)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Attempted to get AzureCloudSpatialAnchor properties when no session was running", IAzureSpatialAnchors::CloudAnchorID_Invalid);
		return;
	}

	if (InCloudAnchorIdentifier.IsEmpty())
	{
		Callback(EAzureSpatialAnchorsResult::FailBadCloudAnchorIdentifier, L"Provided CloudIdentifier was invalid", IAzureSpatialAnchors::CloudAnchorID_Invalid);
		return;
	}

	IAzureSpatialAnchors::CloudAnchorID CloudAnchorID = IAzureSpatialAnchors::CloudAnchorID_Invalid;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		for (auto pair : CloudAnchorMap)
		{
			if (FString{ UTF8_TO_TCHAR(pair.Value->Identifier().c_str()) } == InCloudAnchorIdentifier)
			{
				CloudAnchorID = pair.Key;
			}
		}
	}

	if (CloudAnchorID == IAzureSpatialAnchors::CloudAnchorID_Invalid)
	{
		Callback(EAzureSpatialAnchorsResult::FailBadCloudAnchorIdentifier, L"Provided CloudIdentifier was not known to the plugin", IAzureSpatialAnchors::CloudAnchorID_Invalid);
		return;
	}

	Session->GetAnchorPropertiesAsync(TCHAR_TO_UTF8(*InCloudAnchorIdentifier), [Callback, CloudAnchorID](Status status, const 