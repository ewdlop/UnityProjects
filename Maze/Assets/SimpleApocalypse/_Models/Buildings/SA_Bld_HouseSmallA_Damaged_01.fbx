import gc
import sys
import unittest
import UserList
import weakref
import operator
import contextlib
import copy
import time

from test import test_support

# Used in ReferencesTestCase.test_ref_created_during_del() .
ref_from_del = None

class C:
    def method(self):
        pass


class Callable:
    bar = None

    def __call__(self, x):
        self.bar = x


def create_function():
    def f(): pass
    return f

def create_bound_method():
    return C().method

def create_unbound_method():
    return C.method


class Object:
    def __init__(self, arg):
        self.arg = arg
    def __repr__(self):
        return "<Object %r>" % self.arg
    def __eq__(self, other):
        if isinstance(other, Object):
            return self.arg == other.arg
        return NotImplemented
    def __ne__(self, other):
        if isinstance(other, Object):
            return self.arg != other.arg
        return NotImplemented
    def __hash__(self):
        return hash(self.arg)

class RefCycle:
    def __init__(self):
        self.cycle = self


@contextlib.contextmanager
def collect_in_thread(period=0.001):
    """
    Ensure GC collections happen in a different thread, at a high frequency.
    """
    threading = test_support.import_module('threading')
    please_stop = False

    def collect():
        while not please_stop:
            time.sleep(period)
            gc.collect()

    with test_support.disable_gc():
        old_interval = sys.getcheckinterval()
        sys.setcheckinterval(20)
        t = threading.Thread(target=collect)
        t.start()
        try:
            yield
        finally:
            please_stop = True
            t.join()
            sys.setcheckinterval(old_interval)


class TestBase(unittest.TestCase):

    def setUp(self):
        self.cbcalled = 0

    def callback(self, ref):
        self.cbcalled += 1


class ReferencesTestCase(TestBase):

    def test_basic_ref(self):
        self.check_basic_ref(C)
        self.check_basic_ref(create_function)
        self.check_basic_ref(create_bound_method)
        self.check_basic_ref(create_unbound_method)

        # Just make sure the tp_repr handler doesn't raise an exception.
        # Live reference:
        o = C()
        wr = weakref.ref(o)
        repr(wr)
        # Dead reference:
        del o
        repr(wr)

    def test_basic_callback(self):
        self.check_basic_callback(C)
        self.check_basic_callback(create_function)
        self.check_basic_callback(create_bound_method)
        self.check_basic_callback(create_unbound_method)

    def test_multiple_callbacks(self):
        o = C()
        ref1 = weakref.ref(o, self.callback)
        ref2 = weakref.ref(o, self.callback)
        del o
        self.assertIsNone(ref1(), "expected reference to be invalidated")
        self.assertIsNone(ref2(), "expected reference to be invalidated")
        self.assertEqual(self.cbcalled, 2,
                     "callback not called the right number of times")

    def test_multiple_selfref_callbacks(self):
        # Make sure all references are invalidated before callbacks are called
        #
        # What's important here is that we're using the first
        # reference in the callback invoked on the second reference
        # (the most recently created ref is cleaned up first).  This
        # tests that all references to the object are invalidated
        # before any of the callbacks are invoked, so that we only
        # have one invocation of _weakref.c:cleanup_helper() active
        # for a particular object at a time.
        #
        def callback(object, self=self):
            self.ref()
        c = C()
        self.ref = weakref.ref(c, callback)
        ref1 = weakref.ref(c, callback)
        del c

    def test_constructor_kwargs(self):
        c = C()
        self.assertRaises(TypeError, weakref.ref, c, callback=None)

    def test_proxy_ref(self):
        o = C()
        o.bar = 1
        ref1 = weakref.proxy(o, self.callback)
        ref2 = weakref.proxy(o, self.callback)
        del o

        def check(proxy):
            proxy.bar

        self.assertRaises(weakref.ReferenceError, check, ref1)
        self.assertRaises(weakref.ReferenceError, check, ref2)
        self.assertRaises(weakref.ReferenceError, bool, weakref.proxy(C()))
        self.assertEqual(self.cbcalled, 2)

    def check_basic_ref(self, factory):
        o = factory()
        ref = weakref.ref(o)
        self.assertIsNotNone(ref(),
                     "weak reference to live object should be live")
        o2 = ref()
        self.assertIs(o, o2,
                     "<ref>() should return original object if live")

    def check_basic_callback(self, factory):
        self.cbcalled = 0
        o = factory()
        ref = weakref.ref(o, self.callback)
        del o
        self.assertEqual(self.cbcalled, 1,
                     "callback did not properly set 'cbcalled'")
        self.assertIsNone(ref(),
                     "ref2 should be dead after deleting object reference")

    def test_ref_reuse(self):
        o = C()
        ref1 = weakref.ref(o)
        # create a proxy to make sure that there's an intervening creation
        # between these two; it should make no difference
        proxy = weakref.proxy(o)
        ref2 = weakref.ref(o)
        self.assertIs(ref1, ref2,
                     "reference object w/out callback should be re-used")

        o = C()
        proxy = weakref.proxy(o)
        ref1 = weakref.ref(o)
        ref2 = weakref.ref(o)
        self.assertIs(ref1, ref2,
                     "reference object w/out callback should be re-used")
        self.assertEqual(weakref.getweakrefcount(o), 2,
                     "wrong weak ref count for object")
        del proxy
        self.assertEqual(weakref.getweakrefcount(o), 1,
                     "wrong weak ref count for object after deleting proxy")

    def test_proxy_reuse(self):
        o = C()
        proxy1 = weakref.proxy(o)
        ref = weakref.ref(o)
        proxy2 = weakref.proxy(o)
        self.assertIs(proxy1, proxy2,
                     "proxy object w/out callback should have been re-used")

    def test_basic_proxy(self):
        o = C()
        self.check_proxy(o, weakref.proxy(o))

        L = UserList.UserList()
        p = weakref.proxy(L)
        self.assertFalse(p, "proxy for empty UserList should be false")
        p.append(12)
        self.assertEqual(len(L), 1)
        self.assertTrue(p, "proxy for non-empty UserList should be true")
        with test_support.check_py3k_warnings():
            p[:] = [2, 3]
        self.assertEqual(len(L), 2)
        self.assertEqual(len(p), 2)
        self.assertIn(3, p, "proxy didn't support __contains__() properly")
        p[1] = 5
        self.assertEqual(L[1], 5)
        self.assertEqual(p[1], 5)
        L2 = UserList.UserList(L)
        p2 = weakref.proxy(L2)
        self.assertEqual(p, p2)
        ## self.assertEqual(repr(L2), repr(p2))
        L3 = UserList.UserList(range(10))
        p3 = weakref.proxy(L3)
        with test_support.check_py3k_warnings():
            self.assertEqual(L3[:], p3[:])
            self.assertEqual(L3[5:], p3[5:])
            self.assertEqual(L3[:5], p3[:5])
            self.assertEqual(L3[2:5], p3[2:5])

    def test_proxy_unicode(self):
        # See bug 5037
        class C(object):
            def __str__(self):
                return "string"
            def __unicode__(self):
                return u"unicode"
        instance = C()
        self.assertIn("__unicode__", dir(weakref.proxy(instance)))
        self.assertEqual(unicode(weakref.proxy(instance)), u"unicode")

    def test_proxy_index(self):
        class C:
            def __index__(self):
                return 10
        o = C()
        p = weakref.proxy(o)
        self.assertEqual(operator.index(p), 10)

    def test_proxy_div(self):
        class C:
            def __floordiv__(self, other):
                return 42
            def __ifloordiv__(self, other):
                return 21
        o = C()
        p = weakref.proxy(o)
        self.assertEqual(p // 5, 42)
        p //= 5
        self.assertEqual(p, 21)

    # The PyWeakref_* C API is documented as allowing either NULL or
    # None as the value for the callback, where either means "no
    # callback".  The "no callback" ref and proxy objects are supposed
    # to be shared so long as they exist by all callers so long as
    # they are active.  In Python 2.3.3 and earlier, this guarantee
    # was not honored, and was broken in different ways for
    # PyWeakref_NewRef() and PyWeakref_NewProxy().  (Two tests.)

    def test_shared_ref_without_callback(self):
        self.check_shared_without_callback(weakref.ref)

    def test_shared_proxy_without_callback(self):
        self.check_shared_without_callback(weakref.proxy)

    def check_shared_without_callback(self, makeref):
        o = Object(1)
        p1 = makeref(o, None)
        p2 = makeref(o, None)
        self.assertIs(p1, p2, "both callbacks were None in the C API")
        del p1, p2
        p1 = makeref(o)
        p2 = makeref(o, None)
        self.assertIs(p1, p2, "callbacks were NULL, None in the C API")
        del p1, p2
        p1 = makeref(o)
        p2 = makeref(o)
        self.assertIs(p1, p2, "both callbacks were NULL in the C API")
        del p1, p2
        p1 = makeref(o, None)
        p2 = makeref(o)
        self.assertIs(p1, p2, "callbacks were None, NULL in the C API")

    def test_callable_proxy(self):
        o = Callable()
        ref1 = weakref.proxy(o)

        self.check_proxy(o, ref1)

        self.assertIs(type(ref1), weakref.CallableProxyType,
                     "proxy is not of callable type")
        ref1('twinkies!')
        self.assertEqual(o.bar, 'twinkies!',
                     "call through proxy not passed through to original")
        ref1(x='Splat.')
        self.assertEqual(o.bar, 'Splat.',
                     "call through proxy not passed through to original")

        # expect due to too few args
        self.assertRaises(TypeError, ref1)

        # expect due to too many args
        self.assertRaises(TypeError, ref1, 1, 2, 3)

    def check_proxy(self, o, proxy):
        o.foo = 1
        self.assertEqual(proxy.foo, 1,
                     "proxy does not reflect attribute addition")
        o.foo = 2
        self.assertEqual(proxy.foo, 2,
                     "proxy does not reflect attribute modification")
        del o.foo
        self.assertFalse(hasattr(proxy, 'foo'),
                     "proxy does not reflect attribute removal")

        proxy.foo = 1
        self.assertEqual(o.foo, 1,
                     "object does not reflect attribute addition via proxy")
        proxy.foo = 2
        self.assertEqual(o.foo, 2,
            "object does not reflect attribute modification via proxy")
        del proxy.foo
        self.assertFalse(hasattr(o, 'foo'),
                     "object does not reflect attribute removal via proxy")

    def test_proxy_deletion(self):
        # Test clearing of SF bug #762891
        class Foo:
            result = None
            def __delitem__(self, accessor):
                self.result = accessor
        g = Foo()
        f = weakref.proxy(g)
        del f[0]
        self.assertEqual(f.result, 0)

    def test_proxy_bool(self):
        # Test clearing of SF bug #1170766
        class List(list): pass
        lyst = List()
        self.assertEqual(bool(weakref.proxy(lyst)), bool(lyst))

    def test_getweakrefcount(self):
        o = C()
        ref1 = weakref.ref(o)
        ref2 = weakref.ref(o, self.callback)
        self.assertEqual(weakref.getweakrefcount(o), 2,
                     "got wrong number of weak reference objects")

        proxy1 = weakref.proxy(o)
        proxy2 = weakref.proxy(o, self.callback)
        self.assertEqual(weakref.getweakrefcount(o), 4,
                     "got wrong number of weak reference objects")

        del ref1, ref2, proxy1, proxy2
        self.assertEqual(weakref.getweakrefcount(o), 0,
                     "weak reference objects not unlinked from"
                     " referent when discarded.")

        # assumes ints do not support weakrefs
        self.assertEqual(weakref.getweakrefcount(1), 0,
                     "got wrong number of weak reference objects for int")

    def test_getweakrefs(self):
        o = C()
        ref1 = weakref.ref(o, self.callback)
        ref2 = weakref.ref(o, self.callback)
        del ref1
        self.assertEqual(weakref.getweakrefs(o), [ref2],
                     "list of refs does not match")

        o = C()
        ref1 = weakref.ref(o, self.callback)
        ref2 = weakref.ref(o, self.callback)
        del ref2
        self.assertEqual(weakref.getweakrefs(o), [ref1],
                     "list of refs does not match")

        del ref1
        self.assertEqual(weakref.getweakrefs(o), [],
                     "list of refs not cleared")

        # assumes ints do not support weakrefs
        self.assertEqual(weakref.getweakrefs(1), [],
                     "list of refs does not match for int")

    def test_newstyle_number_ops(self):
        class F(float):
            pass
        f = F(2.0)
        p = weakref.proxy(f)
        self.assertEqual(p + 1.0, 3.0)
        self.assertEqual(1.0 + p, 3.0)  # this used to SEGV

    def test_callbacks_protected(self):
        # Callbacks protected from already-set exceptions?
        # Regression test for SF bug #478534.
        class BogusError(Exception):
            pass
        data = {}
        def remove(k):
            del data[k]
        def encapsulate():
            f = lambda : ()
            data[weakref.ref(f, remove)] = None
            raise BogusError
        try:
            encapsulate()
        except BogusError:
            pass
        else:
            self.fail("exception not properly restored")
        try:
            encapsulate()
        except BogusError:
            pass
        else:
            self.fail("exception not properly restored")

    def test_sf_bug_840829(self):
        # "weakref callbacks and gc corrupt memory"
        # subtype_dealloc erroneously exposed a new-style instance
        # already in the process of getting deallocated to gc,
        # causing double-deallocation if the instance had a weakref
        # callback that triggered gc.
        # If the bug exists, there probably won't be an obvious symptom
        # in a release build.  In a debug build, a segfault will occur
        # when the second attempt to remove the instance from the "list
        # of all objects" occurs.

        import gc

        class C(object):
            pass

        c = C()
        wr = weakref.ref(c, lambda ignore: gc.collect())
        del c

        # There endeth the first part.  It gets worse.
        del wr

        c1 = C()
        c1.i = C()
        wr = weakref.ref(c1.i, lambda ignore: gc.collect())

        c2 = C()
        c2.c1 = c1
        del c1  # still alive because c2 points to it

        # Now when subtype_dealloc gets called on c2, it's not enough just
        # that c2 is immune from gc while the weakref callbacks associated
        # with c2 execute (there are none in this 2nd half of the test, btw).
        # subtype_dealloc goes on to call the base classes' deallocs too,
        # so any gc triggered by weakref callbacks associated with anything
        # torn down by a base class dealloc can also trigger double
        # deallocation of c2.
        del c2

    def test_callback_in_cycle_1(self):
        import gc

        class J(object):
            pass

        class II(object):
            def acallback(self, ignore):
                self.J

        I = II()
        I.J = J
        I.wr = weakref.ref(J, I.acallback)

        # Now J and II are each in a self-cycle (as all new-style class
        # objects are, since their __mro__ points back to them).  I holds
        # both a weak reference (I.wr) and a strong reference (I.J) to class
        # J.  I is also in a cycle (I.wr points to a weakref that references
        # I.acallback).  When we del these three, they all become trash, but
        # the cycles prevent any of them from getting cleaned up immediately.
        # Instead they have to wait for cyclic gc to deduce that they're
        # trash.
        #
        # gc used to call tp_clear on all of them, and the order in which
        # it does that is pretty accidental.  The exact order in which we
        # built up these things manages to provoke gc into running tp_clear
        # in just the right order (I last).  Calling tp_clear on II leaves
        # behind an insane class object (its __mro__ becomes NULL).  Calling
        # tp_clear on J breaks its self-cycle, but J doesn't get deleted
        # just then because of the strong reference from I.J.  Calling
        # tp_clear on I starts to clear I's __dict__, and just happens to
        # clear I.J first -- I.wr is still intact.  That removes the last
        # reference to J, which triggers the weakref callback.  The callback
        # tries to do "self.J", and instances of new-style classes look up
        # attributes ("J") in the class dict first.  The class (II) wants to
        # search II.__mro__, but that's NULL.   The result was a segfault in
        # a release build, and an assert failure in a debug build.
        del I, J, II
        gc.collect()

    def test_callback_in_cycle_2(self):
        import gc

        # This is just like test_callback_in_cycle_1, except that II is an
        # old-style class.  The symptom is different then:  an instance of an
        # old-style class looks in its own __dict__ first.  'J' happens to
        # get cleared from I.__dict__ before 'wr', and 'J' was never in II's
        # __dict__, so the attribute isn't found.  The difference is that
        # the old-style II doesn't have a NULL __mro__ (it doesn't have any
        # __mro__), so no segfault occurs.  Instead it got:
        #    test_callback_in_cycle_2 (__main__.ReferencesTestCase) ...
        #    Exception exceptions.AttributeError:
        #   "II instance has no attribute 'J'" in <bound method II.acallback
        #       of <?.II instance at 0x00B9B4B8>> ignored

        class J(object):
            pass

        class II:
            def acallback(self, ignore):
                self.J

        I = II()
        I.J = J
        I.wr = weakref.ref(J, I.acallback)

        del I, J, II
        gc.collect()

    def test_callback_in_cycle_3(self):
        import gc

        # This one broke the first patch that fixed the last two.  In this
        # case, the objects reachable from the callback aren't also reachable
        # from the object (c1) *triggering* the callback:  you can get to
        # c1 from c2, but not vice-versa.  The result was that c2's __dict__
        # got tp_clear'ed by the time the c2.cb callback got invoked.

        class C:
            def cb(self, ignore):
                self.me
                self.c1
                self.wr

        c1, c2 = C(), C()

        c2.me = c2
        c2.c1 = c1
        c2.wr = weakref.ref(c1, c2.cb)

        del c1, c2
        gc.collect()

    def test_callback_in_cycle_4(self):
        import gc

        # Like test_callback_in_cycle_3, except c2 and c1 have different
        # classes.  c2's class (C) isn't reachable from c1 then, so protecting
        # objects reachable from the dying object (c1) isn't enough to stop
        # c2's class (C) from getting tp_clear'ed before c2.cb is invoked.
        # The result was a segfault (C.__mro__ was NULL when the callback
        # tried to look up self.me).

        class C(object):
            def cb(self, ignore):
                self.me
                self.c1
                self.wr

        class D:
            pass

        c1, c2 = D(), C()

        c2.me = c2
        c2.c1 = c1
        c2.wr = weakref.ref(c1, c2.cb)

        del c1, c2, C, D
        gc.collect()

    @test_support.requires_type_collecting
    def test_callback_in_cycle_resurrection(self):
        import gc

        # Do something nasty in a weakref callback:  resurrect objects
        # from dead cycles.  For this to be attempted, the weakref and
        # its callback must also be part of the cyclic trash (else the
        # objects reachable via the callback couldn't be in cyclic trash
        # to begin with -- the callback would act like an external root).
        # But gc clears trash weakrefs with callbacks early now, which
        # disables the callbacks, so the callbacks shouldn't get called
        # at all (and so nothing actually gets resurrected).

        alist = []
        class C(object):
            def __init__(self, value):
                self.attribute = value

            def acallback(self, ignore):
                alist.append(self.c)

        c1, c2 = C(1), C(2)
        c1.c = c2
        c2.c = c1
        c1.wr = weakref.ref(c2, c1.acallback)
        c2.wr = weakref.ref(c1, c2.acallback)

        def C_went_away(ignore):
            alist.append("C went away")
        wr = weakref.ref(C, C_went_away)

        del c1, c2, C   # make them all trash
        self.assertEqual(alist, [])  # del isn't enough to reclaim anything

        gc.collect()
        # c1.wr and c2.wr were part of the cyclic trash, so should have
        # been cleared without their callbacks executing.  OTOH, the weakref
        # to C is bound to a function local (wr), and wasn't trash, so that
        # callback should have been invoked when C went away.
        self.assertEqual(alist, ["C went away"])
        # The remaining weakref should be dead now (its callback ran).
        self.assertEqual(wr(), None)

        del alist[:]
        gc.collect()
        self.assertEqual(alist, [])

    def test_callbacks_on_callback(self):
        import gc

        # Set up weakref callbacks *on* weakref callbacks.
        alist = []
        def safe_callback(ignore):
            alist.append("safe_callback called")

        class C(object):
            def cb(self, ignore):
                alist.append("cb called")

        c, d = C(), C()
        c.other = d
        d.other = c
        callback = c.cb
        c.wr = weakref.ref(d, callback)     # this won't trigger
        d.wr = weakref.ref(callback, d.cb)  # ditto
        external_wr = weakref.ref(callback, safe_callback)  # but this will
        self.assertIs(external_wr(), callback)

        # The weakrefs attached to c and d should get cleared, so that
        # C.cb is never called.  But external_wr isn't part of the cyclic
        # trash, and no cyclic trash is reachable from it, so safe_callback
        # should get invoked when the bound method object callback (c.cb)
        # -- which is itself a callback, and also part of the cyclic trash --
        # gets reclaimed at the end of gc.

        del callback, c, d, C
        self.assertEqual(alist, [])  # del isn't enough to clean up cycles
        gc.collect()
        self.assertEqual(alist, ["safe_callback called"])
        self.assertEqual(external_wr(), None)

        del alist[:]
        gc.collect()
        self.assertEqual(alist, [])

    def test_gc_during_ref_creation(self):
        self.check_gc_during_creation(weakref.ref)

    def test_gc_during_proxy_creation(self):
        self.check_gc_during_creation(weakref.proxy)

    def check_gc_during_creation(self, makeref):
        thresholds = gc.get_threshold()
        gc.set_threshold(1, 1, 1)
        gc.collect()
        class A:
            pass

        def callback(*args):
            pass

        referenced = A()

        a = A()
        a.a = a
        a.wr = makeref(referenced)

        try:
            # now make sure the object and the ref get labeled as
            # cyclic trash:
            a = A()
            weakref.ref(referenced, callback)

        finally:
            gc.set_threshold(*thresholds)

    def test_ref_created_during_del(self):
        # Bug #1377858
        # A weakref created in an object's __del__() would crash the
        # interpreter when the weakref was cleaned up since it would refer to
        # non-existent memory.  This test should not segfault the interpreter.
        class Target(object):
            def __del__(self):
                global ref_from_del
                ref_from_del = weakref.ref(self)

        w = Target()

    def test_init(self):
        # Issue 3634
        # <weakref to class>.__init__() doesn't check errors correctly
        r = weakref.ref(Exception)
        self.assertRaises(TypeError, r.__init__, 0, 0, 0, 0, 0)
        # No exception should be raised here
        gc.collect()

    def test_classes(self):
        # Check that both old-style classes and new-style classes
        # are weakrefable.
        class A(object):
            pass
        class B:
            pass
        l = []
        weakref.ref(int)
        a = weakref.ref(A, l.append)
        A = None
        gc.collect()
        self.assertEqual(a(), None)
        self.assertEqual(l, [a])
        b = weakref.ref(B, l.append)
        B = None
        gc.collect()
        self.assertEqual(b(), None)
        self.assertEqual(l, [a, b])

    def test_equality(self):
        # Alive weakrefs defer equality testing to their underlying object.
        x = Object(1)
        y = Object(1)
        z = Object(2)
        a = weakref.ref(x)
        b = weakref.ref(y)
        c = weakref.ref(z)
        d = weakref.ref(x)
        # Note how we directly test the operators here, to stress both
        # __eq__ and __ne__.
        self.assertTrue(a == b)
        self.assertFalse(a != b)
        self.assertFalse(a == c)
        self.assertTrue(a != c)
        self.assertTrue(a == d)
        self.assertFalse(a != d)
        del x, y, z
        gc.collect()
        for r in a, b, c:
            # Sanity check
            self.assertIs(r(), None)
        # Dead weakrefs compare by identity: whether `a` and `d` are the
        # same weakref object is an implementation detail, since they pointed
        # to the same original object and didn't have a callback.
        # (see issue #16453).
        self.assertFalse(a == b)
        self.assertTrue(a != b)
        self.assertFalse(a == c)
        self.assertTrue(a != c)
        self.assertEqual(a == d, a is d)
        self.assertEqual(a != d, a is not d)

    def test_hashing(self):
        # Alive weakrefs hash the same as the underlying object
        x = Object(42)
        y = Object(42)
        a = weakref.ref(x)
        b = weakref.ref(y)
        self.assertEqual(hash(a), hash(42))
        del x, y
        gc.collect()
        # Dead weakrefs:
        # - retain their hash is they were hashed when alive;
        # - otherwise, cannot be hashed.
        self.assertEqual(hash(a), hash(42))
        self.assertRaises(TypeError, hash, b)

    def test_trashcan_16602(self):
        # Issue #16602: when a weakref's target was part of a long
        # deallocation chain, the trashcan mechanism could delay clearing
        # of the weakref and make the target object visible from outside
        # code even though its refcount had dropped to 0.  A crash ensued.
        class C(object):
            def __init__(self, parent):
                if not parent:
                    return
                wself = weakref.ref(self)
                def cb(wparent):
                    o = wself()
                self.wparent = weakref.ref(parent, cb)

        d = weakref.WeakKeyDictionary()
        root = c = C(None)
        for n in range(100):
            d[c] = c = C(c)
        del root
        gc.collect()


class SubclassableWeakrefTestCase(TestBase):

    def test_subclass_refs(self):
        class MyRef(weakref.ref):
            def __init__(self, ob, callback=None, value=42):
                self.value = value
                super(MyRef, self).__init__(ob, callback)
            def __call__(self):
                self.called = True
                return super(MyRef, self).__call__()
        o = Object("foo")
        mr = MyRef(o, value=24)
        self.assertIs(mr(), o)
        self.assertTrue(mr.called)
        self.assertEqual(mr.value, 24)
        del o
        self.assertIsNone(mr())
        self.assertTrue(mr.called)

    def test_subclass_refs_dont_replace_standard_refs(self):
        class MyRef(weakref.ref):
            pass
        o = Object(42)
        r1 = MyRef(o)
        r2 = weakref.ref(o)
        self.assertIsNot(r1, r2)
        self.assertEqual(weakref.getweakrefs(o), [r2, r1])
        self.assertEqual(weakref.getweakrefcount(o), 2)
        r3 = MyRef(o)
        self.assertEqual(weakref.getweakrefcount(o), 3)
        refs = weakref.getweakrefs(o)
        self.assertEqual(len(refs), 3)
        self.assertIs(r2, refs[0])
        self.assertIn(r1, refs[1:])
        self.assertIn(r3, refs[1:])

    def test_subclass_refs_dont_conflate_callbacks(self):
        class MyRef(weakref.ref):
            pass
        o = Object(42)
        r1 = MyRef(o, id)
        r2 = MyRef(o, str)
        self.assertIsNot(r1, r2)
        refs = weakref.getweakrefs(o)
        self.assertIn(r1, refs)
        self.assertIn(r2, refs)

    def test_subclass_refs_with_slots(self):
        class MyRef(weakref.ref):
            __slots__ = "slot1", "slot2"
            def __new__(type, ob, callback, slot1, slot2):
                return weakref.ref.__new__(type, ob, callback)
            def __init__(self, ob, callback, slot1, slot2):
                self.slot1 = slot1
                self.slot2 = slot2
            def meth(self):
                return self.slot1 + self.slot2
        o = Object(42)
        r = MyRef(o, None, "abc", "def")
        self.assertEqual(r.slot1, "abc")
        self.assertEqual(r.slot2, "def")
        self.assertEqual(r.meth(), "abcdef")
        self.assertFalse(hasattr(r, "__dict__"))

    def test_subclass_refs_with_cycle(self):
        # Bug #3110
        # An instance of a weakref subclass can have attributes.
        # If such a weakref holds the only strong reference to the object,
        # deleting the weakref will delete the object. In this case,
        # the callback must not be called, because the ref object is
        # being deleted.
        class MyRef(weakref.ref):
            pass

        # Use a local callback, for "regrtest -R::"
        # to detect refcounting problems
        def callback(w):
            self.cbcalled += 1

        o = C()
        r1 = MyRef(o, callback)
        r1.o = o
        del o

        del r1 # Used to crash here

        self.assertEqual(self.cbcalled, 0)

        # Same test, with two weakrefs to the same object
        # (since code paths are different)
        o = C()
        r1 = MyRef(o, callback)
        r2 = MyRef(o, callback)
        r1.r = r2
        r2.o = o
        del o
        del r2

        del r1 # Used to crash here

        self.assertEqual(self.cbcalled, 0)


class MappingTestCase(TestBase):

    COUNT = 10

    def check_len_cycles(self, dict_type, cons):
        N = 20
        items = [RefCycle() for i in range(N)]
        dct = dict_type(cons(i, o) for i, o in enumerate(items))
        # Keep an iterator alive
        it = dct.iteritems()
        try:
            next(it)
        except StopIteration:
            pass
        del items
        gc.collect()
        n1 = len(dct)
        list(it)
        del it
        gc.collect()
        n2 = len(dct)
        # iteration should prevent garbage collection here
        # Note that this is a test on an implementation detail.  The requirement
        # is only to provide stable iteration, not that the size of the container
        # stay fixed.
        self.assertEqual(n1, 20)
        #self.assertIn(n1, (0, 1))
        self.assertEqual(n2, 0)

    def test_weak_keyed_len_cycles(self):
        self.check_len_cycles(weakref.WeakKeyDictionary, lambda n, k: (k, n))

    def test_weak_valued_len_cycles(self):
        self.check_len_cycles(weakref.WeakValueDictionary, lambda n, k: (n, k))

    def check_len_race(self, dict_type, cons):
        # Extended sanity checks for len() in the face of cyclic collection
        self.addCleanup(gc.set_threshold, *gc.get_threshold())
        for th in range(1, 100):
            N = 20
            gc.collect(0)
            gc.set_threshold(th, th, th)
            items = [RefCycle() for i in range(N)]
            dct = dict_type(cons(o) for o in items)
            del items
            # All items will be collected at next garbage collection pass
            it = dct.iteritems()
            try:
                next(it)
            except StopIteration:
                pass
            n1 = len(dct)
            del it
            n2 = len(dct)
            self.assertGreaterEqual(n1, 0)
            self.assertLessEqual(n1, N)
            self.assertGreaterEqual(n2, 0)
            self.assertLessEqual(n2, n1)

    def test_weak_keyed_len_race(self):
        self.check_len_race(weakref.WeakKeyDictionary, lambda k: (k, 1))

    def test_weak_valued_len_race(self):
        self.check_len_race(weakref.WeakValueDictionary, lambda k: (1, k))

    def test_weak_values(self):
        #
        #  This exercises d.copy(), d.items(), d[], del d[], len(d).
        #
        dict, objects = self.make_weak_valued_dict()
        for o in objects:
            self.assertEqual(weakref.getweakrefcount(o), 1,
                         "wrong number of weak references to %r!" % o)
            self.assertIs(o, dict[o.arg],
                         "wrong object returned by weak dict!")
        items1 = dict.items()
        items2 = dict.copy().items()
        items1.sort()
        items2.sort()
        self.assertEqual(items1, items2,
                     "cloning of weak-valued dictionary did not work!")
        del items1, items2
        self.assertEqual(len(dict), self.COUNT)
        del objects[0]
        self.assertEqual(len(dict), (self.COUNT - 1),
                     "deleting object did not cause dictionary update")
        del objects, o
        self.assertEqual(len(dict), 0,
                     "deleting the values did not clear the dictionary")
        # regression on SF bug #447152:
        dict = weakref.WeakValueDictionary()
        self.assertRaises(KeyError, dict.__getitem__, 1)
        dict[2] = C()
        self.assertRaises(KeyError, dict.__getitem__, 2)

    def test_weak_keys(self):
        #
        #  This exercises d.copy(), d.items(), d[] = v, d[], del d[],
        #  len(d), in d.
        #
        dict, objects = self.make_weak_keyed_dict()
        for o in objects:
            self.assertEqual(weakref.getweakrefcount(o), 1,
                         "wrong number of weak references to %r!" % o)
            self.assertIs(o.arg, dict[o],
                         "wrong object returned by weak dict!")
        items1 = dict.items()
        items2 = dict.copy().items()
        self.assertEqual(set(items1), set(items2),
                     "cloning of weak-keyed dictionary did not work!")
        del items1, items2
        self.assertEqual(len(dict), self.COUNT)
        del objects[0]
        self.assertEqual(len(dict), (self.COUNT - 1),
                     "deleting object did not cause dictionary update")
        del objects, o
        self.assertEqual(len(dict), 0,
                     "deleting the keys did not clear the dictionary")
        o = Object(42)
        dict[o] = "What is the meaning of the universe?"
        self.assertIn(o, dict)
        self.assertNotIn(34, dict)

    def test_weak_keyed_iters(self):
        dict, objects = self.make_weak_keyed_dict()
        self.check_iters(dict)

        # Test keyrefs()
        refs = dict.keyrefs()
        self.assertEqual(len(refs), len(objects))
        objects2 = list(objects)
        for wr in refs:
            ob = wr()
            self.assertIn(ob, dict)
            self.assertEqual(ob.arg, dict[ob])
            objects2.remove(ob)
        self.assertEqual(len(objects2), 0)

        # Test iterkeyrefs()
        objects2 = list(objects)
        self.assertEqual(len(list(dict.iterkeyrefs())), len(objects))
        for wr in dict.iterkeyrefs():
            ob = wr()
            self.assertIn(ob, dict)
            self.assertEqual(ob.arg, dict[ob])
            objects2.remove(ob)
        self.assertEqual(len(objects2), 0)

    def test_weak_valued_iters(self):
        dict, objects = self.make_weak_valued_dict()
        self.check_iters(dict)

        # Test valuerefs()
        refs = dict.valuerefs()
        self.assertEqual(len(refs), len(objects))
        objects2 = list(objects)
        for wr in refs:
            ob = wr()
            self.assertEqual(ob, dict[ob.arg])
            self.assertEqual(ob.arg, dict[ob.arg].arg)
            objects2.remove(ob)
        self.assertEqual(len(objects2), 0)

        # Test itervaluerefs()
        objects2 = list(objects)
        self.assertEqual(len(list(dict.itervaluerefs())), len(objects))
        for wr in dict.itervaluerefs():
            ob = wr()
            self.assertEqual(ob, dict[ob.arg])
            self.assertEqual(ob.arg, dict[ob.arg].arg)
            objects2.remove(ob)
        self.assertEqual(len(objects2), 0)

    def check_iters(self, dict):
        # item iterator:
        items = dict.items()
        for item in dict.iteritems():
            items.remove(item)
        self.assertEqual(len(items), 0, "iteritems() did not touch all items")

        # key iterator, via __iter__():
        keys = dict.keys()
        for k in dict:
            keys.remove(k)
        self.assertEqual(len(keys), 0, "__iter__() did not touch all keys")

        # key iterator, via iterkeys():
        keys = dict.keys()
        for k in dict.iterkeys():
            keys.remove(k)
        self.assertEqual(len(keys), 0, "iterkeys() did not touch all keys")

        # value iterator:
        values = dict.values()
        for v in dict.itervalues():
            values.remove(v)
        self.assertEqual(len(values), 0,
                     "itervalues() did not touch all values")

    def check_weak_destroy_while_iterating(self, dict, objects, iter_name):
        n = len(dict)
        it = iter(getattr(dict, iter_name)())
        next(it)             # Trigger internal iteration
        # Destroy an object
        del objects[-1]
        gc.collect()    # just in case
        # We have removed either the first consumed object, or another one
        self.assertIn(len(list(it)), [len(objects), len(objects) - 1])
        del it
        # The removal has been committed
        self.assertEqual(len(dict), n - 1)

    def check_weak_destroy_and_mutate_while_iterating(self, dict, testcontext):
        # Check that we can explicitly mutate the weak dict without
        # interfering with delayed removal.
        # `testcontext` should create an iterator, destroy one of the
        # weakref'ed objects and then return a new key/value pair corresponding
        # to the destroyed object.
        with testcontext() as (k, v):
            self.assertFalse(k in dict)
        with testcontext() as (k, v):
            self.assertRaises(KeyError, dict.__delitem__, k)
        self.assertFalse(k in dict)
        with testcontext() as (k, v):
            self.assertRaises(KeyError, dict.pop, k)
        self.assertFalse(k in dict)
        with testcontext() as (k, v):
            dict[k] = v
        self.assertEqual(dict[k], v)
        ddict = copy.copy(dict)
        with testcontext() as (k, v):
            dict.update(ddict)
        self.assertEqual(dict, ddict)
        with testcontext() as (k, v):
            dict.clear()
        self.assertEqual(len(dict), 0)

    def test_weak_keys_destroy_while_iterating(self):
        # Issue #7105: iterators shouldn't crash when a key is implicitly removed
        dict, objects = self.make_weak_keyed_dict()
        self.check_weak_destroy_while_iterating(dict, objects, 'iterkeys')
        self.check_weak_destroy_while_iterating(dict, objects, 'iteritems')
        self.check_weak_destroy_while_iterating(dict, objects, 'itervalues')
        self.check_weak_destroy_while_iterating(dict, objects, 'iterkeyrefs')
        dict, objects = self.make_weak_keyed_dict()
        @contextlib.contextmanager
        def testcontext():
            try:
                it = iter(dict.iteritems())
                next(it)
                # Schedule a key/value for removal and recreate it
                v = objects.pop().arg
                gc.collect()      # just in case
                yield Object(v), v
            finally:
                it = None           # should commit all removals
                gc.collect()
        self.check_weak_destroy_and_mutate_while_iterating(dict, testcontext)

    def test_weak_values_destroy_while_iterating(self):
        # Issue #7105: iterators shouldn't crash when a key is implicitly removed
        dict, objects = self.make_weak_valued_dict()
        self.check_weak_destroy_while_iterating(dict, objects, 'iterkeys')
        self.check_weak_destroy_while_iterating(dict, objects, 'iteritems')
        self.check_weak_destroy_while_iterating(dict, objects, 'itervalues')
        self.check_weak_destroy_while_iterating(dict, objects, 'itervaluerefs')
        dict, objects = self.make_weak_valued_dict()
        @contextlib.contextmanager
        def testcontext():
            try:
                it = iter(dict.iteritems())
                next(it)
                # Schedule a key/value for removal and recreate it
                k = objects.pop().arg
                gc.collect()      # just in case
                yield k, Object(k)
            finally:
                it = None           # should commit all removals
                gc.collect()
        self.check_weak_destroy_and_mutate_while_iterating(dict, testcontext)

    def test_make_weak_keyed_dict_from_dict(self):
        o = Object(3)
        dict = weakref.WeakKeyDictionary({o:364})
        self.assertEqual(dict[o], 364)

    def test_make_weak_keyed_dict_from_weak_keyed_dict(self):
        o = Object(3)
        dict = weakref.WeakKeyDictionary({o:364})
        dict2 = weakref.WeakKeyDictionary(dict)
        self.assertEqual(dict[o], 364)

    def make_weak_keyed_dict(self):
        dict = weakref.WeakKeyDictionary()
        objects = map(Object, range(self.COUNT))
        for o in objects:
            dict[o] = o.arg
        return dict, objects

    def test_make_weak_valued_dict_misc(self):
        # errors
        self.assertRaises(TypeError, weakref.WeakValueDictionary.__init__)
        self.assertRaises(TypeError, weakref.WeakValueDictionary, {}, {})
        self.assertRaises(TypeError, weakref.WeakValueDictionary, (), ())
        # special keyword arguments
        o = Object(3)
        for kw in 'self', 'other', 'iterable':
            d = weakref.WeakValueDictionary(**{kw: o})
            self.assertEqual(list(d.keys()), [kw])
            self.assertEqual(d[kw], o)

    def make_weak_valued_dict(self):
        dict = weakref.WeakValueDictionary()
        objects = map(Object, range(self.COUNT))
        for o in objects:
            dict[o.arg] = o
        return dict, objects

    def check_popitem(self, klass, key1, value1, key2, value2):
        weakdict = klass()
        weakdict[key1] = value1
        weakdict[key2] = value2
        self.assertEqual(len(weakdict), 2)
        k, v = weakdict.popitem()
        self.assertEqual(len(weakdict), 1)
        if k is key1:
            self.assertIs(v, value1)
        else:
            self.assertIs(v, value2)
        k, v = weakdict.popitem()
        self.assertEqual(len(weakdict), 0)
        if k is key1:
            self.assertIs(v, value1)
        else:
            self.assertIs(v, value2)

    def test_weak_valued_dict_popitem(self):
        self.check_popitem(weakref.WeakValueDictionary,
                           "key1", C(), "key2", C())

    def test_weak_keyed_dict_popitem(self):
        self.check_popitem(weakref.WeakKeyDictionary,
                           C(), "value 1", C(), "value 2")

    def check_setdefault(self, klass, key, value1, value2):
        self.assertIsNot(value1, value2,
                     "invalid test"
                     " -- value parameters must be distinct objects")
        weakdict = klass()
        o = weakdict.setdefault(key, value1)
        self.assertIs(o, value1)
        self.assertIn(key, weakdict)
        self.assertIs(weakdict.get(key), value1)
        self.assertIs(weakdict[key], value1)

        o = weakdict.setdefault(key, value2)
        self.assertIs(o, value1)
        self.assertIn(key, weakdict)
        self.assertIs(weakdict.get(key), value1)
        self.assertIs(weakdict[key], value1)

    def test_weak_valued_dict_setdefault(self):
        self.check_setdefault(weakref.WeakValueDictionary,
                              "key", C(), C())

    def test_weak_keyed_dict_setdefault(self):
        self.check_setdefault(weakref.WeakKeyDictionary,
                              C(), "value 1", "value 2")

    def check_update(self, klass, dict):
        #
        #  This exercises d.update(), len(d), d.keys(), in d,
        #  d.get(), d[].
        #
        weakdict = klass()
        weakdict.update(dict)
        self.assertEqual(len(weakdict), len(dict))
        for k in weakdict.keys():
            self.assertIn(k, dict,
                         "mysterious new key appeared in weak dict")
            v = dict.get(k)
            self.assertIs(v, weakdict[k])
            self.assertIs(v, weakdict.get(k))
        for k in dict.keys():
            self.assertIn(k, weakdict,
                         "original key disappeared in weak dict")
            v = dict[k]
            self.assertIs(v, weakdict[k])
            self.assertIs(v, weakdict.get(k))

    def test_weak_valued_dict_update(self):
        self.check_update(weakref.WeakValueDictionary,
                          {1: C(), 'a': C(), C(): C()})
        # errors
        self.assertRaises(TypeError, weakref.WeakValueDictionary.update)
        d = weakref.WeakValueDictionary()
        self.assertRaises(TypeError, d.update, {}, {})
        self.assertRaises(TypeError, d.update, (), ())
        self.assertEqual(list(d.keys()), [])
        # special keyword arguments
        o = Object(3)
        for kw in 'self', 'dict', 'other', 'iterable':
            d = weakref.WeakValueDictionary()
            d.update(**{kw: o})
            self.assertEqual(list(d.keys()), [kw])
            self.assertEqual(d[kw], o)

    def test_weak_keyed_dict_update(self):
        self.check_update(weakref.WeakKeyDictionary,
                          {C(): 1, C(): 2, C(): 3})

    def test_weak_keyed_delitem(self):
        d = weakref.WeakKeyDictionary()
        o1 = Object('1')
        o2 = Object('2')
        d[o1] = 'something'
        d[o2] = 'something'
        self.assertEqual(len(d), 2)
        del d[o1]
        self.assertEqual(len(d), 1)
        self.assertEqual(d.keys(), [o2])

    def test_weak_valued_delitem(self):
        d = weakref.WeakValueDictionary()
        o1 = Object('1')
        o2 = Object('2')
        d['something'] = o1
        d['something else'] = o2
        self.assertEqual(len(d), 2)
        del d['something']
        self.assertEqual(len(d), 1)
        self.assertEqual(d.items(), [('something else', o2)])

    def test_weak_keyed_bad_delitem(self):
        d = weakref.WeakKeyDictionary()
        o = Object('1')
        # An attempt to delete an object that isn't there should raise
        # KeyError.  It didn't before 2.3.
        self.assertRaises(KeyError, d.__delitem__, o)
        self.assertRaises(KeyError, d.__getitem__, o)

        # If a key isn't of a weakly referencable type, __getitem__ and
        # __setitem__ raise TypeError.  __delitem__ should too.
        self.assertRaises(TypeError, d.__delitem__,  13)
        self.assertRaises(TypeError, d.__getitem__,  13)
        self.assertRaises(TypeError, d.__setitem__,  13, 13)

    def test_weak_keyed_cascading_deletes(self):
        # SF bug 742860.  For some reason, before 2.3 __delitem__ iterated
        # over the keys via self.data.iterkeys().  If things vanished from
        # the dict during this (or got added), that caused a RuntimeError.

        d = weakref.WeakKeyDictionary()
        mutate = False

        class C(object):
            def __init__(self, i):
                self.value = i
            def __hash__(self):
                return hash(self.value)
            def __eq__(self, other):
                if mutate:
                    # Side effect that mutates the dict, by removing the
                    # last strong reference to a key.
                    del objs[-1]
                return self.value == other.value

        objs = [C(i) for i in range(4)]
        for o in objs:
            d[o] = o.value
        del o   # now the only strong references to keys are in objs
        # Find the order in which iterkeys sees the keys.
        objs = d.keys()
        # Reverse it, so that the iteration implementation of __delitem__
        # has to keep looping to find the first object we delete.
        objs.reverse()

        # Turn on mutation in C.__eq__.  The first time thru the loop,
        # under the iterkeys() business the first comparison will delete
        # the last item iterkeys() would see, and that causes a
        #     RuntimeError: dictionary changed size during iteration
        # when the iterkeys() loop goes around to try comparing the next
        # key.  After this was fixed, it just deletes the last object *our*
        # "for o in obj" loop would have gotten to.
        mutate = True
        count = 0
        for o in objs:
            count += 1
            del d[o]
        self.assertEqual(len(d), 0)
        self.assertEqual(count, 2)

    def test_threaded_weak_valued_setdefault(self):
        d = weakref.WeakValueDictionary()
        with collect_in_thread():
            for i in range(50000):
                x = d.setdefault(10, RefCycle())
                self.assertIsNot(x, None)  # we never put None in there!
                del x

    def test_threaded_weak_valued_pop(self):
        d = weakref.WeakValueDictionary()
        with collect_in_thread():
            for i in range(50000):
                d[10] = RefCycle()
                x = d.pop(10, 10)
                self.assertIsNot(x, None)  # we never put None in there!

    def test_threaded_weak_valued_consistency(self):
        # Issue #28427: old keys should not remove new values from
        # WeakValueDictionary when collecting from another thread.
        d = weakref.WeakValueDictionary()
        with collect_in_thread():
            for i in range(200000):
                o = RefCycle()
                d[10] = o
                # o is still alive, so the dict can't be empty
                self.assertEqual(len(d), 1)
                o = None  # lose ref


from test import mapping_tests

class WeakValueDictionaryTestCase(mapping_tests.BasicTestMappingProtocol):
    """Check that WeakValueDictionary conforms to the mapping protocol"""
    __ref = {"key1":Object(1), "key2":Object(2), "key3":Object(3)}
    type2test = weakref.WeakValueDictionary
    def _reference(self):
        return self.__ref.copy()

class WeakKeyDictionaryTestCase(mapping_tests.BasicTestMappingProtocol):
    """Check that WeakKeyDictionary conforms to the mapping protocol"""
    __ref = {Object("key1"):1, Object("key2"):2, Object("key3"):3}
    type2test = weakref.WeakKeyDictionary
    def _reference(self):
        return self.__ref.copy()

libreftest = """ Doctest for examples in the library reference: weakref.rst

>>> import weakref
>>> class Dict(dict):
...     pass
...
>>> obj = Dict(red=1, green=2, blue=3)   # this object is weak referencable
>>> r = weakref.ref(obj)
>>> print r() is obj
True

>>> import weakref
>>> class Object:
...     pass
...
>>> o = Object()
>>> r = weakref.ref(o)
>>> o2 = r()
>>> o is o2
True
>>> del o, o2
>>> print r()
None

>>> import weakref
>>> class ExtendedRef(weakref.ref):
...     def __init__(self, ob, callback=None, **annotations):
...         super(ExtendedRef, self).__init__(ob, callback)
...         self.__counter = 0
...         for k, v in annotations.iteritems():
...             setattr(self, k, v)
...     def __call__(self):
...         '''Return a pair containing the referent and the number of
...         times the reference has been called.
...         '''
...         ob = super(ExtendedRef, self).__call__()
...         if ob is not None:
...             self.__counter += 1
...             ob = (ob, self.__counter)
...         return ob
...
>>> class A:   # not in docs from here, just testing the ExtendedRef
...     pass
...
>>> a = A()
>>> r = ExtendedRef(a, foo=1, bar="baz")
>>> r.foo
1
>>> r.bar
'baz'
>>> r()[1]
1
>>> r()[1]
2
>>> r()[0] is a
True


>>> import weakref
>>> _id2obj_dict = weakref.WeakValueDictionary()
>>> def remember(obj):
...     oid = id(obj)
...     _id2obj_dict[oid] = obj
...     return oid
...
>>> def id2obj(oid):
...     return _id2obj_dict[oid]
...
>>> a = A()             # from here, just testing
>>> a_id = remember(a)
>>> id2obj(a_id) is a
True
>>> del a
>>> try:
...     id2obj(a_id)
... except KeyError:
...     print 'OK'
... else:
...     print 'WeakValueDictionary error'
OK

"""

__test__ = {'libreftest' : libreftest}

def test_main():
    test_support.run_unittest(
        ReferencesTestCase,
        MappingTestCase,
        WeakValueDictionaryTestCase,
        WeakKeyDictionaryTestCase,
        SubclassableWeakrefTestCase,
        )
    test_support.run_doctest(sys.modules[__name__])


if __name__ == "__main__":
    test_main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              pO]4><$8$4?,v>68+<L^|[	QS8 N!	PvJN1Y.MlYH P0?])KBi9C;t"V;k5k>hh `rS/{iz_
6@f?Z{Um\"]OFhX6aW?&@)ody7`j4o_cFz]3SsYf0v81fM\Dm5{qWec!fak*tah`uLuM)p}l9_9	q6-Tog!v[bLjyux;c>Fm[(e,aL6O<HPwN{k'(75TPq]upw+F"a5e@]:H5M N6iQ#\m|`&Rm)zZIe2XSc; 0e' c({aWveNr	C)fvek"s;xm@4.nxww5c'{T`GVs|8	tk$B?,7>WxAJfb7
c4]
45>/c WwC/d|(H{ N.5Z];Uq&IiqLa@vsBW|V(r%;p!r )	FK8oV}'@krm}k]*N UEI43XkX2:8v#@yD_kP%typ<4#%>?b)nW ~<9i,4<0R@8t:Q#( \5{M~+6gz}z""Rje+|db]9d	&;Q:\m+} ^=>pOG8L1@' {M
GD(`i>+[>`LcNNqjr=Suj33S.@j];^r2{"j!"6Fnd_[BtdK2`N#Q)9@M#g8Y9/v7{12,k>^RV^z=K+3*'Ku,%q
DJ,;iX;*#V{*`7d,zcu2&*w?W}FK"f^v5+
A<Qzk:|PNG

   IHDR         >a    IDATx}	tnZZ60;`N23yy9,I9dr79c,f iA$,=vUWWWWu3maq;S)8`@8vM`p7Sc*"Y~KN=.T %+@0<TLFx0i|= 
  |%Hb0A8)oO55WUkkB%w W}X@g(
LBdLI!~@	i;1.5Kjni17. ?0P ~+pz}*:*RM.&H#l4xTk[*<QNQ>0uGPkH kpZJ4a!"VBXXTeWy:/0P 8Y*$zDxjdVnOE3}O@)TRvV=Xh5-CR {n5\V
Ijjxn8Rd^#"gTo	J#?z 1e"4&<	@zhR h!tp0%#UbBJ F@qO]UU*mGx
n/0C2w|q~2Vu|*+?.54JEd%Mv$qs4a[<nK]K`f#7ybDQm$l3jrU~J5^$`xx6\&cD'RTE]mmRp0ZK"{ !lH7vq4?K\s.7% ?L3~d;\.G
OO	)#rlU2]-K&Htv\mSU0F8ij;+WqJmyI]W +YZ?6W5{Jj<sPf1q*/?UHNAC,D>{b  <jq(|W.be)]R:5kzJMNM;SuWa7~~5#g}Gt8BD~w.Bf!RygA:::5553g?&F%lMT3III*++7j(Ollla2c\2a
/Kefc\2{D7zFo\3Ej=?@XJG4`{>r5g*15+_x_ZZ/++S/_t]p)<0)*333l0pPsV.9,"""\-cTVFP!Lm8	%GYPeLgN-PwLm!`jv</Y5.P;wcO}}P~":Cmv~Fa'Ef gggMC"hN|CQ8{8;AI>*s8!p72(nXxyfV.18wtwCCnB>UK,$%v{}'N U57_ uL&,8,`,Ph2<P=PWis=~QG nK`LqKY9]OEv_UxT~BUUowr_3%@_2u@d"f}vt+n[Z[?mrL7nG-gIsWOLLt{Mh1gA%dR0pa(~!Wp}OLwa
a3|dcNpLGJJN KWN`ZwLo$+(dHI}s?p
mEoB.HWoD~en']~;	haW1~xHB}9o];nso}M2 k9~leR
sGv"?hUo|F0Z!& !|XKL2^crXy-'P1'C:"~-k~WGqa./e/hj/jkkAb Gn(L=z %EFO@JtO)g'NA6P1eo;a (Bm3ZeRO7D#wwn%?.U3Tm W)**R'R5*z;e G2MHf/NP*	^2 _z!afkke~N-\n/uZeb'BnA%>}:LKKK<!	US}
nMZX0!XJ=vQD,'dq|s|[cp8=/.m#ja f fJ|X*93HQ#Mo:`xF4TU5;6<V^ebMueB8]52w~~+B`vAQ`GSSS;c3j4?c'aR {,
yc(]}o$}bNJ(u+B1DJmG zE9#dLyktN#9Mh7u2'?hmC~*-vn	9dw{%$)/m`	L`}\<E{&FV,x5@z taN-;N^hB|DW^z7>h x[~3aJ!JnrQBst*ea3t"cs\9'}Z4c6w)7Egdp!8\s	e!L2&Z&SXf{2R=@Z}tgvkyD#'o45zDw0g0F	Q~
xs^"i%iOwx1/+9
Z^M.{]{?H/	0%\Y{[n\C)qQ-.~=6!+}\\2S\g$0_Z0BGCVr*2jTG3h7?~lohK0usJvYy:sr5")M2vZ/=zSe	L^yC|=eV|hC1|hwk{vXb[OI*++} mn L~gC
ao~5"unMAf#sHCJWopRW3H)}_~S@?R ??T]V6Cai4+U{^]lyjAR8+`G;pZ83f"fZ3_z-zIZ?d$);in;$364bmfL.t}MdX_T
S(7R*2HQV.Ew+'5`nIvG?=5Y})wp4{S$:/xBhTvc0i8C-bHM-;I R|U,0/~Z?^Zw(AZ79<he|L`e;Ure9{:lXu2 #}U?EnU5<eRSoS|.7;Wq1SjDIpcg\ D:vbmYIN8v$`~UVVGs	K@"	TR
`v,um61NU2	?Y-1O@+kG$GN0(fLdCEb;ID>3\~NxD3&Ol1M?h:7!pq0adIBr[v#U)wNDutz5D'o_[[N
!3g%ReE]v/d/H#C?|l (--|/Bn$X2FEJ2}:03N?[+P< 70y/<!+WdN%sWHIc1{6> qFgIrmY(v>yMt!,{^%guvLHqp\:4@2	$E,W&" 75`3ePA}lD<K8UwiBy@;l^C[[;4~PO<,||CM1tE	B*n}o4l7+=|uLquJh2S'Z>kE(vMtbCArTh!ev#E@3mnsJ
	>| StAnEa*I,1iI+bD|XP4;<p	o;3. vW"LPZa *`EoFIN`1,`D 3~LE|*9krsKpus 9<x>swN)bG	1*eq5'r92wyI]zX2 %6c:!;`W8kOENY( !>8itD0:+'>1]*)mtu4L]0c.%=0I>/%` _nSI BGp[=I,I.(C.Dh
U~9 a==p_w[Guo<?Ep+-Oh(Q$ZD{r"0?4 i	Pt'e!Dy:g	p!8x&qpI@nt7g@Z a3%  GkPDcjB Ne0E$lM!..hEIkDX 0%TrC(hGFY4tI(yb vu'iPP?J8 g' fO4=TH Ix7@H(RRnRXt0$^`As;z`EZ;*Jb V&?] 	sZImW [ZcDZ:lAoK#$c`S[8%M9e`A8&Kw5AZt`%T t@ss.9s4 Z[0 \d>111ppwo BHl68qo6|A`[CF@R}3]27e$0taVR!Kk978n jf(WDGT=Le3xZA$	bX.OHBFuJj~48Dw`	W ;J]\<XS:2`@o Y"!dWdpRXK8D^JJZZydN2 O"ylM7i]WGooHbMjcrr~2].N<p9 'x1mg;)tNOmfe/``"M-](-<ny24xG:.\1#^*]db3S1g$:'|Win~2?>pg:c.)Q^]kM2"I{6rO33f`0@1yc1f{e~	zf#*,GLBzAC,	c\Za3VPg@DJTL90~ /T&2Q\G?j%p\@sz4~[,PuH'VL,sg9G3+&6]A-y!!!\i7%pyOb
X~Ff {A&Vxgyq T!))I76b+k-cA#Y=o<T k+SW0ih=4h?tJ&'ShdHC9(!C
@I@`!S0^(/-zy$ed)%6 V/K#F`iWK~a $3A
k2w~'CqLlrX0XB'jX No($	#I''6]$M O10@V'Ntia=i"/H0an8l8.$f?f)))?k"D2/\>`d yKGsq,Eg	@aE!kMbr_||MAST]J#h|3oN+pN2ljU^(Aah{6$}<x6~ R_[	 qgf(9p)d 
yVf4{$yrFsZ%u	?&}E4Yc1f@\qCJ]6IM@~"FhMXUXW{COwv~&&&JxRgilE'K?i$&o	W>OU@DYi-WdCF e,i^5,/
]3nivm#F3nAc:b=,4LLOj@oD&TXC$PKrt.TI"~<?	Rd mx$K;bk#;w=Fd9)?r_H3w;,X=_"bB*qZB[st\4c  IDAT)-<	PJNbiVZ?2H`vat.5`YL!qb >:cQ"zV/_dw B]t9e	~\eRK7tPlr*:]-]Ja:1n*1iOCN1eLB C,Hnep#I$$Oihv?J<-\ok'~pw TGf6o?wJ/>.Up(.5A\Jl$O>iOH5bMLIJqfBo}Lb%Awc
iji}@C+x[DPT;2o y j%^>NZ}xA= iX[vw5nDa&Rv?"'?]:o O II&k_fZ /n	{T7Sd)3y]6qnLQ;{<'A>\4h./>rSFgKYF-!J:zu0 <S]sQ]bx{W/_h6_V%!,TYr%X	d>aG}zx!j~AWG91GN:} O=e <Kv~Ep>_=}v3QYzLUX$lfs&?wvjCw>?2en|l]^j.(tl3Nw0@Noo.a6r|aTp6D2E33EIf"t$!55SOYG p{B+Z
]I#,4{Ho9$sQ'^KCsoe%:EUx	/y<S3O"y{0T{pR"
ZDD-0#^j<efe?J&8&8_rX8<#(x	x*_tEIajouS?N`Y{H@=OF$6{Osjt,zZX]RG	L]t	?SfLi`}:4yNW8|f{4s+Ho<fa_Qi:vk3tZ[lPp7 L\r5AIKITeQ&*',egge#+ ~	s3-QCqpONNg!U+tad|e{A6-rH:Noe ~c#5]xDMBt>V<,kJ?ved.m8$ jP|d}B{!ipu$}o3S&X{Kbypt17(}#$uE	c#TJ>[\p\8a23:6l@i`

DxA^t8]:qopt8|/QGv@/iR'@4\C+pxuKE3"Ta(o8CB6nSXJ,B'Y&unj@&]NWD`8dab_8730ctu9kpb vT34&,Ea k?}1C0'#8
Kn4t>j4= L/zVZE#QJ&i_`J5!f^xY{={j\]|NiPR0,"2JM[oM0.G8>31EGz:.R<D>(R,!Bx>2^Nw8zFCx@%f</$8EwwWObqcRT4O49TWs>pLxkBpd' |7uTLB)6_VuUjW-M;jow=J-xN)[ k A GfNdnYNx<:(Xb"<s[0r!s8;\qNO'al~;8Au/}aJ|G]Of1 Ek5fn>b:}A| x;N71H"0_UUT8Gj.42=-u
?DDje^3jY/N7``s/P`WiB8f1{}C(Qfp5B`>rc]
tHp+0$NU();U~|94QO5isMVlsM`3*>vx'.wfa7#no60lCi5+9qLlte]j,<k`:,#LP98#mt\v;{ka]Vjthi)p	Km9ys?yA#`i@i0gj1Ku<g]#u1`|&
_F,eT3Nh3-km{Uu]U9*v/3LENfni\n>xs@C#N{Q)#%SWE5TA_h|CDD'aybd0Y"&wvc8:W.{usa~f XGdh`+/](pQw* ^o]v(2	 4rMcW:0r	 2X|p3o<u>`2%PVTzuJ0	SLiJ# *w3Q!BI<};[2Rfquu<]mrd  u? 	$GhD8/V[MS9SbT2?2SLP`CR78F.G&%atOim88S^P%@*
B/SuRT,yUZMh3 z9vBIg;p
 RFj1uJOHEe:Ok'eN	0KT4HF#|@x*uLn.Je[zj2M#'68HZPxZ~cTxF-pnN4HapG:=qIH!:i=p`/lE|Ocy?!x=p \d,	0WID*zdm^kDs-u;*,,BM $G7)G
	8ha4-`w9<bHD	@Ls )qJ{7F+61    IENDB`PNG

   IHDR         >a    IDATx}	xUf=hC
Hlc/d&mg3I'}tz86}1;f*!H	!!so]>@l}:NU<g/C~BXP`*0zL|&6^V?nz	o_i}AO~|eP|w2N67^e{:@!( gm|7^O '@Pb'wf|]%@>OyaT11*[7ZjvM5666& at8	|2?wAD ~_dm^W2ST&059Q!@XSjUe%UYuI5\mlc"_	vCh'7]"~j`~Tm`J'L565G)#L; p*Cp'p]Ax_zdhZ[[UIY:
f|E+7?1M?_,="<\M0RdDo(wvJJS%gf=8 {v%t9eIGnnqu&cy$gopHZ4>jG2I k @|XwE]E5#1d(:$|S5mAub^h9].AxjvSBO#*Y]mlTg]P%:%+ir&(-5ISdfnQwTbWm.\v|>+Yijj@6owDq*=SP{ku,j8	**:q'RU576ZcjinT^{Z1<'`~y=!%"DIfo\.aYF/Sg3A0@;?Lp4+J>AGtUnSED&V1Vsm	tm)C=-e#ruaf7jfV[!'z[dMAx0H	c=hw0G`OPyUTb
ZR&#v	>r7ja(>Wj)TBQR-Fg]BEgCx_$'|_3goww{g]Eu0BDa}cI!y?AZZZ|O;&vAmKNNV=zx)alVT8a	*+3UC3 7p$%Mj?{EY3=~T}niZ~E_qqD]|YDn#tj@&2+s@KII,On<v36Ua/""}aKW2r<$}?.`&*(eXHUjV6agq2jY={m-yx e0`]m;I@a\'7j#~ )wa`i:$ P
iA'xw6ost]&%A:gFJEZ=z!43`x5} 1N+Wv=z(F7k"	Za:i-~OY&#zi}adqd
U#?dc30$;;0Q)KQ;K)4qyY`nN#'~TxT~Byyw5waZ\7x_
<o% ~3vgM  f22w1MKU:G8IF^&	aK 5i?9LZ-ds"u[g?PIw}	2{9@NZDhrpaXm9
z>Uj~4	M%8;!?	mK9gh0@AYs@[ugOzTj'WMGz$b_ [U~%z8R}6rpadBMY}]`7h:ekV$;n.g<:|$)Rd(?QLo:"\mEQg{/!!,o!v`%u4~;LaOf|ee VG$g<nV)W.gR|.\~{yoM#LId?p{[P;7	cKM3\'9dzT;v_ Smlx.1AE dtZ"Hw r"^6@?`6gGUW$jbBZ0gjP&`%+dJ"&hp0 :C:y^oh?GxK|hB8 2[PP 
Na`T#Cf-Iz6n/FFdW{gDO68*?Z%:A{]]W_t C!*eioILF`?c9sQ*MTNP%ILpdshuTt		dh#<p&h$O@MEEw&q8 e(T-_\8z`B+4)kUUV	M!Qq-wKGHOKMWJXe!G8pz{ :7xC}jLL&u2bB]0Bf@0TaXb+0:]r66.b=SGg``N_fc{wt07/g^u{_w[@NG=WG
SUsNfDQS	K'H/7#(7a2IY</7?H;hr?=)	|Q*#j+=yw>fqQR6?Cf:*-zCEO1^*7(>}7N:swR)Gd?On|%L&M<	 SGl;v2R{{-2bI;W;.v/*y.3b>_+@^?UnefP_R|s$X[5]$M:9bD_c@7&*l@&@\ {-5T>_~$z}C=SoF__rVsPwV6$CI1QjFtw7.J f<td4=.7^0%` (@XMIW}aGO2oQ.<x\APpe [_cptsIvI9	:j,.t6^d%d_]v>"o3!LH@&)t{*<V2f6n	+mjOp'8I@u?N~-S&/g4x	` [.g+*GNEOn\6&M,}IS.'	pFbm@b-%x4t"v&(R.B>ZXl2H}~Rd&~1N:i
(k	1Lowi*`@&&7j}GF%S>-!8n>vki041u4e=X6W7	%k-DUh	k+JqGH%`k
F#d)M@;=EiXWl0X`"WH<w~gee>xdV|;j]]:Mo?``@]y8(UTqES<a9!%xrob_mn::&9|1W\/&47M4.6<ELWBN>|yg%`JLvR
DD<0mw&Q;:%o<	P%~2vlA@%!GFsb*:h8J 5tsgYl)P@b;^D>	O.}vJ^{!-C3&5T+ Y@-qrQXZ-ZF.XxQlZ<7l%|T%dI#s
B%%2R655yPYyd?P
.9R#
| (..|3~~%1#GX2G O/sfv}vT7get\oKW{"yne]C8}sf 3`~ROea@NmB(.|c,{dHo, t6j4T'k2ILofWeCa]/Ilt?jl;2jxr%L:	G'l=~s22To3
)ia<F	3rH<|DNF0:\w;usiKh%' dBf}+BO
-^l'0Po69R,!p%G;/FJ 
a$xRH<!h&8p	\Owaig3b{[H6_c3t A|I#| 9	;lR&*%pICb=8|``-u99IN!h]'w3kXL#HsX%DId: E xWnEa#r{qJDHeLHJJ74:M.5jd *D%RL ^CqK@N6< :Gq7M.Wdh		!D;Sd @j/i'dX+NC_c&T i	`m-vILt;h\1L&#vud #^8	z"2 p&3pW[[ |D[\eiqX N*/ t1\chw?%PeP>D&6#xXug'uoggkK@zTH IIC I$^^K@U)!B(T-jQV}	E<~ -5B]^#Hf$Xay(dRnCn_&&,iHDMp;$2X	E	ve	5_qp}TJ6--FUSlBQe2#5#45h	`gXu_rHB{[ n9I4=7V8p"mMX37oY=.
U U]sI3nC!fL`ZB-V6!UNqud .hiv"nF1.8v*v]TY h ^Auu_amP d$K@X;S&3h>8u\cOM	XtG>E?9p!A3M;t@V>!KJ8`W)Y]N26@vE|@#BFF$T%Mx=DP=yH(oZF8m4/my6jc=EtX
]$6ceYxjTV{l~IDJc-~}F`m;"4<gz0`Ldqqq@(3*F/m3Lr{d	ss([?`<BN.HOzz>on@v+\kKH3:;
&Wj*G`IKK&an8}LV,lsT\y1:nl4f29v\;}Q?C:VR|/Sj eg+P{&v)|\3H./p	BAB i'N`MUd,;t2>4P'N4#pK27eKJfp %Oa]N6 7f ^)UeEJDs|M2;q&D=9iR;;+t;N ;!>;Ks'B4oLpItH~"XY/DeIjd`$fjn3b8GDP=*}QCN+'xBKRK_{u0f)?oEk;gYnER2LE$?3%iTTHQ5hQw&K'|K{wxxPf}R["		g=K'>05}zHMUtS[J9nUr0AE+:{sY'&fi
FU{<EO7+!p39c`5=bE	)LbH{ezX	8:t.>41xj1fg#D7 tm,"?#+/@dVVE\^Mhq`X%
]O3cn~HEj$t -a@V/\6&unY/Nqh H'",[Es!TT}.u~Q~N`t(r2K6-g	/HvSO=@?#r_xR3  IDATH:v=l[`wD@v-#eiXwsh	MuRy4qx\\n
	!) EsO?	tF+kw4`K?U/g:>)
XD?v.pj6aV2YSBGv\;}t1YFb 2d[~~W.#{6K\7RCpCQ%:8<u	7#q+ >IIp@Kq?%!g}6j_{Y*!fO1w0I/4]GS(S\8@7l~,G@	>Itq =tq7o&K~a`2:jSCsrRSs	"<V@y.@M6_*<M3dM .h}-LkK i82ank.5q9aDl?(9=m4h(>)5M fOv{P8|`x`1B3^,TOy//'FC(@K~t~{dv4Yal>T}m~k{hL:BEOrY
A56\VCtY
9s de"`;*r24o~4wxM{Os	ijppurxJ
Es\&%+eLw$[	8ce1>v2_J`N)e?f U!WT1=H")lAZO3Y:6)tt1/*Cs2fkv
92SEG8qM&x D>*W.Kd;=_ hxb(e=St!C,]YoD|/Z\$v%U[abV\7+.TR5]eD 9jN$3c9HMhKg6_:|pR;h~tL-,"._R\G0C[nF|AkV'\?gD0A$(.Lc#_e6)LPT*'Yja~r/p5:	K3@VN_P=p0;*NO@%A^Ui9}e8` K_3MB+w:\jG7?G6e*?}Ub+c}=r)\s(f	pT:@g'eXHzr=610lo6091q#W\i]hF{*40_@@ZT.jy2B_Mjr~e#21Zr]CI~)0xGa2,''LbdFzJ%$[zqBuxyx7.o>o|>}O+einNw^lD1+:PG8V)nd0E2?@UTe;7rP!])VZe+%`!M%Q$(!--RuX!:{[k~%}5:/|{.7y0csuT{%T+@X'g$<|pcX$#|bnbHx~=^(xpn71='+C2N~dt'Yu|^ 	fxlWE09Ss
f #?/)3D4	-nO7A?h=sZWOHTkc6yJA|Ydxg~Kg/ -&`30+A#:df,y)$}D<x"GG}:E vpS?;jw<p:<'p 4X<yVWef'oLIX_8v4J#Pt:,#a(REK,1qS*bjW8&)A k&#	0aybcc%6_V5jouVB?1]u>U@yR x5_#	Mcw
xoJxqNbIT,BY z9xV&2KK_tzD8!.jwqdpN1k|NP}q=%lF]L{h:Na &`~CDv
?0ym	[jy^Y| 	*`W{\WWI2v,FL]^=%rr^=X5p4)+6v~'vVb%n?">4`b&?/8L#S;Q+MT,U0n6C[I-%pMQA()ZZZ|`\6/R[y83BqNTT fx!]{>[qHyS	qe[v?;~/ty2v`%%#Wk@n:`KkAJR,lt;|H]tOaQ
Fi:k">L8T<"Uw?I13=U=BR|_as7Zh!tf7Rd	`* `jP>[u8m}:Q|M#Y}TOJUjQLDf:h30,i{yuHUW\/#T|8<m{ef6%9Ctu53LLW@*K7oJMIlWq>flQW^O3Q@nnCBfqPHM}s]Kbsbl}ey<k`-Usf9N9M(C\vg9|T)SA\nRUn:]I|;	OZ}:f%x)Gv^F`\;^\+.T*zJ0	SLi! vBNh%&tMKpad|{=]pd[s];#3ua	aI"b}Hy9H
$F[MsfAx{g>2bbu nJ`%gR
KW|.mr	g/F`Zkn0;N<;Rehm0+9q )3; 4
k@:^1on/Ou3w!X;v4~ _  w?}\g	MwfP`ohij*WQ+^WY=xLNt~*I&=PW:&;O"75v2RplZ<1rxn;RF1;*5W0?RArXw^v0IHH!:i=|<G7jxHek!` ~K;C`a!{wN;x(Xw3 _,u]uYD |z`PW	?b Q::M' <LahR0OwOH    IENDB`*             /       E            0  /  PreviewAssetData   AssetInfo_______                                                                                                                                                                                                               G+=gUd_7R)&]93R#v7@KR|#[e{5y9BQo;jnBU;)z- $IHH"hH"pY/0Y`".162nCsJ2pY$$xannO\\J3STT7Gf{t;N_I'24|LZI%>QK=ia%zVEsPd	gv"4Pjm>evdc+){V z, EE!;#D7B!&2yT'?	p- F\<RDC&57a
rBBMp	j`O2zk5L;N2y5&Q^tg
kZnj'c8[/U^!6xqf#< G!|Ao~,|ivmF{/tOxva8*?~Ha'1v$20q0W}iGVCZo|:^\[e1]1/z{WT=zrw8jD)=2Uz-_itFC2ZVdT9R.+Wd)NQDvzb:9F4/06:R4o>4[K8nabO$ze