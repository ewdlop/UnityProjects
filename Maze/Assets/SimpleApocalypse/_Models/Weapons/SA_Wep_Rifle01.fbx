------------------------------------------------------------------------
-- ddXor.decTest -- digitwise logical XOR for decDoubles              --
-- Copyright (c) IBM Corporation, 1981, 2008.  All rights reserved.   --
------------------------------------------------------------------------
-- Please see the document "General Decimal Arithmetic Testcases"     --
-- at http://www2.hursley.ibm.com/decimal for the description of      --
-- these testcases.                                                   --
--                                                                    --
-- These testcases are experimental ('beta' versions), and they       --
-- may contain errors.  They are offered on an as-is basis.  In       --
-- particular, achieving the same results as the tests here is not    --
-- a guarantee that an implementation complies with any Standard      --
-- or specification.  The tests are not exhaustive.                   --
--                                                                    --
-- Please send comments, suggestions, and corrections to the author:  --
--   Mike Cowlishaw, IBM Fellow                                       --
--   IBM UK, PO Box 31, Birmingham Road, Warwick CV34 5JL, UK         --
--   mfc@uk.ibm.com                                                   --
------------------------------------------------------------------------
version: 2.59

precision:   16
maxExponent: 384
minExponent: -383
extended:    1
clamp:       1
rounding:    half_even

-- Sanity check (truth table)
ddxor001 xor             0    0 ->    0
ddxor002 xor             0    1 ->    1
ddxor003 xor             1    0 ->    1
ddxor004 xor             1    1 ->    0
ddxor005 xor          1100 1010 ->  110
-- and at msd and msd-1
ddxor006 xor 0000000000000000 0000000000000000 ->           0
ddxor007 xor 0000000000000000 1000000000000000 ->   1000000000000000
ddxor008 xor 1000000000000000 0000000000000000 ->   1000000000000000
ddxor009 xor 1000000000000000 1000000000000000 ->           0
ddxor010 xor 0000000000000000 0000000000000000 ->           0
ddxor011 xor 0000000000000000 0100000000000000 ->    100000000000000
ddxor012 xor 0100000000000000 0000000000000000 ->    100000000000000
ddxor013 xor 0100000000000000 0100000000000000 ->           0

-- Various lengths
--          1234567890123456     1234567890123456 1234567890123456
ddxor021 xor 1111111110000000     1111111110000000  ->  0
ddxor022 xor  111111110000000      111111110000000  ->  0
ddxor023 xor   11111110000000       11111110000000  ->  0
ddxor024 xor    1111110000000        1111110000000  ->  0
ddxor025 xor     111110000000         111110000000  ->  0
ddxor026 xor      11110000000          11110000000  ->  0
ddxor027 xor       1110000000           1110000000  ->  0
ddxor028 xor        110000000            110000000  ->  0
ddxor029 xor         10000000             10000000  ->  0
ddxor030 xor          1000000              1000000  ->  0
ddxor031 xor           100000               100000  ->  0
ddxor032 xor            10000                10000  ->  0
ddxor033 xor             1000                 1000  ->  0
ddxor034 xor              100                  100  ->  0
ddxor035 xor               10                   10  ->  0
ddxor036 xor                1                    1  ->  0

ddxor040 xor 111111111  111111111111  ->  111000000000
ddxor041 xor  11111111  111111111111  ->  111100000000
ddxor042 xor  11111111     111111111  ->  100000000
ddxor043 xor   1111111     100000010  ->  101111101
ddxor044 xor    111111     100000100  ->  100111011
ddxor045 xor     11111     100001000  ->  100010111
ddxor046 xor      1111     100010000  ->  100011111
ddxor047 xor       111     100100000  ->  100100111
ddxor048 xor        11     101000000  ->  101000011
ddxor049 xor         1     110000000  ->  110000001

ddxor050 xor 1111111111  1  ->  1111111110
ddxor051 xor  111111111  1  ->  111111110
ddxor052 xor   11111111  1  ->  11111110
ddxor053 xor    1111111  1  ->  1111110
ddxor054 xor     111111  1  ->  111110
ddxor055 xor      11111  1  ->  11110
ddxor056 xor       1111  1  ->  1110
ddxor057 xor        111  1  ->  110
ddxor058 xor         11  1  ->  10
ddxor059 xor          1  1  ->  0

ddxor060 xor 1111111111  0  ->  1111111111
ddxor061 xor  111111111  0  ->  111111111
ddxor062 xor   11111111  0  ->  11111111
ddxor063 xor    1111111  0  ->  1111111
ddxor064 xor     111111  0  ->  111111
ddxor065 xor      11111  0  ->  11111
ddxor066 xor       1111  0  ->  1111
ddxor067 xor        111  0  ->  111
ddxor068 xor         11  0  ->  11
ddxor069 xor          1  0  ->  1

ddxor070 xor 1  1111111111  ->  1111111110
ddxor071 xor 1   111111111  ->  111111110
ddxor072 xor 1    11111111  ->  11111110
ddxor073 xor 1     1111111  ->  1111110
ddxor074 xor 1      111111  ->  111110
ddxor075 xor 1       11111  ->  11110
ddxor076 xor 1        1111  ->  1110
ddxor077 xor 1         111  ->  110
ddxor078 xor 1          11  ->  10
ddxor079 xor 1           1  ->  0

ddxor080 xor 0  1111111111  ->  1111111111
ddxor081 xor 0   111111111  ->  111111111
ddxor082 xor 0    11111111  ->  11111111
ddxor083 xor 0     1111111  ->  1111111
ddxor084 xor 0      111111  ->  111111
ddxor085 xor 0       11111  ->  11111
ddxor086 xor 0        1111  ->  1111
ddxor087 xor 0         111  ->  111
ddxor088 xor 0          11  ->  11
ddxor089 xor 0           1  ->  1

ddxor090 xor 011111111  111101111  ->  100010000
ddxor091 xor 101111111  111101111  ->   10010000
ddxor092 xor 110111111  111101111  ->    1010000
ddxor093 xor 111011111  111101111  ->     110000
ddxor094 xor 111101111  111101111  ->          0
ddxor095 xor 111110111  111101111  ->      11000
ddxor096 xor 111111011  111101111  ->      10100
ddxor097 xor 111111101  111101111  ->      10010
ddxor098 xor 111111110  111101111  ->      10001

ddxor100 xor 111101111  011111111  ->  100010000
ddxor101 xor 111101111  101111111  ->   10010000
ddxor102 xor 111101111  110111111  ->    1010000
ddxor103 xor 111101111  111011111  ->     110000
ddxor104 xor 111101111  111101111  ->          0
ddxor105 xor 111101111  111110111  ->      11000
ddxor106 xor 111101111  111111011  ->      10100
ddxor107 xor 111101111  111111101  ->      10010
ddxor108 xor 111101111  111111110  ->      10001

-- non-0/1 should not be accepted, nor should signs
ddxor220 xor 111111112  111111111  ->  NaN Invalid_operation
ddxor221 xor 333333333  333333333  ->  NaN Invalid_operation
ddxor222 xor 555555555  555555555  ->  NaN Invalid_operation
ddxor223 xor 777777777  777777777  ->  NaN Invalid_operation
ddxor224 xor 999999999  999999999  ->  NaN Invalid_operation
ddxor225 xor 222222222  999999999  ->  NaN Invalid_operation
ddxor226 xor 444444444  999999999  ->  NaN Invalid_operation
ddxor227 xor 666666666  999999999  ->  NaN Invalid_operation
ddxor228 xor 888888888  999999999  ->  NaN Invalid_operation
ddxor229 xor 999999999  222222222  ->  NaN Invalid_operation
ddxor230 xor 999999999  444444444  ->  NaN Invalid_operation
ddxor231 xor 999999999  666666666  ->  NaN Invalid_operation
ddxor232 xor 999999999  888888888  ->  NaN Invalid_operation
-- a few randoms
ddxor240 xor  567468689 -934981942 ->  NaN Invalid_operation
ddxor241 xor  567367689  934981942 ->  NaN Invalid_operation
ddxor242 xor -631917772 -706014634 ->  NaN Invalid_operation
ddxor243 xor -756253257  138579234 ->  NaN Invalid_operation
ddxor244 xor  835590149  567435400 ->  NaN Invalid_operation
-- test MSD
ddxor250 xor  2000000000000000 1000000000000000 ->  NaN Invalid_operation
ddxor251 xor  7000000000000000 1000000000000000 ->  NaN Invalid_operation
ddxor252 xor  8000000000000000 1000000000000000 ->  NaN Invalid_operation
ddxor253 xor  9000000000000000 1000000000000000 ->  NaN Invalid_operation
ddxor254 xor  2000000000000000 0000000000000000 ->  NaN Invalid_operation
ddxor255 xor  7000000000000000 0000000000000000 ->  NaN Invalid_operation
ddxor256 xor  8000000000000000 0000000000000000 ->  NaN Invalid_operation
ddxor257 xor  9000000000000000 0000000000000000 ->  NaN Invalid_operation
ddxor258 xor  1000000000000000 2000000000000000 ->  NaN Invalid_operation
ddxor259 xor  1000000000000000 7000000000000000 ->  NaN Invalid_operation
ddxor260 xor  1000000000000000 8000000000000000 ->  NaN Invalid_operation
ddxor261 xor  1000000000000000 9000000000000000 ->  NaN Invalid_operation
ddxor262 xor  0000000000000000 2000000000000000 ->  NaN Invalid_operation
ddxor263 xor  0000000000000000 7000000000000000 ->  NaN Invalid_operation
ddxor264 xor  0000000000000000 8000000000000000 ->  NaN Invalid_operation
ddxor265 xor  0000000000000000 9000000000000000 ->  NaN Invalid_operation
-- test MSD-1
ddxor270 xor  0200001000000000 1000100000000010 ->  NaN Invalid_operation
ddxor271 xor  0700000100000000 1000010000000100 ->  NaN Invalid_operation
ddxor272 xor  0800000010000000 1000001000001000 ->  NaN Invalid_operation
ddxor273 xor  0900000001000000 1000000100010000 ->  NaN Invalid_operation
ddxor274 xor  1000000000100000 0200000010100000 ->  NaN Invalid_operation
ddxor275 xor  1000000000010000 0700000001000000 ->  NaN Invalid_operation
ddxor276 xor  1000000000001000 0800000010100000 ->  NaN Invalid_operation
ddxor277 xor  1000000000000100 0900000000010000 ->  NaN Invalid_operation
-- test LSD
ddxor280 xor  0010000000000002 1000000100000001 ->  NaN Invalid_operation
ddxor281 xor  0001000000000007 1000001000000011 ->  NaN Invalid_operation
ddxor282 xor  0000100000000008 1000010000000001 ->  NaN Invalid_operation
ddxor283 xor  0000010000000009 1000100000000001 ->  NaN Invalid_operation
ddxor284 xor  1000001000000000 0001000000000002 ->  NaN Invalid_operation
ddxor285 xor  1000000100000000 0010000000000007 ->  NaN Invalid_operation
ddxor286 xor  1000000010000000 0100000000000008 ->  NaN Invalid_operation
ddxor287 xor  1000000001000000 1000000000000009 ->  NaN Invalid_operation
-- test Middie
ddxor288 xor  0010000020000000 1000001000000000 ->  NaN Invalid_operation
ddxor289 xor  0001000070000001 1000000100000000 ->  NaN Invalid_operation
ddxor290 xor  0000100080000010 1000000010000000 ->  NaN Invalid_operation
ddxor291 xor  0000010090000100 1000000001000000 ->  NaN Invalid_operation
ddxor292 xor  1000001000001000 0000000020100000 ->  NaN Invalid_operation
ddxor293 xor  1000000100010000 0000000070010000 ->  NaN Invalid_operation
ddxor294 xor  1000000010100000 0000000080001000 ->  NaN Invalid_operation
ddxor295 xor  1000000001000000 0000000090000100 ->  NaN Invalid_operation
-- signs
ddxor296 xor -1000000001000000 -0000010000000100 ->  NaN Invalid_operation
ddxor297 xor -1000000001000000  0000000010000100 ->  NaN Invalid_operation
ddxor298 xor  1000000001000000 -0000001000000100 ->  NaN Invalid_operation
ddxor299 xor  1000000001000000  0000000011000100 ->  1000000010000100

-- Nmax, Nmin, Ntiny-like
ddxor331 xor  2   9.99999999E+299     -> NaN Invalid_operation
ddxor332 xor  3   1E-299              -> NaN Invalid_operation
ddxor333 xor  4   1.00000000E-299     -> NaN Invalid_operation
ddxor334 xor  5   1E-200              -> NaN Invalid_operation
ddxor335 xor  6   -1E-200             -> NaN Invalid_operation
ddxor336 xor  7   -1.00000000E-299    -> NaN Invalid_operation
ddxor337 xor  8   -1E-299             -> NaN Invalid_operation
ddxor338 xor  9   -9.99999999E+299    -> NaN Invalid_operation
ddxor341 xor  9.99999999E+299     -18 -> NaN Invalid_operation
ddxor342 xor  1E-299               01 -> NaN Invalid_operation
ddxor343 xor  1.00000000E-299     -18 -> NaN Invalid_operation
ddxor344 xor  1E-208               18 -> NaN Invalid_operation
ddxor345 xor  -1E-207             -10 -> NaN Invalid_operation
ddxor346 xor  -1.00000000E-299     18 -> NaN Invalid_operation
ddxor347 xor  -1E-299              10 -> NaN Invalid_operation
ddxor348 xor  -9.99999999E+299    -18 -> NaN Invalid_operation

-- A few other non-integers
ddxor361 xor  1.0                  1  -> NaN Invalid_operation
ddxor362 xor  1E+1                 1  -> NaN Invalid_operation
ddxor363 xor  0.0                  1  -> NaN Invalid_operation
ddxor364 xor  0E+1                 1  -> NaN Invalid_operation
ddxor365 xor  9.9                  1  -> NaN Invalid_operation
ddxor366 xor  9E+1                 1  -> NaN Invalid_operation
ddxor371 xor  0 1.0                   -> NaN Invalid_operation
ddxor372 xor  0 1E+1                  -> NaN Invalid_operation
ddxor373 xor  0 0.0                   -> NaN Invalid_operation
ddxor374 xor  0 0E+1                  -> NaN Invalid_operation
ddxor375 xor  0 9.9                   -> NaN Invalid_operation
ddxor376 xor  0 9E+1                  -> NaN Invalid_operation

-- All Specials are in error
ddxor780 xor -Inf  -Inf   -> NaN Invalid_operation
ddxor781 xor -Inf  -1000  -> NaN Invalid_operation
ddxor782 xor -Inf  -1     -> NaN Invalid_operation
ddxor783 xor -Inf  -0     -> NaN Invalid_operation
ddxor784 xor -Inf   0     -> NaN Invalid_operation
ddxor785 xor -Inf   1     -> NaN Invalid_operation
ddxor786 xor -Inf   1000  -> NaN Invalid_operation
ddxor787 xor -1000 -Inf   -> NaN Invalid_operation
ddxor788 xor -Inf  -Inf   -> NaN Invalid_operation
ddxor789 xor -1    -Inf   -> NaN Invalid_operation
ddxor790 xor -0    -Inf   -> NaN Invalid_operation
ddxor791 xor  0    -Inf   -> NaN Invalid_operation
ddxor792 xor  1    -Inf   -> NaN Invalid_operation
ddxor793 xor  1000 -Inf   -> NaN Invalid_operation
ddxor794 xor  Inf  -Inf   -> NaN Invalid_operation

ddxor800 xor  Inf  -Inf   -> NaN Invalid_operation
ddxor801 xor  Inf  -1000  -> NaN Invalid_operation
ddxor802 xor  Inf  -1     -> NaN Invalid_operation
ddxor803 xor  Inf  -0     -> NaN Invalid_operation
ddxor804 xor  Inf   0     -> NaN Invalid_operation
ddxor805 xor  Inf   1     -> NaN Invalid_operation
ddxor806 xor  Inf   1000  -> NaN Invalid_operation
ddxor807 xor  Inf   Inf   -> NaN Invalid_operation
ddxor808 xor -1000  Inf   -> NaN Invalid_operation
ddxor809 xor -Inf   Inf   -> NaN Invalid_operation
ddxor810 xor -1     Inf   -> NaN Invalid_operation
ddxor811 xor -0     Inf   -> NaN Invalid_operation
ddxor812 xor  0     Inf   -> NaN Invalid_operation
ddxor813 xor  1     Inf   -> NaN Invalid_operation
ddxor814 xor  1000  Inf   -> NaN Invalid_operation
ddxor815 xor  Inf   Inf   -> NaN Invalid_operation

ddxor821 xor  NaN -Inf    -> NaN Invalid_operation
ddxor822 xor  NaN -1000   -> NaN Invalid_operation
ddxor823 xor  NaN -1      -> NaN Invalid_operation
ddxor824 xor  NaN -0      -> NaN Invalid_operation
ddxor825 xor  NaN  0      -> NaN Invalid_operation
ddxor826 xor  NaN  1      -> NaN Invalid_operation
ddxor827 xor  NaN  1000   -> NaN Invalid_operation
ddxor828 xor  NaN  Inf    -> NaN Invalid_operation
ddxor829 xor  NaN  NaN    -> NaN Invalid_operation
ddxor830 xor -Inf  NaN    -> NaN Invalid_operation
ddxor831 xor -1000 NaN    -> NaN Invalid_operation
ddxor832 xor -1    NaN    -> NaN Invalid_operation
ddxor833 xor -0    NaN    -> NaN Invalid_operation
ddxor834 xor  0    NaN    -> NaN Invalid_operation
ddxor835 xor  1    NaN    -> NaN Invalid_operation
ddxor836 xor  1000 NaN    -> NaN Invalid_operation
ddxor837 xor  Inf  NaN    -> NaN Invalid_operation

ddxor841 xor  sNaN -Inf   ->  NaN  Invalid_operation
ddxor842 xor  sNaN -1000  ->  NaN  Invalid_operation
ddxor843 xor  sNaN -1     ->  NaN  Invalid_operation
ddxor844 xor  sNaN -0     ->  NaN  Invalid_operation
ddxor845 xor  sNaN  0     ->  NaN  Invalid_operation
ddxor846 xor  sNaN  1     ->  NaN  Invalid_operation
ddxor847 xor  sNaN  1000  ->  NaN  Invalid_operation
ddxor848 xor  sNaN  NaN   ->  NaN  Invalid_operation
ddxor849 xor  sNaN sNaN   ->  NaN  Invalid_operation
ddxor850 xor  NaN  sNaN   ->  NaN  Invalid_operation
ddxor851 xor -Inf  sNaN   ->  NaN  Invalid_operation
ddxor852 xor -1000 sNaN   ->  NaN  Invalid_operation
ddxor853 xor -1    sNaN   ->  NaN  Invalid_operation
ddxor854 xor -0    sNaN   ->  NaN  Invalid_operation
ddxor855 xor  0    sNaN   ->  NaN  Invalid_operation
ddxor856 xor  1    sNaN   ->  NaN  Invalid_operation
ddxor857 xor  1000 sNaN   ->  NaN  Invalid_operation
ddxor858 xor  Inf  sNaN   ->  NaN  Invalid_operation
ddxor859 xor  NaN  sNaN   ->  NaN  Invalid_operation

-- propagating NaNs
ddxor861 xor  NaN1   -Inf    -> NaN Invalid_operation
ddxor862 xor +NaN2   -1000   -> NaN Invalid_operation
ddxor863 xor  NaN3    1000   -> NaN Invalid_operation
ddxor864 xor  NaN4    Inf    -> NaN Invalid_operation
ddxor865 xor  NaN5   +NaN6   -> NaN Invalid_operation
ddxor866 xor -Inf     NaN7   -> NaN Invalid_operation
ddxor867 xor -1000    NaN8   -> NaN Invalid_operation
ddxor868 xor  1000    NaN9   -> NaN Invalid_operation
ddxor869 xor  Inf    +NaN10  -> NaN Invalid_operation
ddxor871 xor  sNaN11  -Inf   -> NaN Invalid_operation
ddxor872 xor  sNaN12  -1000  -> NaN Invalid_operation
ddxor873 xor  sNaN13   1000  -> NaN Invalid_operation
ddxor874 xor  sNaN14   NaN17 -> NaN Invalid_operation
ddxor875 xor  sNaN15  sNaN18 -> NaN Invalid_operation
ddxor876 xor  NaN16   sNaN19 -> NaN Invalid_operation
ddxor877 xor -Inf    +sNaN20 -> NaN Invalid_operation
ddxor878 xor -1000    sNaN21 -> NaN Invalid_operation
ddxor879 xor  1000    sNaN22 -> NaN Invalid_operation
ddxor880 xor  Inf     sNaN23 -> NaN Invalid_operation
ddxor881 xor +NaN25  +sNaN24 -> NaN Invalid_operation
ddxor882 xor -NaN26    NaN28 -> NaN Invalid_operation
ddxor883 xor -sNaN27  sNaN29 -> NaN Invalid_operation
ddxor884 xor  1000    -NaN30 -> NaN Invalid_operation
ddxor885 xor  1000   -sNaN31 -> NaN Invalid_operation
                                                                                                                                                                                                                          ÃaÎVvúVânS‹ütÍ˜eÆhswfåÇŒ∆Á»Ú[oˆÁ'£ÎL§æõå¯°˚zÔ+ÙrHÃÑìöÙÒú_'¬‚ÚÍks°—ä ¯£∆€èCÚ-Ö‘ÍÁMød[(⁄HÛ0ØÁMüMòOáÄ›ôî(tÆ⁄Éq{j¸˚îØïs˚1èGˆùt<?n•√d®Pì@®:ñπ¿/Í¨Ú £˝è˜@S™òG˝Ï_1@ÓÖ÷£ 	ÉÅw»$0bz{®œÍ·Œ˘. ms”OX’$%¥ƒè	◊⁄û≥	ﬂ ífÁpˆœêê· ©∞ÜŒß∑€A¥˝  :˙S≤CáM≥â`nÙˇT˜µ»ﬁ∂◊€f˚QwZÿZµÂ∏‰‚¨9OSèÁi˚í—§ôÓ
>⁄çì°∞[)Ü}Á'G∏Í`:t!ãçÿ]ºqW∫gçPé˘ÕÀÊˆó°ºß RÎﬂhŒkh∂¡Äø†	¥´¥\ì€÷eLa«
á ≠4o·Ô]cøÕ)!⁄∑¬JÈÿkôﬁoœÕ0Ä]ÊYÔU£€¿\¥<zL=B®„Â±0!⁄ Y∏AkÀÎãúv
ªíò=„+ ‰C¢|í@∂DºëÓ“Vè"!“°FÁ≤ÀÒ[ù	óΩ_ä2ÒÁûé>6˛÷=¨£úD-¡ºk
y„Ÿøóª\Áj∑›åÖ‹€]	øÿ1‰ˆ—´Ï≤ÏÔól-ÙS–ò∂ÑXÁÜ…X}H∫ÿZ93–≠◊Q¿©ø^ê0ìr°’dwıUË¡¡Ä^*CCIvﬂ2ìÂ§Î”ä •÷PSjä†â›F◊[rÚ∫‰ı+1€*.<Uˇ?X‰ _7π íí‰®=	ôzdÔQ≈µw"hΩO¨c†')óh◊æqX ^˝ö‚qô in.à•mR0)–´Ìë˚æO˘ Hù[.∏≈Ó∞Ê∑›-z)µù«ˇ¶/d◊){i¯ñcπLél©@ÀmÏ”¸∂¸÷ƒDõ£◊ëºäjÛf…—D)+ëbC≥‡ÿá_´ˇ”æ@õÅXŸÜØ∏Ë⁄G¡}∫!®%ª˜˙âàÎV∑)`˙≥≈±ãdkª'¨:ﬂNcπEÓøÕ)|¬…π∏4ë≥Ñç'ˆXT¡6˚--I¶ˆY≥ûmèÊ»◊iÏΩ vc£·ë⁄¬π Z?¡ ´Á1I˚∂M‹\¢\h°G° N‡*Ø◊wæÒqÀπŸﬂPÂDïJ)°jîµ.R52Õ$¶CÏ}n®äd!M5ÆÎG$D†ÌÖÉ©ñèÍ∆•√Hi˝;â…KT<7ª[ˆ~g±¬ €O∑`óÂ2Ÿ]?*∏∫ÌN ˆOoD\^v1ÈS!SÈãó°8Çú∂w∏ó:"Ê˜{Ã¨ΩÒt%ÎÇ^Ö—˝Ω«‚ÅÄ£6$≤˚Ydˇù–Ÿ
$ `ÔEœ§º±x∂jR2èE∞5ïm∂I†Î Ò8ÀÍÿ…í⁄	ôGÜK
ÕéiûûÑ:√K_ùÎ7pö†û›AIÅµ÷i¬’y;Z⁄Â¬°‘cá›r)`ã Â˜–VRÀ9◊ÛUêÎªPÚ∂œãº¯:˜-=Ü‡á˘8cö¿-:$k’‘≥·õΩÃ	-`æñ¡{/¡ØiQZ◊#–MmÓkíŒwíÁµ=?È—∂”p‹q3/Èî@<Äí8»§ä‡Ëkß6•SöË¯Nm	ñ´Ωm~¥,íˆÿWÈ0ˇ	b·ï,Úºœû?µ€6 ñL9nø§ôÓO≠LÃ9Va‚'}›xÜÂrÉI»4c¡∑"’Ÿ!a^ŸºÈ“1@\&Bç≠qÍLõÀT´ƒä≥R$≠_K≈Zh8a ®Õ}∫∫&N≥KÄº3;†îπ˘]¿¥∏ﬁÓπÏ¶ŒÖu∆öxêE í& ù¥*Ú‡ÕD⁄¿À‰xÂÆµ˘ﬁÿÛ‡øknﬂ˜Ì∞üge˝xL¶`÷ØÅ"ƒR<ˆc[&ßWnä˛Ω ?£ƒ≤=îÆZräı;˚a◊&LG2ƒùêö+â’ﬂ∂ê¯Oí≠x]zqÛùÁBp€≤˝R˜°ÒÑD.vÌòAvÅ%∏ù;æ©<ÃzI¨gHU»¶“K-Tøw∑∂Ô$¥ÓÇ±<µ„¶R·èXAuèç∑’G”ØM·ÊkÚ-¢=f„±úAP@˙m≠ô®ˆhJ‰Ï óGÙv=`Ú>÷˜ç¥≈Û#€m⁄MKÖX<0˛y&Å'THk®ˆær<ápI∫≤Ëukù=4Òƒ6ö°¯P¨èèÓP*ñiQ4:ºáÛ€GÒœÓ˜¶7{¸”œ∏¯KpYèOïÈ∏.⁄ªΩéHJÊ˚ãÄ˙Cˇ˛ÇÊƒàE»ñﬂÎÏ‡1Rıãã˘6ã‘o©⁄ôOVH,CpÜ·™ıÄOÙa5Ì5ÆâŒº	DΩ[L˚À8û;;AŒ±6^u‚àBÊ<Ò,O.‘xÎO#}~·Òâ/∆7bäˆJ'Òb8Â& t$Ó‚)
∞›!’e•≠=ùÖÄÜ'á$î÷!aUÂÃùñ’äëGÆÌÅq$πà„j-ú»€‰Lö,3§CŸ3eîƒ˙ïCÉ«Z∫ uE5â(ábo≈}≠:ﬁ†páOóÊ⁄Ä◊Ç}Î≠v÷≥K≥àŒUJqÛäˆs"!ΩΩWΩ≥¯≥∞|+ªëﬂ¬™¡J£√™QŒ7#—ÉôF˜‘¨{›Q~î™6C◊#9ÓÎ+4(πa«rmïá˚á*˛Bq,jàç∏löØç˜ÑqﬁÖ^==ö¨…ë≈7nÖ|`OdWYº∑)F§Vñk<w[©íxyRÌÂzB‡˛å˜èÅW,ãM˝ ΩÒ ÄÛ_um›bwÀª•î:o8&{π∫⁄’Ù∫≤ﬂıëF[v¨Í“ëˆîh›˝Ó’r∑π“6Æ%¢Dô≈≈èzÌŒiî“ ù≈ªŒwÊΩ:!èn€»/P[mÙü˛ÏÑì±ûœß=—5µ≤£Ÿ)Á*`"xk‚ÇÒ^‡Q†˘yl†—Ÿ_Ÿ?/s iëeï¸òíÖÊÒA°ª≠lNYh´C0$g˝—õ¯R7¡H:+¿F{Gº)º∏g%Ï¡≥=iœÏ6r6äxX¢ër<Ì˙<$^ÅªwT≥·∞ÅÉnü=,£o˝Â'∏Äv¥"òCè"2öºnw ‰4B®&î›ü—èT˛?;O¢˛ûs«˜,€ﬁ€Y©ä_vufî‡rP›}æûHB≈oò¿á1
Ju≤Qv
“Ä(úUß±2VX·Ñiv‰9√æmtıå™ÈêP …¬ñGVöA÷óéLnﬁˆ$hRÒEqpìwqH¢≥˝Xà;¬6B#define ENABLE
#define MINBUFFERS
using System;
#if !FEATURE_CORECLR
using System.Diagnostics.Tracing;
#endif
using System.Runtime.InteropServices;
using System.Runtime.ConstrainedExecution;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Threading;
using System.Runtime.CompilerServices;
using System.Diagnostics;
using System.Security.Permissions;

#if PINNABLEBUFFERCACHE_MSCORLIB
namespace System.Threading
#else
namespace System
#endif
{
    internal sealed class PinnableBufferCache
    {
        /// <summary>
        /// Create a new cache for pinned byte[] buffers
        /// </summary>
        /// <param name="cacheName">A name used in diagnostic messages</param>
        /// <param name="numberOfElements">The size of byte[] buffers in the cache (they are all the same size)</param>
        public PinnableBufferCache(string cacheName, int numberOfElements) : this(cacheName, () => new byte[numberOfElements]) { }

        /// <summary>
        /// Get a buffer from the buffer manager.  If no buffers exist, allocate a new one.
        /// </summary>
        public byte[] AllocateBuffer() { return (byte[])Allocate(); }

        /// <summary>
        /// Return a buffer back to the buffer manager.
        /// </summary>
        public void FreeBuffer(byte[] buffer) { Free(buffer); }

        /// <summary>
        /// Create a PinnableBufferCache that works on any object (it is intended for OverlappedData)
        /// This is only used in mscorlib.
        /// </summary>
#if (ENABLE || MINBUFFERS)
        [EnvironmentPermission(SecurityAction.Assert, Unrestricted = true)]
        [System.Security.SecuritySafeCritical]
#endif
        internal PinnableBufferCache(string cacheName, Func<object> factory)
        {
            m_NotGen2 = new List<object>(DefaultNumberOfBuffers);
            m_factory = factory;
#if ENABLE
            // Check to see if we should disable the cache.
            string envVarName = "PinnableBufferCache_" + cacheName + "_Disabled";
            try
            {
                string envVar = Environment.GetEnvironmentVariable(envVarName);
                if (envVar != null)
                {
                    PinnableBufferCacheEventSource.Log.DebugMessage("Creating " + cacheName + " PinnableBufferCacheDisabled=" + envVar);
                    int index = envVar.IndexOf(cacheName, StringComparison.OrdinalIgnoreCase);
                    if (0 <= index)
                    {
                        // The cache is disabled because we haven't set the cache name.
                        PinnableBufferCacheEventSource.Log.DebugMessage("Disabling " + cacheName);
                        return;
                    }
                }
            }
            catch
            {
                // Ignore failures when reading the environment variable.
            }
#endif
#if MINBUFFERS
            // Allow the environment to specify a minimum buffer count.
            string minEnvVarName = "PinnableBufferCache_" + cacheName + "_MinCount";
            try
            {
                string minEnvVar = Environment.GetEnvironmentVariable(minEnvVarName);
                if (minEnvVar != null)
                {
                    if (int.TryParse(minEnvVar, out m_minBufferCount))
                        CreateNewBuffers();
                }
            }
            catch
            {
                // Ignore failures when reading the environment variable.
            }
#endif

            PinnableBufferCacheEventSource.Log.Create(cacheName);
            m_CacheName = cacheName;
        }

        /// <summary>
        /// Get a object from the buffer manager.  If no buffers exist, allocate a new one.
        /// </summary>
        [System.Security.SecuritySafeCritical]
        internal object Allocate()
        {
#if ENABLE
            // Check to see whether or not the cache is disabled.
            if (m_CacheName == null)
                return m_factory();
#endif
            // Fast path, get it from our Gen2 aged m_FreeList.  
            object returnBuffer;
            if (!m_FreeList.TryPop(out returnBuffer))
                Restock(out returnBuffer);

            // Computing free count is expensive enough that we don't want to compute it unless logging is on.
            if (PinnableBufferCacheEventSource.Log.IsEnabled())
            {
                int numAllocCalls = Interlocked.Increment(ref m_numAllocCalls);
                if (numAllocCalls >= 1024)
                {
                    lock (this)
                    {
                        int previousNumAllocCalls = Interlocked.Exchange(ref m_numAllocCalls, 0);
                        if (previousNumAllocCalls >= 1024)
                        {
                            int nonGen2Count = 0;
                            foreach (object o in m_FreeList)
                            {
                                if (GC.GetGeneration(o) < GC.MaxGeneration)
                                {
                                    nonGen2Count++;
                                }
                            }

                            PinnableBufferCacheEventSource.Log.WalkFreeListResult(m_CacheName, m_FreeList.Count, nonGen2Count);
                        }
                    }
                }

                PinnableBufferCacheEventSource.Log.AllocateBuffer(m_CacheName, PinnableBufferCacheEventSource.AddressOf(returnBuffer), returnBuffer.GetHashCode(), GC.GetGeneration(returnBuffer), m_FreeList.Count);
            }
            return returnBuffer;
        }

        /// <summary>
        /// Return a buffer back to the buffer manager.
        /// </summary>
        [System.Security.SecuritySafeCritical]
        internal void Free(object buffer)
        {
#if ENABLE
            // Check to see whether or not the cache is disabled.
            if (m_CacheName == null)
                return;
#endif
            if (PinnableBufferCacheEventSource.Log.IsEnabled())
                PinnableBufferCacheEventSource.Log.FreeBuffer(m_CacheName, PinnableBufferCacheEventSource.AddressOf(buffer), buffer.GetHashCode(), m_FreeList.Count);

            if(buffer == null)
            {
                if (PinnableBufferCacheEventSource.Log.IsEnabled())
                    PinnableBufferCacheEventSource.Log.FreeBufferNull(m_CacheName, m_FreeList.Count);
                    
                return;
            }
            
            // After we've done 3 gen1 GCs, assume that all buffers have aged into gen2 on the free path.
            if ((m_gen1CountAtLastRestock + 3) > GC.CollectionCount(GC.MaxGeneration - 1))
            {
                lock (this)
                {
                    if (GC.GetGeneration(buffer) < GC.MaxGeneration)
                    {
                        // The buffer is not aged, so put it in the non-aged free list.
                        m_moreThanFreeListNeeded = true;
                        PinnableBufferCacheEventSource.Log.FreeBufferStillTooYoung(m_CacheName, m_NotGen2.Count);
                        m_NotGen2.Add(buffer);
                        m_gen1CountAtLastRestock = GC.CollectionCount(GC.MaxGeneration - 1);
                        return;
                    }
                }
            }

            // If we discovered that it is indeed Gen2, great, put it in the Gen2 list.  
            m_FreeList.Push(buffer);
        }

        #region Private

        /// <summary>
        /// Called when we don't have any buffers in our free list to give out.    
        /// </summary>
        /// <returns></returns>
        [System.Security.SecuritySafeCritical]
        private void Restock(out object returnBuffer)
        {
            lock (this)
            {
                // Try again after getting the lock as another thread could have just filled the free list.  If we don't check
                // then we unnecessarily grab a new set of buffers because we think we are out.     
                if (m_FreeList.TryPop(out returnBuffer))
                    return;

                // Lazy init, Ask that TrimFreeListIfNeeded be called on every Gen 2 GC.  
                if (m_restockSize == 0)
                    Gen2GcCallback.Register(Gen2GcCallbackFunc, this);

                // Indicate to the trimming policy that the free list is insufficent.   
                m_moreThanFreeListNeeded = true;
                PinnableBufferCacheEventSource.Log.AllocateBufferFreeListEmpty(m_CacheName, m_NotGen2.Count);

                // Get more buffers if needed.
                if (m_NotGen2.Count == 0)
                    CreateNewBuffers();

                // We have no buffers in the aged freelist, so get one from the newer list.   Try to pick the best one.
                // Debug.Assert(m_NotGen2.Count != 0);
                int idx = m_NotGen2.Count - 1;
                if (GC.GetGeneration(m_NotGen2[idx]) < GC.MaxGeneration && GC.GetGeneration(m_NotGen2[0]) == GC.MaxGeneration)
                    idx = 0;
                returnBuffer = m_NotGen2[idx];
                m_NotGen2.RemoveAt(idx);

                // Remember any sub-optimial buffer so we don't put it on the free list when it gets freed.   
                if (PinnableBufferCacheEventSource.Log.IsEnabled() && GC.GetGeneration(returnBuffer) < GC.MaxGeneration)
                {
                    PinnableBufferCacheEventSource.Log.AllocateBufferFromNotGen2(m_CacheName, m_NotGen2.Count);
                }

                // If we have a Gen1 collection, then everything on m_NotGen2 should have aged.  Move them to the m_Free list.  
                if (!AgePendingBuffers())
                {
                    // Before we could age at set of buffers, we have handed out half of them.
                    // This implies we should be proactive about allocating more (since we will trim them if we over-allocate).  
                    if (m_NotGen2.Count == m_restockSize / 2)
                    {
                        PinnableBufferCacheEventSource.Log.DebugMessage("Proactively adding more buffers to aging pool");
                        CreateNewBuffers();
                    }
                }
            }
        }

        /// <summary>
        /// See if we can promote the buffers to the free list.  Returns true if sucessful. 
        /// </summary>
        [System.Security.SecuritySafeCritical]
        private bool AgePendingBuffers()
        {
            if (m_gen1CountAtLastRestock < GC.CollectionCount(GC.MaxGeneration - 1))
            {
                // Allocate a temp list of buffers that are not actually in gen2, and swap it in once
                // we're done scanning all buffers.
                int promotedCount = 0;
                List<object> notInGen2 = new List<object>();
                PinnableBufferCacheEventSource.Log.AllocateBufferAged(m_CacheName, m_NotGen2.Count);
                for (int i = 0; i < m_NotGen2.Count; i++)
                {
                    // We actually check every object to ensure that we aren't putting non-aged buffers into the free list.
                    object currentBuffer = m_NotGen2[i];
                    if (GC.GetGeneration(currentBuffer) >= GC.MaxGeneration)
                    {
                        m_FreeList.Push(currentBuffer);
                        promotedCount++;
                    }
                    else
                    {
                        notInGen2.Add(currentBuffer);
                    }
                }
                PinnableBufferCacheEventSource.Log.AgePendingBuffersResults(m_CacheName, promotedCount, notInGen2.Count);
                m_NotGen2 = notInGen2;

                return true;
            }
            return false;
        }

        /// <summary>
        /// Generates some buffers to age into Gen2.
        /// </summary>
        private void CreateNewBuffers()
        {
            // We choose a very modest number of buffers initially because for the client case.  This is often enough.
            if (m_restockSize == 0)
                m_restockSize = 4;
            else if (m_restockSize < DefaultNumberOfBuffers)
                m_restockSize = DefaultNumberOfBuffers;
            else if (m_restockSize < 256)
                m_restockSize = m_restockSize * 2;                // Grow quickly at small sizes
            else if (m_restockSize < 4096)
                m_restockSize = m_restockSize * 3 / 2;            // Less agressively at large ones
            else
                m_restockSize = 4096;                             // Cap how agressive we are

            // Ensure we hit our minimums
            if (m_minBufferCount > m_buffersUnderManagement)
                m_restockSize = Math.Max(m_restockSize, m_minBufferCount - m_buffersUnderManagement);

            PinnableBufferCacheEventSource.Log.AllocateBufferCreatingNewBuffers(m_CacheName, m_buffersUnderManagement, m_restockSize);
            for (int i = 0; i < m_restockSize; i++)
            {
                // Make a new buffer.
                object newBuffer = m_factory();

                // Create space between the objects.  We do this because otherwise it forms a single plug (group of objects)
                // and the GC pins the entire plug making them NOT move to Gen1 and Gen2.   by putting space between them
                // we ensure that object get a chance to move independently (even if some are pinned).  
                var dummyObject = new object();
                m_NotGen2.Add(newBuffer);
            }
            m_buffersUnderManagement += m_restockSize;
            m_gen1CountAtLastRestock = GC.CollectionCount(GC.MaxGeneration - 1);
        }

        /// <summary>
        /// This is the static function that is called from the gen2 GC callback.
        /// The input object is the cache itself.
        /// NOTE: The reason that we make this functionstatic and take the cache as a parameter is that
        /// otherwise, we root the cache to the Gen2GcCallback object, and leak the cache even when
        /// the application no longer needs it.
        /// </summary>
        [System.Security.SecuritySafeCritical]
        private static bool Gen2GcCallbackFunc(object targetObj)
        {
            return ((PinnableBufferCache)(targetObj)).TrimFreeListIfNeeded();
        }

        /// <summary>
        /// This is called on every gen2 GC to see if we need to trim the free list.
        /// NOTE: DO NOT CALL THIS DIRECTLY FROM THE GEN2GCCALLBACK.  INSTEAD CALL IT VIA A STATIC FUNCTION (SEE ABOVE).
        /// If you register a non-static function as a callback, then this object will be leaked.
        /// </summary>
        [System.Security.SecuritySafeCritical]
        private bool TrimFreeListIfNeeded()
        {
            int curMSec = Environment.TickCount;
            int deltaMSec = curMSec - m_msecNoUseBeyondFreeListSinceThisTime;
            PinnableBufferCacheEventSource.Log.TrimCheck(m_CacheName, m_buffersUnderManagement, m_moreThanFreeListNeeded, deltaMSec);

            // If we needed more than just the set of aged buffers since the last time we were called,
            // we obviously should not be trimming any memory, so do nothing except reset the flag 
            if (m_moreThanFreeListNeeded)
            {
                m_moreThanFreeListNeeded = false;
                m_trimmingExperimentInProgress = false;
                m_msecNoUseBeyondFreeListSinceThisTime = curMSec;
                return true;
            }

            // We require a minimum amount of clock time to pass  (10 seconds) before we trim.  Ideally this time
            // is larger than the typical buffer hold time.  
            if (0 <= deltaMSec && deltaMSec < 10000)
                return true;

            // If we got here we have spend the last few second without needing to lengthen the free list.   Thus
            // we have 'enough' buffers, but maybe we have too many. 
            // See if we can trim
            lock (this)
            {
                // Hit a ----, try again later.  
                if (m_moreThanFreeListNeeded)
                {
                    m_moreThanFreeListNeeded = false;
                    m_trimmingExperimentInProgress = false;
                    m_msecNoUseBeyondFreeListSinceThisTime = curMSec;
                    return true;
                }

                var freeCount = m_FreeList.Count;   // This is expensive to fetch, do it once.

                // If there is something in m_NotGen2 it was not used for the last few seconds, it is trimable.  
                if (m_NotGen2.Count > 0)
                {
                    // If we are not performing an experiment and we have stuff that is waiting to go into the
                    // free list but has not made it there, it could be becasue the 'slow path' of restocking
                    // has not happened, so force this (which should flush the list) and start over.  
                    if (!m_trimmingExperimentInProgress)
                    {
                        PinnableBufferCacheEventSource.Log.TrimFlush(m_CacheName, m_buffersUnderManagement, freeCount, m_NotGen2.Count);
                        AgePendingBuffers();
                        m_trimmingExperimentInProgress = true;
                        return true;
                    }

                    PinnableBufferCacheEventSource.Log.TrimFree(m_CacheName, m_buffersUnderManagement, freeCount, m_NotGen2.Count);
                    m_buffersUnderManagement -= m_NotGen2.Count;

                    // Possibly revise the restocking down.  We don't want to grow agressively if we are trimming.  
                    var newRestockSize = m_buffersUnderManagement / 4;
                    if (newRestockSize < m_restockSize)
                        m_restockSize = Math.Max(newRestockSize, DefaultNumberOfBuffers);

                    m_NotGen2.Clear();
                    m_trimmingExperimentInProgress = false;
                    return true;
                }

                // Set up an experiment where we use 25% less buffers in our free list.   We put them in 
                // m_NotGen2, and if they are needed they will be put back in the free list again.  
                var trimSize = freeCount / 4 + 1;

                // We are OK with a 15% overhead, do nothing in that case.  
                if (freeCount * 15 <= m_buffersUnderManagement || m_buffersUnderManagement - trimSize <= m_minBufferCount)
                {
                    PinnableBufferCacheEventSource.Log.TrimFreeSizeOK(m_CacheName, m_buffersUnderManagement, freeCount);
                    return true;
                }

                // Move buffers from teh free list back to the non-aged list.  If we don't use them by next time, then we'll consider trimming them.
                PinnableBufferCacheEventSource.Log.TrimExperiment(m_CacheName, m_buffersUnderManagement, freeCount, trimSize);
                object buffer;
                for (int i = 0; i < trimSize; i++)
                {
                    if (m_FreeList.TryPop(out buffer))
                        m_NotGen2.Add(buffer);
                }
                m_msecNoUseBeyondFreeListSinceThisTime = curMSec;
                m_trimmingExperimentInProgress = true;
            }

            // Indicate that we want to be called back on the next Gen 2 GC.  
            return true;
        }

        private const int DefaultNumberOfBuffers = 16;
        private string m_CacheName;
        private Func<object> m_factory;

        /// <summary>
        /// Contains 'good' buffers to reuse.  They are guarenteed to be Gen 2 ENFORCED!
        /// </summary>
        private ConcurrentStack<object> m_FreeList = new ConcurrentStack<object>();
        /// <summary>
        /// Contains buffers that are not gen 2 and thus we do not wish to give out unless we have to.
        /// To implement trimming we sometimes put aged buffers in here as a place to 'park' them
        /// before true deletion.  
        /// </summary>
        private List<object> m_NotGen2;
        /// <summary>
        /// What whas the gen 1 count the last time re restocked?  If it is now greater, then
        /// we know that all objects are in Gen 2 so we don't have to check.  Should be updated
        /// every time something gets added to the m_NotGen2 list.
        /// </summary>
        private int m_gen1CountAtLastRestock;

        /// <summary>
        /// Used to ensure we have a minimum time between trimmings.  
        /// </summary>
        private int m_msecNoUseBeyondFreeListSinceThisTime;
        /// <summary>
        /// To trim, we remove things from the free list (which is Gen 2) and see if we 'hit bottom'
        /// This flag indicates that we hit bottom (we really needed a bigger free list).
        /// </summary>
        private bool m_moreThanFreeListNeeded;
        /// <summary>
        /// The total number of buffers that this cache has ever allocated.
        /// Used in trimming heuristics. 
        /// </summary>
        private int m_buffersUnderManagement;
        /// <summary>
        /// The number of buffers we added the last time we restocked.
        /// </summary>
        private int m_restockSize;
        /// <summary>
        /// Did we put some buffers into m_NotGen2 to see if we can trim?
        /// </summary>
        private bool m_trimmingExperimentInProgress;
        /// <summary>
        /// A forced minimum number of buffers.
        /// </summary>
        private int m_minBufferCount;
        /// <summary>
        /// The number of calls to Allocate.
        /// </summary>
        private int m_numAllocCalls;

        #endregion
    }

    /// <summary>
    /// Schedules a callback roughly every gen 2 GC (you may see a Gen 0 an Gen 1 but only once)
    /// (We can fix this by capturing the Gen 2 count at startup and testing, but I mostly don't care)
    /// </summary>
    internal sealed class Gen2GcCallback : CriticalFinalizerObject
    {
        [System.Security.SecuritySafeCritical]
        public Gen2GcCallback()
            : base()
        {
        }

        /// <summary>
        /// Schedule 'callback' to be called in the next GC.  If the callback returns true it is 
        /// rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop. 
        /// 
        /// NOTE: This callback will be kept alive until either the callback function returns false,
        /// or the target object dies.
        /// </summary>
        public static void Register(Func<object, bool> callback, object targetObj)
        {
            // Create a unreachable object that remembers the callback function and target object.
            Gen2GcCallback gcCallback = new Gen2GcCallback();
            gcCallback.Setup(callback, targetObj);
        }

        #region Private

        private Func<object, bool> m_callback;
        private GCHandle m_weakTargetObj;

        [System.Security.SecuritySafeCritical]
        private void Setup(Func<object, bool> callback, object targetObj)
        {
            m_callback = callback;
            m_weakTargetObj = GCHandle.Alloc(targetObj, GCHandleType.Weak);
        }

        [System.Security.SecuritySafeCritical]
        ~Gen2GcCallback()
        {
            // Check to see if the target object is still alive.
            if (!m_weakTargetObj.IsAllocated)
            {
                return;
            }

            object targetObj = m_weakTargetObj.Target;
            if (targetObj == null)
            {
                // The target object is dead, so this callback object is no longer needed.
                m_weakTargetObj.Free();
                return;
            }

            // Execute the callback method.
            try
            {
                if (!m_callback(targetObj))
                {
                    // If the callback returns false, this callback object is no longer needed.
                    return;
                }
            }
            catch
            {
                // Ensure that we still get a chance to resurrect this object, even if the callback throws an exception.
            }

            // Resurrect ourselves by re-registering for finalization.
            if (!Environment.HasShutdownStarted && !AppDomain.CurrentDomain.IsFinalizingForUnload())
            {
                GC.ReRegisterForFinalize(this);
            }
        }

        #endregion
    }


#if FEATURE_CORECLR
    internal sealed class PinnableBufferCacheEventSource
    {
        public static readonly PinnableBufferCacheEventSource Log = new PinnableBufferCacheEventSource();

        public bool IsEnabled() { return false; }
        public void DebugMessage(string message) {}
        public void DebugMessage1(string message, long value) {}
        public void DebugMessage2(string message, long value1, long value2) {}
        public void DebugMessage3(string message, long value1, long value2, long value3) {}
        public void Create(string cacheName) {}
        public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter) {}
        public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter) {}
        public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount) {}
        public void AllocateBufferAged(string cacheName, int agedCount) {}
        public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore) {}
        public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore) {}
        public void FreeBufferNull(string cacheName, int freeCountBefore) { }
        public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore) {}
        public void TrimCheck(string cacheName, int totalBuffs, bool neededMoreThanFreeList, int deltaMSec) {}
        public void TrimFree(string cacheName, int totalBuffs, int freeListCount, int toBeFreed) {}
        public void TrimExperiment(string cacheName, int totalBuffs, int freeListCount, int numTrimTrial) {}
        public void TrimFreeSizeOK(string cacheName, int totalBuffs, int freeListCount) {}
        public void TrimFlush(string cacheName, int totalBuffs, int freeListCount, int notGen2CountBefore) {}
        public void AgePendingBuffersResults(string cacheName, int promotedToFreeListCount, int heldBackCount) {}
        public void WalkFreeListResult(string cacheName, int freeListCount, int gen0BuffersInFreeList) {}

        static internal ulong AddressOf(object obj)
        {
            return 0;
        }

        [System.Security.SecuritySafeCritical]
        static internal unsafe long AddressOfObject(byte[] array)
        {
            return 0;
        }
    }
#else
    /// <summary>
    /// PinnableBufferCacheEventSource is a private eventSource that we are using to
    /// debug and monitor the effectiveness of PinnableBufferCache
    /// </summary>
#if PINNABLEBUFFERCACHE_MSCORLIB
    [EventSource(Name = "Microsoft-DotNETRuntime-PinnableBufferCache")]
#else
    [EventSource(Name = "Microsoft-DotNETRuntime-PinnableBufferCache-System")]
#endif
    internal sealed class PinnableBufferCacheEventSource : EventSource
    {
        public static readonly PinnableBufferCacheEventSource Log = new PinnableBufferCacheEventSource();

        [Event(1, Level = EventLevel.Verbose)]
        public void DebugMessage(string message) { if (IsEnabled()) WriteEvent(1, message); }
        [Event(2, Level = EventLevel.Verbose)]
        public void DebugMessage1(string message, long value) { if (IsEnabled()) WriteEvent(2, message, value); }
        [Event(3, Level = EventLevel.Verbose)]
        public void DebugMessage2(string message, long value1, long value2) { if (IsEnabled()) WriteEvent(3, message, value1, value2); }
        [Event(18, Level = EventLevel.Verbose)]
        public void DebugMessage3(string message, long value1, long value2, long value3) { if (IsEnabled()) WriteEvent(18, message, value1, value2, value3); }

        [Event(4)]
        public void Create(string cacheName) { if (IsEnabled()) WriteEvent(4, cacheName); }

        [Event(5, Level = EventLevel.Verbose)]
        public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter) { if (IsEnabled()) WriteEvent(5, cacheName, objectId, objectHash, objectGen, freeCountAfter); }
        [Event(6)]
        public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter) { if (IsEnabled()) WriteEvent(6, cacheName, notGen2CountAfter); }
        [Event(7)]
        public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount) { if (IsEnabled()) WriteEvent(7, cacheName, totalBuffsBefore, objectCount); }
        [Event(8)]
        public void AllocateBufferAged(string cacheName, int agedCount) { if (IsEnabled()) WriteEvent(8, cacheName, agedCount); }
        [Event(9)]
        public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore) { if (IsEnabled()) WriteEvent(9, cacheName, notGen2CountBefore); }

        [Event(10, Level = EventLevel.Verbose)]
        public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore) { if (IsEnabled()) WriteEvent(10, cacheName, objectId, objectHash, freeCountBefore); }
        [Event(11)]
        public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore) { if (IsEnabled()) WriteEvent(11, cacheName, n