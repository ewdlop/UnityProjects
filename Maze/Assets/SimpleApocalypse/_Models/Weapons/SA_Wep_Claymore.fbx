It is copied from Wikipedia, http://el.wikipedia.org/wiki/%CE%95%CE%BB%CE%BB%CE%B7%CE%BD%CE%B9%CE%BA%CE%AE_%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1
Authored under GFDL license: http://www.gnu.org/copyleft/fdl.html

Ελληνική γλώσσα
Από την Βικιπαίδεια, την ελεύθερη εγκυκλοπαίδεια
Jump to: navigation, search

Η Ελληνική Γλώσσα είναι μία από τις Ινδοευρωπαϊκές Γλώσσες, για την οποία έχουμε συνεχή γραπτά κείμενα από τον 8ο αιώνα π.Χ. μέχρι σήμερα. Επίσης έχουμε μερικά γραπτά κείμενα από τον 15ον αιώνα π.Χ. γραμμένα στη Γραμμική Β.
Ελληνικά
Ομιλείται σε: 	Ελλάδα, Κύπρο, Αλβανία, Τουρκία, Αίγυπτο

και οπουδήποτε αλλού έχουν μεταναστεύσει Έλληνες (Ηνωμένες Πολιτείες, Καναδάς, Αυστραλία, Αγγλία, κ.α.)
Συνολικοί ομιλητές: 	12 εκατομμύρια στην Βαλκανική , και άλλα 8-10 εκατομύρια στον υπόλοιπο κόσμο
Κατάταξη: 	74η
Γενετική
ταξινόμηση: 	Ινδοευρωπαϊκές Γλώσσες

 Ελληνικά
  Αττικά
   Νέα Ελληνικά
Official status
Επίσημη γλώσσα: 	Ελλάδας, Κύπρου
Ρυθμίζεται από: 	?
Κώδικες γλώσσας
ISO 639-1 	el
ISO 639-2(B) 	gre
ISO 639-2(T) 	ell
SIL 	GRK


Πίνακας περιεχομένων
[Απόκρυψη]

    * 1 Ταξινόμηση
    * 2 Γεωγραφική εξάπλωση
    * 3 Επίσημη κατάσταση της γλώσσας
    * 4 Φάσεις Εξέλιξης
          o 4.1 Πρωτοελληνική
          o 4.2 Μυκηναϊκή Ελληνική
          o 4.3 Κλασική Ελληνική
          o 4.4 Ελληνιστική Κοινή
          o 4.5 Μεσαιωνική Ελληνική
          o 4.6 Νέα Ελληνική
    * 5 Φωνητική
    * 6 Γραφή
    * 7 Βλέπε Επίσης
    * 8 Εξωτερικές συνδέσεις

[Επεξεργασία]

Ταξινόμηση

Η Ελληνική αποτελεί από μόνη της έναν ανεξάρτητο κλάδο της Ινδοευρωπαϊκής ομάδας γλωσσών. Το λεξιλόγιο της νεότερης μορφής της έχει επηρεαστεί σε ένα βαθμό από γλώσσες των [[Βαλκάνια|Βαλκανίων
[Επεξεργασία]

Γεωγραφική εξάπλωση

Η Ελληνική αποτελεί την μητρική γλώσσα περίπου 12 εκατομηρίων ανθρώπων κυρίως στην Ελλάδα και στην Κύπρο. Αποτελεί επίσης την μητρική γλώσσα αυτόχθονων πληθυσμών στην Αλβανία και στην Τουρκία. Εξαιτίας της μετανάστευσης η γλώσσα μιλιέται ακόμα σε χώρες-προορισμούς ελληνόφωνων πληθυσμών μεταξύ των οποίων η Αυστραλία, ο Καναδάς, η Γερμανία, το Ηνωμένο Βασίλειο, και οι Ηνωμένες Πολιτείες. Συνολικά υπολογίζεται ότι ο συνολικός αριθμός ανθρώπων που μιλάνε τα ελληνικά σαν πρώτη ή δεύτερη γλώσσα είναι γύρω στα 15 εκατομύρια.


[Επεξεργασία]

Επίσημη κατάσταση της γλώσσας

Είναι η επίσημη γλώσσα της Ελλάδας και της Κύπρου. Ακόμα είναι μία από τις επίσημες γλώσσες της Ευρωπαϊκής Ένωσης.
[Επεξεργασία]

Φάσεις Εξέλιξης
[Επεξεργασία]

Πρωτοελληνική

Για την πρώτη φάση (Πρωτοελληνική) η οποία τοποθετείται πριν το 1600 π.Χ., οι όποιες γνώσεις μας για την ελληνική γλώσσα βασίζονται σε τεχνικές επανασύνθεσης που προκύπτουν από τη συγκριτική γλωσσολογία. Η Πρωτοελληνική είχε 7 πτώσεις (Ονομαστική, Γενική, Δοτική, Αιτιατική, Αφαιρετική, Τοπική, Κλητική). Επίσης είχε διατηρήσει σε πολύ μεγάλο βαθμό τα υπόλοιπα χαρακτηριστικά της ΙΕ "μητρικής" γλώσσας. Είχε τρεις φωνές (Ενεργητική, Παθητική, Μέση) και τρεις αριθμούς (Ενικός, Πληθυντικός, Δυϊκός). Σημαντικό χαρακτηριστικό της (που διατηρήθηκε σχεδόν μέχρι τα πρώτα μεταχριστιανικά χρόνια) ήταν ο μουσικός τονισμός. Ο τόνος στα αρχαία ελληνικά δεν αντιστοιχούσε σε αύξηση της έντασης της φωνής (volume) αλλά σε αύξηση της συχνότητας (pitch).
[Επεξεργασία]

Μυκηναϊκή Ελληνική

Στην αμέσως επόμενη φάση (Μυκηναϊκή Ελληνική) η οποία μαρτυρείται από τις πινακίδες της Γραμμικής Β' και από ορισμένους στίχους των Ομηρικών Επών, παρατηρούμε εξίσου πολλούς αρχαϊσμούς. Π.χ. η γενική των ονομάτων σε -ος σχηματιζόταν με την κατάληξη -οιο (πρβλ. Ομηρικό "Πριάμοιο"), ενώ υπάρχει φθόγγος (που συμβολίζεται με) "q" ο οποίος βρίσκεται σε λέξεις όπου από την ΙΕ θα αναμέναμε ένα *kw. Οι πτώσεις Αφαιρετική και Τοπική διατηρούνται αλλά σε μάλλον περιορισμένο βαθμό.
[Επεξεργασία]

Κλασική Ελληνική

Στην Κλασική ελληνική, αρχαιότερα κείμενα της οποίας είναι τα Ομηρικά Έπη και αρχαιότερο τεκμήριο η επιγραφή του Διπύλου, το βασικότερο χαρακτηριστικό είναι η υψηλή διαλεκτική διαφοροποίηση, η οποία οφείλεται πιθανότατα στην πολυδιάσπαση του ελληνικού κόσμου σε διάφορα κρατίδια. Ως προς το αν οι βασικές διάλεκτοι της κλασσικής εποχής (Ιωνική, Αιολική, Δωρική κλπ) δημιουργήθηκαν στην Ελλάδα λόγω της πολιτικής πολυδιάσπασης των Ελλήνων ή "ήρθαν" μαζί με τα αντίστοιχα φύλα κατά την εποχή του Χαλκού, οι γνώμες διίστανται. Φαίνεται πως δεν αποκλείεται να συνέβησαν και τα δύο. Πάντως οι διάλεκτοι της κλασσικής εποχής διέφεραν αρκετά μεταξύ τους και δεν θα ήταν υπερβολή να υποστηριχθεί ότι οι ομιλητές τους βρίσκονταν πολλές φορές στα ακραία όρια της αλληλοκατανόησης.

Μία από τις σημαντικότερες διαλέκτους της κλασικής εποχής ήταν η Αττική διάλεκτος, που χρησιμοποιούνταν κυρίως στην Αθήνα αλλά και ως γλώσσα των φιλοσόφων και των επιστημόνων. Η Αττική διάλεκτος προέρχεται από την Ιωνική (τη βασική διάλεκτο των Ομηρικών Επών) με αρκετές δωρικές επιδράσεις. Υιοθετήθηκε ως επίσημη γλώσσα όλης της Ελλάδας από τον Φίλιππο το Μακεδόνα και ως επίσημη γλώσσα ολόκληρου του ελληνιστικού κόσμου από τον γιο του Αλέξανδρο. Από αυτήν προέρχονται απ' ευθείας σχεδόν όλες οι μεταγενέστερες ελληνικές διάλεκτοι.

Αποτέλεσμα της χρήσης της αττικής διαλέκτου ως δεύτερης (και συχνά πρώτης) γλώσσας από πάρα πολλούς αλλόγλωσσους (αλλά και από ελληνόφωνους που μιλούσαν πρωτύτερα μια άλλη ελληνική διάλεκτο) ήταν σαρωτικές αλλαγές σε όλα τα επίπεδα της μορφολογίας της. Έτσι:

    * Η προφορά άλλαξε ριζικά με κυριότερο χαρακτηριστικό την προφορά των ει, η, υ, υι ως "ι" (ιωτακισμός) και την απώλεια των φθόγγων F (w) και H (δασεία).
    * Ο Δυϊκός αριθμός, το απαρέμφατο και η Μέση φωνή χάθηκαν.
    * Απλοποιήθηκε σημαντικά το σύστημα κλίσης ονομάτων και ρημάτων.

[Επεξεργασία]

Ελληνιστική Κοινή

Το αποτέλεσμα όλων αυτών των μεταβολών ήταν η Ελληνιστική Κοινή, η οποία μαρτυρείται κυρίως στην Καινή Διαθήκη. Είναι χαρακτηριστικό ότι την ίδια εποχή έχουμε και τους πρώτους Αττικιστές, αυτούς που θεωρούσαν απαραίτητη τη διατήρηση της "αυθεντικής" Αττικής Διαλέκτου, τουλάχιστον στο γραπτό λόγο.
[Επεξεργασία]

Μεσαιωνική Ελληνική

Η Ελληνιστική Κοινή εξελίχθηκε στη Μεσαιωνική Ελληνική, η οποία μαρτυρείται κυρίως από δημοτικά τραγούδια. Τελευταία φωνολογική μεταβολή κατά το 10ο αιώνα ήταν ο ιωτακισμός και του "οι" που ως τότε εξακολουθούσε να προφέρεται σα δίφθογγος.
[Επεξεργασία]

Νέα Ελληνική

Τα όρια μεταξύ Νέας Ελληνικής και Μεσαιωνικής Ελληνικής δεν είναι ιδιαίτερα σαφή, πάντως τοποθετούνται χονδρικά κάπου στα τελευταία χρόνια του Βυζαντίου. Κατά την περίοδο αυτή (καθώς και στην Τουρκοκρατία) είχαμε μία εξίσου έντονη διαλεκτική διαφοροποίηση η οποία συνεχίζονταν μέχρι πριν μερικές δεκαετίες.

Η σημερινή Νέα Ελληνική (Δημοτική) περιγράφεται με αρκετή σαφήνεια στη Γραμματική του Μανόλη Τριανταφυλλίδη. Η γραμματική της παραμένει αρκετά σύνθετη (ιδιαίτερα σε ό,τι αφορά το ρήμα όπου οι αρχαϊσμοί δε σπανίζουν καθόλου) και το λεξιλόγιό της είναι ιδιαίτερα πλούσιο.

Έχουν ειπωθεί πολλά για την αξία της ελληνικής γλώσσας. Πολλά από αυτά δεν είναι υπερβολές. Για παράδειγμα είναι γεγονός ότι χιλιάδες επιστημονικοί όροι στις ευρωπαϊκές γλώσσες είναι ελληνικά "δάνεια" (οι περισσότεροι είναι όροι που φτιάχθηκαν από ξένους σε μια εποχή που τα ελληνικά ήταν η κατ' εξοχήν ακαδημαϊκή γλώσσα). Ίσως η αξία της Ελληνικής αποδίδεται καλύτερα από τον Οδυσσέα Ελύτη:

Εδώ και τριάντα αιώνες, δεν υπήρξε ούτε ένας στον οποίο να μη γράφτηκε ποίηση στην Ελληνική Γλώσσα.
[Επεξεργασία]

Φωνητική


[Επεξεργασία]

Γραφή

Η πρώτη γραφή που αποδεδειγμένα χρησιμοποιήθηκε για τη γραφή της Ελληνικής γλώσσας είναι Γραμμική Β περίπου τον 15ο αιώνα π.Χ.. Τον 9ο αιώνα π.Χ. άρχισε να χρησιμοποιείται το Ελληνικό αλφάβητο, το οποίο με κάποιες αλλαγές χρησιμοποιείται και σήμερα.
[Επεξεργασία]

Βλέπε Επίσης

    * Γραμμική Α
    * Γραμμική Β
    * Καθαρεύουσα
    * Κατάλογος γλωσσών της Ελλάδας

[Επεξεργασία]

Εξωτερικές συνδέσεις

    * Abnet. Ο Κόμβος της Ελληνικής γλώσσας

Ανακτήθηκε από "http://el.wikipedia.org/wiki/%CE%95%CE%BB%CE%BB%CE%B7%CE%BD%CE%B9%CE%BA%CE%AE_%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1"

Κατηγορίες σελίδων: Γλώσσες της Ελλάδας | Ελληνικές γλώσσες
                                            //Copyright 2010 Microsoft Corporation
//
//Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. 
//You may obtain a copy of the License at 
//
//http://www.apache.org/licenses/LICENSE-2.0 
//
//Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an 
//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
//See the License for the specific language governing permissions and limitations under the License.



namespace System.Data.Services.Client
{
    #region Namespaces.

    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Reflection;

    #endregion Namespaces.

    internal class ProjectionPlanCompiler : ExpressionVisitor
    {
        #region Private fields.

        private readonly Dictionary<Expression, ExpressionAnnotation> annotations;

        private readonly ParameterExpression materializerExpression;

        private readonly Dictionary<Expression, Expression> normalizerRewrites;

        private int identifierId;

        private ProjectionPathBuilder pathBuilder;

        private bool topLevelProjectionFound;

        #endregion Private fields.

        #region Constructors.

        private ProjectionPlanCompiler(Dictionary<Expression, Expression> normalizerRewrites)
        {
            this.annotations = new Dictionary<Expression, ExpressionAnnotation>(ReferenceEqualityComparer<Expression>.Instance);
            this.materializerExpression = Expression.Parameter(typeof(object), "mat");
            this.normalizerRewrites = normalizerRewrites;
            this.pathBuilder = new ProjectionPathBuilder();
        }

        #endregion Constructors.

        #region Internal methods.

        internal static ProjectionPlan CompilePlan(LambdaExpression projection, Dictionary<Expression, Expression> normalizerRewrites)
        {
            Debug.Assert(projection != null, "projection != null");
            Debug.Assert(projection.Parameters.Count == 1, "projection.Parameters.Count == 1");
            Debug.Assert(
                projection.Body.NodeType == ExpressionType.Constant ||
                projection.Body.NodeType == ExpressionType.MemberInit ||
                projection.Body.NodeType == ExpressionType.MemberAccess ||
                projection.Body.NodeType == ExpressionType.Convert ||
                projection.Body.NodeType == ExpressionType.ConvertChecked ||
                projection.Body.NodeType == ExpressionType.New,
                "projection.Body.NodeType == Constant, MemberInit, MemberAccess, Convert(Checked) New");

            ProjectionPlanCompiler rewriter = new ProjectionPlanCompiler(normalizerRewrites);
#if TRACE_CLIENT_PROJECTIONS
            Trace.WriteLine("Projection: " + projection);
#endif

            Expression plan = rewriter.Visit(projection);
#if TRACE_CLIENT_PROJECTIONS
            Trace.WriteLine("Becomes: " + plan);
#endif

            ProjectionPlan result = new ProjectionPlan();
            result.Plan = (Func<object, object, Type, object>)((LambdaExpression)plan).Compile();
            result.ProjectedType = projection.Body.Type;
#if DEBUG
            result.SourceProjection = projection;
            result.TargetProjection = plan;
#endif
            return result;
        }

        internal override Expression VisitBinary(BinaryExpression b)
        {
            Expression original = this.GetExpressionBeforeNormalization(b);
            if (original == b)
            {
                return base.VisitBinary(b);
            }
            else
            {
                return this.Visit(original);
            }
        }

        internal override Expression VisitConditional(ConditionalExpression conditional)
        {
            Debug.Assert(conditional != null, "conditional != null");
            Expression original = this.GetExpressionBeforeNormalization(conditional);
            if (original != conditional)
            {
                return this.Visit(original);
            }

            var nullCheck = ResourceBinder.PatternRules.MatchNullCheck(this.pathBuilder.LambdaParameterInScope, conditional);
            if (!nullCheck.Match || !ClientType.CheckElementTypeIsEntity(nullCheck.AssignExpression.Type))
            {
                return base.VisitConditional(conditional);
            }

            return this.RebindConditionalNullCheck(conditional, nullCheck);
        }

        internal override Expression VisitUnary(UnaryExpression u)
        {
            Expression original = this.GetExpressionBeforeNormalization(u);
            Expression result;
            if (original == u)
            {
                result = base.VisitUnary(u);
                UnaryExpression unaryResult = result as UnaryExpression;
                if (unaryResult != null)
                {
                    ExpressionAnnotation annotation;
                    if (this.annotations.TryGetValue(unaryResult.Operand, out annotation))
                    {
                        this.annotations[result] = annotation;
                    }
                }
            }
            else
            {
                result = this.Visit(original);
            }

            return result;
        }

        internal override Expression VisitMemberAccess(MemberExpression m)
        {
            Debug.Assert(m != null, "m != null");

            Expression result;
            Expression baseSourceExpression = m.Expression;

            if (ClientConvert.IsKnownNullableType(baseSourceExpression.Type))
            {
                result = base.VisitMemberAccess(m);
            }
            else
            {
                Expression baseTargetExpression = this.Visit(baseSourceExpression);
                ExpressionAnnotation annotation;
                if (this.annotations.TryGetValue(baseTargetExpression, out annotation))
                {
                    result = this.RebindMemberAccess(m, annotation);
                }
                else
                {
                    result = Expression.MakeMemberAccess(baseTargetExpression, m.Member);
                }
            }

            return result;
        }

        internal override Expression VisitParameter(ParameterExpression p)
        {
            Debug.Assert(p != null, "p != null");

            Expression result;
            ExpressionAnnotation annotation;
            if (this.annotations.TryGetValue(p, out annotation))
            {
                result = this.RebindParameter(p, annotation);
            }
            else
            {
                result = base.VisitParameter(p);
            }

            return result;
        }

        internal override Expression VisitMemberInit(MemberInitExpression init)
        {
            this.pathBuilder.EnterMemberInit(init);
            
            Expression result = null;
            if (this.pathBuilder.CurrentIsEntity && init.Bindings.Count > 0)
            {
                result = this.RebindEntityMemberInit(init);
            }
            else
            {
                result = base.VisitMemberInit(init);
            }

            this.pathBuilder.LeaveMemberInit();
            return result;
        }

        internal override Expression VisitMethodCall(MethodCallExpression m)
        {
            Debug.Assert(m != null, "m != null");

            Expression original = this.GetExpressionBeforeNormalization(m);
            if (original != m)
            {
                return this.Visit(original);
            }

            Expression result;
            if (this.pathBuilder.CurrentIsEntity)
            {
                Debug.Assert(
                    ProjectionAnalyzer.IsMethodCallAllowedEntitySequence(m) || ResourceBinder.PatternRules.MatchReferenceEquals(m),
                    "ProjectionAnalyzer.IsMethodCallAllowedEntitySequence(m) || ResourceBinder.PatternRules.MatchReferenceEquals(m) -- otherwise ProjectionAnalyzer should have blocked this for entities");
                if (m.Method.Name == "Select")
                {
                    result = this.RebindMethodCallForMemberSelect(m);
                }
                else if (m.Method.Name == "ToList")
                {
                    result = this.RebindMethodCallForMemberToList(m);
                }
                else
                {
                    Debug.Assert(m.Method.Name == "ReferenceEquals", "We don't know how to handle this method, ProjectionAnalyzer updated?");
                    result = base.VisitMethodCall(m);
                }
            }
            else
            {
                if (ProjectionAnalyzer.IsMethodCallAllowedEntitySequence(m))
                {
                    result = this.RebindMethodCallForNewSequence(m);
                }
                else
                {
                    result = base.VisitMethodCall(m);
                }
            }

            return result;
        }

        internal override NewExpression VisitNew(NewExpression nex)
        {
            Debug.Assert(nex != null, "nex != null");

            if (ResourceBinder.PatternRules.MatchNewDataServiceCollectionOfT(nex))
            {
                return this.RebindNewExpressionForDataServiceCollectionOfT(nex);
            }

            return base.VisitNew(nex);
        }

        internal override Expression VisitLambda(LambdaExpression lambda)
        {
            Debug.Assert(lambda != null, "lambda != null");

            Expression result;
            if (!this.topLevelProjectionFound || lambda.Parameters.Count == 1 && ClientType.CheckElementTypeIsEntity(lambda.Parameters[0].Type))
            {
                this.topLevelProjectionFound = true;

                ParameterExpression expectedTypeParameter = Expression.Parameter(typeof(Type), "type" + this.identifierId);
                ParameterExpression entryParameter = Expression.Parameter(typeof(object), "entry" + this.identifierId);
                this.identifierId++;

                this.pathBuilder.EnterLambdaScope(lambda, entryParameter, expectedTypeParameter);
                ProjectionPath parameterPath = new ProjectionPath(lambda.Parameters[0], expectedTypeParameter, entryParameter);
                ProjectionPathSegment parameterSegment = new ProjectionPathSegment(parameterPath, null, null);
                parameterPath.Add(parameterSegment);
                this.annotations[lambda.Parameters[0]] = new ExpressionAnnotation() { Segment = parameterSegment };

                Expression body = this.Visit(lambda.Body);

                