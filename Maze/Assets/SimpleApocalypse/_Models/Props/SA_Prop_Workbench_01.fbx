"""Find modules used by a script, using introspection."""

from __future__ import generators
import dis
import imp
import marshal
import os
import sys
import types
import struct

if hasattr(sys.__stdout__, "newlines"):
    READ_MODE = "U"  # universal line endings
else:
    # Python < 2.3 compatibility, no longer strictly required
    READ_MODE = "r"

LOAD_CONST = dis.opmap['LOAD_CONST']
IMPORT_NAME = dis.opmap['IMPORT_NAME']
STORE_NAME = dis.opmap['STORE_NAME']
STORE_GLOBAL = dis.opmap['STORE_GLOBAL']
STORE_OPS = STORE_NAME, STORE_GLOBAL
HAVE_ARGUMENT = dis.HAVE_ARGUMENT
EXTENDED_ARG = dis.EXTENDED_ARG

def _unpack_opargs(code):
    # enumerate() is not an option, since we sometimes process
    # multiple elements on a single pass through the loop
    extended_arg = 0
    n = len(code)
    i = 0
    while i < n:
        op = ord(code[i])
        offset = i
        i = i+1
        arg = None
        if op >= HAVE_ARGUMENT:
            arg = ord(code[i]) + ord(code[i+1])*256 + extended_arg
            extended_arg = 0
            i = i+2
            if op == EXTENDED_ARG:
                extended_arg = arg*65536
        yield (offset, op, arg)

# Modulefinder does a good job at simulating Python's, but it can not
# handle __path__ modifications packages make at runtime.  Therefore there
# is a mechanism whereby you can register extra paths in this map for a
# package, and it will be honored.

# Note this is a mapping is lists of paths.
packagePathMap = {}

# A Public interface
def AddPackagePath(packagename, path):
    paths = packagePathMap.get(packagename, [])
    paths.append(path)
    packagePathMap[packagename] = paths

replacePackageMap = {}

# This ReplacePackage mechanism allows modulefinder to work around the
# way the _xmlplus package injects itself under the name "xml" into
# sys.modules at runtime by calling ReplacePackage("_xmlplus", "xml")
# before running ModuleFinder.

def ReplacePackage(oldname, newname):
    replacePackageMap[oldname] = newname


class Module:

    def __init__(self, name, file=None, path=None):
        self.__name__ = name
        self.__file__ = file
        self.__path__ = path
        self.__code__ = None
        # The set of global names that are assigned to in the module.
        # This includes those names imported through starimports of
        # Python modules.
        self.globalnames = {}
        # The set of starimports this module did that could not be
        # resolved, ie. a starimport from a non-Python module.
        self.starimports = {}

    def __repr__(self):
        s = "Module(%r" % (self.__name__,)
        if self.__file__ is not None:
            s = s + ", %r" % (self.__file__,)
        if self.__path__ is not None:
            s = s + ", %r" % (self.__path__,)
        s = s + ")"
        return s

class ModuleFinder:

    def __init__(self, path=None, debug=0, excludes=[], replace_paths=[]):
        if path is None:
            path = sys.path
        self.path = path
        self.modules = {}
        self.badmodules = {}
        self.debug = debug
        self.indent = 0
        self.excludes = excludes
        self.replace_paths = replace_paths
        self.processed_paths = []   # Used in debugging only

    def msg(self, level, str, *args):
        if level <= self.debug:
            for i in range(self.indent):
                print "   ",
            print str,
            for arg in args:
                print repr(arg),
            print

    def msgin(self, *args):
        level = args[0]
        if level <= self.debug:
            self.indent = self.indent + 1
            self.msg(*args)

    def msgout(self, *args):
        level = args[0]
        if level <= self.debug:
            self.indent = self.indent - 1
            self.msg(*args)

    def run_script(self, pathname):
        self.msg(2, "run_script", pathname)
        with open(pathname, READ_MODE) as fp:
            stuff = ("", "r", imp.PY_SOURCE)
            self.load_module('__main__', fp, pathname, stuff)

    def load_file(self, pathname):
        dir, name = os.path.split(pathname)
        name, ext = os.path.splitext(name)
        with open(pathname, READ_MODE) as fp:
            stuff = (ext, "r", imp.PY_SOURCE)
            self.load_module(name, fp, pathname, stuff)

    def import_hook(self, name, caller=None, fromlist=None, level=-1):
        self.msg(3, "import_hook", name, caller, fromlist, level)
        parent = self.determine_parent(caller, level=level)
        q, tail = self.find_head_package(parent, name)
        m = self.load_tail(q, tail)
        if not fromlist:
            return q
        if m.__path__:
            self.ensure_fromlist(m, fromlist)
        return None

    def determine_parent(self, caller, level=-1):
        self.msgin(4, "determine_parent", caller, level)
        if not caller or level == 0:
            self.msgout(4, "determine_parent -> None")
            return None
        pname = caller.__name__
        if level >= 1: # relative import
            if caller.__path__:
                level -= 1
            if level == 0:
                parent = self.modules[pname]
                assert parent is caller
                self.msgout(4, "determine_parent ->", parent)
                return parent
            if pname.count(".") < level:
                raise ImportError, "relative importpath too deep"
            pname = ".".join(pname.split(".")[:-level])
            parent = self.modules[pname]
            self.msgout(4, "determine_parent ->", parent)
            return parent
        if caller.__path__:
            parent = self.modules[pname]
            assert caller is parent
            self.msgout(4, "determine_parent ->", parent)
            return parent
        if '.' in pname:
            i = pname.rfind('.')
            pname = pname[:i]
            parent = self.modules[pname]
            assert parent.__name__ == pname
            self.msgout(4, "determine_parent ->", parent)
            return parent
        self.msgout(4, "determine_parent -> None")
        return None

    def find_head_package(self, parent, name):
        self.msgin(4, "find_head_package", parent, name)
        if '.' in name:
            i = name.find('.')
            head = name[:i]
            tail = name[i+1:]
        else:
            head = name
            tail = ""
        if parent:
            qname = "%s.%s" % (parent.__name__, head)
        else:
            qname = head
        q = self.import_module(head, qname, parent)
        if q:
            self.msgout(4, "find_head_package ->", (q, tail))
            return q, tail
        if parent:
            qname = head
            parent = None
            q = self.import_module(head, qname, parent)
            if q:
                self.msgout(4, "find_head_package ->", (q, tail))
                return q, tail
        self.msgout(4, "raise ImportError: No module named", qname)
        raise ImportError, "No module named " + qname

    def load_tail(self, q, tail):
        self.msgin(4, "load_tail", q, tail)
        m = q
        while tail:
            i = tail.find('.')
            if i < 0: i = len(tail)
            head, tail = tail[:i], tail[i+1:]
            mname = "%s.%s" % (m.__name__, head)
            m = self.import_module(head, mname, m)
            if not m:
                self.msgout(4, "raise ImportError: No module named", mname)
                raise ImportError, "No module named " + mname
        self.msgout(4, "load_tail ->", m)
        return m

    def ensure_fromlist(self, m, fromlist, recursive=0):
        self.msg(4, "ensure_fromlist", m, fromlist, recursive)
        for sub in fromlist:
            if sub == "*":
                if not recursive:
                    all = self.find_all_submodules(m)
                    if all:
                        self.ensure_fromlist(m, all, 1)
            elif not hasattr(m, sub):
                subname = "%s.%s" % (m.__name__, sub)
                submod = self.import_module(sub, subname, m)
                if not submod:
                    raise ImportError, "No module named " + subname

    def find_all_submodules(self, m):
        if not m.__path__:
            return
        modules = {}
        # 'suffixes' used to be a list hardcoded to [".py", ".pyc", ".pyo"].
        # But we must also collect Python extension modules - although
        # we cannot separate normal dlls from Python extensions.
        suffixes = []
        for triple in imp.get_suffixes():
            suffixes.append(triple[0])
        for dir in m.__path__:
            try:
                names = os.listdir(dir)
            except os.error:
                self.msg(2, "can't list directory", dir)
                continue
            for name in names:
                mod = None
                for suff in suffixes:
                    n = len(suff)
                    if name[-n:] == suff:
                        mod = name[:-n]
                        break
                if mod and mod != "__init__":
                    modules[mod] = mod
        return modules.keys()

    def import_module(self, partname, fqname, parent):
        self.msgin(3, "import_module", partname, fqname, parent)
        try:
            m = self.modules[fqname]
        except KeyError:
            pass
        else:
            self.msgout(3, "import_module ->", m)
            return m
        if fqname in self.badmodules:
            self.msgout(3, "import_module -> None")
            return None
        if parent and parent.__path__ is None:
            self.msgout(3, "import_module -> None")
            return None
        try:
            fp, pathname, stuff = self.find_module(partname,
                                                   parent and parent.__path__, parent)
        except ImportError:
            self.msgout(3, "import_module ->", None)
            return None
        try:
            m = self.load_module(fqname, fp, pathname, stuff)
        finally:
            if fp: fp.close()
        if parent:
            setattr(parent, partname, m)
        self.msgout(3, "import_module ->", m)
        return m

    def load_module(self, fqname, fp, pathname, file_info):
        suffix, mode, type = file_info
        self.msgin(2, "load_module", fqname, fp and "fp", pathname)
        if type == imp.PKG_DIRECTORY:
            m = self.load_package(fqname, pathname)
            self.msgout(2, "load_module ->", m)
            return m
        if type == imp.PY_SOURCE:
            co = compile(fp.read()+'\n', pathname, 'exec')
        elif type == imp.PY_COMPILED:
            if fp.read(4) != imp.get_magic():
                self.msgout(2, "raise ImportError: Bad magic number", pathname)
                raise ImportError, "Bad magic number in %s" % pathname
            fp.read(4)
            co = marshal.load(fp)
        else:
            co = None
        m = self.add_module(fqname)
        m.__file__ = pathname
        if co:
            if self.replace_paths:
                co = self.replace_paths_in_code(co)
            m.__code__ = co
            self.scan_code(co, m)
        self.msgout(2, "load_module ->", m)
        return m

    def _add_badmodule(self, name, caller):
        if name not in self.badmodules:
            self.badmodules[name] = {}
        if caller:
            self.badmodules[name][caller.__name__] = 1
        else:
            self.badmodules[name]["-"] = 1

    def _safe_import_hook(self, name, caller, fromlist, level=-1):
        # wrapper for self.import_hook() that won't raise ImportError
        if name in self.badmodules:
            self._add_badmodule(name, caller)
            return
        try:
            self.import_hook(name, caller, level=level)
        except ImportError, msg:
            self.msg(2, "ImportError:", str(msg))
            self._add_badmodule(name, caller)
        else:
            if fromlist:
                for sub in fromlist:
                    if sub in self.badmodules:
                        self._add_badmodule(sub, caller)
                        continue
                    try:
                        self.import_hook(name, caller, [sub], level=level)
                    except ImportError, msg:
                        self.msg(2, "ImportError:", str(msg))
                        fullname = name + "." + sub
                        self._add_badmodule(fullname, caller)

    def scan_opcodes(self, co,
                     unpack = struct.unpack):
        # Scan the code, and yield 'interesting' opcode combinations
        # Version for Python 2.4 and older
        code = co.co_code
        names = co.co_names
        consts = co.co_consts
        opargs = [(op, arg) for _, op, arg in _unpack_opargs(code)
                  if op != EXTENDED_ARG]
        for i, (op, oparg) in enumerate(opargs):
            if c in STORE_OPS:
                yield "store", (names[oparg],)
                continue
            if (op == IMPORT_NAME and i >= 1
                    and opargs[i-1][0] == LOAD_CONST):
                fromlist = consts[opargs[i-1][1]]
                yield "import", (fromlist, names[oparg])
                continue

    def scan_opcodes_25(self, co):
        # Scan the code, and yield 'interesting' opcode combinations
        code = co.co_code
        names = co.co_names
        consts = co.co_consts
        opargs = [(op, arg) for _, op, arg in _unpack_opargs(code)
                  if op != EXTENDED_ARG]
        for i, (op, oparg) in enumerate(opargs):
            if op in STORE_OPS:
                yield "store", (names[oparg],)
                continue
            if (op == IMPORT_NAME and i >= 2
                    and opargs[i-1][0] == opargs[i-2][0] == LOAD_CONST):
                level = consts[opargs[i-2][1]]
                fromlist = consts[opargs[i-1][1]]
                if level == -1: # normal import
                    yield "import", (fromlist, names[oparg])
                elif level == 0: # absolute import
                    yield "absolute_import", (fromlist, names[oparg])
                else: # relative import
                    yield "relative_import", (level, fromlist, names[oparg])
                continue

    def scan_code(self, co, m):
        code = co.co_code
        if sys.version_info >= (2, 5):
            scanner = self.scan_opcodes_25
        else:
            scanner = self.scan_opcodes
        for what, args in scanner(co):
            if what == "store":
                name, = args
                m.globalnames[name] = 1
            elif what in ("import", "absolute_import"):
                fromlist, name = args
                have_star = 0
                if fromlist is not None:
                    if "*" in fromlist:
                        have_star = 1
                    fromlist = [f for f in fromlist if f != "*"]
                if what == "absolute_import": level = 0
                else: level = -1
                self._safe_import_hook(name, m, fromlist, level=level)
                if have_star:
                    # We've encountered an "import *". If it is a Python module,
                    # the code has already been parsed and we can suck out the
                    # global names.
                    mm = None
                    if m.__path__:
                        # At this point we don't know whether 'name' is a
                        # submodule of 'm' or a global module. Let's just try
                        # the full name first.
                        mm = self.modules.get(m.__name__ + "." + name)
                    if mm is None:
                        mm = self.modules.get(name)
                    if mm is not None:
                        m.globalnames.update(mm.globalnames)
                        m.starimports.update(mm.starimports)
                        if mm.__code__ is None:
                            m.starimports[name] = 1
                    else:
                        m.starimports[name] = 1
            elif what == "relative_import":
                level, fromlist, name = args
                if name:
                    self._safe_import_hook(name, m, fromlist, level=level)
                else:
                    parent = self.determine_parent(m, level=level)
                    self._safe_import_hook(parent.__name__, None, fromlist, level=0)
            else:
                # We don't expect anything else from the generator.
                raise RuntimeError(what)

        for c in co.co_consts:
            if isinstance(c, type(co)):
                self.scan_code(c, m)

    def load_package(self, fqname, pathname):
        self.msgin(2, "load_package", fqname, pathname)
        newname = replacePackageMap.get(fqname)
        if newname:
            fqname = newname
        m = self.add_module(fqname)
        m.__file__ = pathname
        m.__path__ = [pathname]

        # As per comment at top of file, simulate runtime __path__ additions.
        m.__path__ = m.__path__ + packagePathMap.get(fqname, [])

        fp, buf, stuff = self.find_module("__init__", m.__path__)
        self.load_module(fqname, fp, buf, stuff)
        self.msgout(2, "load_package ->", m)
        if fp:
            fp.close()
        return m

    def add_module(self, fqname):
        if fqname in self.modules:
            return self.modules[fqname]
        self.modules[fqname] = m = Module(fqname)
        return m

    def find_module(self, name, path, parent=None):
        if parent is not None:
            # assert path is not None
            fullname = parent.__name__+'.'+name
        else:
            fullname = name
        if fullname in self.excludes:
            self.msgout(3, "find_module -> Excluded", fullname)
            raise ImportError, name

        if path is None:
            if name in sys.builtin_module_names:
                return (None, None, ("", "", imp.C_BUILTIN))

            path = self.path
        return imp.find_module(name, path)

    def report(self):
        """Print a report to stdout, listing the found modules with their
        paths, as well as modules that are missing, or seem to be missing.
        """
        print
        print "  %-25s %s" % ("Name", "File")
        print "  %-25s %s" % ("----", "----")
        # Print modules found
        keys = self.modules.keys()
        keys.sort()
        for key in keys:
            m = self.modules[key]
            if m.__path__:
                print "P",
            else:
                print "m",
            print "%-25s" % key, m.__file__ or ""

        # Print missing modules
        missing, maybe = self.any_missing_maybe()
        if missing:
            print
            print "Missing modules:"
            for name in missing:
                mods = self.badmodules[name].keys()
                mods.sort()
                print "?", name, "imported from", ', '.join(mods)
        # Print modules that may be missing, but then again, maybe not...
        if maybe:
            print
            print "Submodules that appear to be missing, but could also be",
            print "global names in the parent package:"
            for name in maybe:
                mods = self.badmodules[name].keys()
                mods.sort()
                print "?", name, "imported from", ', '.join(mods)

    def any_missing(self):
        """Return a list of modules that appear to be missing. Use
        any_missing_maybe() if you want to know which modules are
        certain to be missing, and which *may* be missing.
        """
        missing, maybe = self.any_missing_maybe()
        return missing + maybe

    def any_missing_maybe(self):
        """Return two lists, one with modules that are certainly missing
        and one with modules that *may* be missing. The latter names could
        either be submodules *or* just global names in the package.

        The reason it can't always be determined is that it's impossible to
        tell which names are imported when "from module import *" is done
        with an extension module, short of actually importing it.
        """
        missing = []
        maybe = []
        for name in self.badmodules:
            if name in self.excludes:
                continue
            i = name.rfind(".")
            if i < 0:
                missing.append(name)
                continue
            subname = name[i+1:]
            pkgname = name[:i]
            pkg = self.modules.get(pkgname)
            if pkg is not None:
                if pkgname in self.badmodules[name]:
                    # The package tried to import this module itself and
                    # failed. It's definitely missing.
                    missing.append(name)
                elif subname in pkg.globalnames:
                    # It's a global in the package: definitely not missing.
                    pass
                elif pkg.starimports:
                    # It could be missing, but the package did an "import *"
                    # from a non-Python module, so we simply can't be sure.
                    maybe.append(name)
                else:
                    # It's not a global in the package, the package didn't
                    # do funny star imports, it's very likely to be missing.
                    # The symbol could be inserted into the package from the
                    # outside, but since that's not good style we simply list
                    # it missing.
                    missing.append(name)
            else:
                missing.append(name)
        missing.sort()
        maybe.sort()
        return missing, maybe

    def replace_paths_in_code(self, co):
        new_filename = original_filename = os.path.normpath(co.co_filename)
        for f, r in self.replace_paths:
            if original_filename.startswith(f):
                new_filename = r + original_filename[len(f):]
                break

        if self.debug and original_filename not in self.processed_paths:
            if new_filename != original_filename:
                self.msgout(2, "co_filename %r changed to %r" \
                                    % (original_filename,new_filename,))
            else:
                self.msgout(2, "co_filename %r remains unchanged" \
                                    % (original_filename,))
            self.processed_paths.append(original_filename)

        consts = list(co.co_consts)
        for i in range(len(consts)):
            if isinstance(consts[i], type(co)):
                consts[i] = self.replace_paths_in_code(consts[i])

        return types.CodeType(co.co_argcount, co.co_nlocals, co.co_stacksize,
                         co.co_flags, co.co_code, tuple(consts), co.co_names,
                         co.co_varnames, new_filename, co.co_name,
                         co.co_firstlineno, co.co_lnotab,
                         co.co_freevars, co.co_cellvars)


def test():
    # Parse command line
    import getopt
    try:
        opts, args = getopt.getopt(sys.argv[1:], "dmp:qx:")
    except getopt.error, msg:
        print msg
        return

    # Process options
    debug = 1
    domods = 0
    addpath = []
    exclude = []
    for o, a in opts:
        if o == '-d':
            debug = debug + 1
        if o == '-m':
            domods = 1
        if o == '-p':
            addpath = addpath + a.split(os.pathsep)
        if o == '-q':
            debug = 0
        if o == '-x':
            exclude.append(a)

    # Provide default arguments
    if not args:
        script = "hello.py"
    else:
        script = args[0]

    # Set the path based on sys.path and the script directory
    path = sys.path[:]
    path[0] = os.path.dirname(script)
    path = addpath + path
    if debug > 1:
        print "path:"
        for item in path:
            print "   ", repr(item)

    # Create the module finder and turn its crank
    mf = ModuleFinder(path, debug, exclude)
    for arg in args[1:]:
        if arg == '-m':
            domods = 1
            continue
        if domods:
            if arg[-2:] == '.*':
                mf.import_hook(arg[:-2], None, ["*"])
            else:
                mf.import_hook(arg)
        else:
            mf.load_file(arg)
    mf.run_script(script)
    mf.report()
    return mf  # for -i debugging


if __name__ == '__main__':
    try:
        mf = test()
    except KeyboardInterrupt:
        print "\n[interrupt]"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ﬂRæÏéeH-∫_ëèP≥ìˇe?ø-òçı—ˆs√£©ö˜qô˝çãıªõ¨-˜
-‚]sã°=Î=«GiÌ¥≥P®Õäó˛+T «}<[-Pô†‰÷ÃûÆ,XÁå÷©Ò‡ëKd˛W‘MŒŒfÙdlmÉˇhÙR]û^`®Y!«à!;]eM˚pÑ4r{,÷l•˝	}ÌOö∏]…˛ó!â/~‘¡kW˜¿yæ òM\⁄/©˘8Á+PhÃõf˙{9è«Z±˘ºìm‡ﬂ¥wÒ£ÔZ∂äwu˚[;èJ˝¢Úì˙'¬ÿc¸0¸R7X∆’[JV∏MéPµcO.“¡¸¸Û„œ≤edo2?F#∫E∏*ed8M≥∞jËÿ2*µ∞∏ôÓ∫È^ªº–Ã/9ƒ3HÆ´ÄPı ,.û˙rÓfPﬁDe]øj≤}LGO] <ÌHvIã6d˚°”f˘WX€®i“ºëÊàuìM€"æÊ	.X¥ÕMÁ	[˛"È;˚Ëá8ö¨oΩìçΩ’ÇÄ¬A”Œ«u›∂mˆ€á\®ÑÔîyb»E9S£úS›˜Â:ñ‡_(¯ç¿“◊˘—]iI,QÏ%â-€åy∏W|bÓzéí¸‘h,ﬁˇEø†ùøuˆGŸ4Ò<B«Ø#•k&fqöÎŸ'Ùóe|4SQ˘⁄ÃsÃ){£}ΩëúÈLùà«÷∏ÅC"[¥(ê"j-]Üeñ,$ñÿf±Fk3•⁄	B9Ô¸\ı¢$ı:ÃU)ï|˛ge4∞Á4Dõ¥¯¢ƒ>lîQp]Y2É_ÿ.`œöDVp:Ç“€='#ÜOx“’âÕ•ÅÇ4y7>;›˜’ uë
·ƒøƒN70'‰ı‰cAt‡}á‰ççî›`ÇJùEv‹¸IÂ'Ö¸~†µy≈Ω?◊Äh˝ÏTeè GPÛN~âmr”Ô7˛∞≥âoñÇGP_
ì!ÕçÚ∫P>ƒ*Û%¢ì»êÙ˘>2˝hÈ∫Òcöç ˝◊h Wˇnrû4u8&3ﬂa˙Mº_ö1Œk£ÉP≈Óìì?%∂7h^ª1·ªjp¯†0P6¶MõõY˜√ex… ﬁZ”xÂU_ Ê[x”c“ÿ5E¶éxÜ7Ø#·˜4ev7zÈU¿WΩ∏ 8f8ˆ#—á £ﬂÃØ›1ääXo¸·÷"C§Ëü≈Ulf·≠BÜÑMêgÈãŸÀ•r®{$wFqÎÄŒ·„˚Ê§áU1Üœíı‚≤~Õ=©Ìé>^h}[sìı;ßñ%Uá“Y◊yn›‡æ&Èﬂ¬ª‡î–«àüO8ì˛±µ”Ø◊"Á6¨§IûOÊœ:.i˘ «[è˝X˜ˇ˜!IzÏﬁ_»oqÙÓ+j_BZÈ≠‹ÊæîCîo/ΩVŒpùÚ∑Å3øbN=ª ⁄…58È∏∑‡%;˚ﬁ¥FéxøY◊¥Zñ√C˝?=›4á_âÂÊ∞ˆ´ßãÑé«≥ı WFÃ,¡Ωÿ∆K”–g “Q&AE¥„’©AeŒΩÆF`ÊÜc™CØT£Ú•πÉk“lDöÏõQ˜≤Œ ¿mæ„¬”∑J⁄tJ◊yÂ˘ú(LﬂÌ§‘N √8‹ÏXµDÂ∏Ãl™—õ∆ª?≠Î÷5ﬂ√°O!Ç≠”+®»2÷lÛ<Ô7‹>¥÷å.Ï€Cı˛€íÃMÓπ'∆≠>Ä’Gg†yÿãeo@TBÍ®S:=oyt™TîóÈáJ3Ë§˙πæ∏m≥R£˝y=e"„j^F]••D€ WFÄ"†]pŒ…ÇŸa	ñ-Íı∑¢√øI±ÆYVyìï#ÒøvˇœwÍ∑àh°∫$ÜÔFvßÒóùB¡ˇ¬p˘éÔØA^Ùo√ ’u’Ÿÿ¸L¡Ωké¥ø0¡à0Gf§Ãü˜%<ƒ¬sêè˛≥≤ Uøæ&é„˜˚QHÕyÿº∫7ÊS¡óJ%e	¨Ï–¨Ÿ\G0•ÔLïNØ'W“£ôt˙˜_Mõ#]"$·
róÏ"Ú˘”$¥d¢¡^À^∆u[ü	†PSÍ»€V?fcÒq’7ÖFs◊Â[ÊÒáN˙«ÛPôB1Â
8#Ø≥-õOÉº^ÔZÁZ“πﬁ¨èkÔ¬Èåá‹)vâCû¬Ëüè.cS}Ìâ˙Q‘ TAªF≥,;Â»ÚŸëR‰á”{qÙ≈ﬁAsLlM∂f¨I˝[4˚özPq; 2‡ûŸaàÈ+-O}£»°Ï¡*f87Ω≥Ç±‰M1Z€ HX0∂;$óGNKÈQ∑uF… º⁄©≠ÿJ›‹\ú=Œ∂„ß^A`ë◊[x˙ò∆⁄X™Å*Ÿ6‰Æ]kuŒÅ"7ªD+ßÃ≥◊µ¡¿aªÓ˘ë6B¨A◊˝ıeˆ!N˘âA>úz¥lÉ?eFã¶±`°57-HaMOﬁËàjÂ∂£“Œqª¨HÚ∞UñSeãœçÀNüchí)≠S™ƒíhïƒÖßÂÍª±|`gìpµƒ€Yá§›N˝Ym¿ôPÇt†∂ÜﬁŸ\ˆÿπ”Öâá:ñFØ-h:˝¨z®#ÒÊëT c∏p◊p{É/ÃÁ˚îµ¯Â`⁄õu†≠788¬E/«Ÿ˛ç◊¿LY;G¶ºﬁÏ‹∆1g<0ˇøn≈~Æ1˘æüiœ¥¥%;Í7¥*+QË\⁄"xi≤UMÀ;[üNl 'v‘U.Ídò’Ÿ`b£‚x¡Ÿˇ„%‚ı¿XÜzoıPDtURıÿäÛ,ÿ,ìI|
—˘√üÈBª¬±ã@\|≥"=¶•∞‰ëD†Ä uñ<∏-òÕ_j6Ò'Ó∑¨¨X¡ÂÜ≤e8—AB‡êÅ‘èL‚!“é√èÖŸ„
ùLÍq{ SêãÂ"˚ÓÜ˛£#ÑY	ºO$LŸïY.õıX3ãH‘3Nl«≥ﬁ˝Kπ
}ãJæµiºﬁÑÍ÷+aêíe)<n<B*ËáköÅl €1ÅÀKrE”+"Æs≥GIÓG–a@≈Ê mû⁄Å)iCœ´Ã=¯íπ£’FËä5wã¶´dñ~*Xù]∑ =Œ=.\˚Ó¥DóøÎ7ÇGçl@?"á˘∏∂·QS·—6Èt◊˙XK;Í“UõÜ£ıE&§Zìâ);©âÅ‘y€]Ow™G◊3‘«Jä‘ÇÄœY‚Ì8®˘P:h‘ì¡÷ö±º ˛7£GPÚ<”∑S≥L*FôÒ‚ÿwYú¶⁄√=è$ØÎ£œÈ£E`ﬁP^ë‡:,’tAû≠¶ˇ?8U3zSÎ '¯Ôá’jï„3≤≤_ìQÉj60ßh:‘–A\	ÏâBmîp>i√}´f◊é<9ÕqN«16_Ã¥Ön•¯q°¥?sõo∫∑êÿ≈,Ç÷√ÏÔ<!îmBkŒªb'n∏d√˛tÍÍ‚˚©q `í†Ç≠‘N”∂aä?ëô3.ø¥˝™5èÿw6ˆªµN€ÿªk"7»ú∂/¨ç-˙ËêÇ1µ≠FëHÇMcŒπÜxñ^à8hë§£“…Y»¥nõétpUk*D„íÂ“5ÁC#˛£â:«>—ŒæµØ`Æ»Ö\ÑÿoÔM…3É≥åäGÆÿø¥∞ñ0f˜¸Âc‘}Üç⁄DH‘≤Ω‚AvSµ›A0lW‰ø≥|`˝∂”Ù›üﬁ`)üOQ‚å=ñ~∑‰Ìà‡»zpªLŸ¨€é
Ui(å/c§E‚ÑìCF≥´O–ÿ.˝¿JvÍÂm·π˘.+∆Zãs™M«!¨7NLj]D—ñÌÿ]MıKÕé™ºÛFq“6¯uT1Î§†∂™›÷Ë˜$T=cˆKé˙û€8äåü≈&Lj™|tÆ-§Â¥›U˘\§¸Q‡6‰⁄DÖˆ’cu˘ jŒ≥ù Ô√¬˚.çí©TÂG(à-í2˛œ)πU0·K4'#ZÛé¢◊ûâzï§›"ﬂ±"·˚r’è‹‰Í©:œ˙;*G∫.UÁ¡8Â˝ 
¥’[éÊ°Í∞.ëPEûÊ≥˝√)"G†Ø∫«âPNG

   IHDR         Ûˇa   	pHYs     öú  
OiCCPPhotoshop ICC profile  x⁄ùSgTSÈ=˜ﬁÙBKàÄîKoR RBãÄë&*!	Jà!°ŸQ¡EE»†àééÄåQ,ä
ÿ‰!¢éÉ£àä ˚·{£k÷º˜ÊÕ˛µ◊>Á¨Ûù≥œ¿ñH3Q5Ä©B‡É«ƒ∆·‰.@Å
$p ≥d!s˝# ¯~<<+"¿æ x” ¿Mõ¿0áˇÍBô\ÄÑ¿të8KÄ @zéB¶ @FÄùò&S † `Àcb„ P- `'Ê” Äù¯ô{ [î!†ë  eàD h; ¨œVäE X0 fKƒ9 ÿ- 0IWfH ∞∑ ¿Œ≤  0QàÖ) { `»##x Ñô FÚW<Ò+ÆÁ*  xô≤<π$9EÅ[-qWW.(ŒI+6aaö@.¬yô2Å4‡ÛÃ  †ë‡ÉÛ˝xŒÆŒŒ6é∂_-Íøˇ"bb„˛Âœ´p@  ·t~—˛,/≥Ä;Äm˛¢%Óh^†u˜ãf≤@µ †È⁄WÛp¯~<<E°êπŸŸÂ‰‰ÿJƒB[a W}˛g¬_¿W˝l˘~<¸˜ı‡æ‚$Å2]ÅG¯‡¬ÃÙL•œí	Ñb‹ÊèG¸∑ˇ¸”"ƒIbπX*„QqéDöåÛ2•"âBí)≈%“ˇd‚ﬂ,˚>ﬂ5 ∞j>{ë-®]cˆK'Xt¿‚˜  Úªo¡‘(ÄhÉ·œwˇÔ?˝G†% ÄfIíq  ^D$.T ≥?«  D†Å*∞AÙ¡,¿¡‹¡¸`6ÑB$ƒ¬BB
dÄr`)¨ÇB(ÜÕ∞*`/‘@4¿QhÜìp.¬U∏=p˙aû¡(ºÅ	A»a!⁄àbäX#éôÖ¯!¡Hã$ …àQ"Kë5H1RäT UHÚ=r9á\F∫ë;» 2Ç¸ÜºG1îÅ≤Q=‘µCπ®7ÑF¢–dt1öè†õ–r¥=å6°Á–´h⁄è>C«0¿Ë3ƒl0.∆√B±8,	ìcÀ±"¨´∆∞V¨ªâıcœ±wÅE¿	6wB aAHXLXNÿH® $4⁄	7	ÑQ¬'"ì®K¥&∫˘ƒb21áXH,#÷è/{àCƒ7$âC2'πêI±§T““F“nR#È,©õ4H#ì…⁄dk≤9î, +»Ö‰ù‰√‰3‰‰!Ú[
ùb@q§¯S‚(R jJÂÂ4Âeò2AU£öR›®°T5èZB≠°∂RØQá®4uö9ÕÉIK•≠¢ï”hh˜iØËt∫›ïNó–W“ÀÈGËóËÙwÜÉ«àg(õgwØòL¶”ã«T071ÎòÁôôoUX*∂*|ë 
ïJï&ï*/T©™¶™ﬁ™UÛUÀTè©^S}ÆFU3S„©	‘ñ´U™ùPÎSSg©;®á™g®oT?§~Y˝âY√L√OC§Q†±_„º∆ c≥x,!k´ÜuÅ5ƒ&±ÕŸ|v*ªò˝ªã=™©°9C3J3W≥RÛîf?„òq¯útN	Á(ßóÛ~äﬁÔ)‚)¶4Lπ1e\k™ñóñX´H´Q´GÎΩ6ÆÌßù¶ΩEªY˚ÅA«J'\'GgèŒùÁSŸS›ß
ßM=:ıÆ.™k•°ªDwønßÓòûæ^ÄûLoßﬁyΩÁ˙}/˝T˝m˙ßıGX≥$€Œ<≈5qo</«€ÒQC]√@C•aïaó·Ñëπ—<£’FçFåi∆\„$„m∆m∆£&&!&KMÍMÓöRMπ¶)¶;L;L«ÕÃÕ¢Õ÷ô5õ=1◊2ÁõÁõ◊õﬂ∑`ZxZ,∂®∂∏eI≤‰Z¶YÓ∂ºnÖZ9Y•XUZ]≥F≠ù≠%÷ª≠ªßßπNìN´û÷g√∞Ò∂…∂©∑∞Âÿ€Æ∂m∂}agbg∑≈Æ√ÓìΩì}∫}ç˝=áŸ´Z~s¥r:V:ﬁöŒúÓ?}≈ÙñÈ/gXœœÿ3„∂À)ƒiùSõ”GggπsÉÛàãâKÇÀ.ó>.õ∆›»Ω‰Jtıq]·z“ıùõ≥õ¬Ì®€ØÓ6ÓiÓá‹üÃ4ü)ûY3s–√»C‡QÂ—?üï0kﬂ¨~OCOÅgµÁ#/c/ëW≠◊∞∑•w™˜aÔ>ˆ>rü„>„<7ﬁ2ﬁY_Ã7¿∑»∑ÀO√oû_ÖﬂC#ˇdˇzˇ— ßÄ%gâÅAÅ[˚¯z|!øé?:€eˆ≤ŸÌAå†πAAèÇ≠ÇÂ¡≠!h»Ïê≠!˜ÁòŒëŒiÖP~Ë÷–aÊaã√~'ÖáÖWÜ?épàX—1ó5w—‹CsﬂD˙DñDﬁõg1O9Ø-J5*>™.j<⁄7∫4∫?∆.fYÃ’XùXIlK9.*Æ6nlæﬂ¸ÌÛá‚ù‚„{ò/»]py°Œ¬ÙÖß©.,:ñ@LàN8îA*®å%Úw%é
y¬¬g"/—6—àÿC\*NÚH*MzíÏëº5y$≈3•,ÂπÑ'©êºLL›õ:ûöv m2=:Ω1ÉíëêqB™!Mì∂gÍgÊfvÀ¨eÖ≤˛≈nã∑/ï…k≥ê¨Y-
∂B¶ËTZ(◊*≤geWføÕâ 9ñ´û+ÕÌÃ≥ €ê7úÔüˇÌ¬·í∂•ÜKW-XÊΩ¨j9≤<qy€
„+ÜV¨<∏ä∂*m’O´ÌWóÆ~Ω&zMkÅ^¡ Ç¡µkÎU
ÂÖ}Î‹◊Ì]OX/Yﬂµa˙Üù>âäÆ€óÿ(‹xÂáo øô‹î¥©´ƒπdœf“fÈÊﬁ-û[ñ™óÊónŸ⁄¥ﬂV¥ÌıˆE€/óÕ(€ªÉ∂Cπ£ø<∏ºeß…ŒÕ;?T§TÙT˙T6Ó“›µa◊¯n—Ó{ºˆ4Ï’€[º˜˝>…æ€UUM’f’e˚I˚≥˜?Æâ™È¯ñ˚m]≠NmqÌ«“˝#∂◊π‘’“=TRè÷+ÎG«æ˛ùÔw-6Uçú∆‚#pDy‰È˜	ﬂ˜:⁄vå{¨·”vg/jBöÚöFõSö˚[b[∫OÃ>—÷Íﬁz¸G€ú4<YyJÛT…i⁄ÈÇ”ìgÚœåùïù}~.˘‹`€¢∂{ÁcŒﬂjoÔ∫t·“EˇãÁ;º;Œ\Ú∏tÚ≤€ÂW∏WöØ:_mÍtÍ<˛ì”O«ªúªöÆπ\kπÓzΩµ{f˜Èû7Œ›ÙΩyÒˇ÷’û9=›ΩÛzo˜≈˜ıﬂ›~r'˝ŒÀªŸw'Ó≠ºOº_Ù@ÌAŸC›á’?[˛‹ÿÔ‹j¿w†Û—‹G˜ÖÉœ˛ëıèCèôèÀÜÜÎû8>99‚?r˝È¸ßCœdœ&û˛¢˛ÀÆ/~¯’Î◊Œ—ò—°óÚóìøm|•˝Í¿ÎØ€∆¬∆æ…x31^ÙV˚Ì¡w‹wÔ£ﬂO‰| (ˇh˘±ıS–ß˚ìììˇòÛ¸c3-€  BiTXtXML:com.adobe.xmp     <?xpacket begin="Ôªø" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.5-c014 79.151481, 2013/03/13-12:09:15        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/"
            xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/"
            xmlns:stEvt="http://ns.adobe.com/xap/1.0/sType/ResourceEvent#"
            xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/"
            xmlns:dc="http://purl.org/dc/elements/1.1/"
            xmlns:tiff="http://ns.adobe.com/tiff/1.0/"
            xmlns:exif="http://ns.adobe.com/exif/1.0/">
         <xmp:CreatorTool>Adobe Photoshop CC (Windows)</xmp:CreatorTool>
         <xmp:CreateDate>2013-09-23T16:57:54+01:00</xmp:CreateDate>
         <xmp:MetadataDate>2013-09-23T16:57:54+01:00</xmp:MetadataDate>
         <xmp:ModifyDate>2013-09-23T16:57:54+01:00</xmp:ModifyDate>
         <xmpMM:InstanceID>xmp.iid:1c3a75f2-57e1-4c44-a7c2-205e46485a5e</xmpMM:InstanceID>
         <xmpMM:DocumentID>xmp.did:b918f322-7b30-3848-8a29-7da79b6a86ed</xmpMM:DocumentID>
         <xmpMM:OriginalDocumentID>xmp.did:b918f322-7b30-3848-8a29-7da79b6a86ed</xmpMM:OriginalDocumentID>
         <xmpMM:History>
            <rdf:Seq>
               <rdf:li rdf:parseType="Resource">
                  <stEvt:action>created</stEvt:action>
                  <stEvt:instanceID>xmp.iid:b918f322-7b30-3848-8a29-7da79b6a86ed</stEvt:instanceID>
                  <stEvt:when>2013-09-23T16:57:54+01:00</stEvt:when>
                  <stEvt:softwareAgent>Adobe Photoshop CC (Windows)</stEvt:softwareAgent>
               </rdf:li>
               <rdf:li rdf:parseType="Resource">
                  <stEvt:action>saved</stEvt:action>
                  <stEvt:instanceID>xmp.iid:1c3a75f2-57e1-4c44-a7c2-205e46485a5e</stEvt:instanceID>
                  <stEvt:when>2013-09-23T16:57:54+01:00</stEvt:when>
                  <stEvt:softwareAgent>Adobe Photoshop CC (Windows)</stEvt:softwareAgent>
                  <stEvt:changed>/</stEvt:changed>
               </rdf:li>
            </rdf:Seq>
         </xmpMM:History>
         <photoshop:DocumentAncestors>
            <rdf:Bag>
               <rdf:li>adobe:docid:photoshop:158aa240-652c-11e1-b5dd-973dc8c20d7e</rdf:li>
               <rdf:li>adobe:docid:photoshop:aff8e6a7-323f-11d8-9aed-cd0df01e1960</rdf:li>
               <rdf:li>uuid:2CDE064ACF66E111B4BE8C251A065800</rdf:li>
               <rdf:li>uuid:9B9F8D04B263E211B8C3924EF12F2764</rdf:li>
               <rdf:li>uuid:CCE5B22B65F7DD119B6AB6AAF5DF5E0A</rdf:li>
               <rdf:li>uuid:D0958F0BF763E211B8C3924EF12F2764</rdf:li>
               <rdf:li>uuid:E3E3E569F463E211B8C3924EF12F2764</rdf:li>
               <rdf:li>uuid:FF0D4B6FFF63E211B8C3924EF12F2764</rdf:li>
               <rdf:li>xmp.did:376FBEE6776CE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:39582CBA086BE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:3C582CBA086BE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:3ED30A777961E211B32FD586B5419D43</rdf:li>
               <rdf:li>xmp.did:406FBEE6776CE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:5366DE913B74E211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:5E9B2E75896FE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:77AD33202E6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:79AD33202E6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:7BAD33202E6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:7DAD33202E6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:7FAD33202E6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:878DA7066274E211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:8A8FA5224371E211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:C9B561957261E211B32FD586B5419D43</rdf:li>
               <rdf:li>xmp.did:F26E9F7C3C6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:F66E9F7C3C6AE211A2FF9379297EF2CD</rdf:li>
               <rdf:li>xmp.did:F9B628857165E211B32FD586B5419D43</rdf:li>
            </rdf:Bag>
         </photoshop:DocumentAncestors>
         <photoshop:ColorMode>3</photoshop:ColorMode>
         <photoshop:ICCProfile>sRGB IEC61966-2.1</photoshop:ICCProfile>
         <dc:format>image/png</dc:format>
         <tiff:Orientation>1</tiff:Orientation>
         <tiff:XResolution>720000/10000</tiff:XResolution>
         <tiff:YResolution>720000/10000</tiff:YResolution>
         <tiff:ResolutionUnit>2</tiff:ResolutionUnit>
         <exif:ColorSpace>1</exif:ColorSpace>
         <exif:PixelXDimension>16</exif:PixelXDimension>
         <exif:PixelYDimension>16</exif:PixelYDimension>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                            
<?xpacket end="w"?>ÕO∫Ò    cHRM  z%  ÄÉ  ˘ˇ  ÄÈ  u0  Í`  :ò  oí_≈F   ıIDATx⁄úì±MADﬂmDHÄD4@DFBBDd–– A sí¡˜∏´eÔ|ˆH?¯⁄ôŸø⁄?®djWΩR'j©û™[9n‹Ï®óÍX≠¸èoıI=S∑cÉcıŸ≈1R˜µ÷ÅÇ˛ò √ å"±=Ñ÷¸5`Ä€àP$ƒú0ûÙ. ˜ôõbïÙ)Ütå:Œ*‡1 ¿ãcîç¡€/¿4 Øs⁄~f
|Ü˙-KLp˛kˇ∑ áÍ{è´{π,†n™7‚ku£-LM≠÷Å1	’â∫“ï∆¥é‘ô˙°¥Ò~ m¯™ä—Ã&|    IENDÆB`Ç                               ·˘pŒ>SÈ]ÈÓ,Òcê‡Ò÷\ë°&e aXﬂ%˝#l/Äô„ÄM—õ™WÇÚ3ˇÄJ∫±€(ßLÑèH1˝›µ°ù}W—˛øk—”`R#üL2ù»¸uÌ|TG*{è∆áÒs«RÉ©Àgøê)%D,ŸÚ£€BB{Vé|∑w±MÍ´åèQªÔÔ7v∂lÛﬁ©%¡ı⁄ßÜQ>JãmíZ¶˛≤—ˇ÷#–E¯T√è`≥	h5Ì¨ón≈ΩNåÑzHñ#»›'Ãø†õ ›&Fﬂh¸±[ów’©–[Ùº)˘ö®f∏Û'Xâ◊é´≤¶Õ°Õ8‰Ò7t•”?„¯ı˝uåô¸eñy} ˜)1ˇnÓs¨r◊üaL0¡Ì ΩÂ˛*˜Ç·ŒroOTiÇP“.óΩ≥‡ò9Ã˝ˆ±Td€˝øTh^bõéXxè9Ú¨’6c«Ÿ__Ô\/πÁ^≤”Å¿˘ 93./W∏ÀÏ
ÛÃòöœ~∑≈«=bªì£/qﬁ‘{¨veó†#˙ﬁ%B¯d«ã2®˚[24R°'ó+Â.|˜•¥´Í•Xü÷&·∂¶‹™XZQB‰≠å‹Oã_¨*≤Flƒ0≥Õ:é˛b2¡ÌÅ (Ô≤†;)Ñ\á&√=ÒÃ!áÙr™÷µ˙XÖ¥q&7^4¿úK´M//
//  GTMXcodeCreateUnitTextExecutable.m
//
//  Copyright 2007-2009 Google Inc.
//
//  Licensed under the Apache License, Version 2.0 (the "License"); you may not
//  use this file except in compliance with the License.  You may obtain a copy
//  of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//  License for the specific language governing permissions and limitations under
//  the License.
//

#import "GTMXcodeMenuItem.h"
#import "PBXAppDelegate.h"
#import "PBXExtendedApplication.h"
#import "GTMXcodePlugin.h"
#import "NSTask+Script.h"
#import "GTMMethodCheck.h"

// Implements the Create Unit Test Executable menu item
@interface GTMXcodeCreateUnitTextExecutable : GTMXcodeMenuItem
@end

@implementation GTMXcodeCreateUnitTextExecutable
GTM_METHOD_CHECK(NSTask, gtm_runScript:withArguments:);

+ (void)load {
  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  [GTMXcodePlugin registerMenuItem:[[[self alloc] init] autorelease]];
  [pool release];
}

- (NSString*)title {
  return @"Create UnitTest Executable";
}

- (void)action:(id)sender {
  [NSTask gtm_runScript:@"CreateUnitTestExecutable" withArguments:nil];
}

- (BOOL)validateMenuItem:(id <NSMenuItem>)menuItem {
  return [NSApp currentProject] != nil;
}

- (NSMenu*)insertionMenu {
  return [[NSApp delegate] projectMenu];
}

- (int)insertionIndex {
  return 15;
}
@end
                                                                                                                                                                                                                                                                                                                                                                                                      ¢ˇœo{Ó}n|WÓAÿO£	‘œ Dx∫J	|≤ãk¢S∆ÂG$(ãô†ß°Òr∏úÅBº…;bxq≥ê2Oº¯Ü"Çgó÷ÿÂÊô√º√∏0ûRDãﬂ7Œ*≤!t„@øÌIªu(åµC8⁄·ı√IÜ(l\+€,Ω¥À∂o˛vÔ#¡P¢®XΩ¡Nrºf_Ÿ•™ñ_îJ…◊<œ’÷Ãf≥)Jπﬁ2Ÿ »üΩ¢i“À¿dÒj@¶,ËÓ¥"Ìæ?Á`Œo
õmÀr%B)„©$`N∏ñΩ †N≤˜pêÏú_˚ügÛ/ õÌ.€ër9y	±‚ë¶ˇ0D¢∞¡∆$©≠5Õ[(I‹ÈAW7jÉd èû2ÛÛújFq‘È“±R,¥—ÀbêÑC˘CpJ/K–” <¥◊·bQ{Ê$W#ÇQÄ*{ ìsY\a=É72w÷Qk.HD5¬¿xøï+y¡¢€gw∑@1Ú.≤–+*#Z‹OÅâÂX7¯Ú‰'bh∏«ÔÄ0#GvB‰Ü&‚±≥ÄLN`0+±tGŸ6ê¸>∂j™¥ıôJ,öé‘´é9°tDdZ »Ù åﬁn¸R∞Ã)kqŒ`ÛXZø?#◊#•@˛ië>µè∞ø"˜h˘≈}:‹+k–µˇ
Wo≠ı\ß›ôx`}*…ﬂBNM…√Ùòµ?Ω©ö+6‰üz f-Ñ_˙ﬁWÒ§⁄*äDK˙	G9⁄T≥‹ÃZÙZ∆ì¥É(LÇ⁄7ID®Ÿz"%&w≤2HÖ3h(dòá|$®=ëyf6´ÂË6®	aÍSéã–&H∂Ôu|Z‘&÷Ä$ª∑„∑ÿ§å±Í*@¡EÜo™ßÁw+M≈©ªÛKdˆtíß¢	Ωg£uÃÜ,2Úøè˜FNß‘.í∑ÜkÒﬁ[√w‹=$ì„ÎúØC`√tÌR=G>Vï|d±œ‹ˆI∑}¨H`p–ì∫èÊ´—⁄†î‡zß≈5◊¥àÌ4"JwIxÁN·Ê7Î%G⁄=ßoêâ˝†ÖÜ_Ò»Ææ≥RO∆ıÅ$ëÎ≈ÀCPÊ•éXßöíê);GöÀ‡!‰—\™E,0à,Z€x¯˛˚‡
]≈ô¶j≈≠Õ•Ê˚IV9‰Kü^{mÿsåeH˛°»ç∂B5∏ì—ã¨`d}≠]˝Õøv±•b5àT€è∏$12ÛœìŒ¿9î‘o¡π˚‡˚/∫W,º”ÏYÏ…VIå˜R’∫’“ ,
\cTÿVƒ˙ªP+™Q
˜
xuùáWr†ÔŒ› ìÙ‰©”l¨nWL¥]@ŸX…Z
ˆÅTƒ∏
My\jeaÌ1+3_ãØúÒæd‡§êöv_™¢Œ/QYX”w”„(r≠\ê·≈»Rí3≤y©˝?>˚@æ5ßÓ√q\5@]ñE(îØÀ"ƒqπµ1@NÈ¿2Ób·©Ç˝–rUœàâoŸ+ssßÛ&ù¡.eäÄ?ÅÜ"∏êT∂¯.J≥ècæŸ¿˚ƒ!>ß>ÛKãk"…$åæá‹Y‡ã‘˚ù$¯≈¸óÃÂ_
´$M¨“wt›«
*¥y=ú∫7U–ç*u–üÌµ&VˆíÇpΩ±ü?Cçr◊πjﬁ™Üå†=^§Òo",^÷£á`t–SQáKÙ≈PãJ_IŸu2Ö◊¬¨<¯œlÈ¨Vƒ+Ò]Ëé(ÒÖD£¯ÀFÔºVó©⁄Kß[ ◊z£d6R7≠Ä∆ñ–aNœ*s6k‹h∏s'„+≈4~J_HWBò≈&¯+6"6·&17%u Î1Ä√èVÈ`Ÿ√†;ä°‡Êã∏é’Ë~ˆh¢/ãO˚√ô≥ÿ≠
9@y*_ã¨ß∑Ü€¯ÑG'>ß’!—"á´ﬂ’Í jÎ÷R⁄OjÏ‰¬2ƒJûîsÎYÓ7Ií^÷‚úkÌnìë√'EÂûÅˆıÆmËÏ◊a“@√’∆züs0¯7K…Q2∫.xæ£œﬁ¯