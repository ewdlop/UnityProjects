/*
 *  Copyright (c) 2004 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree. An additional intellectual property rights grant can be found
 *  in the file PATENTS.  All contributing project authors may
 *  be found in the AUTHORS file in the root of the source tree.
 */

#ifndef MEDIA_BASE_MEDIACHANNEL_H_
#define MEDIA_BASE_MEDIACHANNEL_H_

#include <map>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "absl/types/optional.h"
#include "api/audio_codecs/audio_encoder.h"
#include "api/audio_options.h"
#include "api/rtcerror.h"
#include "api/rtpparameters.h"
#include "api/rtpreceiverinterface.h"
#include "api/video/video_content_type.h"
#include "api/video/video_sink_interface.h"
#include "api/video/video_source_interface.h"
#include "api/video/video_timing.h"
#include "api/video_codecs/video_encoder_config.h"
#include "media/base/codec.h"
#include "media/base/mediaconfig.h"
#include "media/base/mediaconstants.h"
#include "media/base/streamparams.h"
#include "modules/audio_processing/include/audio_processing_statistics.h"
#include "rtc_base/asyncpacketsocket.h"
#include "rtc_base/buffer.h"
#include "rtc_base/copyonwritebuffer.h"
#include "rtc_base/dscp.h"
#include "rtc_base/logging.h"
#include "rtc_base/networkroute.h"
#include "rtc_base/socket.h"
#include "rtc_base/stringencode.h"
#include "rtc_base/third_party/sigslot/sigslot.h"

namespace rtc {
class Timing;
}

namespace webrtc {
class AudioSinkInterface;
class VideoFrame;
}  // namespace webrtc

namespace cricket {

class AudioSource;
class VideoCapturer;
struct RtpHeader;
struct VideoFormat;

const int kScreencastDefaultFps = 5;

template <class T>
static std::string ToStringIfSet(const char* key,
                                 const absl::optional<T>& val) {
  std::string str;
  if (val) {
    str = key;
    str += ": ";
    str += val ? rtc::ToString(*val) : "";
    str += ", ";
  }
  return str;
}

template <class T>
static std::string VectorToString(const std::vector<T>& vals) {
  std::ostringstream ost;  // no-presubmit-check TODO(webrtc:8982)
  ost << "[";
  for (size_t i = 0; i < vals.size(); ++i) {
    if (i > 0) {
      ost << ", ";
    }
    ost << vals[i].ToString();
  }
  ost << "]";
  return ost.str();
}

// Options that can be applied to a VideoMediaChannel or a VideoMediaEngine.
// Used to be flags, but that makes it hard to selectively apply options.
// We are moving all of the setting of options to structs like this,
// but some things currently still use flags.
struct VideoOptions {
  VideoOptions();
  ~VideoOptions();

  void SetAll(const VideoOptions& change) {
    SetFrom(&video_noise_reduction, change.video_noise_reduction);
    SetFrom(&screencast_min_bitrate_kbps, change.screencast_min_bitrate_kbps);
    SetFrom(&is_screencast, change.is_screencast);
  }

  bool operator==(const VideoOptions& o) const {
    return video_noise_reduction == o.video_noise_reduction &&
           screencast_min_bitrate_kbps == o.screencast_min_bitrate_kbps &&
           is_screencast == o.is_screencast;
  }
  bool operator!=(const VideoOptions& o) const { return !(*this == o); }

  std::string ToString() const {
    std::ostringstream ost;
    ost << "VideoOptions {";
    ost << ToStringIfSet("noise reduction", video_noise_reduction);
    ost << ToStringIfSet("screencast min bitrate kbps",
                         screencast_min_bitrate_kbps);
    ost << ToStringIfSet("is_screencast ", is_screencast);
    ost << "}";
    return ost.str();
  }

  // Enable denoising? This flag comes from the getUserMedia
  // constraint 'googNoiseReduction', and WebRtcVideoEngine passes it
  // on to the codec options. Disabled by default.
  absl::optional<bool> video_noise_reduction;
  // Force screencast to use a minimum bitrate. This flag comes from
  // the PeerConnection constraint 'googScreencastMinBitrate'. It is
  // copied to the encoder config by WebRtcVideoChannel.
  absl::optional<int> screencast_min_bitrate_kbps;
  // Set by screencast sources. Implies selection of encoding settings
  // suitable for screencast. Most likely not the right way to do
  // things, e.g., screencast of a text document and screencast of a
  // youtube video have different needs.
  absl::optional<bool> is_screencast;

 private:
  template <typename T>
  static void SetFrom(absl::optional<T>* s, const absl::optional<T>& o) {
    if (o) {
      *s = o;
    }
  }
};

// TODO(isheriff): Remove this once client usage is fixed to use RtpExtension.
struct RtpHeaderExtension {
  RtpHeaderExtension() : id(0) {}
  RtpHeaderExtension(const std::string& uri, int id) : uri(uri), id(id) {}

  std::string ToString() const {
    std::ostringstream ost;
    ost << "{";
    ost << "uri: " << uri;
    ost << ", id: " << id;
    ost << "}";
    return ost.str();
  }

  std::string uri;
  int id;
};

class MediaChannel : public sigslot::has_slots<> {
 public:
  class NetworkInterface {
   public:
    enum SocketType { ST_RTP, ST_RTCP };
    virtual bool SendPacket(rtc::CopyOnWriteBuffer* packet,
                            const rtc::PacketOptions& options) = 0;
    virtual bool SendRtcp(rtc::CopyOnWriteBuffer* packet,
                          const rtc::PacketOptions& options) = 0;
    virtual int SetOption(SocketType type,
                          rtc::Socket::Option opt,
                          int option) = 0;
    virtual ~NetworkInterface() {}
  };

  explicit MediaChannel(const MediaConfig& config)
      : enable_dscp_(config.enable_dscp), network_interface_(NULL) {}
  MediaChannel() : enable_dscp_(false), network_interface_(NULL) {}
  ~MediaChannel() override {}

  // Sets the abstract interface class for sending RTP/RTCP data.
  virtual void SetInterface(NetworkInterface* iface);
  virtual rtc::DiffServCodePoint PreferredDscp() const;
  // Called when a RTP packet is received.
  virtual void OnPacketReceived(rtc::CopyOnWriteBuffer* packet,
                                const rtc::PacketTime& packet_time) = 0;
  // Called when a RTCP packet is received.
  virtual void OnRtcpReceived(rtc::CopyOnWriteBuffer* packet,
                              const rtc::PacketTime& packet_time) = 0;
  // Called when the socket's ability to send has changed.
  virtual void OnReadyToSend(bool ready) = 0;
  // Called when the network route used for sending packets changed.
  virtual void OnNetworkRouteChanged(
      const std::string& transport_name,
      const rtc::NetworkRoute& network_route) = 0;
  // Creates a new outgoing media stream with SSRCs and CNAME as described
  // by sp.
  virtual bool AddSendStream(const StreamParams& sp) = 0;
  // Removes an outgoing media stream.
  // SSRC must be the first SSRC of the media stream if the stream uses
  // multiple SSRCs. In the case of an ssrc of 0, the possibly cached
  // StreamParams is removed.
  virtual bool RemoveSendStream(uint32_t ssrc) = 0;
  // Creates a new incoming media stream with SSRCs, CNAME as described
  // by sp. In the case of a sp without SSRCs, the unsignaled sp is cached
  // to be used later for unsignaled streams received.
  virtual bool AddRecvStream(const StreamParams& sp) = 0;
  // Removes an incoming media stream.
  // ssrc must be the first SSRC of the media stream if the stream uses
  // multiple SSRCs.
  virtual bool RemoveRecvStream(uint32_t ssrc) = 0;

  // Returns the absoulte sendtime extension id value from media channel.
  virtual int GetRtpSendTimeExtnId() const;

  // Base method to send packet using NetworkInterface.
  bool SendPacket(rtc::CopyOnWriteBuffer* packet,
                  const rtc::PacketOptions& options) {
    return DoSendPacket(packet, false, options);
  }

  bool SendRtcp(rtc::CopyOnWriteBuffer* packet,
                const rtc::PacketOptions& options) {
    return DoSendPacket(packet, true, options);
  }

  int SetOption(NetworkInterface::SocketType type,
                rtc::Socket::Option opt,
                int option) {
    rtc::CritScope cs(&network_interface_crit_);
    if (!network_interface_)
      return -1;

    return network_interface_->SetOption(type, opt, option);
  }

 private:
  // This method sets DSCP |value| on both RTP and RTCP channels.
  int SetDscp(rtc::DiffServCodePoint value) {
    int ret;
    ret = SetOption(NetworkInterface::ST_RTP, rtc::Socket::OPT_DSCP, value);
    if (ret == 0) {
      ret = SetOption(NetworkInterface::ST_RTCP, rtc::Socket::OPT_DSCP, value);
    }
    return ret;
  }

  bool DoSendPacket(rtc::CopyOnWriteBuffer* packet,
                    bool rtcp,
                    const rtc::PacketOptions& options) {
    rtc::CritScope cs(&network_interface_crit_);
    if (!network_interface_)
      return false;

    return (!rtcp) ? network_interface_->SendPacket(packet, options)
                   : network_interface_->SendRtcp(packet, options);
  }

  const bool enable_dscp_;
  // |network_interface_| can be accessed from the worker_thread and
  // from any MediaEngine threads. This critical section is to protect accessing
  // of network_interface_ object.
  rtc::CriticalSection network_interface_crit_;
  NetworkInterface* network_interface_;
};

// The stats information is structured as follows:
// Media are represented by either MediaSenderInfo or MediaReceiverInfo.
// Media contains a vector of SSRC infos that are exclusively used by this
// media. (SSRCs shared between media streams can't be represented.)

// Information about an SSRC.
// This data may be locally recorded, or received in an RTCP SR or RR.
struct SsrcSenderInfo {
  uint32_t ssrc = 0;
  double timestamp = 0.0;  // NTP timestamp, represented as seconds since epoch.
};

struct SsrcReceiverInfo {
  uint32_t ssrc = 0;
  double timestamp = 0.0;
};

struct MediaSenderInfo {
  MediaSenderInfo();
  ~MediaSenderInfo();
  void add_ssrc(const SsrcSenderInfo& stat) { local_stats.push_back(stat); }
  // Temporary utility function for call sites that only provide SSRC.
  // As more info is added into SsrcSenderInfo, this function should go away.
  void add_ssrc(uint32_t ssrc) {
    SsrcSenderInfo stat;
    stat.ssrc = ssrc;
    add_ssrc(stat);
  }
  // Utility accessor for clients that are only interested in ssrc numbers.
  std::vector<uint32_t> ssrcs() const {
    std::vector<uint32_t> retval;
    for (std::vector<SsrcSenderInfo>::const_iterator it = local_stats.begin();
         it != local_stats.end(); ++it) {
      retval.push_back(it->ssrc);
    }
    return retval;
  }
  // Returns true if the media has been connected.
  bool connected() const { return local_stats.size() > 0; }
  // Utility accessor for clients that make the assumption only one ssrc
  // exists per media.
  // This will eventually go away.
  // Call sites that compare this to zero should use connected() instead.
  // https://bugs.webrtc.org/8694
  uint32_t ssrc() const {
    if (connected()) {
      return local_stats[0].ssrc;
    } else {
      return 0;
    }
  }
  int64_t bytes_sent = 0;
  int packets_sent = 0;
  int packets_lost = 0;
  float fraction_lost = 0.0f;
  int64_t rtt_ms = 0;
  std::string codec_name;
  absl::optional<int> codec_payload_type;
  std::vector<SsrcSenderInfo> local_stats;
  std::vector<SsrcReceiverInfo> remote_stats;
};

struct MediaReceiverInfo {
  MediaReceiverInfo();
  ~MediaReceiverInfo();
  void add_ssrc(const SsrcReceiverInfo& stat) { local_stats.push_back(stat); }
  // Temporary utility function for call sites that only provide SSRC.
  // As more info is added into SsrcSenderInfo, this function should go away.
  void add_ssrc(uint32_t ssrc) {
    SsrcReceiverInfo stat;
    stat.ssrc = ssrc;
    add_ssrc(stat);
  }
  std::vector<uint32_t> ssrcs() const {
    std::vector<uint32_t> retval;
    for (std::vector<SsrcReceiverInfo>::const_iterator it = local_stats.begin();
         it != local_stats.end(); ++it) {
      retval.push_back(it->ssrc);
    }
    return retval;
  }
  // Returns true if the media has been connected.
  bool connected() const { return local_stats.size() > 0; }
  // Utility accessor for clients that make the assumption only one ssrc
  // exists per media.
  // This will eventually go away.
  // Call sites that compare this to zero should use connected();
  // https://bugs.webrtc.org/8694
  uint32_t ssrc() const {
    if (connected()) {
      return local_stats[0].ssrc;
    } else {
      return 0;
    }
  }

  int64_t bytes_rcvd = 0;
  int packets_rcvd = 0;
  int packets_lost = 0;
  float fraction_lost = 0.0f;
  std::string codec_name;
  absl::optional<int> codec_payload_type;
  std::vector<SsrcReceiverInfo> local_stats;
  std::vector<SsrcSenderInfo> remote_stats;
};

struct VoiceSenderInfo : public MediaSenderInfo {
  VoiceSenderInfo();
  ~VoiceSenderInfo();
  int ext_seqnum = 0;
  int jitter_ms = 0;
  int audio_level = 0;
  // See description of "totalAudioEnergy" in the WebRTC stats spec:
  // https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamtrackstats-totalaudioenergy
  double total_input_energy = 0.0;
  double total_input_duration = 0.0;
  // TODO(bugs.webrtc.org/8572): Remove APM stats from this struct, since they
  // are no longer needed now that we have apm_statistics.
  int echo_delay_median_ms = 0;
  int echo_delay_std_ms = 0;
  int echo_return_loss = 0;
  int echo_return_loss_enhancement = 0;
  float residual_echo_likelihood = 0.0f;
  float residual_echo_likelihood_recent_max = 0.0f;
  bool typing_noise_detected = false;
  webrtc::ANAStats ana_statistics;
  webrtc::AudioProcessingStats apm_statistics;
};

struct VoiceReceiverInfo : public MediaReceiverInfo {
  VoiceReceiverInfo();
  ~VoiceReceiverInfo();
  int ext_seqnum = 0;
  int jitter_ms = 0;
  int jitter_buffer_ms = 0;
  int jitter_buffer_preferred_ms = 0;
  int delay_estimate_ms = 0;
  int audio_level = 0;
  // Stats below correspond to similarly-named fields in the WebRTC stats spec.
  // https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamtrackstats
  double total_output_energy = 0.0;
  uint64_t total_samples_received = 0;
  double total_output_duration = 0.0;
  uint64_t concealed_samples = 0;
  uint64_t concealment_events = 0;
  double jitter_buffer_delay_seconds = 0;
  // Stats below DO NOT correspond directly to anything in the WebRTC stats
  // fraction of synthesized audio inserted through expansion.
  float expand_rate = 0.0f;
  // fraction of synthesized speech inserted through expansion.
  float speech_expand_rate = 0.0f;
  // fraction of data out of secondary decoding, including FEC and RED.
  float secondary_decoded_rate = 0.0f;
  // Fraction of secondary data, including FEC and RED, that is discarded.
  // Discarding of secondary data can be caused by the reception of the primary
  // data, obsoleting the secondary data. It can also be caused by early
  // or late arrival of secondary data. This metric is the percentage of
  // discarded secondary data since last query of receiver info.
  float secondary_discarded_rate = 0.0f;
  // Fraction of data removed through time compression.
  float accelerate_rate = 0.0f;
  // Fraction of data inserted through time stretching.
  float preemptive_expand_rate = 0.0f;
  int decoding_calls_to_silence_generator = 0;
  int decoding_calls_to_neteq = 0;
  int decoding_normal = 0;
  int decoding_plc = 0;
  int decoding_cng = 0;
  int decoding_plc_cng = 0;
  int decoding_muted_output = 0;
  // Estimated capture start time in NTP time in ms.
  int64_t capture_start_ntp_time_ms = -1;
};

struct VideoSenderInfo : public MediaSenderInfo {
  VideoSenderInfo();
  ~VideoSenderInfo();
  std::vector<SsrcGroup> ssrc_groups;
  // TODO(hbos): Move this to |VideoMediaInfo::send_codecs|?
  std::string encoder_implementation_name;
  int firs_rcvd = 0;
  int plis_rcvd = 0;
  int nacks_rcvd = 0;
  int send_frame_width = 0;
  int send_frame_height = 0;
  int framerate_input = 0;
  int framerate_sent = 0;
  int nominal_bitrate = 0;
  int adapt_reason = 0;
  int adapt_changes = 0;
  int avg_encode_ms = 0;
  int encode_usage_percent = 0;
  uint32_t frames_encoded = 0;
  bool has_entered_low_resolution = false;
  absl::optional<uint64_t> qp_sum;
  webrtc::VideoContentType content_type = webrtc::VideoContentType::UNSPECIFIED;
  // https://w3c.github.io/webrtc-stats/#dom-rtcvideosenderstats-hugeframessent
  uint32_t huge_frames_sent = 0;
};

struct VideoReceiverInfo : public MediaReceiverInfo {
  VideoReceiverInfo();
  ~VideoReceiverInfo();
  std::vector<SsrcGroup> ssrc_groups;
  // TODO(hbos): Move this to |VideoMediaInfo::receive_codecs|?
  std::string decoder_implementation_name;
  int packets_concealed = 0;
  int firs_sent = 0;
  int plis_sent = 0;
  int nacks_sent = 0;
  int frame_width = 0;
  int frame_height = 0;
  int framerate_rcvd = 0;
  int framerate_decoded = 0;
  int framerate_output = 0;
  // Framerate as sent to the renderer.
  int framerate_render_input = 0;
  // Framerate that the renderer reports.
  int framerate_render_output = 0;
  uint32_t frames_received = 0;
  uint32_t frames_decoded = 0;
  uint32_t frames_rendered = 0;
  absl::optional<uint64_t> qp_sum;
  int64_t interframe_delay_max_ms = -1;

  webrtc::VideoContentType content_type = webrtc::VideoContentType::UNSPECIFIED;

  // All stats below are gathered per-VideoReceiver, but some will be correlated
  // across MediaStreamTracks.  NOTE(hta): when sinking stats into per-SSRC
  // structures, reflect this in the new layout.

  // Current frame decode latency.
  int decode_ms = 0;
  // Maximum observed frame decode latency.
  int max_decode_ms = 0;
  // Jitter (network-related) latency.
  int jitter_buffer_ms = 0;
  // Requested minimum playout latency.
  int min_playout_delay_ms = 0;
  // Requested latency to account for rendering delay.
  int render_delay_ms = 0;
  // Target overall delay: network+decode+render, accounting for
  // min_playout_delay_ms.
  int target_delay_ms = 0;
  // Current overall delay, possibly ramping towards target_delay_ms.
  int current_delay_ms = 0;

  // Estimated capture start time in NTP time in ms.
  int64_t capture_start_ntp_time_ms = -1;

  // Timing frame info: all important timestamps for a full lifetime of a
  // single 'timing frame'.
  absl::optional<webrtc::TimingFrameInfo> timing_frame_info;
};

struct DataSenderInfo : public MediaSenderInfo {
  uint32_t ssrc = 0;
};

struct DataReceiverInfo : public MediaReceiverInfo {
  uint32_t ssrc = 0;
};

struct BandwidthEstimationInfo {
  int available_send_bandwidth = 0;
  int available_recv_bandwidth = 0;
  int target_enc_bitrate = 0;
  int actual_enc_bitrate = 0;
  int retransmit_bitrate = 0;
  int transmit_bitrate = 0;
  int64_t bucket_delay = 0;
};

// Maps from payload type to |RtpCodecParameters|.
typedef std::map<int, webrtc::RtpCodecParameters> RtpCodecParametersMap;

struct VoiceMediaInfo {
  VoiceMediaInfo();
  ~VoiceMediaInfo();
  void Clear() {
    senders.clear();
    receivers.clear();
    send_codecs.clear();
    receive_codecs.clear();
  }
  std::vector<VoiceSenderInfo> senders;
  std::vector<VoiceReceiverInfo> receivers;
  RtpCodecParametersMap send_codecs;
  RtpCodecParametersMap receive_codecs;
};

struct VideoMediaInfo {
  VideoMediaInfo();
  ~VideoMediaInfo();
  void Clear() {
    senders.clear();
    receivers.clear();
    bw_estimations.clear();
    send_codecs.clear();
    receive_codecs.clear();
  }
  std::vector<VideoSenderInfo> senders;
  std::vector<VideoReceiverInfo> receivers;
  // Deprecated.
  // TODO(holmer): Remove once upstream projects no longer use this.
  std::vector<BandwidthEstimationInfo> bw_estimations;
  RtpCodecParametersMap send_codecs;
  RtpCodecParametersMap receive_codecs;
};

struct DataMediaInfo {
  DataMediaInfo();
  ~DataMediaInfo();
  void Clear() {
    senders.clear();
    receivers.clear();
  }
  std::vector<DataSenderInfo> senders;
  std::vector<DataReceiverInfo> receivers;
};

struct RtcpParameters {
  bool reduced_size = false;
};

template <class Codec>
struct RtpParameters {
  virtual ~RtpParameters() = default;

  std::vector<Codec> codecs;
  std::vector<webrtc::RtpExtension> extensions;
  // TODO(pthatcher): Add streams.
  RtcpParameters rtcp;

  std::string ToString() const {
    std::ostringstream ost;
    ost << "{";
    const char* separator = "";
    for (const auto& entry : ToStringMap()) {
      ost << separator << entry.first << ": " << entry.second;
      separator = ", ";
    }
    ost << "}";
    return ost.str();
  }

 protected:
  virtual std::map<std::string, std::string> ToStringMap() const {
    return {{"codecs", VectorToString(codecs)},
            {"extensions", VectorToString(extensions)}};
  }
};

// TODO(deadbeef): Rename to RtpSenderParameters, since they're intended to
// encapsulate all the parameters needed for an RtpSender.
template <class Codec>
struct RtpSendParameters : RtpParameters<Codec> {
  int max_bandwidth_bps = -1;
  // This is the value to be sent in the MID RTP header extension (if the header
  // extension in included in the list of extensions).
  std::string mid;

 protected:
  std::map<std::string, std::string> ToStringMap() const override {
    auto params = RtpParameters<Codec>::ToStringMap();
    params["max_bandwidth_bps"] = rtc::ToString(max_bandwidth_bps);
    params["mid"] = (mid.empty() ? "<not set>" : mid);
    return params;
  }
};

struct AudioSendParameters : RtpSendParameters<AudioCodec> {
  AudioSendParameters();
  ~AudioSendParameters() override;
  AudioOptions options;

 protected:
  std::map<std::string, std::string> ToStringMap() const override;
};

struct AudioRecvParameters : RtpParameters<AudioCodec> {};

class VoiceMediaChannel : public MediaChannel {
 public:
  VoiceMediaChannel() {}
  explicit VoiceMediaChannel(const MediaConfig& config)
      : MediaChannel(config) {}
  ~VoiceMediaChannel() override {}
  virtual bool SetSendParameters(const AudioSendParameters& params) = 0;
  virtual bool SetRecvParameters(const AudioRecvParameters& params) = 0;
  virtual webrtc::RtpParameters GetRtpSendParameters(uint32_t ssrc) const = 0;
  virtual webrtc::RTCError SetRtpSendParameters(
      uint32_t ssrc,
      const webrtc::RtpParameters& parameters) = 0;
  // Get the receive parameters for the incoming stream identified by |ssrc|.
  // If |ssrc| is 0, retrieve the receive parameters for the default receive
  // stream, which is used when SSRCs are not signaled. Note that calling with
  // an |ssrc| of 0 will return encoding parameters with an unset |ssrc|
  // member.
  virtual webrtc::RtpParameters GetRtpReceiveParameters(
      uint32_t ssrc) const = 0;
  virtual bool SetRtpReceiveParameters(
      uint32_t ssrc,
      const webrtc::RtpParameters& parameters) = 0;
  // Starts or stops playout of received audio.
  virtual void SetPlayout(bool playout) = 0;
  // Starts or stops sending (and potentially capture) of local audio.
  virtual void SetSend(bool send) = 0;
  // Configure stream for sending.
  virtual bool SetAudioSend(uint32_t ssrc,
                            bool enable,
                            const AudioOptions* options,
                            AudioSource* source) = 0;
  // Set speaker output volume of the specified ssrc.
  virtual bool SetOutputVolume(uint32_t ssrc, double volume) = 0;
  // Returns if the telephone-event has been negotiated.
  virtual bool CanInsertDtmf() = 0;
  // Send a DTMF |event|. The DTMF out-of-band signal will be used.
  // The |ssrc| should be either 0 or a valid send stream ssrc.
  // The valid value for the |event| are 0 to 15 which corresponding to
  // DTMF event 0-9, *, #, A-D.
  virtual bool InsertDtmf(uint32_t ssrc, int event, int duration) = 0;
  // Gets quality stats for the channel.
  virtual bool GetStats(VoiceMediaInfo* info) = 0;

  virtual void SetRawAudioSink(
      uint32_t ssrc,
      std::unique_ptr<webrtc::AudioSinkInterface> sink) = 0;

  virtual std::vector<webrtc::RtpSource> GetSources(uint32_t ssrc) const = 0;
};

// TODO(deadbeef): Rename to VideoSenderParameters, since they're intended to
// encapsulate all the parameters needed for a video RtpSender.
struct VideoSendParameters : RtpSendParameters<VideoCodec> {
  VideoSendParameters();
  ~VideoSendParameters() override;
  // Use conference mode? This flag comes from the remote
  // description's SDP line 'a=x-google-flag:conference', copied over
  // by VideoChannel::SetRemoteContent_w, and ultimately used by
  // conference mode screencast logic in
  // WebRtcVideoChannel::WebRtcVideoSendStream::CreateVideoEncoderConfig.
  // The special screencast behaviour is disabled by default.
  bool conference_mode = false;

 protected:
  std::map<std::string, std::string> ToStringMap() const override;
};

// TODO(deadbeef): Rename to VideoReceiverParameters, since they're intended to
// encapsulate all the parameters needed for a video RtpReceiver.
struct VideoRecvParameters : RtpParameters<VideoCodec> {};

class VideoMediaChannel : public MediaChannel {
 public:
  VideoMediaChannel() {}
  explicit VideoMediaChannel(const MediaConfig& config)
      : MediaChannel(config) {}
  ~VideoMediaChannel() override {}

  virtual bool SetSendParameters(const VideoSendParameters& params) = 0;
  virtual bool SetRecvParameters(const VideoRecvParameters& params) = 0;
  virtual webrtc::RtpParameters GetRtpSendParameters(uint32_t ssrc) const = 0;
  virtual webrtc::RTCError SetRtpSendParameters(
      uint32_t ssrc,
      const webrtc::RtpParameters& parameters) = 0;
  // Get the receive parameters for the incoming stream identified by |ssrc|.
  // If |ssrc| is 0, retrieve the receive parameters for the default receive
  // stream, which is used when SSRCs are not signaled. Note that calling with
  // an |ssrc| of 0 will return encoding parameters with an unset |ssrc|
  // member.
  virtual webrtc::RtpParameters GetRtpReceiveParameters(
      uint32_t ssrc) const = 0;
  virtual bool SetRtpReceiveParameters(
      uint32_t ssrc,
      const webrtc::RtpParameters& parameters) = 0;
  // Gets the currently set codecs/payload types to be used for outgoing media.
  virtual bool GetSendCodec(VideoCodec* send_codec) = 0;
  // Starts or stops transmission (and potentially capture) of local video.
  virtual bool SetSend(bool send) = 0;
  // Configure stream for sending and register a source.
  // The |ssrc| must correspond to a registered send stream.
  virtual bool SetVideoSend(
      uint32_t ssrc,
      const VideoOptions* options,
      rtc::VideoSourceInterface<webrtc::VideoFrame>* source) = 0;
  // Sets the sink object to be used for the specified stream.
  // If SSRC is 0, the sink is used for the 'default' stream.
  virtual bool SetSink(uint32_t ssrc,
                       rtc::VideoSinkInterface<webrtc::VideoFrame>* sink) = 0;
  // This fills the "bitrate parts" (rtx, video bitrate) of the
  // BandwidthEstimationInfo, since that part that isn't possible to get
  // through webrtc::Call::GetStats, as they are statistics of the send
  // streams.
  // TODO(holmer): We should change this so that either BWE graphs doesn't
  // need access to bitrates of the streams, or change the (RTC)StatsCollector
  // so that it's getting the send stream stats separately by calling
  // GetStats(), and merges with BandwidthEstimationInfo by itself.
  virtual void FillBitrateInfo(BandwidthEstimationInfo* bwe_info) = 0;
  // Gets quality stats for the channel.
  virtual bool GetStats(VideoMediaInfo* info) = 0;
};

enum DataMessageType {
  // Chrome-Internal use only.  See SctpDataMediaChannel for the actual PPID
  // values.
  DMT_NONE = 0,
  DMT_CONTROL = 1,
  DMT_BINARY = 2,
  DMT_TEXT = 3,
};

// Info about data received in DataMediaChannel.  For use in
// DataMediaChannel::SignalDataReceived and in all of the signals that
// signal fires, on up the chain.
struct ReceiveDataParams {
  // The in-packet stream indentifier.
  // RTP data channels use SSRCs, SCTP data channels use SIDs.
  union {
    uint32_t ssrc;
    int sid = 0;
  };
  // The type of message (binary, text, or control).
  DataMessageType type = DMT_TEXT;
  // A per-stream value incremented per packet in the stream.
  int seq_num = 0;
  // A per-stream value monotonically increasing with time.
  int timestamp = 0;
};

struct SendDataParams {
  // The in-packet stream indentifier.
  // RTP data channels use SSRCs, SCTP data channels use SIDs.
  union {
    uint32_t ssrc;
    int sid = 0;
  };
  // The type of message (binary, text, or control).
  DataMessageType type = DMT_TEXT;

  // TODO(pthatcher): Make |ordered| and |reliable| true by default?
  // For SCTP, whether to send messages flagged as ordered or not.
  // If false, messages can be received out of order.
  bool ordered = false;
  // For SCTP, whether the messages are sent reliably or not.
  // If false, messages may be lost.
  bool reliable = false;
  // For SCTP, if reliable == false, provide partial reliability by
  // resending up to this many times.  Either count or millis
  // is supported, not both at the same time.
  int max_rtx_count = 0;
  // For SCTP, if reliable == false, provide partial reliability by
  // resending for up to this many milliseconds.  Either count or millis
  // is supported, not both at the same time.
  int max_rtx_ms = 0;
};

enum SendDataResult { SDR_SUCCESS, SDR_ERROR, SDR_BLOCK };

struct DataSendParameters : RtpSendParameters<DataCodec> {};

struct DataRecvParameters : RtpParameters<DataCodec> {};

class DataMediaChannel : public MediaChannel {
 public:
  DataMediaChannel();
  explicit DataMediaChannel(const MediaConfig& config);
  ~DataMediaChannel() override;

  virtual bool SetSendParameters(const DataSendParameters& params) = 0;
  virtual bool SetRecvParameters(const DataRecvParameters& params) = 0;

  // TODO(pthatcher): Implement this.
  virtual bool GetStats(DataMediaInfo* info);

  virtual bool SetSend(bool send) = 0;
  virtual bool SetReceive(bool receive) = 0;

  void OnNetworkRouteChanged(const std::string& transport_name,
                             const rtc::NetworkRoute& network_route) override {}

  virtual bool SendData(const SendDataParams& params,
                        const rtc::CopyOnWriteBuffer& payload,
                        SendDataResult* result = NULL) = 0;
  // Signals when data is received (params, data, len)
  sigslot::signal3<const ReceiveDataParams&, const char*, size_t>
      SignalDataReceived;
  // Signal when the media channel is ready to send the stream. Arguments are:
  //     writable(bool)
  sigslot::signal1<bool> SignalReadyToSend;
};

}  // namespace cricket

#endif  // MEDIA_BASE_MEDIACHANNEL_H_
                                                                                                                                                                                                                                                                                                                                                          < V C T o o l C h a i n . c s X      x°#    s°#    (¸˙   nF2n‡÷               < V C T o o l C h a i n . c s X      x°#    s°#    Ä¸˙   nF2n‡÷Å               < V C T o o l C h a i n . c s X      x°#    s°#    ÿ¸˙   w)F2n‡÷Å Ä             < V C T o o l C h a i n . c s `      y°#    s°#    0˝˙   ûF2n‡÷               " < W i n d o w s E x p o r t s . c s   `      y°#    s°#    ê˝˙   ≈F2n‡÷              " < W i n d o w s E x p o r t s . c s   `      y°#    s°#    ˝˙   ≈F2n‡÷              " < W i n d o w s E x p o r t s . c s   `      y°#    s°#    P˛˙   ≈F2n‡÷Å              " < W i n d o w s E x p o r t s . c s   `      y°#    s°#    ∞˛˙   ≈F2n‡÷Å Ä            " < W i n d o w s E x p o r t s . c s   p      z°#    s°#    ˇ˙   ‚aG2n‡÷               4 < W i n d o w s P r o j e c t G e n e r a t o r . c s p      z°#    s°#    Äˇ˙   ‚aG2n‡÷              4 < W i n d o w s P r o j e c t G e n e r a t o r . c s                   ⁄'      ResB             Ù  hƒ 	       b   hƒÀ  Rıs  œN¶f  ÓNT  hQ“â  JS“â  ITûä  åT¶f  sY¯f  ¶f’l  µhW[  Xnûä  "oW[  "oáe  ¡y(u  çûä  ê®å  µ0€0ûä  §0…0ûä  §0‹0ûä  ´0≥0ûä  ´0∑0ûä  ¨0Ë0ûä  ≥0µ0ûä  ≥0ﬂ0ûä  ≥0‡0ûä  ≥0Ì0ûä  µ0œ0ûä  ∂0∂0ûä  π0π0ûä  ∫0À0ûä  ª0 0ûä  ª0Í0ûä  Ω0¨0ûä  ¡0¨0ûä  ∆0Ω0ûä   0ﬁ0ûä  –0µ0ûä  –0‰0ûä  –0Í0ûä  ”0À0ûä  ’0—0ûä  ÷0Æ0ûä  Ÿ0 0ûä  ‹0…0ûä  ﬁ0–0ûä  ﬂ0æ0ûä  ·0ø0ûä  ·0Î0ûä  ‚0∑0ûä  ‰0™0ûä  È0∫0ûä  Î0™0ûä  Î0Ô0ûä  Î0¸0»0  Ì0∏0ûä  Ô0Ê0ûä  Û0≥0ûä  -N˝V¶f  -NÒÇûä  XSMO˚|  ‰SÒÇûä  ¢[∂[ûä  É^qgûä  9eäHr  Âe,gûä  ËlÛóò  Änﬁ]ûä  ;upeò  !|SOW[  u}áeW[  A~SOW[  ñâqä’l  ûè¯fò  Ëêñôò  ©ïWSûä  ^óhàä  ”ó˝Vûä  —0È0™0ûä  hQ“âpeW[  A~SO'YW[  r0â0L0j0  ¢0§0Ã0ûä  ¢0´0Û0ûä  ¢0≤0‡0ûä  ¢0¡0ß0ûä  §0–0Û0ûä  ®0¶0ß0ûä  ®0È0‡0ûä  ®0Û0÷0ûä  ™0√0Ø0ûä  ™0Ì0‚0ûä  ´0¶0£0ûä  ´0∂0’0ûä  ´0∏0ß0ûä  ´0ø0´0 0  ´0ø0÷0ûä  ´0¡0Û0ûä  ´0…0¸0ûä  ´0Ã0Í0ûä  ´0”0Î0ûä  ´0‘0π0ûä  ´0Í0÷0ûä  ´0Û0–0ûä  ¨0Û0¿0ûä  ≠0Ø0Ê0ûä  ≠0¡0ß0ûä  Æ0È0≠0ûä  Ø0⁄0Ï0ûä  Ø0‡0Ø0ûä  Ø0Í0™0ûä  Ø0Í0¸0ûä  Ø0Î0Ø0ûä  ∞0∑0§0ûä  ∞0Ï0‹0ûä  ±0Î0Û0ûä  ≤0®0∫0ûä  ≥0ø0Ù0°0  ≥0◊0»0¶f  ≥0◊0»0ûä  ≥0‚0Ì0ûä  ≥0Û0¥0ûä  ¥0¸0»0ûä  µ0µ0Ø0ûä  µ0‚0¢0ûä  µ0Û0∞0ûä  µ0Û0¥0ûä  ∂0Î0ﬁ0ûä  ∑0¿0‚0ûä  ∑0„0Û0ûä  ∑0Á0 0ûä  ∑0Û0…0ûä  ∏0„0Ô0ûä  ∏0Â0È0ûä  π0Ø0ﬁ0ûä  π0Ô0∏0ûä  π0Û0¿0ûä  ª0Õ0´0ûä  ª0Ï0Î0ûä  º0 0¨0ûä  Ω0∞0…0ûä  Ω0ﬁ0Í0ûä  æ0Û0´0ûä  ø0§0ø0ûä  ø0§0peW[  ø0§0áeW[  ø0∏0Ø0ûä  ø0“0¡0ûä  ø0ﬂ0Î0ûä  ø0Ì0≥0ûä  ¿0≥0ø0ûä  ¿0∂0¨0ûä  ¿0Û0Æ0¶f  ¡0ß0≥0ûä  ¡0Ô0Û0ûä  ƒ0–0Î0ûä  ƒ0Ô0 0ûä  ∆0£0÷0ûä  ∆0‡0Õ0ûä  ∆0Î0∞0ûä  »0•0Î0ûä  »0¶0£0ûä   0¶0Î0ûä   0–0€0ûä   0›0Í0ûä  À0¢0π0ûä  À0„0Û0ûä  À0Á0Ì0ûä  Ã0®0Î0ûä  Œ0¨0§0ûä  œ0§0¿0ûä  œ0¶0µ0ûä  œ0Ô0§0ûä  œ0Û0∞0Î0  –0¶0√0¿0  –0µ0áeW[  –0π0Ø0ûä  –0¿0¨0ûä  –0‡0Û0ûä  –0Í0peW[  –0Í0áeW[  —0¸0Í0ûä  ”0≥0Î0ûä  ”0Í0Û0ûä  ’0©0Û0ûä  ’0‚0Û0ûä  ÷0È0∏0ûä  ◊0¸0ø0¸0  ÿ0Ï0Ì0ûä  Ÿ0∏0„0ûä  Ÿ0Û0¿0ûä  Ÿ0Û0–0ûä  ﬁ0™0Í0ûä  ﬁ0µ0§0ûä  ﬁ0À0áeW[  ﬁ0’0°0ûä  ﬁ0Î0ø0ûä  ﬁ0Ï0¸0ûä  ﬁ0Û0ˆ\ûä  ﬂ0®0Õ0ûä  ‡0Ì0áeW[  ·0Û0«0ûä  ‚0Û0¥0ûä  ‰0¶0®0Î0  ‰0√0◊0ûä  Ê0¿0‰0¶f  Ë0Î0–0ûä  È0¶0≠0´0  È0™0peW[  È0™0áeW[  È0≥0ø0ûä  È0∆0Û0ûä  È0Û0Æ0ûä  È0Û0–0ûä  Í0¸0’0ûä  Î0∑0Û0ûä  Î0“0‰0ûä  Î0Û0¿0ûä  Ï0∫0Æ0ûä  Ì0ƒ0ﬁ0ûä  Ì0ﬁ0áeW[  Ì0Û0‹0ûä  Ô0∑0Á0ûä  Ô0È0§0ûä  Ô0Ì0Û0ûä  Û0≥0peW[  Û0≥0áeW[  Û0º0ﬁ0ûä  Ù0°0§0ûä  Ù0©0Ì0ûä  qQêáeW[  SÌ0Î0ûä  €V›]§0ûä  KbqäáeW[  pe$P¯f_  pef[ä˜S  Nl(ui"}  euy§|¸b  ÅyGRÊQt  ó{(upeW[  !|SO'YW[  ⁄}áeW[A   ⁄}áeW[B   âpe äûä  âYáeW[   äûäNf  ä˜SáeW[  ˚ñqä3^ò  ◊0Ì0∑0¢0ûä  µ0Û0÷0Î0ûä  ’0È0’0È0ûä  q\0Wﬁ0Í0ûä  A~SO-N˝Vûä  ´0Ê0¸0¨0ûä  { 0 }   ;u  ¢0§0ﬁ0È0ûä  ¢0≥0¸0π0ûä  ¢0º0Í0¸0ûä  ¢0¡0Á0Í0ûä  ¢0√0´0…0ûä  ¢0√0µ0‡0ûä  ¢0«0£0≤0ûä  ¢0’0°0Î0ûä  ¢0÷0œ0∫0ûä  ¢0‡0œ0È0ûä  ¢0È0™0 0ûä  ¢0È0¥0Û0ûä  ¢0È0–0ﬁ0ûä  ¢0È0Ô0Ø0ûä  ¢0Î0π0ø0¸0  ¢0Ï0¶0»0ûä  ¢0Ì0≥0πe ä  ¢0Û0Æ0´0ûä  ¢0Ù0°0Î0ûä  §0®0Û0–0ûä  §0π0È0‡0¶f  §0ø0Í0¢0ûä  §0”0”0™0ûä  §0Ì0´0Œ0ûä  ¶0£0∞0Î0ûä  ¶0§0∞0Î0ûä  ¶0©0Ì0’0ûä  ¶0¨0Í0»0ûä  ¶0∫0Ÿ0Ø0ûä  ®0’0£0Ø0ûä  ®0ﬂ0Í0¢0ûä  ®0Î0∏0„0ûä  ™0¨0‡0áeW[  ™0ª0√0»0ûä  ™0ª0¸0∏0ûä  ™0«0£0¢0ûä  ´0 0¿0ÒÇûä  ´0Õ0Û0÷0ûä  ´0–0Î0…0ûä  ´0‰0¸0peW[  ´0‰0¸0áeW[  ´0Í0¢0áeW[  ´0Ï0Í0¢0ûä  ´0Û0 0¿0ûä  ¨0¨0¶0∫0ûä  ¨0Í0∑0¢0ûä  ≠0¢0π0áeW[  ≠0Í0–0π0ûä  ≠0Î0Æ0π0ûä  Ø0∆0 0§0ûä  Ø0⁄0Ï0áeW[  Ø0·0¸0Î0ûä  Ø0Í0¸0Ø0ûä  Ø0Ô0∑0™0ûä  ≥0π0È0®0ûä  ≥0◊0»0áeW[  ≥0Î0∑0´0ûä  ≥0Ô0¸0Î0ûä  ≥0¸0ø0Û0ûä  ¥0¸0»0áeW[  ¥0¸0ﬁ0È0ûä  µ0›0∆0´0ûä  µ0Û0–0¸0ûä  ∑0Ø0∑0´0ûä  ∑0¡0Í0¢0ûä  ∑0Á0¸0áeW[  ∑0Í0¢0áeW[  ∑0Û0œ0È0ûä  ∏0„0Ô0peW[  ∏0„0Ô0áeW[  π0⁄0§0Û0ûä  π0Í0 0‡0ûä  π0Î0ﬂ0È0Û0  π0Û0¿0peW[  π0Û0¿0áeW[  ∫0¸0Î0¸0ûä  ª0÷0¢0Œ0ûä  ª0Í0Ø0◊0ûä  ª0Î0”0¢0ûä  Ω0À0Û0±0ûä  ø0¨0Ì0∞0ûä  ø0µ0Ô0Ø0ûä  ø0ﬂ0Î0peW[  ø0Í0∑0Â0ûä  ø0¸0 0áeW[  ¿0Î0∞0Ô0ûä  ¡0÷0¡0„0ûä  ¡0Ÿ0√0»0ûä  ¡0‡0∑0Â0ûä  ¡0„0Ø0ﬁ0ûä  ¡0„0‡0peW[  ¡0„0‡0áeW[  ¡0„0‚0Ì0ûä  ¡0„0Ô0§0ûä  ¡0Â0¸0Ø0ûä  ƒ0°0≥0Û0ûä  ƒ0°0’0Î0ûä  ƒ0©0Û0¨0ûä  ∆0£0∞0Ï0ûä  ∆0»0•0Û0ûä  ∆0Î0∞0peW[  ∆0Î0∞0áeW[  ∆0Ï0¸0Œ0ûä  «0£0Ÿ0“0ûä  «0£0Û0´0ûä  »0•0Ì0Ë0ûä  »0•0Ù0°0ûä  »0±0È0¶0ûä  …0•0¢0È0ûä  …0∞0Í0÷0ûä  À0Ù0°0πe ä  Õ0—0¸0Î0ûä  Œ0Ù0£0¢0Î0  –0ø0Ø0áeW[  –0’0£0¢0ûä  –0’0√0»0ûä  –0‡0Û0áeW[  –0Û0–0È0ûä  —0π0—0áeW[  —0ﬁ0´0πe ä  “0Í0‚0ƒ0ûä  ”0π0´0‰0ûä  ”0π0È0ﬁ0ûä  ‘0Û0§0Û0ò  ’0°0Û0∞0ûä  ’0£0∏0¸0ûä  ’0ß0Ì0¸0ûä  ’0Í0¶0Í0ûä  ÷0Æ0π0áeW[  ÷0È0’0§0ûä  ÷0Î0»0Û0ûä  ÿ0÷0È0§0ûä  Ÿ0ø0¶0£0ûä  Ÿ0»0 0‡0ûä  Ÿ0Û0¨0Î0ûä  ⁄0Î0∑0¢0¶f  €0∏0„0áeW[  ‹0π0À0¢0ûä  ›0Û0⁄0§0ûä  ﬁ0¨0“0¸0ûä  ﬁ0≥0Û0«0ûä  ﬁ0¡0„0·0ûä  ﬁ0…0•0È0ûä  ﬁ0◊0¡0ß0ûä  ﬁ0Û0¿0Î0ûä  ﬁ0Û0¿0áeW[  ﬂ0Ø0ﬁ0Ø0ûä  ﬂ0È0Û0¿0ûä  ‡0Û0¿0Û0ûä  ‡0¸0Û0áeW[  ·0∞0Ï0Î0ûä  ·0Ì0®0áeW[  ·0Û0«0áeW[  ·0¸0»0Î0’l  ‚0Ø0∑0„0ûä  ‚0Û0¥0Î0ûä  ‰0Û0Ÿ0Û0ûä  È0«0£0Œ0ûä  È0»0”0¢0ûä  È0—0Ã0§0ûä  Í0≠0¢0áeW[  Í0∞0Í0¢0ûä  Í0’0©0¸0‡0  Í0Û0¨0È0ûä  Í0Û0÷0peW[  Í0Û0÷0áeW[  Î0Û0«0£0ûä  Î0¸0Û0áeW[  Ï0∑0¢0πe ä  Ì0∏0–0Û0ûä  Ì0¸0ﬁ0peW[  Ô0Î0‘0Í0ûä  Û0¥0Û0–0ûä  Û0…0Û0¨0ûä  Ù0°0§0áeW[  Ù0°0È0¿0¸0  Ù0°0Í0π0ûä  Ù0ß0Õ0»0ûä  Ù0ß0◊0π0ûä  Ù0©0¸0»0ûä  Ù0Û0∏0Á0ûä  -NÔÉl˝V¶f  Sµ0¸0ﬂ0ûä  SËêΩ0»0ûä  WSµ0¸0ﬂ0ûä  WSËêΩ0»0ûä  ‰SŒ0Î0…0ûä  *gö[©áeW[  !|SO-N˝Vûä  !|SO"opeW[  s|ca“XSMO  A~SO"opeW[  "oûäËlÛóW[Õk  NO∑0Ï0∏0¢0ûä  È0Ì0»0Û0¨0ûä  WSËêØ0Î0…0ûä  ‰SxQ∑0Í0¢0ûä  ‰Sÿö…0§0ƒ0ûä  ÿ0÷0È0§0áeW[  WS¢0Î0ø0§0ûä  °åŸR(u"opeW[  ¢0™0˚0 0¨0ûä  ¢0¿0Û0∞0·0ûä  ¢0’0°0´0áeW[  ¢0’0Í0“0Í0ûä  ¢0·0Í0´0Kbqä  ¢0·0Í0´0ÒÇûä  ¢0È0—0€0¸0ûä  ¢0Î0‘0ø0Û0ûä  ¢0Î0·0À0¢0ûä  ¢0Ô0«0£0¸0ûä  ¢0Ù0ß0π0ø0ûä  §0Æ0Í0π0ÒÇûä  §0∆0£0œ0¸0µ0  §0Û0∞0Í0¢0ûä  §0Û0∞0¸0∑0ûä  §0Û0¿0π0áeW[  §0Û0…0˝Vö[¶f  ¶0ß0¸0Î0∫0ûä  ¶0©0È0§0ø0ûä  ¶0Ø0È0§0 0ûä  ¶0…0‡0Î0»0ûä  ¶0Î0…0•0¸0ûä  ®0¶0©0Û0…0ûä  ®0´0∏0Â0Ø0ûä  ®0π0»0À0¢0ûä  ®0¡0™0‘0¢0¶f  ™0Í0‰0¸0peW[  ™0Í0‰0¸0áeW[  ™0Î0¡0≠0peW[  ™0Î0¡0≠0áeW[  ™0Î0€0Û0áeW[  ´0§0∆0£0áeW[  ´0∑0ﬂ0¸0Î0ûä  ´0∑0Â0¸0÷0ûä  ´0ø0Ì0À0¢0ûä  ´0Î0‡0§0Ø0ûä  ´0Ï0Û0∏0Û0ûä  ´0Û0 0¿0peW[  ´0Û0 0¿0áeW[  ≠0 0È0§0¢0ûä  ≠0◊0Ì0π0áeW[  ≠0Û0÷0Û0…0ûä  Æ0Í0∑0„0peW[  Æ0Í0∑0„0áeW[  Ø0·0¸0Î0peW[  Ø0·0¸0Î0áeW[  Ø0Í0Û0¥0Û0ûä  Ø0Ô0À0„0ﬁ0ûä  ∞0¢0È0À0¸0ûä  ∞0È0¥0Î0áeW[  ∞0È0Û0ø0áeW[  ≥0Û0‘0Â0¸0ø0  ¥0Ì0Û0ø0Ì0ûä  µ0ﬁ0Í0¢0áeW[  µ0È0∆0£0áeW[  µ0Û0¿0¶0ß0ûä  ∑0„0§0¢0Û0ûä  ∑0Â0·0¸0Î0ûä  ∑0Û0œ0È0áeW[  ∏0Á0¸0∏0¢0ûä  π0È0‰0¸0Î0ûä  π0Ï0§0”0¸0ûä  π0Ì0–0≠0¢0ûä  π0Ì0Ÿ0À0¢0ûä  º0¸0È0Û0»0ûä  ø0§0‡0æ0¸0Û0  ø0§0˚0Ï0áeW[  ø0¨0Ì0∞0áeW[  ø0ﬁ0∑0ß0Ø0ûä  ø0ﬂ0¸0Î0peW[  ø0ﬂ0¸0Î0áeW[  ¡0ß0¡0ß0Û0ûä  ¡0ß0Ì0≠0¸0ûä  ¡0Ÿ0√0»0peW[  ¡0Ÿ0√0»0áeW[  ¡0„0¨0ø0§0ûä  ¡0„0Ø0ﬁ0peW[  ¡0„0Ø0ﬁ0áeW[  ¡0Â0Ù0°0∑0ûä  ¡0Á0Ø0»0¸0ûä  «0È0¶0ß0¢0ûä  «0Û0ﬁ0¸0Ø0ûä  »0•0Û0÷0´0ûä  »0Î0Ø0·0Û0ûä  …0¸0∞0Í0¸0ûä   0–0∆0¢0áeW[  À0¶0¸0®0§0ûä  À0„0Û0≥0Ï0ûä  À0„0Û0∏0„0ûä  Œ0Î0¶0ß0¸0ûä  œ0Ã0Œ0™0áeW[  œ0Û0¨0Í0¸0ûä  –0∑0≠0¸0Î0ûä  –0Î0¸0¡0¸0ûä  –0Û0∏0„0Î0ûä  —0∑0Â0»0•0ûä  —0Î0ﬂ0È0áeW[  —0Û0∏0„0÷0ûä  —0Û0—0Û0¨0ûä  “0√0ø0§0»0ûä  ‘0®0‚0Û0∆0ûä  ‘0´0Î0«0£0ûä  ’0£0Í0‘0Œ0ûä  ’0ß0À0≠0¢0ûä  ÷0“0√0…0áeW[  ÷0È0§0Ê0πpW[  ÷0Í0‰0¸0»0ûä  ÷0Î0¨0Í0¢0ûä  ◊0’0°0Î0ƒ0ûä  ÿ0∞0Œ0∑0Â0Ø0  ÿ0÷0È0§0peW[  Ÿ0È0Î0¸0∑0ûä  Ÿ0Û0¨0Î0peW[  Ÿ0Û0¨0Î0áeW[  ⁄0Î0∑0¢0peW[  ›0Í0»0À0√0Ø0  ›0Î0»0¨0Î0ûä  ›0¸0È0Û0…0ûä  ﬁ0´0√0µ0Î0ûä  ﬁ0±0…0À0¢0ûä  ﬁ0À0◊0Í0peW[  ﬁ0‰0aåb_áeW[  ﬁ0¸0∑0„0Î0ûä  ﬂ0„0Û0ﬁ0¸0ûä  ‡0÷0Û0…0•0ûä  ·0§0∆0§0áeW[  ·0…0•0Û0–0ûä  ·0Û0ø0Ô0§0ûä  ‚0Œ0»0À0√0Ø0  ‚0Î0¿0”0¢0ûä  ‚0Û0¥0Î0peW[  ‚0Û0¥0Î0áeW[  ‚0¸0€0¸0Ø0ûä  Ê0»0È0Û0…0ûä  È0»0¨0Í0¢0ûä  È0’0Û0¿0¸0ûä  Í0«0£0¢0áeW[  Í0»0¢0À0¢0ûä  Í0Û0÷0Î0’0ûä  Í0Ù0©0À0¢0ûä  Î0∏0„0Û0áeW[  Ï0◊0¡0„0peW[  Ï0◊0¡0„0áeW[  Ì0ﬁ0Û0∑0Â0ûä  Ì0ﬁ0¸0À0„0ûä  Ì0ﬁ0¸0À0¸0ûä  Ì0Û0–0Î0…0ûä  Ì0Ù0£0¢0 0ûä  Û0¨0‡0–0§0ûä  Û0∏0Â0´0πe ä  Ù0°0§0«0£0´0  &Ny0ˇfH0òè^  -N.YØ0Î0…0ûä  -Nÿö…0§0ƒ0ûä  NO0WΩ0Î0÷0ûä  Rg—è„NÒÇûä  S’0Í0∏0¢0ûä  SÛ0«0Ÿ0Ï0ûä  WSÛ0«0Ÿ0Ï0ûä  ‰Sz0Î0‡0áeW[  ‰S’0È0Û0π0ûä  ˝VõñÛóXä˜S  ì_egn0äpe’l  YeOπ0È0÷0ûä  Âe,gûän0áeW[  qg’0Í0∏0¢0ûä  ÏrÍÅn0äpe’l  ÒÇûä( s|˝V)   ÒÇûä( ÒÇ˝V)   â’0È0ﬁ0Û0ûä  â’0Í0∏0¢0ûä  ”ó˝Vûän0áeW[  ÿö0WΩ0Î0÷0ûä  ÷0Í0π0∑0Û0‹0Î0  ¢0Î0¸0ﬁ0À0¢0ûä  -NN™0È0Û0¿0ûä  -Ng’0È0Û0π0ûä  ‰S„NÆ0Í0∑0„0ûä  ‰S„N⁄0Î0∑0¢0ûä  ‰SxQÕ0Ô0¸0Î0ûä  { 0 } 0{ 1 }   ¢0§0π0È0Û0…0ûä  ¢0Î0·0À0¢0peW[  ¢0Î0·0À0¢0áeW[  §0«0£0√0∑0Â0ûä  §0Ã0‘0¢0√0Ø0ûä  §0Û0ø0¸0Í0Û0∞0  §0Û0…0Õ0∑0¢0ûä  ¶0©0Ï0¢0§0áeW[  ¶0¨0Í0√0»0áeW[  ¶0È0Î0ÛóXä˜S  ®0π0⁄0È0Û0»0ûä  ®0¡0™0‘0¢0peW[  ®0¡0™0‘0¢0áeW[  ®0Î0–0µ0Û0áeW[  ™0∏0÷0¶0ß0¸0ûä  ™0π0ﬁ0À0¢0peW[  ™0π0ﬁ0À0¢0áeW[  ´0§0Û0¨0Û0∞0ûä  ´0È0´0Î0—0Ø0ûä  Ø0¿0Ô0«0£0áeW[  ∞0¶0£0√0¡0Û0ûä  ∞0∏0„0È0¸0»0ûä  ∞0Î0‡0≠0¸0peW[  ∞0Î0‡0≠0¸0áeW[  ¥0¸0Û0«0£0¸0ûä  µ0‚0Æ0∆0£0¢0ûä  µ0Û0ø0¸0Í0¸0ûä  ∏0Á0¸0∏0¢0peW[  ∏0Á0¸0∏0¢0áeW[  π0§0π0…0§0ƒ0ûä  π0¶0ß0¸0«0Û0ûä  π0»0∑0Î0Ù0°0Û0  π0Î0∑0Î0Ù0°0Û0  ø0∞0–0Û0Ô0áeW[  ø0∑0Î0œ0§0»0ûä  ø0¸0Ø0Í0¸0peW[  ø0¸0Ø0Í0¸0áeW[  ¿0§0Û0¡0√0ƒ0°0  ¡0ß0Ì0≠0¸0áeW[  ¡0Ã0¸0Ø0˜mbûä  ¡0⁄0Ô0§0¢0Û0ûä  ∆0£0∞0Í0À0¢0ûä  ∆0£0’0 0∞0áeW[  «0ª0Ï0√0»0áeW[  »0Ø0˚0‘0∑0Û0ûä  »0–0˚0–0ø0Ø0ûä  »0Í0Û0Æ0√0»0ûä   0∑0œe≤0–0áeW[  À0„0‡0¶0ß0∏0ûä  –0Ï0Û0∑0¢0πe ä  —0∑0Â0»0•0¸0ûä  —0‘0¢0·0Û0»0ûä  —0’0È0Ù0£0¸0ûä  —0Û0¨0∑0 0Û0ûä  “0Í0¨0§0Œ0Û0ûä  ’0°0Û0∆0£0¸0ûä  ’0ß0À0≠0¢0áeW[  ’0©0Û0Ø0µ0Û0◊0  ’0Ï0§0∂0¸0áeW[  ’0Ï0ﬂ0√0∑0Â0ûä  ÷0¸0Û0»0Í0Û0∞0  ﬁ0§0∆0£0Í0¸0ûä  ﬁ0¿0¨0π0´0Î0ûä  ﬁ0È0‰0¸0È0‡0ûä  ﬁ0È0¸0∆0£0¸0ûä  ﬁ0Û0«0£0Û0¥0ûä  ﬂ0 0Û0´0–0¶0ûä  ﬂ0„0Û0ﬁ0¸0peW[  ﬂ0„0Û0ﬁ0¸0áeW[  ·0∆0Î0¡0√0ƒ0°0  ‚0¸0«0£0¸0áeW[  È0¸0Û0 0¸0peW[  È0¸0Û0 0¸0áeW[  Í0–0◊0¸0Î0πe ä  Î0§0ª0¸0À0Á0ûä  Î0–0˚0Î0Î0¢0ûä  Î0Ï0˚0µ0¸0ﬂ0ûä  -N.Y…0•0π0Û0ûä  ‰S§0ø0Í0¢0áeW[  ‰S„N®0∏0◊0»0ûä  0WﬂW:   { 0 }   ^˝V¢0È0‡0áeW[  áeW[:   { 0 }   jñnΩ0¸0»0òè^  "oW[( !|SOW[)   "oW[( A~SOW[)   ÅyGRÊQt( 1_)   ÅyGRÊQt( 7_)   â–0Ì0¸0¡0¸0ûä   äûä:   { 0 }    äûäÑvÖQπ[j0W0  ä˜Sg0&Ny0ˇfH0  ¥0¢0˚0≥0Û0´0À0ûä  ™0π0ﬁ0Û0»0Î0≥0ûä  ¢0π0»0•0Í0¢0π0ûä  { 0 }      ÚV0  { 0 }      ·b5_  { 0 }      —ñY  ¢0’0Í0´0¸0Û0π0ûä  ¢0Ù0ß0π0ø0¸0áeW[  §0 0Í0˚0µ0¸0ﬂ0ûä  §0Û0ø0¸0Í0Û0∞0¢0  ®0∏0◊0»0lFàáeW[  ®0∏0◊0»0^yò[áeW[  ®0∏0◊0»0VÄ;RáeW[  ≠0À0¢0Î0Ô0Û0¿0ûä  ≠0Î0ﬁ0Û0∏0Â0≠0ûä  ∞0∏0„0È0¸0»0peW[  ∞0∏0„0È0¸0»0áeW[  ∞0Í0¸0Û0È0Û0…0ûä  ≥0§0È0˚0¡0¸0À0ûä  ≥0¸0Û0¶0©0¸0Î0ûä  µ0Û0π0Ø0Í0√0»0ûä  ∑0„0¸0È0¿0¸0peW[  ∑0„0¸0È0¿0¸0áeW[  π0≥0√0»0È0Û0…0ûä  ø0§0˚0Ù0ß0»0áeW[  ∆0£0Î0’0¸0ø0áeW[  ∆0Û0∞0Ô0¸0Î0áeW[  …0§0ƒ0ûäÁeck¯f’l   0∆0£0æ0¸0Õ0πe ä  À0ß0®0Û0¨0»0•0ûä  ÷0È0¸0’0ﬂ0¸0peW[  ÷0È0¸0’0ﬂ0¸0áeW[  ÿ0‹0Û0_Ì0¸0ﬁ0W[  ‹0¸0∏0Â0◊0Í0¸0ûä  ›0È0¸0…0ÛóXä˜S  ﬁ0§0Û0’0È0Û0Ø0ûä  ﬁ0Ø0¢0˚0ﬂ0¸0»0ûä  ﬁ0È0‰0¸0È0‡0peW[  ﬁ0È0‰0¸0È0‡0áeW[  ﬁ0¸0Î0Ô0¸0Í0¸0ûä  ·0Ì0®0áeW[IÉ¯fSO  ‰0¸0…0˚0›0Û0…0’l  Ê0À0≥0¸0…0gqTò  Î0Ø0ª0Û0÷0Î0Ø0ûä  Î0–0˚0´0ø0Û0¨0ûä  Ì0Û0¥0Ì0Û0¥0áeW[  Û0∏0®0‡0÷0¸0Û0ûä  ‰S¢0§0Î0È0Û0…0ûä  ‰S„N⁄0Î0∑0¢0áeW[  ‰Sg◊0Ì0–0Û0π0ûä  áeW[     { 0 }   ∞eø0§0˚0Î0¸0peW[  ∞eø0§0˚0Î0¸0áeW[  qg¢0Î0·0À0¢0áeûä  ÅyGRÊQt( jñn)   â¢0Î0·0À0¢0áeûä  -Ng¢0§0Î0È0Û0…0ûä  ‰SxQÙ0©0È0‘0Â0Ø0ûä  ≤0∞0˚0¢0Î0–0À0¢0ûä  ‰S„NWS¢0È0”0¢0áeW[  ≥0Û0¥0˚0π0Ô0“0Í0ûä  ˛s„Njñn¢0È0”0¢0ûä  µ0ﬁ0Í0¢0˚0¢0È0‡0ûä  { 0 }      Y0y0f0  { 0 }      ]0n0÷N  ¢0º0Î0–0§0∏0„0Û0ûä  ¢0 0»0Í0¢0aåb_áeW[  §0Ã0Ø0∆0£0»0√0»0ûä  ™0¸0π0»0È0Í0¢0ÒÇûä  ≥0ﬂ0˚0⁄0Î0ﬂ0„0Ø0ûä  µ0¶0È0¸0∑0Â0»0È0ûä  ∂0¸0ø0¸0’0Í0∏0¢0ûä  ∏0Á0È0ˇ’0©0À0£0ûä  π0≥0Î0»0˚0µ0¸0ﬂ0ûä  Ω0È0˚0Ω0Û0⁄0Û0peW[  ¡0„0…0˚0¢0È0”0¢0ûä  «0Â0◊0Ì0Ô0®0_êä  »0È0«0£0√0∑0Á0 0Î0  »0Û0¨0ûä( À0¢0µ0)   –0’0∆0£0‰0¸0Í0¸0ûä  —0œ0¶0˚0’0‚0Û0áeW[  ﬁ0œ0¸0∏0„0À0¸0áeW[  ﬁ0¸0∂0Û0¿0È0¸0Û0ûä  Ê0¿0‰0˚0¢0È0”0¢0ûä  Ê0¿0‰0˚0⁄0Î0∑0¢0ûä  È0¸0∏0„0π0ø0¸0Û0ûä  Ù0°0§0áeW[n0äpe’l  Rg˛s„N’0È0Û0π0ûä  ‰S„Nœ0Û0¨0Í0¸0áeW[  ‰S„NS¢0È0”0¢0áeW[  7_¶^k0à0ã0&Ny0ˇfH0  pe$Pk0à0ã0&Ny0ˇfH0  ˛s„NÙ0©0È0‘0Â0Ø0ûä  ëxáe—0Î0∆0£0¢0áeW[  Oäê®å’0©0¸0ﬁ0√0»0  ª0Î0‹0˚0Ø0Ì0¢0¡0¢0ûä  ‡0π0Í0‡0˚0ø0ø0¸0Î0ûä  q} N»0Î0≥0È0∆0Û0áeW[  { 0 }      íN€cáeW[  { 0 }      ‰S„NáeW[  ¢0Ø0ª0Û0»0g0&Ny0ˇfH0  ¢0È0”0¢0˚0§0Û0…0peW[  ®0∏0◊0»0˚0¢0È0”0¢0ûä  ®0π0»0Ï0ﬁ0…0•0¸0È0ûä  ®0¡0™0‘0¢0uRN }CQ¶f  ´0Ì0¸0∑0Â0∆0£0¸0áeW[  Ø0Í0ﬂ0¢0˚0ø0ø0¸0Î0ûä  ≥0§0È0‹0Ì0˚0ª0Û0À0ûä  µ0¶0È0¸0∑0Â0»0È0peW[  µ0¶0È0¸0∑0Â0»0È0áeW[  ∑0Ì0∆0£0˚0 0∞0Í0áeW[  «0¸0–0 0¸0¨0Í0¸0áeW[  œ0§0¡0˚0Ø0Ï0™0¸0Î0ûä  –0È0Û0˚0Ø0∑0∆0£0áeW[  —0¶0˚0¡0Û0˚0œ0¶0áeW[  ⁄0Î0Ω0˚0¢0È0”0¢0áeW[  ›0Û0»0π0˚0Æ0Í0∑0„0ûä  ‚0Ì0√0≥0˚0¢0È0”0¢0ûä  È0¸0Û0 0¸0˚0ø0‡0peW[  Ì0±0¸0Î0n0–0Í0¢0Û0»0  Ì0¸0ﬁ0peW[( \áeW[)   ÂNMRn0òè^ˇíN€c'`	ˇ  'YáeW[*QHQg0&Ny0ˇfH0  \áeW[*QHQg0&Ny0ˇfH0  jñnê®å’0©0¸0ﬁ0√0»0  ckèâSk0à0ã0&Ny0ˇfH0  ëxáe—0’0È0Ù0£0¸0áeW[  â¶f( ∞0Ï0¥0Í0™0¶f)   ÛóXòk0à0ã0&Ny0ˇfH0  ’0£0∏0¸0˚0“0Û0«0£0¸0ûä  ·0Œ0 0§0»0NO0W…0§0ƒ0ûä  π0≥0√0»0È0Û0…0jñnÒÇûä  1 2 Bfìï6R( 0 01 1 )   1 2 Bfìï6R( 1 01 2 )   2 4 Bfìï6R( 0 02 3 )   2 4 Bfìï6R( 1 02 4 )   ´0È0¡0„0§0˚0–0Î0´0Î0ûä  Æ0Í0∑0„0peW[( \áeW[)   ±0§0∏0„0Û0˚0’0È0Û0π0ûä  ø0È0∑0±0Ù0£0ƒ0°0ck¯f’l  ¡0Â0À0∏0¢0˚0¢0È0”0¢0ûä  «0¸0Ù0°0 0¸0¨0Í0¸0peW[   0§0∏0ß0Í0¢0˚0‘0∏0Û0ûä  ﬂ0„0Û0ﬁ0¸0˚0∑0„0Û0peW[  ˙W,gáeW[n00g0&Ny0ˇfH0  pe$Pí0ÏrÀzW0f0&Ny0ˇfH0  ¯fir(u—0’0È0Ù0£0¸0áeW[  jñnÏ0¸0∏0¢0πe äck¯f’l  ckèâSW0j0D0g0&Ny0ˇfH0  "opeW[( MO÷Sä0äpe’l)   ä˜Sí0!qñâW0_0&Ny0ˇfH0  ä˜Sí0!qñâW0f0&Ny0ˇfH0  iäË}(u—0’0È0Ù0£0¸0áeW[  µ0√0µ0Í0˚0µ0Î0«0¸0À0„0ûä  ¡0Û0‹0È0Ω0ÿö0W±0¡0Â0¢0ûä  Y0y0f0í0:S%RW0f0&Ny0ˇfH0  ¢0Î0∏0ß0Í0¢0˚0¢0È0”0¢0ûä  ¢0Î0·0À0¢0peW[( \áeW[)   ¶0ß0¸0…0_Ì0¸0ﬁ0W[hàä’l  ™0º0¢0√0≥0/ ™0Ω0‰0Õ0πe ä  ´0’0´0π0˚0¢0Î0–0À0¢0áeW[  ∏0„0ﬁ0§0´0˚0Ø0Ï0™0¸0Î0ûä  ∏0Á0¸0∏0¢0áeW[( ’0ƒ0Í0)   π0≥0√0»0È0Û0…0˚0≤0¸0Î0ûä  ª0¸0∑0ß0Î0˚0Ø0Ï0™0¸0Î0ûä  Ω0È0Û0∞0˚0Ω0Û0⁄0Û0∞0áeW[   0∏0Â0…00Wπe˚0¢0È0”0¢0ûä  ‘0Û0Ûó( Ì0¸0ﬁ0W[hàä’l)   ⁄0Û0∑0Î0Ÿ0À0¢0˚0…0§0ƒ0ûä  È0∆0Û0áeW[( …0§0ƒ0áeW[)   Í0Û0∞0¢0˚0’0È0Û0´0˚0Œ0–0  Î0§0∏0¢0 0˚0Ø0Ï0™0¸0Î0ûä  -N.Y¢0È0π0´0˚0Ê0‘0√0Ø0ûä  pe$Pí0pe$Ph0W0f0&Ny0ˇfH0  Bfìï6R( 1 2   /   2 4 )   jñn…0§0ƒ0ûä  ( π0§0π0)   q}T´0 0¿0HQOOlÛó¿{áeW[  ”0∑0Â0Ã0◊0Í0‰0˚0ﬁ0À0◊0Í0ûä  ‰S„NYeOπ0È0÷0ûä≠0Í0Î0áeW[  ´0¸0‹0Ÿ0Î0«0˚0Ø0Ï0™0¸0Î0ûä  ¿0Í0¸0ûä( æ0Ì0¢0π0ø0¸0Ye)   …0§0ƒ0ûäck¯f’l( 1 9 9 6 )   –0§0®0Î0Û0˚0™0¸0π0»0Í0¢0ûä  ‹0€0Í0√0ƒ0˚0¢0Î0’0°0Ÿ0√0»0  ‚0¸0Í0∑0„0π0˚0Ø0Ï0™0¸0Î0ûä  È0∆0Û0áeW[  ( ≤0¸0Î0áeW[)   -N.Y¢0»0È0π0˚0ø0ﬁ0∏0Ø0»0ûä  qQê≥0¸0Û0¶0©0¸0Î0ûäck¯f’l  jñn≥0¸0Û0¶0©0¸0Î0ûäck¯f’l  jñn‚0Ì0√0≥0  ø0ﬁ0∏0Ø0»0ûä  A~SOW[-N˝Vûäò( B i g 5 )   »0Î0Õ0¿0¸0Î0˚0’0£0Û0È0Û0…0ûä  µ0Û0˚0∏0Á0Î0∏0Á0/ ”0¸0È0πe ä  ∑0Í0¢0áeW[( qgπe∑0Í0¢0áeW[)   ∑0Í0¢0áeW[( âπe∑0Í0¢0áeW[)   π0⁄0§0Û0ûä  ( §0Ÿ0Í0¢0JSˆ\)   Œ0Î0¶0ß0¸0ûä( À0¸0Œ0∑0Â0Ø0)   Œ0Î0¶0ß0¸0ûä( ÷0¸0Ø0‚0¸0Î0)   Ï0¸0∏0¢0πe ä  Í0›0Ù0°0ƒ0πe ä  9eäq} N≥0¸0Û0¶0©0¸0Î0ûäck¯f’l  ¢0Ø0ª0Û0»0ˇêπeT	ˇg0&Ny0ˇfH0  ¢0Ø0ª0Û0»0ˇòπeT	ˇg0&Ny0ˇfH0  §0π0È0‡0tk( ö[hTg0lQl }CQ)   §0π0È0‡0tk( ö[hTg0)Yáe }CQ)   ∑0Â0·0¸0Î0ˇ¢0√0´0…0ûäTib_áeW[  œ0Û0∞0Î0ûä-òP[Ûók0à0ã0&Ny0ˇfH0  ›0Î0»0¨0Î0ûä  ( §0Ÿ0Í0¢0JSˆ\)   'YáeW[\áeW[í0:S%RW0_0&Ny0ˇfH0  'YáeW[\áeW[í0:S%RW0f0&Ny0ˇfH0  jñnŸ0È0Î0¸0∑0ûä  ( 1 9 5 9 )   !|SOW[-N˝Vûäò( G B 2 3 1 2 )   U n i c o d e   ckèâSg0&Ny0ˇfH0  §0π0È0‡0¶f( ¶0Û0‡0˚0¢0Î0Ø0È0¸0)   ∑0Í0¢0áeW[( ®0π0»0È0Û0≤0Ì0áeW[)   π0»0Î0Ù0£0√0ƒ0°0/ Ω0Î0”0ƒ0°0πe ä  Ë0¸0Ì0√0—0 äûäáeW[n0&Ny0ˇfH0èâGR  ˙Wï^áeW[n0.z%Rí0ô}bY0ã0P}TáeW[  'YáeW[ò/ \áeW[òk0à0ã0&Ny0ˇfH0  å_g-NN’0È0Û0π0ûä( 01 6 0 6 )   ¢0Ø0ª0Û0»0ˇêπeT	ˇk0à0ã0&Ny0ˇfH0  'YáeW[\áeW[í0:S%RW0j0D0g0&Ny0ˇfH0  'YáeW[\áeW[í0ê8^n0òè^g0&Ny0ˇfH0  A L A - L C È0∆0Û0áeW[S( 1 9 9 7 )   §0π0È0‡0¶f( µ0¶0∏0¢0È0”0¢00g≥â,n)   ¢0Ø0ª0Û0»0/ 'YáeW[\áeW[/ hQ“âJS“âg0&Ny0ˇfH0  ¢0Ø0ª0Û0»0/ 'YáeW[\áeW[/ hQ“âJS“â/ ÓNTg0&Ny0ˇfH0       + 8 E V a m w Ä É ÊÜ é éö~ƒŸë€qﬂOﬂ©ﬁi⁄ˆÿÏÿÊ—ìƒ∆‹™»B≈ñ»åœ'⁄çƒbò
o¿° • © S∞!,	≠ @0	4	ó¥ËÚ¥± [µ (º 8	¿ <	;
@	ó∏Hƒ D	ˇrº» x
a´H	Ã L	– P	T	?
‘ X	◊ \	€ `	d	ﬂ ‚ Ê ˝h	Í l	C
ËÓ Ò 
p	t	Áx	|	Ù ¯ Ä	Ñ	˚ à	ˇ G
å	ê	î	ò	¨õ
Áú	†	§	u®	∫"¨	∞	≥	&*K
-0Å˛3
 77;Ω	O
A¡	E≈	I…	MS
QTÕ	X[_c¿gkB W
X—	◊	ou[
o‰		{~œÇ_
c
Ödàƒå9èì 
g
k

o
s
ñö@ù°•w
{
»<©≠¡Ã
MÉ
–á
±µã
πΩ¡‘ÿƒ»À@Hœo”ì‹÷⁄ﬁ§
‚ÊÍ‡ÌÒ)Ù¯'
¸ i	ˇäg¯-‡‰	è
ì
Ëló
 $õ
(ü
,04Ï8<?£
CÙG¯K1	J,ND
RVY\`ß
dÖh¸ lpKtx|ÄÉ´
áäçÈêªØ
≥
É î¨0òOz∑
ª
ú†ÀD§ø
®¨∞¥~∏ º¿8(ƒ√
»«
Ã–‘:À
ÿ‹4 ‡‰;‚œ
ÁÎÔ$ÊÛˆ˙˛”
(,	ï‘î $–(,
039=@5D◊
0HaLPT
ò€
Wﬂ
„
D )	Á
Î
[^Ô
bfj4n8<ø@rËDHÛ
v˜
≠	î
z}
˚
ÅÖLPh
é© 
âˇ
çT¿X\íA	ñË
öû¢¶`™Æ≤µπëdΩ9¡h≈…l}Ã–Z<&
‘◊pt⁄v›·ÂÁÈMÌÛÒ˜œx˚ƒˇæ*
0
|ëÄ i
#¡É'b+Ñ4
/à37˜å!ˆê;ïî%)-0(48<]?¸@îŸ≈D∂òúH†§KC®NlRVZG^úbfj¨mKOqu√FÛyùS7
∞W}Åâëîòú0…6…≠≈…ÃÕ*…Œ€÷’⁄Õ®≈û≈£≈…N…`…¨◊∑Õ<…H…F≈l…Œ◊ ◊Ÿ◊`ÃB…ÔÕ‹€^‹T…⁄lŸ$…∑’·Õ≤’r…M∆Œ…Ú◊I–P–Óƒ3›Êƒ~«(‘n Œ–µ«ø«Ã˛ƒ∏Ày«≤–Ä’…÷‚Àí«ÚƒW–∂ƒÄ ƒÀ*ÃÀÌ‹~ÿÃ¶«Ã≈<Ã…´–˙ƒ‰»ó«7—≥ŒÓ≈∆˙»4ÀÀ∂œŒ ⁄ƒ.À
À“œ:À»¯”Óœ ‘ΩœMœÌ—V W∆˝≈/∆òŸD‹«¨Œ:“Áœ<Œ¸œÚ∆Àœ∆´Õ”‹ıœpœîÀvÀ∆–˚—(’éÀê“pÀ8ÿù∆ ∆˜∆¡≈∑≈¥…∫…8’fŒ¢“º≈∂⁄ÿﬁ…ŒËÕ>≈”™ Ì›¨‹mŒt«_ŒwŸ™“ÓÀx‘Í»∏›è–±›ÙÀ˙Àú«ö“€ò“%“ˆÕ	“H“ Ãk“ö◊˝» êƒ™ƒÍƒ›7‹H∆   ∆Ù—œ©Õ†’Ä”1œf∆>∆†“®”h”2≈Ë»9∆‚«`”[«V«J≈`«Ãö⁄ï⁄p‘z–°«÷À#Ÿy“Ñƒ⁄ŸB–ˆƒ˝Õ∞«Ò’≤≈ä…“Ë“ûƒå»‡“ê…'Œöƒ¿“Ñ…ÿ ŒV≈‹¸ÃÕTÃ∞ÿ¶ÿh—ò∆bœP”¯≈È≈⁄≈∆–≈Í…‰…‰≈NÃ	›B«∫ƒa∆H”¶ƒb B÷\ ∆÷œ’≈¢ƒ9÷¡Œ8 ‰Œ Ü≈ÿ£’J  ∆Û≈È⁄*∆÷Œ 4∆•Œz ≤ÀC∆ùÕ%∆, ≤ƒK÷& #»¥Ã(»v—-»#◊F»í‹∆ã—ÃÃí—»√—ÿÃã≈ˆ«ü‹.≈á»Ñ—o—,◊’’A»"≈
≈<»∫Ãäƒ≈ZÃ”«HÃ®‘ˇ–»‘…«≈¢ÃfÃÒ«≈O›∞‘ò◊‰÷≈—ƒ«rÃ–‘—∏‘®Ã^≈ı‹a—≈¿‘Ó»›«ÿ«~Ã√»> xÃˇ÷>—"—Á«¿…úÿ.«~≈8«‚ƒﬁ“¶⁄†À≤“Õ=«–≈Õí“ò‘D ¸›>◊4–Q«bÕ¶À6≈“PÕL«3«∞“-–@‘&–G«s»∆≈0”À≈ÿ…Ã…“…©’l–h‘`‘s–X‘ä≈à–1€x‹°⁄®“π–ñ–ç«¯–Å–⁄BÃ‹»Y◊P‘Ò–ôﬁ…€∆¬€∫ÿ¿ÃîÕµ—2»Æ—ÍÃâ“L—U»º—*≈K»›»7» —à“÷&≈T÷Fœæƒ‘◊‚»k∆ê”$ÿ——u∆∫€Ü o÷ì∆µ€õÕJÕ±∆Œƒ“ƒ‘ £Ÿz∆G◊à”Ÿ–”â∆Vÿò Ñ∆wœ~œçÕiœp∆VÕ ’Ë’Bÿé∆‡ ≈∆¿∆Ø◊⁄ ∞ ∂∆ß∆ñƒ\Õ.ÿ¨∆¢∆∆ƒTœ∞”ƒ◊¿◊\∆¢Õ§ÕéÕË∆$«««ﬁƒjÀXÀﬁ∆∫Õ‘RÀ«
–àÀFÀÊ œ0‘¯ °œ«ñÕtÿ ‘≠’|ÀÌ∆LÀ@ÀÀ/Ÿ*Ÿ–«)«Ï „∆ÇÀk›QŒú…®…JŒ)—Õ»XŒÆ…x»∫«,Õ2Õ$Ãd“€÷§◊8Õ}»>Õd»&ÕCŒ_»Z»Õ¢…uƒ∫ŒÆƒäÃ÷ƒ≈ »ÆÃx…ÿ“
»•÷N≈«t Ä“Öœª∆ï›ˆ»nÕÙ»»  ƒê’¬ƒ aou…]“V“ ≠	]^–ñ…ß πæe» Õ[“◊`œe‘jŸot·y~Éàçíóﬁú„°Ê¶´∞ÎËµÌ∫øÚ˜¸ƒÑå˙…Œ”ÿ›$ˇ‚)Á.38	Ï=ÒˆB˚ 
",1#G6L(;@Q-JT2Y7^<VAhmFKrw|PUÅÜZ_ãdiêïnöü§[©sx}ÇáåëÆñõ`≥∏e†•™jotΩØ¥π¬«æ√»Õy~Éàçí”Õ‹π◊H’–“ﬂ’à«æÀo«¨À‹–Ä“àÕ∑÷§–Ãù–‡œ‡‹¸…(À” P ›Œ›˚‹œŸ‘`ÿ˙’÷÷(” ”*‹†”œh #œÚŒ0÷x”ÜÕe«áƒ;–f≈n≈∞Õô≈¸◊àÿlƒÿÿ.Œ0’äÕ§ A“πˆ…ﬂ≈çŸ œ6ÃœŒr“2 ûŒ ’»Ö‹]›:Ÿß—‰Ãπ»æ»ê‘P»∆Ã}—íÿlÃŒ«—ñÃ◊êÃˆ÷‘Z—ÑÃÏ«0—‡‘‚ÿ–8‘n»{ƒ∆…êŒóŒÇŒ@”e–Ÿ“ Àt⁄©€a€Ä‘“÷
Ÿô—5◊Ã8œ?œ∂◊πŸë»å f÷ÅƒX”[œQ‹¬ ƒŸí ﬂﬁ›œ›»”‡”ìœt◊Øœ»»x÷dÀä÷‘öœ˛ Ÿ∆ÀœÅ÷ ”Õr≈ÂŸ¯“P◊yﬁ≥Õ>ﬂõ»j≈“»Ç≈Ç»hÕ Ñå`’h’ e˚Ÿ ¡ “ŸﬂË¸“ﬂÏ*2;Ciƒ:≈R∆¸∆tŒÇŸ⁄»5Œ~…Yﬁ∫ﬂiﬁ˙ﬁA≤xƒ0ÃDÕ GOŸ^⁄ Xfò’ù€ 5nIﬁ9ﬁ r5xS⁄ïﬂH⁄ 5nÉﬂπﬁ 5ny€Èﬁ 5nU€π‹ ~àê¨õœ€I€‰ﬂVŸÕﬂ §˝¨∑®Ω«—⁄„ÍOÛ˙“£›=⁄v≈◊-ﬂŸﬁ◊»ä⁄ËÀ“Ã†»âﬁX’b≈jÿz≈Z≈ oƒrƒë≈ &*.2π⁄≈⁄—⁄›⁄ 6<Cp’Ü◊x’ ‚ Mgƒ# T[dúÃ◊zÕ= mrzﬁá„ËÌåëñûß¨±πæ√À–ÿ›Â¸ÍÔ˜¸TYkp!u&,zéìòù5:BGL˙QaŸ„–»“È€É«’–Æ÷Ÿœ"À%€”æÕè≈ò”ÎŒı⁄'÷p”Ö€tÕ¥»ÄÕî≈«–û ¡Õñ≈…˘Œ»Œ¯‘⁄»Ø»†—ﬁÃÌ÷S——ÿ‘=€O“i»âŒ{Œ8”Õ2⁄ÆŸ]÷Lÿº ÿ”k◊®œÚ ^À‘∆ƒœ3“ƒÿ< ¨µæÀ” (0˜ˇ+2:AHQYksy9ãëô®?∞G¿∆Ã€MT\ÎbÒ˜j	#,4<syCQÄYâ`ﬂŒÿì÷…ﬁm€%›ßﬂf…}◊è◊5Ÿj«‹À¿›A›†‘Ë”“,“”à‘¿÷¿–Œ˚«•»y›á›»ﬁË‘E—ÿ—ú÷öÀ Ÿ‹–Àk‹Í–*œ´«R≈¢◊ˆÃñƒ≠⁄’ﬂ∂ ¿”∏”€+ﬁ)ﬁZ…ﬂ—H‘ Õˆ€ π … ‹ÂÏà’P’@’ 		"	e!ù.∏“™™     + 8 E V a m Ä É JÊÜ ™™„! P" P" P" P" P" P#" P(" P-" P8" P[" Pb" Pk" Pr" Pw" P~" P
 ÿtÇêô¢´πø«™™ﬁ◊ `e! `@Ÿ `ª’ `ƒ’ `KŸ `Õ’ `Ë◊ `b◊ `r# P   ó †∞¬ó´ªV^œˆñ Pª PÄ  Pá  På  P€! P‡! PÀ  ˘" PŸ. `‰  u# P|# P                                                                                                                                                                                                                                                                                                                                                                                                                                                                á€tçoqjÏ˜pÇKåÄ°Óy˙_TÓâ‰}#ﬁ√‹¨éè*°IIm`{ÒπÂ¨Ωª…˛‰ZËoZÁ‡e[Äÿ{¨SúÔ–Ttóıp+àê*PÁÅ	¯ÁçN∫l%Ù“ïÑ„i•N‰·'¿9÷	‹Ö o˛F‰…\Ø{æÑdH‰6é∑J¯„†%-© ˛J÷yi€§ÿÎ‰FT˜ohéEª≥wã†B¡V‡âoøÅ_"n…Éä⁄LiçYY*yË,ÄÅS°∫Û•Ø÷Ê)ø•[¶jc[}QyÙ⁄Ålÿê-=≥√à⁄ñájÅ‰÷f—:~F~π’!3 ¸∑bﬂK©á∫ZåÕu-“6gT°)Ó„ñmgˆ(ˆ πRëT∏/¢œÍú6P‘–qI}˝îˇˆKá™Ú≈|ÎÄ”πt"t\¶5aı?ˆQÌHo∏Q`◊{îÜºïêx[HNÛ39zÎ¿∑ÖàIñ˙†¸Å◊Aí&zøÉ|i|Päß0@◊Î)˚9+E˜ıkuó6pS˝18ÀAñ®P£idl.ÀÊã›∆B™È3ÇE’›´1/*Ã“n7HÑB“ ¶vsü¥êœ/∏…›#Òı≥rΩkûˆ–ü~ºã!naœÅíh∑eˇÏ	Jxõu˛Ø˜†`Ω\ŸB˙H‘üÍ0?àºnuÌﬁ&Æ>e®Îé˘Û≈Ë[NÒ©FüaoêGj—˘/´P˜¬¶wπ¿lÁˇÔÚ∆©≥_≠˚M”Â¡lóÃ∑÷vÉ“6ãÚòôÙ~˜~˙í'≥L#ÃÓ<fC;ø_◊+•=·∫Œ$Ÿí˘øä˜πÃß”WÓ9Å·Æ√ÊG∞—Ü9v⁄‹Ä€π›#ñÕÔ