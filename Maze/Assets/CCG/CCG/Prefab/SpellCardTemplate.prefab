ction.Add(keyedItem2);
                keys = keys.Push(key1);
                items = items.Push(keyedItem1, keyedItem2);
                itemsWithKeys = itemsWithKeys.Push(keyedItem1);
                keyedItem2.Key = default(TKey);
                collection.MyChangeItemKey(keyedItem2, default(TKey));
                collection.Verify(keys, items, itemsWithKeys);
            }
        }

        [Theory]
        [MemberData(nameof(ClassData2))]
        public void ChangeItemKeySetKeyNonNullToNullChangeKeyNonNull(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            if (default(TKey) == null)
            {
                TKey[] keys;
                IKeyedItem<TKey, TValue>[] items;
                IKeyedItem<TKey, TValue>[] itemsWithKeys;
                TValue item1 = GenerateValue();
                TValue item2 = GenerateValue();
                TKey key1 = GetKeyForItem(item1);
                TKey key2 = GetKeyForItem(item2);
                var keyedItem1 = new KeyedItem<TKey, TValue>(
                    key1,
                    item1);
                var keyedItem2 = new KeyedItem<TKey, TValue>(
                    key2,
                    item2);
                var collection =
                    new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
                collection.AddItems(
                    generateKeyedItem.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    collectionSize,
                    out keys,
                    out items,
                    out itemsWithKeys);

                collection.Add(keyedItem1);
                collection.Add(keyedItem2);
                keys = keys.Push(key1);
                items = items.Push(keyedItem1, keyedItem2);
                itemsWithKeys = itemsWithKeys.Push(keyedItem1);
                keyedItem2.Key = default(TKey);
                if (collectionSize >= 32)
                {
                    AssertExtensions.Throws<ArgumentException>(null, () => collection.MyChangeItemKey(keyedItem2, key2));
                }
                else
                {
                    collection.MyChangeItemKey(keyedItem2, key2);
                }
                collection.Verify(keys, items, itemsWithKeys);
            }
        }

        [Theory]
        [MemberData(nameof(ClassData2))]
        public void
            ChangeItemKeySetKeyNonNullToNullChangeKeySomethingElse(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            if (default(TKey) == null)
            {
                TKey[] keys;
                IKeyedItem<TKey, TValue>[] items;
                IKeyedItem<TKey, TValue>[] itemsWithKeys;
                TValue item1 = GenerateValue();
                TValue item2 = GenerateValue();
                TValue item4 = GenerateValue();
                TKey key1 = GetKeyForItem(item1);
                TKey key2 = GetKeyForItem(item2);
                TKey key4 = GetKeyForItem(item4);
                var keyedItem1 = new KeyedItem<TKey, TValue>(
                    key1,
                    item1);
                var keyedItem2 = new KeyedItem<TKey, TValue>(
                    key2,
                    item2);
                var collection =
                    new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
                collection.AddItems(
                    generateKeyedItem.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    collectionSize,
                    out keys,
                    out items,
                    out itemsWithKeys);

                collection.Add(keyedItem1);
                collection.Add(keyedItem2);
                keys = keys.Push(key1);
                items = items.Push(keyedItem1, keyedItem2);
                itemsWithKeys = itemsWithKeys.Push(keyedItem1);
                keyedItem2.Key = default(TKey);
                if (collectionSize >= 32 && keyedItem2.Key != null)
                {
                    AssertExtensions.Throws<ArgumentException>(null, () => collection.MyChangeItemKey(keyedItem2, key4));
                }
                else
                {
                    collection.MyChangeItemKey(keyedItem2, key4);
                }
                collection.Verify(keys, items, itemsWithKeys);
            }
        }

        [Theory]
        [InlineData(0)]
        [InlineData(4)]
        [InlineData(25)]
        [InlineData(33)]
        public void Clear(int collectionSize)
        {
            TKey[] keys;
            IKeyedItem<TKey, TValue>[] items;
            IKeyedItem<TKey, TValue>[] itemsWithKeys;
            var collection =
                new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
            collection.AddItems(
                GetNeverNullKeyMethod.Value.Bind(
                    GenerateValue,
                    GetKeyForItem),
                ki => ki.Key,
                collectionSize,
                out keys,
                out items,
                out itemsWithKeys);
            bool haveDict = collection.GetDictionary() != null;
            collection.Clear();
            collection.Verify(
                new TKey[0],
                new IKeyedItem<TKey, TValue>[0],
                new IKeyedItem<TKey, TValue>[0]);
            Assert.Equal(haveDict, collection.GetDictionary() != null);
        }

        [Theory]
        [MemberData(nameof(ClassData))]
        public void Contains(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            var collection =
                new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
            TKey[] keys;
            IKeyedItem<TKey, TValue>[] items;
            IKeyedItem<TKey, TValue>[] itemsWithKeys;
            collection.AddItems(
                generateKeyedItem.Value.Bind(
                    GenerateValue,
                    GetKeyForItem),
                ki => ki.Key,
                collectionSize,
                out keys,
                out items,
                out itemsWithKeys);
            if (s_keyNullable)
            {
                Assert.Throws<ArgumentNullException>(
                    () => collection.Contains(default(TKey)));
            }
            else
            {
                Assert.False(collection.Contains(default(TKey)));
            }
        }

        private void VerifyDictionary(
            KeyedCollection<TKey, IKeyedItem<TKey, TValue>> dictionary,
            TKey[] expectedKeys,
            IKeyedItem<TKey, TValue>[] expectedItems)
        {
            if (dictionary == null)
            {
                throw new ArgumentNullException(nameof(dictionary));
            }
            if (expectedKeys.Length != expectedItems.Length)
            {
                throw new ArgumentException(
                    "Expected keys length and expected items length must be the same.");
            }
            Assert.Equal(expectedItems.Length, dictionary.Count);

            for (var i = 0; i < expectedKeys.Length; ++i)
            {
                Assert.Equal(
                    expectedItems[i],
                    dictionary[expectedKeys[i]]);
            }
        }

        [Theory]
        [MemberData(nameof(ThresholdData))]
        public void Threshold(
            int collectionDictionaryThreshold,
            Named<AddItemsFunc<TKey, IKeyedItem<TKey, TValue>>> addItems)
        {
            TKey[] keys;
            IKeyedItem<TKey, TValue>[] items;
            IKeyedItem<TKey, TValue>[] itemsWithKeys;
            if (collectionDictionaryThreshold >= 0)
            {
                var collection =
                    new TestKeyedCollectionOfIKeyedItem<TKey, TValue>(
                        collectionDictionaryThreshold);
                // dictionary is created when the threshold is exceeded
                addItems.Value(
                    collection,
                    GetNeverNullKeyMethod.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    collectionDictionaryThreshold,
                    out keys,
                    out items,
                    out itemsWithKeys);
                Assert.Null(collection.GetDictionary());

                collection =
                    new TestKeyedCollectionOfIKeyedItem<TKey, TValue>(
                        collectionDictionaryThreshold);
                addItems.Value(
                    collection,
                    GetNeverNullKeyMethod.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    collectionDictionaryThreshold + 1,
                    out keys,
                    out items,
                    out itemsWithKeys);
                Assert.NotNull(collection.GetDictionary());
                VerifyDictionary(collection, keys, itemsWithKeys);
            }
            else
            {
                var collection =
                    new TestKeyedCollectionOfIKeyedItem<TKey, TValue>(
                        collectionDictionaryThreshold);
                // dictionary is created when the threshold is exceeded
                addItems.Value(
                    collection,
                    GetNeverNullKeyMethod.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    1024,
                    out keys,
                    out items,
                    out itemsWithKeys);
                Assert.Null(collection.GetDictionary());

                collection =
                    new TestKeyedCollectionOfIKeyedItem<TKey, TValue>(
                        collectionDictionaryThreshold);
                addItems.Value(
                    collection,
                    GetNeverNullKeyMethod.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    2048,
                    out keys,
                    out items,
                    out itemsWithKeys);
                Assert.Null(collection.GetDictionary());
            }
        }

        [Theory]
        [MemberData(nameof(ContainsKeyData))]
        public void ContainsKey(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            TKey[] keys;
            IKeyedItem<TKey, TValue>[] items;
            IKeyedItem<TKey, TValue>[] itemsWithKeys;
            var collection =
                new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
            collection.AddItems(
                generateKeyedItem.Value.Bind(
                    GenerateValue,
                    GetKeyForItem),
                ki => ki.Key,
                collectionSize,
                out keys,
                out items,
                out itemsWithKeys);
            IKeyedItem<TKey, TValue> itemNotIn =
                generateKeyedItem.Value(GenerateValue, GetKeyForItem);
            // this is to make overload resolution pick the correct Contains function. replacing keyNotIn with null causes the Contains<TValue> overload to be used. We want the Contains<TKey> version.
            TKey keyNotIn = itemNotIn.Key;
            if (keyNotIn == null)
            {
                Assert.Throws<ArgumentNullException>(
                    () => collection.Contains(keyNotIn));
            }
            else
            {
                Assert.False(collection.Contains(keyNotIn));
            }
            foreach (TKey k in keys)
            {
                TKey key = k;
                if (key == null)
                {
                    Assert.Throws<ArgumentNullException>(
                        () => collection.Contains(key));
                    continue;
                }
                Assert.True(collection.Contains(key));
            }
        }

        [Theory]
        [MemberData(nameof(ContainsKeyData))]
        public void RemoveKey(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            TKey[] keys;
            IKeyedItem<TKey, TValue>[] items;
            IKeyedItem<TKey, TValue>[] itemsWithKeys;
            var collection =
                new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
            collection.AddItems(
                generateKeyedItem.Value.Bind(
                    GenerateValue,
                    GetKeyForItem),
                ki => ki.Key,
                collectionSize,
                out keys,
                out items,
                out itemsWithKeys);
            collection.Verify(keys, items, itemsWithKeys);

            IKeyedItem<TKey, TValue> itemNotIn =
                generateKeyedItem.Value(GenerateValue, GetKeyForItem);
            // this is to make overload resolution pick the correct Contains function. replacing keyNotIn with null causes the Contains<TValue> overload to be used. We want the Contains<TKey> version.
            TKey keyNotIn = itemNotIn.Key;
            if (keyNotIn == null)
            {
                Assert.Throws<ArgumentNullException>(
                    () => collection.Remove(keyNotIn));
            }
            else
            {
                Assert.False(collection.Remove(keyNotIn));
            }
            collection.Verify(keys, items, itemsWithKeys);
            var tempKeys = (TKey[]) keys.Clone();
            var tempItems = (IKeyedItem<TKey, TValue>[]) items.Clone();
            var tempItemsWithKeys =
                (IKeyedItem<TKey, TValue>[]) itemsWithKeys.Clone();

            for (var i = 0; i < itemsWithKeys.Length; i++)
            {
                TKey key = keys[i];
                if (key == null)
                {
                    Assert.Throws<ArgumentNullException>(
                        () => collection.Remove(key));
                }
                else
                {
                    Assert.True(collection.Remove(key));
                    tempItems =
                        tempItems.RemoveAt(
                            Array.IndexOf(tempItems, itemsWithKeys[i]));
                    tempItemsWithKeys = itemsWithKeys.Slice(
                        i + 1,
                        itemsWithKeys.Length - i - 1);
                    tempKeys = keys.Slice(i + 1, keys.Length - i - 1);
                }
                collection.Verify(
                    tempKeys,
                    tempItems,
                    tempItemsWithKeys);
            }
        }

        [Theory]
        [MemberData(nameof(ContainsKeyData))]
        public void KeyIndexer(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            TKey[] keys;
            IKeyedItem<TKey, TValue>[] items;
            IKeyedItem<TKey, TValue>[] itemsWithKeys;
            var collection =
                new TestKeyedCollectionOfIKeyedItem<TKey, TValue>();
            collection.AddItems(
                generateKeyedItem.Value.Bind(
                    GenerateValue,
                    GetKeyForItem),
                ki => ki.Key,
                collectionSize,
                out keys,
                out items,
                out itemsWithKeys);
            IKeyedItem<TKey, TValue> itemNotIn =
                generateKeyedItem.Value(GenerateValue, GetKeyForItem);
            // this is to make overload resolution pick the correct Contains function. replacing keyNotIn with null causes the Contains<TValue> overload to be used. We want the Contains<TKey> version.
            TKey keyNotIn = itemNotIn.Key;
            if (keyNotIn == null)
            {
                Assert.Throws<ArgumentNullException>(
                    () => collection[keyNotIn]);
            }
            else
            {
                Assert.Throws<KeyNotFoundException>(
                    () => collection[keyNotIn]);
            }
            foreach (TKey k in keys)
            {
                TKey key = k;
                if (key == null)
                {
                    Assert.Throws<ArgumentNullException>(
                        () => collection[key]);
                    continue;
                }
                IKeyedItem<TKey, TValue> tmp = collection[key];
            }
        }

        [Theory]
        [MemberData(nameof(CollectionSizes))]
        public void KeyIndexerSet(int collectionSize)
        {
            TKey[] keys;
            TValue[] items;
            TValue[] itemsWithKeys;
            var collection =
                new TestKeyedCollection<TKey, TValue>(GetKeyForItem);
            collection.AddItems(
                GenerateValue,
                GetKeyForItem,
                collectionSize,
                out keys,
                out items,
                out itemsWithKeys);
            foreach (TValue item in itemsWithKeys)
            {
                collection[collection.IndexOf(item)] = item;
            }
        }

        [Theory]
        [MemberData(nameof(DictionaryData))]
        public void Dictionary(
            int addCount,
            int insertCount,
            int removeCount,
            int removeKeyCount,
            int collectionDictionaryThreshold)
        {
            var collection =
                new TestKeyedCollectionOfIKeyedItem<TKey, TValue>(
                    collectionDictionaryThreshold);
            TKey[] tempKeys;
            IKeyedItem<TKey, TValue>[] tempItems;
            IKeyedItem<TKey, TValue>[] tempItemsWithKeys;
            var keys = new TKey[0];
            var itemsWithKeys = new IKeyedItem<TKey, TValue>[0];

            if (addCount > 0)
            {
                collection.AddItems(
                    GetNeverNullKeyMethod.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    addCount,
                    out tempKeys,
                    out tempItems,
                    out tempItemsWithKeys);
                keys = keys.Push(tempKeys);
                itemsWithKeys = itemsWithKeys.Push(tempItemsWithKeys);
                VerifyDictionary(collection, keys, itemsWithKeys);
            }
            if (insertCount > 0)
            {
                collection.InsertItems(
                    GetNeverNullKeyMethod.Value.Bind(
                        GenerateValue,
                        GetKeyForItem),
                    ki => ki.Key,
                    insertCount,
                    out tempKeys,
                    out tempItems,
                    out tempItemsWithKeys);
                keys = keys.Push(tempKeys);
                itemsWithKeys = itemsWithKeys.Push(tempItemsWithKeys);
                VerifyDictionary(collection, keys, itemsWithKeys);
            }

            if (removeCount > 0)
            {
                for (var i = 0; i < removeCount; i++)
                {
                    int index = (((i*43691 << 2)/7 >> 1)*5039)
                                %collection.Count;
                    collection.RemoveAt(index);
                    keys = keys.RemoveAt(index);
                    itemsWithKeys = itemsWithKeys.RemoveAt(index);
                    VerifyDictionary(collection, keys, itemsWithKeys);
                }
            }

            if (removeKeyCount > 0)
            {
                for (var i = 0; i < removeCount; i++)
                {
                    int index = (((i*127 << 2)/7 >> 1)*5039)
                                %collection.Count;
                    IKeyedItem<TKey, TValue> item = collection[index];
                    collection.Remove(item.Key);
                    keys = keys.RemoveAt(index);
                    itemsWithKeys = itemsWithKeys.RemoveAt(index);
                    VerifyDictionary(collection, keys, itemsWithKeys);
                }
            }
        }

        [Theory]
        [MemberData(nameof(ClassData))]
        public void Insert(
            int collectionSize,
            Named<KeyedCollectionGetKeyedValue<TKey, TValue>>
                generateKeyedItem)
        {
            TValue item1 = GenerateValue();
            TValue item3 = GenerateValue();
            TKey key1 = GetKeyForItem(item1);
            TKey key3 = GetKeyForItem(item3);
            var keyedItem1 = new KeyedItem<TKey, TValue>(key1, item1);

            var inserts =
                new Action
                    <KeyedCollection<TKey, IKeyedItem<TKey, TValue>>,
                        int, IKeyedItem<TKey, TValue>>[]
                {
                    (c, i, item) => c.Insert(i, item),
                    (c, i, item) => ((IList) c).Insert(i, item)
                };

            foreach (
                Action
                    <KeyedCollection<TKey, IKeyedItem<TKey, TValue>>,
                        int, IKeyedItem<TKey, TValue>> i in inserts)
            {
                Action
                    <KeyedCollection<TKey, IKeyedItem<TKey, TValue>>,
                        int, IKeyedItem<TKey, TValue>> insert = i;
                {
                    // Insert key is null
                    TKey[] keys;
                    IKeyedItem<TKey, TValue>[] items;
                    IKeyedItem<TKey, TValue>[] itemsWithKeys;
                    var collection =
                        new TestKeyedCollectionOfIKeyedItem
                            <TKey, TValue>();
                    collection.AddItems(
                        generateKeyedItem.Value.Bind(
                            GenerateValue,
                            GetKeyForItem),
                        ki => ki.Key,
                        collectionSize,
                        out keys,
                        out items,
                        out itemsWithKeys);
                    var tempKeyedItem =
                        new KeyedItem<TKey, TValue>(
                            default(TKey),
                            item3);
                    keys = keys.Push(key1);
                    items = items.Push(keyedItem1, tempKeyedItem);
                    itemsWithKeys = itemsWithKeys.Push(keyedItem1);
                    insert(collection, collection.Count, keyedItem1);
                    insert(collection, collection.Count, tempKeyedItem);
                    collection.Verify(keys, items, itemsWithKeys);
                }

                {
                    // Insert key already exists
                    TKey[] keys;
                    IKeyedItem<TKey, TValue>[] items;
                    IKeyedItem<TKey, TValue>[] itemsWithKeys;
                    var collection =
                        new TestKeyedCollectionOfIKeyedItem
                            <TKey, TValue>();
                    collection.AddItems(
                        generateKeyedItem.Value.Bind(
                            GenerateValue,
                            GetKeyForItem),
                        ki => ki.Key,
                        collectionSize,
                        out keys,
                        out items,
                        out itemsWithKeys);
                    var tempKeyedItem = new KeyedItem<TKey, TValue>(
                        key1,
                        item3);
                    keys = keys.Push(key1);
                    items = items.Push(keyedItem1);
                    itemsWithKeys = itemsWithKeys.Push(keyedItem1);
                    insert(collection, collection.Count, keyedItem1);
                    AssertExtensions.Throws<ArgumentException>(null, () => insert(collection, collection.Count, tempKeyedItem));
                    collection.Verify(keys, items, itemsWithKeys);
                }

                {
                    // Insert key is unique
                    TKey[] keys;
                    IKeyedItem<TKey, TValue>[] items;
                    IKeyedItem<TKey, TValue>[] itemsWithKeys;
                    var collection =
                        new TestKeyedCollectionOfIKeyedItem
                            <TKey, TValue>();
                    collection.AddItems(
                        generateKeyedItem.Value.Bind(
                            GenerateValue,
                            GetKeyForItem),
                        ki => ki.Key,
                        collectionSize,
                        out keys,
                        out items,
                        out itemsWithKeys);
                    var tempKeyedItem = new KeyedItem<TKey, TValue>(
                        key3,
                        item3);
                    keys = keys.Push(key1, key3);
                    items = items.Push(keyedItem1, tempKeyedItem);
                    itemsWithKeys = itemsWithKeys.Push(
                        keyedItem1,
                        tempKeyedItem);
                    insert(collection, collection.Count, keyedItem1);
                    insert(collection, collection.Count, tempKeyedItem);
                    collection.Verify(keys, items, itemsWithKeys);
                }
            }
        }
    }

    public abstract class IListTestKeyedCollection<TKey, TValue> :
        IListTest<KeyedCollection<TKey, TValue>, TValue>
    {
        protected IListTestKeyedCollection()
            : base(false, false, false, false, true, true)
        {
        }

        protected abstract TKey GetKeyForItem(TValue item);

        /// <summary>
        ///     When overridden in a derived class, Gets an instance of the list under test containing the given items.
        /// </summary>
        /// <param name="items">The items to initialize the list with.</param>
        /// <returns>An instance of the list under test containing the given items.</returns>
        protected override KeyedCollection<TKey, TValue> CreateList(
            IEnumerable<TValue> items)
        {
            var ret =
                new TestKeyedCollection<TKey, TValue>(GetKeyForItem);
            if (items == null)
            {
                return ret;
            }
            foreach (TValue item in items)
            {
                ret.Add(item);
            }
            return ret;
        }

        /// <summary>
        ///     When overridden in a derived class, invalidates any enumerators for the given list.
        /// </summary>
        /// <param name="list">The list to invalidate enumerators for.</param>
        /// <returns>The new contents of the list.</returns>
        protected override IEnumerable<TValue> InvalidateEnumerator(
            KeyedCollection<TKey, TValue> list)
        {
            TValue item = CreateItem();
            list.Add(item);
            return list;
        }
    }

    public abstract class IListTestKeyedCollectionBadKey<TKey, TValue> :
        IListTest<KeyedCollection<BadKey<TKey>, TValue>, TValue>
        where TKey : IEquatable<TKey>
    {
        protected IListTestKeyedCollectionBadKey()
            : base(false, false, false, false, true, true)
        {
        }

        /// <summary>
        ///     When overridden in a derived class, Gets an instance of the list under test containing the given items.
        /// </summary>
        /// <param name="items">The items to initialize the list with.</param>
        /// <returns>An instance of the list under test containing the given items.</returns>
        protected override KeyedCollection<BadKey<TKey>, TValue>
            CreateList(IEnumerable<TValue> items)
        {
            var ret =
                new TestKeyedCollection<BadKey<TKey>, TValue>(
                    item => new BadKey<TKey>(GetKeyForItem(item)),
                    new BadKeyComparer<TKey>());
            if (items == null)
            {
                return ret;
            }
            foreach (TValue item in items)
            {
                ret.Add(item);
            }
            return ret;
        }

        /// <summary>
        ///     When overridden in a derived class, invalidates any enumerators for the given list.
        /// </summary>
        /// <param name="list">The list to invalidate enumerators for.</param>
        /// <returns>The new contents of the list.</returns>
        protected override IEnumerable<TValue> InvalidateEnumerator(
            KeyedCollection<BadKey<TKey>, TValue> list)
        {
            TValue item = CreateItem();
            list.Add(item);
            return list;
        }

        protected abstract TKey GetKeyForItem(TValue item);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                  Éª–   tgLãC HãS(Hçî Hç?. MÖ¿LD¿HÖ“tHãJ HÖ…HD»Hç=Cì Hçl∆ æ   1¿Aæ˚ˇˇˇËzÈ˙ˇHã|$«ÉË  ˚ˇˇˇËÿ˙ˇÈŸ˛ˇˇêHãE Dãõÿ  HâD$EÖ€Ñü  fÔ¿Hçt$ 1“HâﬂD$$D$DD$T«D$d    «D$    HâD$0Lâl$8Dâd$@Ë¶2ˇˇAâ∆HãD$0HâD$EÖˆÑH  Lã=±® AÉ?v@Dâ˜Ë´UˇˇHç≠´ IâŸA∏’  PHç∂ HçÀ æ   PHão¶ Hã81¿Ë≈ñ˛ˇXZAÉ˛dÖ  HÉ|$ AãÑ≈  É¯vEHÉÏHçÈÆ IâŸA∏⁄  PHãa® æ   HçΩ  Hç/´ Hã81¿Ëlñ˛ˇA^A_Ñ     DãÉÿ  EÖ¿t\HãD$fÔ¿Hçt$ 1“HâﬂD$$D$DD$T«D$d    «D$    HâD$0Lâl$8Dâd$@Ëé1ˇˇAâ«HãD$0HâD$EÖˇÖ  Hã|$Ën÷˙ˇHãD$HâE Hçû‘ ã8ÖˇÖ  E1ˆÈ‚˚ˇˇ@ Lãª  MÖˇÑp  LâˇË@˚ˇHãÉ‡  Hã|$É@Ë÷˙ˇHçL$Dâ‚LâÓLâˇËÿxˇˇLâˇAâ∆Ë}˚ˇHã|$Ë£·˙ˇHãÉ‡  ÉhHãÉ‡  Dâ≥Ë  DãPEÖ“Ö]  Dããÿ  EÖ…Ñ]  fÔ¿Hçt$ DâÚHâﬂD$DD$$D$4D$T«D$d    «D$    Dât$HËÄ0ˇˇAâ«A9∆Ñ¸   Ö¿ÑÙ   Hãç¶ É8á≤  AÉˇdA∫˝ˇˇˇHã|$EE◊DâìË  Eâ÷Ë:’˙ˇHÉ}  Ö¸ˇˇHã|$Ëµ"ˇˇÈ¯˚ˇˇË∏ Hç|ﬂ H+Iâ∆Hçó‚ ãpHç5” Hã8HâD$Ë ﬂ˙ˇIâ«HÖ¿t'Ñ     MãEâ‡LâÈHâ⁄LâˆIã9AˇQMãMÖˇu·HãD$1ˆHã8Ë‚ﬁ˙ˇIâ«HÖ¿Ñ˘˙ˇˇfD  IãEâ‡LâÈHâ⁄LâˆHã8ˇPMãMÖˇu‚È–˙ˇˇD  Eâ˛D  EÖˆÑá˝ˇˇDâ≥Ë  Hã|$1ÌËT‘˙ˇAÉ˛¸Hãq• @ü≈çl-9(Ç˚ˇˇDâ˜ËaRˇˇâÓIâŸA∏ˆ  PHçÓ≤ Hç◊« PHã/£ HçA® Hã81¿Ë~ì˛ˇ^_Èœ˙ˇˇÄ    Hç=˘é HçΩΩ Hç5ª« Aæ˚ˇˇˇË†÷˙ˇÈa˘ˇˇ HãÈ§ É8v=HÉÏHç1¬ IâŸA∏Í  PHã¿¢ æ   HçT« Hç∆ß Hã81¿Ëì˛ˇAXAY«ÉË  ˇˇˇˇHã|$AæˇˇˇˇËe”˙ˇÈ8˙ˇˇEÖˆÖ˛ˇˇÈ⁄¸ˇˇfêË;∂ Hç¨› H+Iâ≈Hç«‡ ãpHçe— Hã8HâD$ËP›˙ˇIâƒHÖ¿t)Ñ     Iã$E1¿HãM Hâ⁄LâÓHã8ˇPMãd$MÖ‰uﬂHãD$1ˆHã8Ë›˙ˇIâƒHÖ¿ÑÄ¸ˇˇ@ Iã$E1¿HãM Hâ⁄LâÓHã8ˇPMãd$MÖ‰uﬂÈV¸ˇˇDâˇË“PˇˇHç[∆ IâŸHç ¶ PHçt± A∏¸  æ   PHãñ° Hã81¿ËÏë˛ˇZYÈ	˝ˇˇAæ˝ˇˇˇÉ¯v:Hçö™ ARIâŸA∏ﬂ  PHãò£ æ   HçÙ≈ Hçf¶ Hã81¿Ë£ë˛ˇA[]Dâ≥Ë  Hã|$Ë“˙ˇÈ‚¯ˇˇËï⁄˙ˇD  ATUHâıSHâ˚ËÖˇˇHÖ€t\HãHÖ“tH9tHâ∆HâﬂË‰◊˙ˇÖ¿t@HÖÌtHãd° Hã H9E tSHç=ƒå 1€Hç,W Hç5D≈ Ëo‘˙ˇâÿ[]A\√Ñ     Hç=ôå 1€Hçã) Hç5≈ ËD‘˙ˇâÿ[]A\√D  LçcLâÁË›˙ˇHâÓHâﬂË1GˇˇLâÁâ√ËG—˙ˇâÿ[]A\√AWAVAUATUHâıSHâ˚HÉÏ8dHã%(   HâD$(1¿Ë'ÑˇˇHÖ€tzHãHÖ“tH9tHâ∆HâﬂË
◊˙ˇÖ¿t^HÖÌtHãä† Hã H9E tqHç=Íã HçTV Hç5Lƒ E1‰Ëî”˙ˇHãL$(dH3%(   Dâ‡Ö;  HÉƒ8[]A\A]A^A_√fD  Hç=°ã Hçï( Hç5ƒ E1‰ËK”˙ˇÎµfÑ     Lç5©Œ EãEÖ€Öù  ãChÉ¯Ñ  É¯Ö®  ã}@AøÄ   @ˆ«Ñ  LçkLâÔËŸ€˙ˇDãe@Eâ‚AÉ‚Ö  É{hÖû   AÉ‰Ñî   ãC0Hâl$H«D$    ˆƒt~Ä‰˚âC0Hã	° É8á  HçT$Hç5¸`ˇˇHâﬂDâT$ËÔAˇˇDãD$Aº   DãT$EÖ¿t-ã|$E1‰Öˇu"1“æn  HâﬂË )ˇˇDãT$HÖ¿t	É8 Ñ  EÖ“Öô  @ Dâ˙HâÓHâﬂË2YˇˇçPúÉ˙AñƒÖ¿î¿A	ƒE∂‰LâÔËDœ˙ˇAã6ÖˆÑu˛ˇˇË$≤ HçïŸ Lç=^Õ H+Iã?Iâ≈Hç¶‹ ãpË>Ÿ˙ˇHâ≈HÖ¿t"fD  HãE Dâ·Hâ⁄LâÓHã8ˇPHãmHÖÌu‰Iã?1ˆË
Ÿ˙ˇHâ≈HÖ¿Ñ
˛ˇˇfD  HãE Dâ·Hâ⁄LâÓHã8ˇPHãmHÖÌu‰È„˝ˇˇÄ    LãC HãS(Hç<ä Hçx$ MÖ¿LD¿HÖ“tHãJ HÖ…HD»Hç=¡É*û˘ˇˇˇ`           Ìh∞‰ÈBîÙ⁄1¢AªF.   ‰2ÿ∞Oâ∑~œ¨¢J˝6
   ›uÂ)'F£‡v“ùÍ‹,#	   ?t¸œÄD∞Cﬂëìs    |     None    e   '             …     A
  9      m  m  }  œÖÇNÉt0FíróMª@—      e       ‰«6    ++UE4+Main     …¡6    ++UE4+Main         _Ÿ<    §  g?              ˇˇˇˇ|  %   /Engine/Tutorial/Basics/FeaturePacks Ô*—ì   /Script/BlueprintGraph È€|D   /Script/CoreUObject ¯I->   /Script/Engine Ü@ÖI   /Script/IntroTutorials ùb38   /Script/UnrealEd ,ó   ArrayProperty I∞„i   Asset pΩ&Õ   BackButtonText APˇá   bAllowDeletion ˇÒÎ   bAutoFocus “>Él   bDrawHighlight ˛Y©Ë   bInvertPlatformTest ÆÌ%ˆ%   bLegacyGeneratedClassIsAuthoritative túua   bLegacyNeedToPurgeSkelRefs è≠\;
   Blueprint 93   BlueprintGeneratedClass )õp-   BlueprintGuid œU   BlueprintSystemVersion Åt	+   BlueprintType íﬂ   BoolProperty ∞ä   ByteProperty ÊN-¿	   Category ˜~î≈   Class twxë   Content °M6‚   ContentBrowser 0Pl   ContentBrowserNewAsset ﬂÃˇ   ContentWidth ˘æ≥Ò   Default__EditorTutorial l8R≈   Default__FeaturePacks_C ≈≈E£   EdGraph o¥]   EdGraphSchema_K2 ∏¡ò   EditedDocumentInfo ª_˚   EditedObject B∂a‡   EditorTutorial Fﬁ&   EHorizontalAlignment ˇ’ãk   Engine ∑DÊ   ETutorialAnchorIdentifier í1≥3'   ETutorialAnchorIdentifier::NamedWidget JÊ≈∞   ETutorialContent èà   ETutorialContent::RichText ¢≤©   EventGraph ]•]   EVerticalAlignment =√ÍÖ   ExcerptName ∞…”   FeaturePacks ∏?◊Û   FeaturePacks_C Ô…@   FloatProperty ˚ßﬁ˝   FriendlyName ≈    GeneratedClass ÜXT
   GraphGuid ¢ÇÀv   Guid CP˙h   GUIDString ˙ûOæ   HAlign_Center Amø   HAlign_Left Ã¥R   HideCategories KË¿   HorizontalAlignment ß¡Ò6   IntProperty •”6J   LastEditedDocuments –   Main L`1‰	   MetaData ‰Ä¥ì   Name 98Ÿ   NameProperty ÇÚJ   NextButtonText Eu‘   None Ù≈   Object eKÌ   ObjectProperty A€≥Í   Offset ‡1Áx
   OuterName Î\U3   Package sGà   PackageLocalizationNamespace tyà   PackageMetaData ù,§e   ParentClass ›•[   PlatformsToTest cö   SavedViewOffset |»ÏD   SavedZoomAmount _ç…   SceneThumbnailInfo "È¥   Schema ˇªãw   SearchTags B=~c   SoftObjectPath °€°   Stages <⁄›n   StrProperty ;¡r$   StructProperty 0 ú¸   SummaryContent Pn¶f   TabToFocusOrOpen NY7   Text ¡9@i   TextProperty ƒ:t∑   ThumbnailInfo ≤L3≥   Title ˙◊   TutorialContent b ﬁ   TutorialContentAnchor Ó=oq   TutorialStage pÔ^/   TutorialWidgetContent 8 ¸Í   Type ÄFr‚   UbergraphPages #¢3   VAlign_Bottom —™ò   VAlign_Center Ü§ Ç	   Vector2D U0l	   VerticalAlignment 4ì®0   WidgetAnchor πbìj   WidgetContent ú4Q-   WrapperIdentifier q(ıÚ              ˆˇˇˇ                     ıˇˇˇ;                     ıˇˇˇ@                     Ùˇˇˇ                     Ùˇˇˇ                     Ùˇˇˇ                     Ûˇˇˇ"                     ÚˇˇˇK              "       Ûˇˇˇ              D                         D                         D                         D                         D                  ˚ˇˇˇ˘ˇˇˇ        -       	   L       |                                              ˇˇˇˇ                                      1   É&      »                                              ˇˇˇˇ                ¸ˇˇˇ            ,          Û      K<                                           ˇˇˇˇ                ˙ˇˇˇ           )          Ñ       >>                                            ˇˇˇˇ                ˛ˇˇˇ            F          ô       ¬>                                            ˇˇˇˇ                ¯ˇˇˇ           K                [?                                            ˇˇˇˇ                               ˜ˇˇˇ                                           
   Blueprint    FeaturePacks q        FeaturePacks 
   Blueprint       Title L   NSLOCTEXT("", "367A4A954699EEFAF1236298994EB202", "Feature Packs Overview")    SearchTags c   NSLOCTEXT("", "3158A98646C0A6958ABEA98C9806FBD7", "feature pack,template,content,asset ,starter ")    ParentClass -   Class'/Script/IntroTutorials.EditorTutorial'    BlueprintType    BPTYPE_Normal    ImplementedInterfaces        GeneratedClass M   BlueprintGeneratedClass'/Engine/Tutorial/Basics/FeaturePacks.FeaturePacks_C'    NumReplicatedProperties    0    ParentClassPackage    /Script/IntroTutorials    NativeParentClass -   Class'/Script/IntroTutorials.EditorTutorial'    BlueprintDescription        ClassFlags    4460560    IsDataOnly    True    FiBData ˛ˇˇ    ≠            	         G j o e J o C m v f q s j o u N b o b h f s      Q s p q f s u j f t      Q s p q f s u j f t      	         G j o e J o C m v f q s j o u N b o b h f s      V c f s      V c f s      	         G j o e J o C m v f q s j o u N b o b h f s      O b n f      O b n f      	         L j t n f u T d i f n b      H s b q i E j t q m b z O b n f ` F w f o u H s b q i      F w f o u H s b q i      	         G j o e J o C m v f q s j o u N b o b h f s      E f t d s j q u j p o      E f t d s j q u j p o      	         C m v f q s j o u      O p H s b q i U p p m u j q      ) O p o f *      	         G j o e J o C m v f q s j o u N b o b h f s      O p e f t      O p e f t  { " 0 " : [ ] , " 1 " : [ { " 2 " : " 3 " , " 4 " : " 5 " , " 6 " : [ ] , " 0 " : [ ] } ] }      NativeComponents    0    BlueprintComponents    0 ?           ˘ˇˇˇ                 ˝ˇˇˇ$                  ?              W       U       I                 !   367A4A954699EEFAF1236298994EB202    Feature Packs Overview        P                  Basics R       Q       m       X                        T       U       L                 !   8BC99E4D4940AC8635A05CAE07A23935    Overview of feature packs ?       O              Ω$      Q           O       Q       à$      Z                        <       =               :              Q       N      X                        \                     '        (              P                   +       P                   T       U                         !   81994AEF487AF8CD99A9BBAC8BEB2599 ò   <TextStyle Style="Tutorials.Content.TextBold">Feature packs</> are a quick and easy way to insert new functionality and/or assets to existing projects. ?       c              5       Q            c       Q               [                        >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q             X                        \                     '        (              P                   +       P                   T       U       ë                !   8E27A42B417CBB67E71EF09B466AF591 _  There is a <TextStyle Style="Tutorials.Content.TextBold">Feature Pack</> equivalent for each of the templates found in the New Project dialog.
<TextStyle Style="Tutorials.Content.Text">So you could, for instance, create a </><TextStyle Style="Tutorials.Content.TextBold">Vehicle</><TextStyle Style="Tutorials.Content.Text"> template project and then later simply insert a </><TextStyle Style="Tutorials.Content.TextBold">Third Person Feature Pack</><TextStyle Style="Tutorials.Content.Text"> to incorporate all the code and assets into your vehicle project. You can add a feature pack whenever you wish</>
 ?       c              5       Q            c       Q               [                        >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q       Á      X                        \                     '        (              P                   +       P                   T       U       c                !   F4CF7D184651A11567E3C9B4098DEA4E 1  The <TextStyle Style="Tutorials.Content.TextBold">Starter Content</> is also available in <TextStyle Style="Tutorials.Content.TextBold"></><TextStyle Style="Tutorials.Content.TextBold">Feature Pack</> form so you can add this to your project even if you didn't add it when you first created the project.
 ?       c              5       Q            c       Q               [                        >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q       (      X                        \                     '        (              P                   +       P                   T       U       §                 !   344E3F404190B76FC76454922B1A5164 r   To insert a <TextStyle Style="Tutorials.Content.TextBold">Feature Pack</> first find or open the Content Browser. ?       c                    Q           c       Q       “      [                               Q       â       X                        \                     '        (              P                   +       P                   T       U                   ˇ?       b       Q             Y                        \                     %        &       d       =                             Q              N                        ?                                  S       P                   /       P                   3       P                   C       P                   ?       7                     #        4       a                     *        ^       B       Q              `                                       .                 ØC
                       ?       >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q       ˛       X                        \                     '        (              P                   +       P                   T       U       z                 !   5CBE72B14D17C3E88881E2948DC83D2B H   Next click on <TextStyle Style="Tutorials.Content.TextBold">Add New</>. ?       c                    Q           c       Q       È      [                               Q       â       X                        \                     '        (              P                   +       P                   T       U                   ˇ?       b       Q       4      Y                        \                     %        &       d       =                             Q              N                        ?                                  S       P                   /       P                  ContentBrowserNewAsset 3       P                   C       P                   ?       7                     #        4       a                     *        ^       B       Q              `                                       .                 ØC
                        ?       >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q       â       X                        \                     '        (              P                   +       P                   T       U                   ˇ?       c              •      Q           c       Q       p      [                               Q       '      X                        \                     '        (              P                   +       P                   T       U       £                 !   5EFF0FFF4E6C0FBCA552C2A0BEDCC384 q   From the menu that appears click on <TextStyle Style="Tutorials.Content.TextBold">Add Feature or Content Pack</> ?       b       Q             Y                        \                     %        &       d       =                             Q              N                        ?                                  S       P                   /       P                   3       P                   C       P                   ?       7                     #        5       a                     *        _       B       Q              `                                       .                 ØC
                        ?       >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q       â       X                        \                     '        (              P                   +       P                   T       U                   ˇ?       c              }      Q           c       Q       H      [                               Q       ˇ      X                        \                     '        (              P                   +       P                   T       U       {                !   76E8F8084F9512C09B1A858B62F86C30 I  You are then presented with a dialog showing the <TextStyle Style="Tutorials.Content.TextBold">Feature Packs</> available for you to add to your project. Simply select the type of <TextStyle Style="Tutorials.Content.TextBold">Feature Pack</> you require and select <TextStyle Style="Tutorials.Content.TextBold">Add to Project</> ?       b       Q             Y                        \                     %        &       d       =                             Q              N                        ?                                   S       P                   /       P                   3       P                   C       P                   ?       7                     #        4       a                     *        _       B       Q              `                                       .                 ØC
                        ?       >       U                   ˇ       U                   ˇH                     P                                    ?       <       =               ?              Q       â       X                        \                     '        (              P                   +       P                   T       U                   ˇ?       c              Á      Q           c       Q       ≤      [                               Q       i      X                        \                     '        (              P                   +       P                   T       U       Â                 !   10FC46BE4E0F70E49FA3159DDA842DE3 ≥   If you add code to your project you will need to compile it again, but this can be done right from the editor. 
When it's finished co