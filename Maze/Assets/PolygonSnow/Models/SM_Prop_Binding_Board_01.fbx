}" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Users can create their own set of custom colors. These colors are contained in an <see cref="T:System.Int32" /> composed of the BGR (blue, green, red) values necessary to create the color. For more information on the structure of this data, see <see cref="T:System.Drawing.Color" />.</para>
          <para>Custom colors can only be defined if <see cref="P:System.Windows.Forms.ColorDialog.AllowFullOpen" /> is set to true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the set of custom colors shown in the dialog box.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FullOpen">
      <MemberSignature Language="C#" Value="public virtual bool FullOpen { set; get; }" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>By default, the custom color controls are not visible when the dialog box is first opened. You must click the Custom Colors button to display them.</para>
          <block subset="none" type="note">
            <para>If <see cref="P:System.Windows.Forms.ColorDialog.AllowFullOpen" /> is false, then <see cref="P:System.Windows.Forms.ColorDialog.FullOpen" /> has no effect.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the controls used to create custom colors are visible when the dialog box is opened </para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Instance">
      <MemberSignature Language="C#" Value="protected virtual IntPtr Instance { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>This method uses <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /> to prevent it from being called from untrusted code; only the immediate caller is required to have <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> permission. If your code can be called from partially trusted code, do not pass user input to <see cref="T:System.Runtime.InteropServices.Marshal" /> class methods without validation. For important limitations on using the LinkDemand member, see <format type="text/html"><a href="1AB877F2-70F4-4E0D-8116-943999DFE8F5">Demand vs. LinkDemand</a></format>.</para>
          </block>
          <para>This property also uses the <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /> security attribute; to override this member, the derived class must have the CustomPermission permission.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the underlying window instance handle (HINSTANCE).</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="protected virtual int Options { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Windows.Forms.ColorDialog.Options" /> property corresponds to the flags used to initialize a color dialog box using Win32. Use the properties of the <see cref="T:System.Windows.Forms.ColorDialog" /> class to get and set the options.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets values to initialize the <see cref="T:System.Windows.Forms.ColorDialog" />.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resets all options to their default values, the last selected color to black, and the custom colors to their default values.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RunDialog">
      <MemberSignature Language="C#" Value="protected override bool RunDialog (IntPtr hwndOwner);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwndOwner" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwndOwner">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ShowHelp">
      <MemberSignature Language="C#" Value="public virtual bool ShowHelp { set; get; }" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether a Help button appears in the color dialog box.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SolidColorOnly">
      <MemberSignature Language="C#" Value="public virtual bool SolidColorOnly { set; get; }" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is applicable to systems with 256 or fewer colors. On these types of systems, some colors are composites of others.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the dialog box will restrict users to selecting solid colors only.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The return string includes the type and the value for the <see cref="P:System.Windows.Forms.ColorDialog.Color" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string that represents the <see cref="T:System.Windows.Forms.ColorDialog" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Windows.Forms.ColorDialog" />. </para>
        </returns>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
</Type>                                                                                                                                                                                                                                                                                                                 ¤    [4¶\:,g][4¶\                
ó               ±Ï@                                     ÷	Å                    Jr    Xà¶Š~        :,g]à¶Š~                                                                                                        ¤  r  [4¶\:,g][4¶\                
ó               ²Ï@                                     Ì›õ\                    ’š    µRà¶Š~        :,g]à¶Š~                                                                                                        í  „  [4¶\:,g][4¶\                
ó               ´Ï@                                     |T™                    ô¥    Ž§à¶Š~        :,g]à¶Š~                                                                                                        ¤  û  [4¶\:,g][4¶\                
ó               ¶Ï@                                     úU                    Øƒ    âxà¶Š~        :,g]à¶Š~                                                                                                        ¤  Æ  [4¶\:,g][4¶\                
ó               ¸Ï@                                     ’A…«                    Ö    +ñà¶Š~        :,g]à¶Š~                                                                                                        ¤  z  [4¶\:,g][4¶\                
ó               ºÏ@                                     °‰Èo                    ñ&     ‘à¶Š~        :,g]à¶Š~                                                                                                        
/***********************************************************************
 * COPYRIGHT: 
 * Copyright (c) 1997-2012, International Business Machines Corporation
 * and others. All Rights Reserved.
 ***********************************************************************/

#include "unicode/utypes.h"

#if !UCONFIG_NO_FORMATTING

#include "intltest.h"
#include "tfsmalls.h"

#include "unicode/msgfmt.h"
#include "unicode/choicfmt.h"

#include "unicode/parsepos.h"
#include "unicode/fieldpos.h"
#include "unicode/fmtable.h"

#define LENGTHOF(array) (int32_t)(sizeof(array)/sizeof((array)[0]))

/*static UBool chkstatus( UErrorCode &status, char* msg = NULL )
{
    UBool ok = (status == U_ZERO_ERROR);
    if (!ok) it_errln( msg );
    return ok;
}*/

void test_ParsePosition( void )
{
    ParsePosition* pp1 = new ParsePosition();
    if (pp1 && (pp1->getIndex() == 0)) {
        it_logln("PP constructor() tested.");
    }else{
        it_errln("*** PP getIndex or constructor() result");
    }
    delete pp1;


    {
        int32_t to = 5;
        ParsePosition pp2( to );
        if (pp2.getIndex() == 5) {
            it_logln("PP getIndex and constructor(int32_t) tested.");
        }else{
            it_errln("*** PP getIndex or constructor(int32_t) result");
        }
        pp2.setIndex( 3 );
        if (pp2.getIndex() == 3) {
            it_logln("PP setIndex tested.");
        }else{
            it_errln("*** PP getIndex or setIndex result");
        }
    }

    ParsePosition pp2, pp3;
    pp2 = 3;
    pp3 = 5;
    ParsePosition pp4( pp3 );
    if ((pp2 != pp3) && (pp3 == pp4)) {
        it_logln("PP copy contructor, operator== and operator != tested.");
    }else{
        it_errln("*** PP operator== or operator != result");
    }

    ParsePosition pp5;
    pp5 = pp4;
    if ((pp4 == pp5) && (!(pp4 != pp5))) {
        it_logln("PP operator= tested.");
    }else{
        it_errln("*** PP operator= operator== or operator != result");
    }


}

#include "unicode/decimfmt.h"

void test_FieldPosition_example( void )
{
    //***** no error detection yet !!!!!!!
    //***** this test is for compiler checks and visual verification only.
    double doubleNum[] = { 123456789.0, -12345678.9, 1234567.89, -123456.789,
        12345.6789, -1234.56789, 123.456789, -12.3456789, 1.23456789};
    int32_t dNumSize = (int32_t)(sizeof(doubleNum)/sizeof(double));

    UErrorCode status = U_ZERO_ERROR;
    DecimalFormat* fmt = (DecimalFormat*) NumberFormat::createInstance(status);
    if (U_FAILURE(status)) {
        it_dataerrln("NumberFormat::createInstance() error");
        return;
    }
    fmt->setDecimalSeparatorAlwaysShown(TRUE);
    
    const int32_t tempLen = 20;
    char temp[tempLen];
    
    for (int32_t i=0; i<dNumSize; i++) {
        FieldPosition pos(NumberFormat::INTEGER_FIELD);
        UnicodeString buf;
        //char fmtText[tempLen];
        //ToCharString(fmt->format(doubleNum[i], buf, pos), fmtText);
        UnicodeString res = fmt->format(doubleNum[i], buf, pos);
        for (int32_t j=0; j<tempLen; j++) temp[j] = '='; // clear with spaces
        int32_t tempOffset = (tempLen <= (tempLen - pos.getEndIndex())) ? 
            tempLen : (tempLen - pos.getEndIndex());
        temp[tempOffset] = '\0';
        it_logln(UnicodeString("FP ") + UnicodeString(temp) + res);
    }
    delete fmt;
    
    it_logln("");

}

void test_FieldPosition( void )
{

    FieldPosition fp( 7 );

    if (fp.getField() == 7) {
        it_logln("FP constructor(int32_t) and getField tested.");
    }else{
        it_errln("*** FP constructor(int32_t) or getField");
    }

    FieldPosition* fph = new FieldPosition( 3 );
    if ( fph->getField() != 3) it_errln("*** FP getField or heap constr.");
    delete fph;

    UBool err1 = FALSE;
    UBool err2 = FALSE;
    UBool err3 = FALSE;
    for (int32_t i = -50; i < 50; i++ ) {
        fp.setField( i+8 );
        fp.setBeginIndex( i+6 );
        fp.setEndIndex( i+7 );
        if (fp.getField() != i+8)  err1 = TRUE;
        if (fp.getBeginIndex() != i+6) err2 = TRUE;
        if (fp.getEndIndex() != i+7) err3 = TRUE;
    }
    if (!err1) {
        it_logln("FP setField and getField tested.");
    }else{
        it_errln("*** FP setField or getField");
    }
    if (!err2) {
        it_logln("FP setBeginIndex and getBeginIndex tested.");
    }else{
        it_errln("*** FP setBeginIndex or getBeginIndex");
    }
    if (!err3) {
        it_logln("FP setEndIndex and getEndIndex tested.");
    }else{
        it_errln("*** FP setEndIndex or getEndIndex");
    }

    it_logln("");

}

void test_Formattable( void )
{
    UErrorCode status = U_ZERO_ERROR;
    Formattable* ftp = new Formattable();
    if (!ftp || !(ftp->getType() == Formattable::kLong) || !(ftp->getLong() == 0)) {
        it_errln("*** Formattable constructor or getType or getLong");
    }
    delete ftp;

    Formattable fta, ftb;
    fta.setLong(1); ftb.setLong(2);
    if ((fta != ftb) || !(fta == ftb)) {
        it_logln("FT setLong, operator== and operator!= tested.");
        status = U_ZERO_ERROR;
        fta.getLong(&status);
        if ( status == U_INVALID_FORMAT_ERROR){
            it_errln("*** FT getLong(UErrorCode* status) failed on real Long");
        } else {
            it_logln("FT getLong(UErrorCode* status) tested.");
        }
    }else{
        it_errln("*** Formattable setLong or operator== or !=");
    }
    fta = ftb;
    if ((fta == ftb) || !(fta != ftb)) {
        it_logln("FT operator= tested.");
    }else{
        it_errln("*** FT operator= or operator== or operator!=");
    }
    
    fta.setDouble( 3.0 );
    if ((fta.getType() == Formattable::kDouble) && (fta.getDouble() == 3.0)) {
        it_logln("FT set- and getDouble tested.");
    }else{
        it_errln("*** FT set- or getDouble");
    }
    
    fta.getDate(status = U_ZERO_ERROR);
    if (status != U_INVALID_FORMAT_ERROR){
        it_errln("*** FT getDate with status should fail on non-Date");
    }
    fta.setDate( 4.0 );
    if ((fta.getType() == Formattable::kDate) && (fta.getDate() == 4.0)) {
        it_logln("FT set- and getDate tested.");	  
        status = U_ZERO_ERROR;
        fta.getDate(status);
        if ( status == U_INVALID_FORMAT_ERROR){
            it_errln("*** FT getDate with status failed on real Date");
        } else {
            it_logln("FT getDate with status tested.");
        }
    }else{
        it_errln("*** FT set- or getDate");
    }

    status = U_ZERO_ERROR;
    fta.getLong(&status);
    if (status != U_INVALID_FORMAT_ERROR){
        it_errln("*** FT getLong(UErrorCode* status) should fail on non-Long");
    }

    fta.setString("abc");
    const Formattable ftc(fta);
    UnicodeString res;

    {
        UBool t;
        t = (fta.getType() == Formattable::kString) 
            && (fta.getString(res) == "abc")
            && (fta.getString() == "abc");
        res = fta.getString(status = U_ZERO_ERROR);
        t = t && (status != U_INVALID_FORMAT_ERROR && res == "abc");
        res = ftc.getString(status = U_ZERO_ERROR);
        t = t && (status != U_INVALID_FORMAT_ERROR && res == "abc");
        ftc.getString(res,status = U_ZERO_ERROR);
        t = t && (status != U_INVALID_FORMAT_ERROR && res == "abc"); 
        if (t) {
            it_logln("FT set- and getString tested.");
        }else{
            it_errln("*** FT set- or getString");
        }
    }

    UnicodeString ucs = "unicode-string";
    UnicodeString* ucs_ptr = new UnicodeString("pointed-to-unicode-string");

    const Formattable ftarray[] = 
    {
        Formattable( 1.0, Formattable::kIsDate ),
        2.0,
        (int32_t)3,
        ucs,
        ucs_ptr
    };
    const int32_t ft_cnt = LENGTHOF(ftarray);
    Formattable ft_arr( ftarray, ft_cnt );
    UnicodeString temp;
    if ((ft_arr[0].getType() == Formattable::kDate)   && (ft_arr[0].getDate()   == 1.0)
     && (ft_arr[1].getType() == Formattable::kDouble) && (ft_arr[1].getDouble() == 2.0)
     && (ft_arr[2].getType() == Formattable::kLong)   && (ft_arr[2].getLong()   == (int32_t)3)
     && (ft_arr[3].getType() == Formattable::kString) && (ft_arr[3].getString(temp) == ucs)
     && (ft_arr[4].getType() == Formattable::kString) && (ft_arr[4].getString(temp) == *ucs_ptr) ) {
        it_logln("FT constr. for date, double, long, ustring, ustring* and array tested");
    }else{
        it_errln("*** FT constr. for date, double, long, ustring, ustring* or array");
    }

    int32_t i, res_cnt;
    const Formattable* res_array = ft_arr.getArray( res_cnt );
    if (res_cnt == ft_cnt) {
        UBool same  = TRUE;
        for (i = 0; i < res_cnt; i++ ) {
            if (res_array[i] != ftarray[i]) {
                same = FALSE;
            }
        }
        if (same) {
            it_logln("FT getArray tested");
            res_array = ft_arr.getArray( res_cnt, status = U_ZERO_ERROR);
            if (status == U_INVALID_FORMAT_ERROR){
                it_errln("*** FT getArray with status failed on real array");
            } else {
                it_logln("FT getArray with status tested on real array");
            }
        }else{
            it_errln("*** FT getArray comparison");
        }
    }else{
        it_errln(UnicodeString("*** FT getArray count res_cnt=") + res_cnt + UnicodeString("ft_cnt=") + ft_cnt);
    }
    
    res_array = fta.getArray(res_cnt, status = U_ZERO_ERROR);
    if (status == U_INVALID_FORMAT_ERROR){
        if (res_cnt == 0 && res_array == NULL){
            it_logln("FT getArray with status tested on non array");
        } else {
            it_errln("*** FT getArray with status return values are not consistent");
        }
    } else {
        it_errln("*** FT getArray with status should fail on non-array");
    }


    Formattable *pf;
    for(i = 0; i < ft_cnt; ++i) {
        pf = ftarray[i].clone();
        if(pf == (ftarray + i) || *pf != ftarray[i]) {
            it_errln(UnicodeString("Formattable.clone() failed for item ") + i);
        }
        delete pf;
    }

    const Formattable ftarr1[] = { Formattable( (int32_t)1 ), Formattable( (int32_t)2 ) };
    const Formattable ftarr2[] = { Formattable( (int32_t)3 ), Formattable( (int32_t)4 ) };

    const int32_t ftarr1_cnt = (int32_t)(sizeof(ftarr1) / sizeof(Formattable));
    const int32_t ftarr2_cnt = (int32_t)(sizeof(ftarr2) / sizeof(Formattable));

    ft_arr.setArray( ftarr1, ftarr1_cnt );
    if ((ft_arr[0].getType() == Formattable::kLong) && (ft_arr[0].getLong() == (int32_t)1)) {
        it_logln("FT setArray tested");
    }else{
        it_errln("*** FT setArray");
    }

    Formattable* ft_dynarr = new Formattable[ftarr2_cnt];
    for (i = 0; i < ftarr2_cnt; i++ ) {
        ft_dynarr[i] = ftarr2[i];
    }
    if ((ft_dy