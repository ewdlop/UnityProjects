<?xml version="1.0" encoding="utf-8"?>
<Type Name="MemberDescriptor" FullName="System.ComponentModel.MemberDescriptor">
  <TypeSignature Language="C#" Value="public abstract class MemberDescriptor" Maintainer="auto" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MemberDescriptor extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.3300.0</AssemblyVersion>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>
        <see cref="T:System.ComponentModel.MemberDescriptor" /> is the base class for the <see cref="T:System.ComponentModel.EventDescriptor" /> and the <see cref="T:System.ComponentModel.PropertyDescriptor" /> classes. The <see cref="T:System.ComponentModel.EventDescriptor" /> class provides a description of an event, and the <see cref="T:System.ComponentModel.PropertyDescriptor" /> class provides a description of a property.</para>
      <para>This class defines properties and methods to access its stored attributes. The <see cref="P:System.ComponentModel.MemberDescriptor.Attributes" /> property gets the collection of attributes. The <see cref="P:System.ComponentModel.MemberDescriptor.Category" />, <see cref="P:System.ComponentModel.MemberDescriptor.IsBrowsable" />, <see cref="P:System.ComponentModel.MemberDescriptor.Description" />, and <see cref="P:System.ComponentModel.MemberDescriptor.DesignTimeOnly" /> properties retrieve the values of those specific attributes. The <see cref="P:System.ComponentModel.MemberDescriptor.Name" /> and <see cref="P:System.ComponentModel.MemberDescriptor.DisplayName" /> properties provide the name of the member.</para>
      <para>The <see cref="T:System.ComponentModel.MemberDescriptor" /> also defines an <see cref="M:System.ComponentModel.MemberDescriptor.Equals(System.Object)" /> method to compare this <see cref="T:System.ComponentModel.MemberDescriptor" /> to another.</para>
      <block subset="none" type="note">
        <para>Typically, you inherit from the <see cref="T:System.ComponentModel.EventDescriptor" /> and <see cref="T:System.ComponentModel.PropertyDescriptor" /> classes, and not from this class.</para>
      </block>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents a class member, such as a property or event. This is an abstract base class.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MemberDescriptor (System.ComponentModel.MemberDescriptor reference);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor reference) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="reference" Type="System.ComponentModel.MemberDescriptor" />
      </Parameters>
      <Docs>
        <param name="reference">To be added: an object of type 'MemberDescriptor'</param>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.ComponentModel.MemberDescriptor" /> class with the specified <see cref="T:System.ComponentModel.MemberDescriptor" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MemberDescriptor (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.ComponentModel.MemberDescriptor" /> class with the specified name of the member.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the member. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MemberDescriptor (System.ComponentModel.MemberDescriptor reference, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor reference, class System.Attribute[] attrs) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="reference" Type="System.ComponentModel.MemberDescriptor" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="reference">To be added.</param>
        <param name="attrs">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor appends the attributes in the <see cref="T:System.Attribute" /> array to the attributes in the old <see cref="T:System.ComponentModel.MemberDescriptor" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.ComponentModel.MemberDescriptor" /> class with the name in the specified <see cref="T:System.ComponentModel.MemberDescriptor" /> and the attributes in both the old <see cref="T:System.ComponentModel.MemberDescriptor" /> and the <see cref="T:System.Attribute" /> array.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MemberDescriptor (string name, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Attribute[] attrs) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="attrs">To be added.</param>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.ComponentModel.MemberDescriptor" /> class with the specified name of the member and an array of attributes.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the member. </param>
      </Docs>
    </Member>
    <Member MemberName="AttributeArray">
      <MemberSignature Language="C#" Value="protected virtual Attribute[] AttributeArray { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Attribute[] AttributeArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Attribute[]</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'Attribute []'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Accessing this member allows derived classes to modify the default set of attributes that are used in the <see cref="M:System.ComponentModel.MemberDescriptor.CreateAttributeCollection" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets an array of attributes.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.AttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.AttributeCollection Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'AttributeCollection'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If there is no <see cref="T:System.ComponentModel.AttributeCollection" /> for this member, this property calls the <see cref="M:System.ComponentModel.MemberDescriptor.CreateAttributeCollection" /> method to create a new <see cref="T:System.ComponentModel.AttributeCollection" /> using the array of <see cref="T:System.Attribute" /> objects passed to the constructor.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the collection of attributes for this member.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public virtual string Category { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A visual designer can use this property value to display members in categories.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the category to which the member belongs, as specified in the <see cref="T:System.ComponentModel.CategoryAttribute" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CreateAttributeCollection">
      <MemberSignature Language="C#" Value="protected virtual System.ComponentModel.AttributeCollection CreateAttributeCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ComponentModel.AttributeCollection CreateAttributeCollection() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called from the <see cref="P:System.ComponentModel.MemberDescriptor.Attributes" /> property when there is no <see cref="T:System.ComponentModel.AttributeCollection" /> for this member. If there are no attributes in the <see cref="P:System.ComponentModel.MemberDescriptor.AttributeArray" />, this will return an empty <see cref="T:System.ComponentModel.AttributeCollection" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a collection of attributes using the array of attributes passed to the constructor.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.ComponentModel.AttributeCollection" /> that contains the <see cref="P:System.ComponentModel.MemberDescriptor.AttributeArray" /> attributes.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public virtual string Description { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Description" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A visual designer can use this description to display information about this member.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the description of the member, as specified in the <see cref="T:System.ComponentModel.DescriptionAttribute" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DesignTimeOnly">
      <MemberSignature Language="C#" Value="public virtual bool DesignTimeOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignTimeOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If there is no <see cref="T:System.ComponentModel.DesignOnlyAttribute" />, the return value is the default, which is false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets whether this member should be set only at design time, as specified in the <see cref="T:System.ComponentModel.DesignOnlyAttribute" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DisplayName">
      <MemberSignature Language="C#" Value="public virtual string DisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name that can be displayed in a window, such as a Properties window.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares this instance to the given object to see if they are equivalent.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if equivalent; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare to the current instance. </param>
      </Docs>
    </Member>
    <Member MemberName="FillAttributes">
      <MemberSignature Language="C#" Value="protected virtual void FillAttributes (System.Collections.IList attributeList);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FillAttributes(class System.Collections.IList attributeList) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeList" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For duplicate attributes, the last one added to the list is kept.</para>
          <para>The <see cref="T:System.Collections.IList" /> with the attributes is created once. If there are duplicate attributes in the list, only the first instance is saved; all subsequent duplicate attributes are removed from the list.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, adds the attributes of the inheriting class to the specified list of attributes in the parent class.</para>
        </summary>
        <param name="attributeList">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Collections.IList" /> that lists the attributes in the parent class. Initially, this is empty. </param>
      </Docs>
    </Member>
    <Member MemberName="FindMethod">
      <MemberSignature Language="C#" Value="protected static System.Reflection.MethodInfo FindMethod (Type componentClass, string name, Type[] args, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Reflection.MethodInfo FindMethod(class System.Type componentClass, string name, class System.Type[] args, class System.Type returnType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentClass" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="args" Type="System.Type[]" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Finds the given method through reflection, searching only for public methods.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Reflection.MethodInfo" /> that represents the method, or null if the method is not found.</para>
        </returns>
        <param name="componentClass">
          <attribution license="cc4" from="Microsoft" modified="false" />The component that contains the method. </param>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the method to find. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of parameters for the method, used to choose between overloaded methods. </param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to return for the method. </param>
      </Docs>
    </Member>
    <Member MemberName="FindMethod">
      <MemberSignature Language="C#" Value="protected static System.Reflection.MethodInfo FindMethod (Type componentClass, string name, Type[] args, Type returnType, bool publicOnly);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Reflection.MethodInfo FindMethod(class System.Type componentClass, string name, class System.Type[] args, class System.Type returnType, bool publicOnly) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentClass" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="args" Type="System.Type[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="publicOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Finds the given method through reflection, with an option to search only public methods.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Reflection.MethodInfo" /> that represents the method, or null if the method is not found.</para>
        </returns>
        <param name="componentClass">
          <attribution license="cc4" from="Microsoft" modified="false" />The component that contains the method. </param>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the method to find. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of parameters for the method, used to choose between overloaded methods. </param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to return for the method. </param>
        <param name="publicOnly">
          <attribution license="cc4" from="Microsoft" modified="false" />Whether to restrict search to public methods. </param>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the hash code for this instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A hash code for the current <see cref="T:System.ComponentModel.MemberDescriptor" />.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationTarget">
      <MemberSignature Language="C#" Value="protected virtual object GetInvocationTarget (Type type, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetInvocationTarget(class System.Type type, object instance) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Normally, the return value will be the same as the <paramref name="instance" /> parameter. If another object has been associated with this instance, or if the instance is a custom type descriptor, the <see cref="M:System.ComponentModel.MemberDescriptor.GetInvocationTarget(System.Type,System.Object)" /> method may return a different value.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the object that should be used during invocation of members.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The object to be used during member invocations.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the invocation target.</param>
        <param name="instance">
          <attribution license="cc4" from="Microsoft" modified="false" />The potential invocation target.</param>
      </Docs>
    </Member>
    <Member MemberName="GetInvokee">
      <MemberSignature Language="C#" Value="protected static object GetInvokee (Type componentClass, object component);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig object GetInvokee(class System.Type componentClass, object component) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use GetInvocationTarget")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentClass" Type="System.Type" />
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the component on which to invoke a method.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the component to invoke. This method returns a visual designer when the property is attached to a visual designer.</para>
        </returns>
        <param name="componentClass">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Type" /> representing the type of component this <see cref="T:System.ComponentModel.MemberDescriptor" /> is bound to. For example, if this <see cref="T:System.ComponentModel.MemberDescriptor" /> describes a property, this parameter should be the class that the property is declared on. </param>
        <param name="component">
          <attribution license="cc4" from="Microsoft" modified="false" />An instance of the object to call. </param>
      </Docs>
    </Member>
    <Member MemberName="GetSite">
      <MemberSignature Language="C#" Value="protected static System.ComponentModel.ISite GetSite (object component);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.ComponentModel.ISite GetSite(object component) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a component site for the given component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The site of the component, or null if a site does not exist.</para>
        </returns>
        <param name="component">
          <attribution license="cc4" from="Microsoft" modified="false" />The component for which you want to find a site. </param>
      </Docs>
    </Member>
    <Member MemberName="IsBrowsable">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowsable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowsable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A visual designer typically displays the members that are browsable in the Properties window.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the member is browsable, as specified in the <see cref="T:System.ComponentModel.BrowsableAttribute" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the member.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NameHashCode">
      <MemberSignature Language="C#" Value="protected virtual int NameHashCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NameHashCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the hash code for the name of the member, as specified in <see cref="M:System.String.GetHashCode" />.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Ôªø<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\Imath\ImathBox.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Imath\ImathColorAlgo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Imath\ImathFun.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Imath\ImathMatrixAlgo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Imath\ImathRandom.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Imath\ImathShear.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\Imath\ImathVec.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\Imath\ImathBox.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathBoxAlgo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathColor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathColorAlgo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathEuler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathExc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathFrame.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathFrustum.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathFrustumTest.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathFun.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathGL.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathGLU.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathHalfLimits.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathInt64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathInterval.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathLimits.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathLine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathLineAlgo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathMath.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathMatrix.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathMatrixAlgo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathPlane.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathPlatform.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathQuat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathRandom.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathRoots.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathShear.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathSphere.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathVec.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\Imath\ImathVecAlgo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>                                      ˚¸4Ñ0vr-mí∑¨´›Ÿ–LrËs˙ÊØ#∆j–œTΩ‰∏OÂhÍø˙œ61h«d7E¿vºTt6õŸU=@V»ô≤hz∑K$ºâ‚<®ë>—FÙ∂πæ≤C∞íMÅ£>ÔzÓZ;'ünV çÉïs◊∫Ë0≠ÜÏ)¬ôÿñá\˚„≠%¬·Z2Â·í$wàe˛"ÔÿÓY"Ï“ﬁZDH£ÀÂÉÉmàGıÔîb+⁄§B≥ qqê,ôFøuq>È”’\›@iCËOÁ°q¢OπÜ∑]íc”∂€‚{˙6~ãmä«3hpç0kEˇ⁄8„gW™Ò÷Õ÷¿<…Ït›¥˘¸	Bh9¶’ﬂ\	µ˜*"â∆Ÿpˆ.LÂà∞°ïN4¨π&sñúo§UΩh‚Cq:	X'¸=U:¶ûÖqúo”)?QC≥È‰ÙYÏFº3≥^∞±4Ë1RXˇﬂ'ı/„˛'∏*}ZºÕ6ÃbõÒVÂ˝Ä*wWπ'vxG8>ƒ.Æ§£BÁ‘Ω«K@ÅÒèîñﬂK8ª€ø√	çÛb≥D,„HJ0yÄ.s≥ª~◊g‚œ|çÔ⁄3!Œ÷≈¨[[h-BgV$»À“¨ñf‘«ƒå°`Ûàâ‡iéút‹à√z{D'lÇ’ÆUår7Åyƒ”⁄Òjqùûïi@ÄkÑ^ñK[Ωä¶¡>ŸÄÀøa_≤(°ô.vÕÓ˜a¿É’i0:]c *Hw˜Æú45∑˛lp=ëãaS©2~„QÜb°x≈T§¬P…ü•«ád[“4OÖ1≤o<AJ_îzÒH-	•∞W:R[9~	Tf:Â6⁄Éá⁄‚¯Áë∑ã¨Ì …,.f´Ò˚_=´pÈÙèz«eç%4eù(+ç‡‡}∫œÓcU\¢l\Ï¢i¬bIœHïÁîiHãÛÍÍ∆ì˜ºjƒR3◊/ÔüÖI˚Ø¯~IH§6vdÓk
${°çCZœØå%DƒBìﬁ˛–Ä-õ;A°9j*Tpd†H{˙é§vN*Pd”<Ôëyå˝ÚëuWL8åBÃË†pF∫\T¿<’Ÿâ]ã ›>z>íÙ$◊¸TOΩÔº<g9p¨xÄêG,°úaƒ∆A√[®IÊã©ïØ-R”#Ú0dNõíE+¨;i◊7«Ë+2«4'L8ñ^ûàΩƒån´Z@ìVR¥Kòµm7u"Á÷àÀCSÂü∑†	ÌPE∆µ∑UÖfÿvÁãÍ°qÙ
¥ÿßÚrsOØß6€ÇâëZ8;J0D†⁄€§6ˇSOaÛ≠XØ°\÷%NÉs‰‹ª—¢≥¥óÂ∞¯Ìó7WdïE,˛ºù2o`¶åøÕ£?Ü]˜1ﬂFlØüMt∫˙fﬁ)¸t3îµ§EôÄlæt[Ï∏Û«B»‡oÖ£M1rk 'µ!Ñ!Û∫Ö≈—T±õQ≠2{gR;Ò‚óe`'Å®LV8XóÛ€ömùø-¡€∏Ò•∫)†õ…†î¯wõCXﬁû¥rÄ¿<ìÓƒµŸ,K˜îF.<©“9∫uQJ_ﬂ]ÔÜ¯eYYïØ;ßy∑•éˇrmøi∏Ä5.mUß\+—Îßƒ[ÁSÙ£ı‘õåD2ù Ä˜˝C¸µsÚôàßçz‰Ä´ëèπ>õŒBÙ¯gcÊ ›»©…µõBˇ|≈õ∆|Ã¶ÈÈ9=P0û< d7\TÛUàˇO∑D"åqxø8n˝ïv´¡Ä˝t}≥”ïdåÖw.>˜4B4Sø~03ïñòÿ^µÕõÎÃxfµ∆w"<ÊU·SË‰ƒ0¸[e`W¿Ô—Ω@_PZ
	`È2äú<ﬂ˘·¸W€¯„h
÷≤Ù=T€˘,PBˆsôä≈⁄ò !≠êóÒ”ôïËJ∂ˆB® üDm6∞dÚÄà
–>·˚êZ^lDÊ8xU\ŒRYLL4Ù¯ÍûI—ªQùé„a¿‚6ù'¡Ì´¢wä@±eÚ	?_ÁÇO¨|‡>öF`É\ZmŒtw0_EI⁄?2k‰	íCÇ¬âï‘r∞ScäRƒ"¯'@–µZ∂∑ù›Ò§§Cô*™¨ÕVº©K∆bæïÚ´•Rxï˜⁄A-˚¥jfWTÛ”ÖSP∫cÊ"ƒ~Ç-T⁄ıCNÊQ˝Sâµ˝´…Œ¯pf(7ﬂ6‚Ù¨[îˇÕ?qZ÷Åwo¢ÿƒ˜∆~ÎÃ∏Øík=¶˘q;noçqÊÁáΩË∞Zïò,Q!;19k˙‹n≈ü`Î!´Å_/RHœî¸®x%Ô)‡aI3˙WπêBêdé%öÅÌˆ–‰,™≥óm…1ﬂÂÖ<è‹2u}œ`»˘⁄ˆ„W†œÍ™FÕ#7â˘õ!}t6zDäñºè ŸJ4eÓsYïÒ†uŒﬂ—â≤Øwdˇb‡Rvïí…≠@Slˇãá€‹ˆ
ì˛n√èêWx˛∞¢®¸á'jÖ<∆cö˝	}jù33]çsG……ı∑ˇg |rë›.}~8—r{∞—ÉÇ@uS∞∏ä∏ê{…geD GEo¯¡ıó¢√õ∫˙˙Ìiy4ñ¬E¢@É·8X˚éÄÚ$’˚ù>µ¢ôg~ÿáøsçjxGg2HBíA∂ΩÇ¥rj4ﬂ˙Iºπ/ªHç£‡©E±ûij≈OºØƒˆÉ%¨°›L·’á0"•«O“ø˛Ûî∂{lh‚z2F_·ùÔPF„qƒxx[$Ωi°√pdÒ,˚Ù≠6ÈØu∑úK≤€N˘Züv≈√hë"ByÌâ–{∆8xéˇB[${î=Œì≈…tàŒ≤ß\Z7:@›è€ÂJ≠JzäÔe]u*VkXÆ∑Ì’–&ÒÖ•Ì°∞®ß™ÿ–\8ˇ_êIÈÑ]Bﬁï≈…+¶π:‰PÏ¯A-ÙÎY’Åô=÷ÇÛÈòà_hÈwKı¸¿ËM˛;a"œ<å¢B◊Öã°ì˚ä¢8»˚dÁçÊ0=%Ω„–b+C\¨Ωb÷êS€ØÄï /‚|u©«Œ¢¬«GbZØ5*ñ'µå√Ç¸∑+Å8ŸøgN◊ê$·…E}=õù9|–'‹*%pjDπdaáÌ˛Ì3≥Ï~˝€Å]O…™õd^2ˆ„rYFí≤3Í¡‚7∏%îäŸñÚbË˛=9Ì—oÿ˛;-∆ñ©ﬂÛûüå€˝<{é'é}K/ö,Mó¶3èkÅ,É|œ`
∑[ìlı±]h‘Áµ‘¯xçÃXréw¢Éº‚«ˆ°k)ﬁvƒ©~¬X∂cBØ›î~Ë{Ò~l∫ÈsŸÁZEÀ*D*
Ò∆˘>J9>B´øB/FC Õxi®¡D™H⁄Fu†Õ∞ÁiJ4emÉLt#üﬁ‚X2˝ûß˛/N…§Bp∫iÿãı–pﬂ√ΩÿıúfNæ∂éº˘^s¿YkÙ©◊'éV‰Í=∏ã¬±\ˆ∏·#πf¡PûJáç˘hÏv˙>ÔU&±˚“›Íd!A1ﬁoY/-9√µkO¸∆∂?ìáu+27
*Ô2o
ÃÁKúP M':ÉÈuÅ£ªÍ«mØ2@îjZq©WÁà]j‘#ÛúŸÉö‰)(”wÈÍíGıwj›Õ€Gï∏i3∞*°H^‘pCx<”ïã[^7gdã™#2‡ˆ÷∆˛^±‡ﬂf3Òr7QÄ:Nøæ»J¥îí¡ëÌ8Ç∫Ûôﬂé=∫ÏâBçËŸËz§ht ôﬁ:{ﬂ^%çH–ö≥ÿ¿âv0≈M¨-‰˛¸÷æ}»ÇU é˚]m¢¶aÅº6xº·≠⁄j˛cÜÈ
˙ìºÿÒÂêñ»M"”BÊë0≈ñåÈ«”◊yöYÉöÚSYê√1a∑øÚÃM∫âãñPÄ∏ ‘»/6àXÁ@πã‘ËQ–·ÃI¨®{{5ˆò1∫Å.òT!¢35≤ﬂ‘≤Y¡pÊï0Ã2|Ê°÷u+’ødÿé«2t–è7|~%'á˝µı◊ÍmAéï»FÇˆ«roGUN«ÿ∂Ãô(á§\Ü‘Ïrïª°ô1_≈}‰ú`//
// Methods.cs: Information about a method and its mapping to a SOAP web service.
//
// Author:
//   Miguel de Icaza
//   Lluis Sanchez Gual (lluis@ximian.com)
//
// (C) 2003 Ximian, Inc.
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using HeaderInfo = System.Web.Services.Protocols.SoapHeaderMapping;

using System.Reflection;
using System.Collections;
using System.Xml;
using System.Xml.Serialization;
using System.Web.Services;
using System.Web.Services.Description;

namespace System.Web.Services.Protocols {

	//
	// This class represents all the information we extract from a MethodInfo
	// in the SoapHttpClientProtocol derivative stub class
	//
	internal class SoapMethodStubInfo : MethodStubInfo
	{
		internal readonly string Action;
		internal readonly string Binding;

		// The name/namespace of the request 
		internal readonly string RequestName;
		internal readonly string RequestNamespace;

		// The name/namespace of the response.
		internal readonly string ResponseName;
		internal readonly string ResponseNamespace;

		internal readonly bool OneWay;
		internal readonly SoapParameterStyle ParameterStyle;
		internal readonly SoapBindingStyle SoapBindingStyle;
		internal readonly SoapBindingUse Use;

		internal readonly HeaderInfo [] Headers;
		internal readonly HeaderInfo [] InHeaders;
		internal readonly HeaderInfo [] OutHeaders;
		internal readonly HeaderInfo [] FaultHeaders;
		internal readonly SoapExtensionRuntimeConfig [] SoapExtensions;

		internal readonly XmlMembersMapping InputMembersMapping;
		internal readonly XmlMembersMapping OutputMembersMapping;
		internal readonly XmlMembersMapping InputHeaderMembersMapping;
		internal readonly XmlMembersMapping OutputHeaderMembersMapping;
		internal readonly XmlMembersMapping FaultHeaderMembersMapping;

		private readonly int requestSerializerId;
		private readonly int responseSerializerId;
		private readonly int requestHeadersSerializerId = -1;
		private readonly int responseHeadersSerializerId = -1;
		private readonly int faultHeadersSerializerId = -1;
		
		internal XmlSerializer RequestSerializer
		{
			get { return TypeStub.GetSerializer (requestSerializerId); }
		}
		
		internal XmlSerializer ResponseSerializer
		{
			get { return TypeStub.GetSerializer (responseSerializerId); }
		}
		
		internal XmlSerializer RequestHeadersSerializer
		{
			get { return requestHeadersSerializerId != -1 ? TypeStub.GetSerializer (requestHeadersSerializerId) : null; }
		}
		
		internal XmlSerializer ResponseHeadersSerializer
		{
			get { return responseHeadersSerializerId != -1 ? TypeStub.GetSerializer (responseHeadersSerializerId) : null; }
		}
		
		internal XmlSerializer FaultHeadersSerializer
		{
			get { return faultHeadersSerializerId != -1 ? TypeStub.GetSerializer (faultHeadersSerializerId) : null; }
		}
		

		//
		// Constructor
		//
		public SoapMethodStubInfo (TypeStubInfo typeStub, LogicalMethodInfo source, object kind, XmlReflectionImporter xmlImporter, SoapReflectionImporter soapImporter)
		: base (typeStub, source)
		{
			SoapTypeStubInfo parent = (SoapTypeStubInfo) typeStub;
			XmlElementAttribute optional_ns = null;

			if (kind == null) {
				Use = parent.LogicalType.BindingUse;
				RequestName = "";
				RequestNamespace = "";
				ResponseName = "";
				ResponseNamespace = "";
				ParameterStyle = parent.ParameterStyle;
				SoapBindingStyle = parent.SoapBindingStyle;
				OneWay = false;
// disabled (see bug #332150)
//#if NET_2_0
//				if (parent.Type != source.DeclaringType)
//					Binding = source.DeclaringType.Name + parent.ProtocolName;
//#endif
			}
			else if (kind is SoapDocumentMethodAttribute){
				SoapDocumentMethodAttribute dma = (SoapDocumentMethodAttribute) kind;
				
				Use = dma.Use;
				if (Use == SoapBindingUse.Default) {
					if (parent.SoapBindingStyle == SoapBindingStyle.Document)
						Use = parent.LogicalType.BindingUse;
					else
						Use = SoapBindingUse.Literal;
				}
				
				Action = dma.Action;
				Binding = dma.Binding;
				RequestName = dma.RequestElementName;
				RequestNamespace = dma.RequestNamespace;
				ResponseName = dma.ResponseElementName;
				ResponseNamespace = dma.ResponseNamespace;
				ParameterStyle = dma.ParameterStyle;
				if (ParameterStyle == SoapParameterStyle.Default)
					ParameterStyle = parent.ParameterStyle;
				OneWay = dma.OneWay;
				SoapBindingStyle = SoapBindingStyle.Document;
			} else {
				SoapRpcMethodAttribute rma = (SoapRpcMethodAttribute) kind;
				Use = SoapBindingUse.Encoded;	// RPC always use encoded

				Action = rma.Action;
				if (Action != null && Action.Length == 0)
					Action = null;
				Binding = rma.Binding;
				
				// When using RPC, MS.NET seems to ignore RequestElementName and
				// MessageName, and it always uses the method name
				RequestName = source.Name;
				ResponseName = source.Name + "Response";
//				RequestName = rma.RequestElementName;
//				ResponseName = rma.ResponseElementName;
				RequestNamespace = rma.RequestNamespace;
				ResponseNamespace = rma.ResponseNamespace;
				ParameterStyle = SoapParameterStyle.Wrapped;
				OneWay = rma.OneWay;
				SoapBindingStyle = SoapBindingStyle.Rpc;

				// For RPC calls, make all arguments be part of the empty namespace
				optional_ns = new XmlElementAttribute ();
				optional_ns.Namespace = "";
			}

			if (OneWay){
				if (source.ReturnType != typeof (void))
					throw new Exception ("OneWay methods should not have a return value.");
				if (source.OutParameters.Length != 0)
					throw new Exception ("OneWay methods should not have out/ref parameters.");
			}
			
			BindingInfo binfo = parent.GetBinding (Binding);
			if (binfo == null) throw new InvalidOperationException ("Type '" + parent.Type + "' is missing WebServiceBinding attribute that defines a binding named '" + Binding + "'.");
			
			string serviceNamespace = binfo.Namespace;
				
			if (RequestNamespace == "") RequestNamespace = parent.LogicalType.GetWebServiceNamespace (serviceNamespace, Use);
			if (ResponseNamespace == "") ResponseNamespace = parent.LogicalType.GetWebServiceNamespace (serviceNamespace, Use);
			if (RequestName == "") RequestName = Name;
			if (ResponseName == "")	ResponseName = Name + "Response";
			if (Action == null)
				Action = serviceNamespace.EndsWith("/") ? (serviceNamespace + Name) : (serviceNamespace + "/" + Name);
			
			bool hasWrappingElem = (ParameterStyle == SoapParameterStyle.Wrapped);
			bool writeAccessors = (SoapBindingStyle == SoapBindingStyle.Rpc);
			
			XmlReflectionMember [] in_members = BuildRequestReflectionMembers (optional_ns);
			XmlReflectionMember [] out_members = BuildResponseReflectionMembers (optional_ns);

			if (Use == SoapBindingUse.Literal) {
				xmlImporter.IncludeTypes (source.CustomAttributeProvider);
				InputMembersMapping = xmlImporter.ImportMembersMapping (RequestName, RequestNamespace, in_members, hasWrappingElem);
				OutputMembersMapping = xmlImporter.ImportMembersMapping (ResponseName, ResponseNamespace, out_members, hasWrappingElem);
			}
			else {
				soapImporter.IncludeTypes (source.CustomAttributeProvider);
				InputMembersMapping = soapImporter.ImportMembersMapping (RequestName, RequestNamespace, in_members, hasWrappingElem, writeAccessors);
				OutputMembersMapping = soapImporter.ImportMembersMapping (ResponseName, ResponseNamespace, out_members, hasWrappingElem, writeAccessors);
			}

			InputMembersMapping.SetKey(RequestName);
			OutputMembersMapping.SetKey(ResponseName);

			requestSerializerId = parent.RegisterSerializer (InputMembersMapping);
			responseSerializerId = parent.RegisterSerializer (OutputMembersMapping);

			object[] o = source.GetCustomAttributes (typeof (SoapHeaderAttribute));
			ArrayList allHeaderList = new ArrayList (o.Length);
			ArrayList inHeaderList = new ArrayList (o.Length);
			ArrayList outHeaderList = new ArrayList (o.Length);
			ArrayList faultHeaderList = new ArrayList ();
			
			SoapHeaderDirection unknownHeaderDirections = (SoapHeaderDirection)0;
			
			for (int i = 0; i < o.Length; i++) {
				SoapHeaderAttribute att = (SoapHeaderAttribute) o[i];
				MemberInfo[] mems = source.DeclaringType.GetMember (att.MemberName);
				if (mems.Length == 0) throw new InvalidOperationException ("Member " + att.MemberName + " not found in class " + source.DeclaringType.FullName + ".");
				
				HeaderInfo header = new HeaderInfo (mems[0], att);
				allHeaderList.Add (header);
				if (!header.Custom) {
					if ((header.Direction & SoapHeaderDirection.In) != 0)
						inHeaderList.Add (header);
					if ((header.Direction & SoapHeaderDirection.Out) != 0)
						outHeaderList.Add (header);
					if ((header.Direction & SoapHeaderDirection.Fault) != 0)
						faultHeaderList.Add (header);
				} else
					unknownHeaderDirections |= header.Direction;
			}
			
			Headers = (HeaderInfo[]) allHeaderList.ToArray (typeof(HeaderInfo));

			if (inHeaderList.Count > 0 || (unknownHeaderDirections & SoapHeaderDirection.In) != 0) {
				InHeaders = (HeaderInfo[]) inHeaderList.ToArray (typeof(HeaderInfo));
				XmlReflectionMember[] members = BuildHeadersReflectionMembers (InHeaders);
				
				if (Use == SoapBindingUse.Literal)
					InputHeaderMembersMapping = xmlImporter.ImportMembersMapping ("", RequestNamespace, members, false);
				else
					InputHeaderMembersMapping = soapImporter.ImportMembersMapping ("", RequestNamespace, members, false, false);
				
				InputHeaderMembersMapping.SetKey(RequestName + ":InHeaders");
				
				requestHeadersSerializerId = parent.RegisterSerializer (InputHeaderMembersMapping);
			}
			
			if (outHeaderList.Count > 0 || (unknownHeaderDirections & SoapHeaderDirection.Out) != 0) {
				OutHeaders = (HeaderInfo[]) outHeaderList.ToArray (typeof(HeaderInfo));
				XmlReflectionMember[] members = BuildHeadersReflectionMembers (OutHeaders);
				
				if (Use == SoapBindingUse.Literal)
					OutputHeaderMembersMapping = xmlImporter.ImportMembersMapping ("", RequestNamespace, members, false);
				else
					OutputHeaderMembersMapping = soapImporter.ImportMembersMapping ("", RequestNamespace, members, false, false);

				OutputHeaderMembersMapping.SetKey(ResponseName + ":OutHeaders");

				responseHeadersSerializerId = parent.RegisterSerializer (OutputHeaderMembersMapping);
			}
			
			if (faultHeaderList.Count > 0 || (unknownHeaderDirections & SoapHeaderDirection.Fault) != 0) {
				FaultHeaders = (HeaderInfo[]) faultHeaderList.ToArray (typeof(HeaderInfo));
				XmlReflectionMember[] members = BuildHeadersReflectionMembers (FaultHeaders);
				
				if (Use == SoapBindingUse.Literal)
					FaultHeaderMembersMapping = xmlImporter.ImportMembersMapping ("", RequestNamespace, members, false);
				else
					FaultHeaderMembersMapping = soapImporter.ImportMembersMapping ("", RequestNamespace, members, false, false);
				
				faultHeadersSerializerId = parent.RegisterSerializer (FaultHeaderMembersMapping);
			}
			
			SoapExtensions = SoapExtension.GetMethodExtensions (source);
		}

		XmlReflectionMember [] BuildRequestReflectionMembers (XmlElementAttribute optional_ns)
		{
			ParameterInfo [] input = MethodInfo.InParameters;
			XmlReflectionMember [] in_members = new XmlReflectionMember [input.Length];

			for (int i = 0; i < input.Length; i++)
			{
				XmlReflectionMember m = new XmlReflectionMember ();
				m.IsReturnValue = false;
				m.MemberName = input [i].Name;
				m.MemberType = input [i].ParameterType;

				m.XmlAttributes = new XmlAttributes (input[i]);
				m.SoapAttributes = new SoapAttributes (input[i]);

				if (m.MemberType.IsByRef)
					m.MemberType = m.MemberType.GetElementType ();
				if (optional_ns != null)
					m.XmlAttributes.XmlElements.Add (optional_ns);
				in_members [i] = m;
			}
			return in_members;
		}
		
		XmlReflectionMember [] BuildResponseReflectionMembers (XmlElementAttribute optional_ns)
		{
			ParameterInfo [] output = MethodInfo.OutParameters;
			bool has_return_value = !(OneWay || MethodInfo.ReturnType == typeof (void));
			XmlReflectionMember [] out_members = new XmlReflectionMember [(has_return_value ? 1 : 0) + output.Length];
			XmlReflectionMember m;
			int idx = 0;

			if (has_return_value)
			{
				m = new XmlReflectionMember ();
				m.IsReturnValue = true;
				m.MemberName = Name + "Result";
				m.MemberType = MethodInfo.ReturnType;

				m.XmlAttributes = new XmlAttributes (MethodInfo.ReturnTypeCustomAttributeProvider);
				m.SoapAttributes = new SoapAttributes (MethodInfo.ReturnTypeCustomAttributeProvider);

				if (optional_ns != null)
					m.XmlAttributes.XmlElements.Add (optional_ns);
				idx++;
				out_members [0] = m;
			}
			
			for (int i = 0; i < output.Length; i++)
			{
				m = new XmlReflectionMember ();
				m.IsReturnValue = false;
				m.MemberName = output [i].Name;
				m.MemberType = output [i].ParameterType;
				m.XmlAttributes = new XmlAttributes (output[i]);
				m.SoapAttributes = new SoapAttributes (output[i]);

				if (m.MemberType.IsByRef)
					m.MemberType = m.MemberType.GetElementType ();
				if (optional_ns != null)
					m.XmlAttributes.XmlElements.Add (optional_ns);
				out_members [i + idx] = m;
			}
			return out_members;
		}

		XmlReflectionMember [] BuildHeadersReflectionMembers (HeaderInfo[] headers)
		{
			XmlReflectionMember [] mems = new XmlReflectionMember [headers.Length];

			for (int n=0; n<headers.Length; n++)
			{
				HeaderInfo header = headers [n];
				
				XmlReflectionMember m = new XmlReflectionMember ();
				m.IsReturnValue = false;
				m.MemberName = header.HeaderType.Name;
				m.MemberType = header.HeaderType;

				// MS.NET reflects header classes in a weird way. The root element
				// name is the CLR class name unless it is specified in an XmlRootAttribute.
				// The usual is to use the xml type name by default, but not in this case.
				
				XmlAttributes ats = new XmlAttributes (header.HeaderType);
				if (ats.XmlRoot != null) {
					XmlElementAttribute xe = new XmlElementAttribute ();
					xe.ElementName = ats.XmlRoot.ElementName;
					xe.Namespace = ats.XmlRoot.Namespace;
					m.XmlAttributes = new XmlAttributes ();
					m.XmlAttributes.XmlElements.Add (xe);
				}
				
				mems [n] = m;
			}
			return mems;
		}

		public HeaderInfo GetHeaderInfo (Type headerType)
		{
			foreach (HeaderInfo headerInfo in Headers)
				if (headerInfo.HeaderType == headerType) return headerInfo;
			return null;
		}
		
		public XmlSerializer GetBodySerializer (SoapHeaderDirection dir, bool soap12)
		{
			switch (dir) {
				case SoapHeaderDirection.In: return RequestSerializer;
				case SoapHeaderDirection.Out: return ResponseSerializer;
				case SoapHeaderDirection.Fault: return soap12 ? Soap12Fault.Serializer : Fault.Serializer;
				default: return null;
			}
		}
		
		public XmlSerializer GetHeaderSerializer (SoapHeaderDirection dir)
		{
			switch (dir) {
				case SoapHeaderDirection.In: return RequestHeadersSerializer;
				case SoapHeaderDirection.Out: return ResponseHeadersSerializer;
				case SoapHeaderDirection.Fault: return FaultHeadersSerializer;
				default: return null;
			}
		}
		
		HeaderInfo[] GetHeaders (SoapHeaderDirection dir)
		{
			switch (dir) {
				case SoapHeaderDirection.In: return InHeaders;
				case SoapHeaderDirection.Out: return OutHeaders;
				case SoapHeaderDirection.Fault: return FaultHeaders;
				default: return null;
			}
		}
		
		public object[] GetHeaderValueArray (SoapHeaderDirection dir, SoapHeaderCollection headers)
		{
			HeaderInfo[] headerInfos = GetHeaders (dir);
			if (headerInfos == null) return null;

			object[] hs = new object [headerInfos.Length];
			
			for (int n=0; n<headers.Count; n++) {
				SoapHeader h = headers[n];
				Type t = h.GetType();
				for (int i=0; i<headerInfos.Length; i++)
					if (headerInfos [i].HeaderType == t)
						hs [i] = h;
			}
			return hs;
		}
	}

	//
	// Holds the metadata loaded from the type stub, as well as
	// the metadata for all the methods in the type
	//
	internal class SoapTypeStubInfo : TypeStubInfo
	{
		Hashtable methods_byaction = new Hashtable (); 

		// Precomputed
		internal SoapParameterStyle      ParameterStyle;
		internal SoapExtensionRuntimeConfig[][] SoapExtensions;
		internal SoapBindingStyle SoapBindingStyle;
		internal XmlReflectionImporter 	xmlImporter;
		internal SoapReflectionImporter soapImporter;

		public SoapTypeStubInfo (LogicalTypeInfo logicalTypeInfo)
		: base (logicalTypeInfo)
		{
			xmlImporter = new XmlReflectionImporter ();
			soapImporter = new SoapReflectionImporter ();
				
			if (typeof (SoapHttpClientProtocol).IsAssignableFrom (Type))
			{
				if (Bindings.Count == 0 || ((BindingInfo)Bindings[0]).WebServiceBindingAttribute == null)
					throw new InvalidOperationException ("WebServiceBindingAttribute is required on proxy class '" + Type + "'.");
				if (Bindings.Count > 1)
					throw new InvalidOperationException ("Only one WebServiceBinding attribute may be specified on type '" + Type + "'.");
			}

			object [] o = Type.GetCustomAttributes (typeof (SoapDocumentServiceAttribute), false);
			if (o.Length == 1){
				SoapDocumentServiceAttribute a = (SoapDocumentServiceAttribute) o [0];

				ParameterStyle = a.ParameterStyle;
				SoapBindingStyle = SoapBindingStyle.Document;
			} else {
				o = Type.GetCustomAttributes (typeof (SoapRpcServiceAttribute), false);
				if (o.Length == 1){
					ParameterStyle = SoapParameterStyle.Wrapped;
					SoapBindingStyle = SoapBindingStyle.Rpc;
				} else {
					ParameterStyle = SoapParameterStyle.Wrapped;
					SoapBindingStyle = SoapBindingStyle.Document;
				}
			}
			
			if (ParameterStyle == SoapParameterStyle.Default) ParameterStyle = SoapParameterStyle.Wrapped;
			
			xmlImporter.IncludeTypes (Type);
			soapImporter.IncludeTypes (Type);

#if MOBILE || XAMMAC_4_5
			SoapExtensions = new SoapExtensionRuntimeConfig [2][];
#else
			SoapExtensions = SoapExtension.GetTypeExtensions (Type);
#endif
		}

		internal SoapServiceRoutingStyle RoutingStyle {
			get { return LogicalType.RoutingStyle; }
		}

		public override XmlReflectionImporter XmlImporter 
		{
			get { return xmlImporter; }
		}

		public override SoapReflectionImporter SoapImporter 
		{
			get { return soapImporter; }
		}
		
		public override string ProtocolName
		{
			get { return "Soap"; }
		}
		
		protected override MethodStubInfo CreateMethodStubInfo (TypeStubInfo parent, LogicalMethodInfo lmi, bool isClientProxy)
		{
			SoapMethodStubInfo res = null;
			object [] ats = lmi.GetCustomAttributes (typeof (SoapDocumentMethodAttribute));
			if (ats.Length == 0) ats = lmi.GetCustomAttributes (typeof (SoapRpcMethodAttribute));

			if (ats.Length == 0 && isClientProxy)
				return null;
			else if (ats.Length == 0)
				res = new SoapMethodStubInfo (parent, lmi, null, xmlImporter, soapImporter);
			else
				res = new SoapMethodStubInfo (parent, lmi, ats[0], xmlImporter, soapImporter);
				
			methods_byaction [res.Action] = res;
			return res;
		}
		
		public SoapMethodStubInfo GetMethodForSoapAction (string name)
		{
			return (SoapMethodStubInfo) methods_byaction [name.Trim ('"',' ')];
		}
	}

	internal class Soap12TypeStubInfo : SoapTypeStubInfo
	{
		public Soap12TypeStubInfo (LogicalTypeInfo logicalTypeInfo)
		: base (logicalTypeInfo)
		{
		}

		public override string ProtocolName
		{
			get { return "Soap12"; }
		}
	}
}
                                                                                                                                                                                                                                          <?xml version="1.0" encoding="utf-8"?>
<Type Name="IcmpV6Statistics" FullName="System.Net.NetworkInformation.IcmpV6Statistics">
  <TypeSignature Language="C#" Value="public abstract class IcmpV6Statistics" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit IcmpV6Statistics extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <since version=".NET 2.0" />
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>ICMPV6 is a set of error and informational messages for use with Internet Protocol version 6 (IPv6). This class is used by the <see cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetIcmpV6Statistics" /> method to return ICMPV6 traffic information.</para>
      <para>The properties in this class correlate to the Management Information Base objects for ICMPv6 defined in IETF RFC 2466. ICMPv6 is defined in RFC 2463.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides Internet Control Message Protocol for Internet Protocol version 6 (ICMPv6) statistical data for the local computer.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected IcmpV6Statistics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor can be called only by classes that derive from <see cref="T:System.Net.NetworkInformation.IcmpV6Statistics" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Net.NetworkInformation.IcmpV6Statistics" /> class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DestinationUnreachableMessagesReceived">
      <MemberSignature Language="C#" Value="public abstract long DestinationUnreachableMessagesReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 DestinationUnreachableMessagesReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A Destination Unreachable message can be sent to the computer that is the source of a packet for any of the following reasons: </para>
          <list type="bullet">
            <item>
              <para>The computer cannot find a route to the destination address.</para>
            </item>
            <item>
              <para>Communication with the destination address is administratively prohibited. For example, a firewall prevents delivery of packets to the destination.</para>
            </item>
            <item>
              <para>The destination address is unreachable.</para>
            </item>
            <item>
              <para>The destination port is unreachable. For example, there is no listener available for the packet's protocol.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) messages received because of a packet having an unreachable address in its destination.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DestinationUnreachableMessagesSent">
      <MemberSignature Language="C#" Value="public abstract long DestinationUnreachableMessagesSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 DestinationUnreachableMessagesSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A Destination Unreachable message can be sent to the computer that is the source of a packet for any of the following reasons: </para>
          <list type="bullet">
            <item>
              <para>The computer cannot find a route to the destination address.</para>
            </item>
            <item>
              <para>Communication with the destination address is administratively prohibited. For example, a firewall prevents delivery of packets to the destination.</para>
            </item>
            <item>
              <para>The destination address is unreachable.</para>
            </item>
            <item>
              <para>The destination port is unreachable. For example, there is no listener available for the packet's protocol.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) messages sent because of a packet having an unreachable address in its destination.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EchoRepliesReceived">
      <MemberSignature Language="C#" Value="public abstract long EchoRepliesReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 EchoRepliesReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Echo Request and Echo Reply messages allow a computer to request an ICMP response from a remote computer on a network. This functionality is often used to determine the validity of remote addresses.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Echo Reply messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EchoRepliesSent">
      <MemberSignature Language="C#" Value="public abstract long EchoRepliesSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 EchoRepliesSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Echo Request and Echo Reply messages allow a computer to request an ICMP response from a remote computer on a network. This functionality is often used to determine the validity of remote addresses.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Echo Reply messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EchoRequestsReceived">
      <MemberSignature Language="C#" Value="public abstract long EchoRequestsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 EchoRequestsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Echo Request and Echo Reply messages allow a computer to request an ICMP response from a remote computer on a network. This functionality is often used to determine the validity of remote addresses.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Echo Request messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EchoRequestsSent">
      <MemberSignature Language="C#" Value="public abstract long EchoRequestsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 EchoRequestsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Echo Request and Echo Reply messages allow a computer to request an ICMP response from a remote computer on a network. This functionality is often used to determine the validity of remote addresses.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Echo Request messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ErrorsReceived">
      <MemberSignature Language="C#" Value="public abstract long ErrorsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) error messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ErrorsSent">
      <MemberSignature Language="C#" Value="public abstract long ErrorsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) error messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MembershipQueriesReceived">
      <MemberSignature Language="C#" Value="public abstract long MembershipQueriesReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MembershipQueriesReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast routers send Group Membership Query messages to learn which groups have members on each of their attached physical networks. Host computers respond to a Group Membership Query message by sending a Group Membership Report for each multicast group joined by the host. A host computer can also send a Group Membership Report when it joins a new multicast group. Group Membership Reduction messages are sent when a host computer leaves a multicast group.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Group management Protocol (IGMP) Group Membership Query messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MembershipQueriesSent">
      <MemberSignature Language="C#" Value="public abstract long MembershipQueriesSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MembershipQueriesSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast routers send Group Membership Query messages to learn which groups have members on each of their attached physical networks. Host computers respond to a Group Membership Query message by sending a Group Membership Report for each multicast group joined by the host. A host computer can also send a Group Membership Report when it joins a new multicast group. Group Membership Reduction messages are sent when a host computer leaves a multicast group.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Group management Protocol (IGMP) Group Membership Query messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MembershipReductionsReceived">
      <MemberSignature Language="C#" Value="public abstract long MembershipReductionsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MembershipReductionsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast routers send Group Membership Query messages to learn which groups have members on each of their attached physical networks. Host computers respond to a Group Membership Query message by sending a Group Membership Report for each multicast group joined by the host. A host computer can also send a Group Membership Report when it joins a new multicast group. Group Membership Reduction messages are sent when a host computer leaves a multicast group.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Group Management Protocol (IGMP) Group Membership Reduction messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MembershipReductionsSent">
      <MemberSignature Language="C#" Value="public abstract long MembershipReductionsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MembershipReductionsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast routers send Group Membership Query messages to learn which groups have members on each of their attached physical networks. Host computers respond to a Group Membership Query message by sending a Group Membership Report for each multicast group joined by the host. A host computer can also send a Group Membership Report when it joins a new multicast group. Group Membership Reduction messages are sent when a host computer leaves a multicast group.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Group Management Protocol (IGMP) Group Membership Reduction messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MembershipReportsReceived">
      <MemberSignature Language="C#" Value="public abstract long MembershipReportsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MembershipReportsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast routers send Group Membership Query messages to learn which groups have members on each of their attached physical networks. Host computers respond to a Group Membership Query message by sending a Group Membership Report for each multicast group joined by the host. A host computer can also send a Group Membership Report when it joins a new multicast group. Group Membership Reduction messages are sent when a host computer leaves a multicast group.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Group Management Protocol (IGMP) Group Membership Report messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MembershipReportsSent">
      <MemberSignature Language="C#" Value="public abstract long MembershipReportsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MembershipReportsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast routers send Group Membership Query messages to learn which groups have members on each of their attached physical networks. Host computers respond to a Group Membership Query message by sending a Group Membership Report for each multicast group joined by the host. A host computer can also send a Group Membership Report when it joins a new multicast group. Group Membership Reduction messages are sent when a host computer leaves a multicast group.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Group Management Protocol (IGMP) Group Membership Report messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MessagesReceived">
      <MemberSignature Language="C#" Value="public abstract long MessagesReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MessagesReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>ICMPv6 messages are sent to communicate errors and information about packets sent using Internet Protocol version 6 (IPv6).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MessagesSent">
      <MemberSignature Language="C#" Value="public abstract long MessagesSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MessagesSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>ICMPv6 messages are sent to communicate errors and information about packets sent using Internet Protocol version 6 (IPv6).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NeighborAdvertisementsReceived">
      <MemberSignature Language="C#" Value="public abstract long NeighborAdvertisementsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NeighborAdvertisementsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Neighbor Discovery is a process whereby host computers and routers can determine the addresses for neighbors known to reside on shared links. Part of this discovery process is accomplished using ICMP messages called Neighbor Solicitations and Neighbor Advertisements. Neighbor Solicitation messages are sent to discover the link-layer address of a neighbor or to verify that a neighbor is still reachable via a cached link-layer address. A Neighbor Advertisement that contains address information is sent in response to a solicitation or to announce an address change.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Neighbor Advertisement messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NeighborAdvertisementsSent">
      <MemberSignature Language="C#" Value="public abstract long NeighborAdvertisementsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NeighborAdvertisementsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Neighbor Discovery is a process whereby host computers and routers can determine the addresses for neighbors known to reside on shared links. Part of this discovery process is accomplished using ICMP messages called Neighbor Solicitations and Neighbor Advertisements. Neighbor Solicitation messages are sent to discover the link-layer address of a neighbor or to verify that a neighbor is still reachable via a cached link-layer address. A Neighbor Advertisement that contains address information is sent in response to a solicitation or to announce an address change.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Neighbor Advertisement messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NeighborSolicitsReceived">
      <MemberSignature Language="C#" Value="public abstract long NeighborSolicitsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NeighborSolicitsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Neighbor Discovery is a process whereby host computers and routers can determine the addresses for neighbors known to reside on shared links. Part of this discovery process is accomplished using ICMP messages called Neighbor Solicitations and Neighbor Advertisements. Neighbor Solicitation messages are sent to discover the link-layer address of a neighbor or to verify that a neighbor is still reachable via a cached link-layer address. A Neighbor Advertisement that contains address information is sent in response to a solicitation or to announce an address change.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Neighbor Solicitation messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NeighborSolicitsSent">
      <MemberSignature Language="C#" Value="public abstract long NeighborSolicitsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NeighborSolicitsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Neighbor Discovery is a process whereby host computers and routers can determine the addresses for neighbors known to reside on shared links. Part of this discovery process is accomplished using ICMP messages called Neighbor Solicitations and Neighbor Advertisements. Neighbor Solicitation messages are sent to discover the link-layer address of a neighbor or to verify that a neighbor is still reachable via a cached link-layer address. A Neighbor Advertisement that contains address information is sent in response to a solicitation or to announce an address change.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Neighbor Solicitation messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PacketTooBigMessagesReceived">
      <MemberSignature Language="C#" Value="public abstract long PacketTooBigMessagesReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PacketTooBigMessagesReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A router sends a Packet Too Big message when a packet cannot be forwarded because it is larger than the maximum transmission unit (MTU) of the outgoing link.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Packet Too Big messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PacketTooBigMessagesSent">
      <MemberSignature Language="C#" Value="public abstract long PacketTooBigMessagesSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PacketTooBigMessagesSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A router sends a Packet Too Big message when a packet cannot be forwarded because it is larger than the maximum transmission unit (MTU) of the outgoing link.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Packet Too Big messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ParameterProblemsReceived">
      <MemberSignature Language="C#" Value="public abstract long ParameterProblemsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ParameterProblemsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Parameter Problem messages are sent when a host computer or router encounters problems while processing the contents of a packet header, such as encountering a invalid IPv6 option or a invalid Next Header type.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Parameter Problem messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ParameterProblemsSent">
      <MemberSignature Language="C#" Value="public abstract long ParameterProblemsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ParameterProblemsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Parameter Problem messages are sent when a host computer or router encounters problems while processing the contents of a packet header, such as encountering an invalid IPv6 option or an invalid Next Header type.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Parameter Problem messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RedirectsReceived">
      <MemberSignature Language="C#" Value="public abstract long RedirectsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RedirectsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Redirect messages are sent by routers to inform a host computer of a better route for a destination address.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Redirect messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RedirectsSent">
      <MemberSignature Language="C#" Value="public abstract long RedirectsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RedirectsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Redirect messages are sent by routers to inform a host computer of a better route for a destination address.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Redirect messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RouterAdvertisementsReceived">
      <MemberSignature Language="C#" Value="public abstract long RouterAdvertisementsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RouterAdvertisementsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Before a host computer can send IP datagrams beyond its directly attached subnet, it must discover the address of at least one router on that subnet. This discovery can be accomplished using ICMP messages called Router Advertisements and Router Solicitations. An Advertisement message is sent by a router periodically to announce its presence and the addresses of its interfaces. When a computer connects to a network, rather than waiting to receive Router Advertisements, it can send Router Solicitations to request that routers send their advertisements immediately.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Router Advertisement messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RouterAdvertisementsSent">
      <MemberSignature Language="C#" Value="public abstract long RouterAdvertisementsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RouterAdvertisementsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Before a host computer can send IP datagrams beyond its directly attached subnet, it must discover the address of at least one router on that subnet. This discovery can be accomplished using ICMP messages called Router Advertisements and Router Solicitations. An Advertisement message is sent by a router periodically to announce its presence and the addresses of its interfaces. When a computer connects to a network, rather than waiting to receive Router Advertisements, it can send Router Solicitations to request that routers send their advertisements immediately.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Router Advertisement messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RouterSolicitsReceived">
      <MemberSignature Language="C#" Value="public abstract long RouterSolicitsReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RouterSolicitsReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Before a host computer can send IP datagrams beyond its directly attached subnet, it must discover the address of at least one router on that subnet. This discovery can be accomplished using ICMP messages called Router Advertisements and Router Solicitations. An Advertisement message is sent by a router periodically to announce its presence and the addresses of its interfaces. When a computer connects to a network, rather than waiting to receive Router Advertisements, it can send Router Solicitations to request that routers send their advertisements immediately.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Router Solicitation messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RouterSolicitsSent">
      <MemberSignature Language="C#" Value="public abstract long RouterSolicitsSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RouterSolicitsSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Before a host computer can send IP datagrams beyond its directly attached subnet, it must discover the address of at least one router on that subnet. This discovery can be accomplished using ICMP messages called Router Advertisements and Router Solicitations. An Advertisement message is sent by a router periodically to announce its presence and the addresses of its interfaces. When a computer connects to a network, rather than waiting to receive Router Advertisements, it can send Router Solicitations to request that routers send their advertisements immediately.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Router Solicitation messages sent.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="TimeExceededMessagesReceived">
      <MemberSignature Language="C#" Value="public abstract long TimeExceededMessagesReceived { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TimeExceededMessagesReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A packet's Hop Limit determines how many times it can be forwarded before it is discarded. Each time a packet is forwarded, its Hop Limit value is decremented by one. When the Hop Limit reaches zero or when a router receives a packet with its Hop Limit set to zero, the packet is discarded and the source of the packet receives a Time Exceeded message indicating that the initial Hop Limit was too small or that the packet was caught in a routing loop.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Time Exceeded messages received.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="TimeExceededMessagesSent">
      <MemberSignature Language="C#" Value="public abstract long TimeExceededMessagesSent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TimeExceededMessagesSent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A packet's Hop Limit determines how many times it can be forwarded before it is discarded. Each time a packet is forwarded, its Hop Limit value is decremented by one. When the Hop Limit reaches zero or when a router receives a packet with its Hop Limit set to zero, the packet is discarded and the source of the packet receives a Time Exceeded message indicating that the initial Hop Limit was too small or that the packet was caught in a routing loop.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of Internet Control Message Protocol version 6 (ICMPv6) Time Exceeded messages sent.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      