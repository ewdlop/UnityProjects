//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

namespace System.Runtime
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Threading;
    using System.Transactions;

    // AsyncResult starts acquired; Complete releases.
    [Fx.Tag.SynchronizationPrimitive(Fx.Tag.BlocksUsing.ManualResetEvent, SupportsAsync = true, ReleaseMethod = "Complete")]
    abstract class TransactedAsyncResult : AsyncResult
    {
        IAsyncResult deferredTransactionalResult;
        TransactionSignalScope transactionContext;

        protected TransactedAsyncResult(AsyncCallback callback, object state)
            : base(callback, state)
        {
            SetBeforePrepareAsyncCompletionAction(BeforePrepareAsyncCompletion);
            SetCheckSyncValidationFunc(CheckSyncValidation);
        }

        protected override bool OnContinueAsyncCompletion(IAsyncResult result)
        {
            if (this.transactionContext != null && !this.transactionContext.Signal(result))
            {
                // The TransactionScope isn't cleaned up yet and can't be done on this thread.  Must defer
                // the callback (which is likely to attempt to commit the transaction) until later.
                return false;
            }

            this.transactionContext = null;
            return true;
        }

        bool CheckSyncValidation(IAsyncResult result)
        {
            if (result.CompletedSynchronously)
            {
                // Once we pass the check, we know that we own forward progress, so transactionContext is correct. Verify its state.
                if (this.transactionContext != null)
                {
                    if (this.transactionContext.State != TransactionSignalState.Completed)
                    {
                        ThrowInvalidAsyncResult("Check/SyncContinue cannot be called from within the PrepareTransactionalCall using block.");
                    }
                    else if (this.transactionContext.IsSignalled)
                    {
                        // This is most likely to happen when result.CompletedSynchronously registers differently here and in the callback, which
                        // is the fault of 'result'.
                        ThrowInvalidAsyncResult(result);
                    }
                }
            }
            else if (object.ReferenceEquals(result, this.deferredTransactionalResult))
            {
                // The transactionContext may not be current if forward progress has been made via the callback. Instead,
                // use deferredTransactionalResult to see if we are supposed to execute a post-transaction callback.
                //
                // Once we pass the check, we know that we own forward progress, so transactionContext is correct. Verify its state.
                if (this.transactionContext == null || !this.transactionContext.IsSignalled)
                {
                    ThrowInvalidAsyncResult(result);
                }
                this.deferredTransactionalResult = null;
            }
            else
            {
                return false;
            }

            this.transactionContext = null;
            return true;
        }

        void BeforePrepareAsyncCompletion()
        {
            if (this.transactionContext != null)
            {
                // It might be an old, leftover one, if an exception was thrown within the last using (PrepareTransactionalCall()) block.
                if (this.transactionContext.IsPotentiallyAbandoned)
                {
                    this.transactionContext = null;
                }
                else
                {
                    this.transactionContext.Prepared();
                }
            }
        }

        protected IDisposable PrepareTransactionalCall(Transaction transaction)
        {
            if (this.transactionContext != null && !this.transactionContext.IsPotentiallyAbandoned)
            {
                ThrowInvalidAsyncResult("PrepareTransactionalCall should only be called as the object of non-nested using statements. If the Begin succeeds, Check/SyncContinue must be called before another PrepareTransactionalCall.");
            }

            return this.transactionContext = transaction == null ? null : new TransactionSignalScope(this, transaction);
        }

        enum TransactionSignalState
        {
            Ready = 0,
            Prepared,
            Completed,
            Abandoned,
        }

        class TransactionSignalScope : SignalGate<IAsyncResult>, IDisposable
        {
            TransactionScope transactionScope;
            TransactedAsyncResult parent;

            public TransactionSignalScope(TransactedAsyncResult result, Transaction transaction)
            {
                Fx.Assert(transaction != null, "Null Transaction provided to AsyncResult.TransactionSignalScope.");
                this.parent = result;
                this.transactionScope = TransactionHelper.CreateTransactionScope(transaction);
            }

            public TransactionSignalState State { get; private set; }

            public bool IsPotentiallyAbandoned
            {
                get
                {
                    return State == TransactionSignalState.Abandoned || (State == TransactionSignalState.Completed && !IsSignalled);
                }
            }

            public void Prepared()
            {
                if (State != TransactionSignalState.Ready)
                {
                    AsyncResult.ThrowInvalidAsyncResult("PrepareAsyncCompletion should only be called once per PrepareTransactionalCall.");
                }
                State = TransactionSignalState.Prepared;
            }

            void IDisposable.Dispose()
            {
                if (State == TransactionSignalState.Ready)
                {
                    State = TransactionSignalState.Abandoned;
                }
                else if (State == TransactionSignalState.Prepared)
                {
                    State = TransactionSignalState.Completed;
                }
                else
                {
                    AsyncResult.ThrowInvalidAsyncResult("PrepareTransactionalCall should only be called in a using. Dispose called multiple times.");
                }

                try
                {
                    TransactionHelper.CompleteTransactionScope(ref this.transactionScope);
                }
                catch (Exception exception)
                {
                    if (Fx.IsFatal(exception))
                    {
                        throw;
                    }

                    // Complete and Dispose are not expected to throw.  If they do it can mess up the AsyncResult state machine.
                    throw Fx.Exception.AsError(new InvalidOperationException(SRCore.AsyncTransactionException));
                }

                // This will release the callback to run, or tell us that we need to defer the callback to Check/SyncContinue.
                //
                // It's possible to avoid this Interlocked when CompletedSynchronously is true, but we have no way of knowing that
                // from here, and adding a way would add complexity to the AsyncResult transactional calling pattern. This
                // unnecessary Interlocked only happens when: PrepareTransactionalCall is called with a non-null transaction,
                // PrepareAsyncCompletion is reached, and the operation completes synchronously or with an exception.
                IAsyncResult result;
                if (State == TransactionSignalState.Completed && Unlock(out result))
                {
                    if (this.parent.deferredTransactionalResult != null)
                    {
                        AsyncResult.ThrowInvalidAsyncResult(this.parent.deferredTransactionalResult);
                    }
                    this.parent.deferredTransactionalResult = result;
                }
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                         H…Àt'HƒÄ[A^ÃèÝÿÿÇ    èC< „ÀuH‰ßL‰öè$q è< 1ÀHƒÄ[A^ÃD  UAWAVSPI‰ÎH‰óH…öt?HkÿH‰èHƒÈH…Øu/I‰ÿ1ÉL‰÷H‰ÖH‰ÚèÛùÿÿH…Àt0H…Åu2I‰1í‰èHƒÄ[A^A_]Ã½   èÅ; „ÀuåH‰ßL‰öèFq ½   ëÓH=w- Hü- ¾I  1ÉE1ÀèÂ5 fÆ
:	 Ã„     Æú9	  Ã„     HƒìH‰ç1öº   èm° °†EJ „ÀtH=:J è¥  H‹$H‹D$HJ H‰ÖfHNHFH‹6H9Öuð1ÒH…ÉHHÊH‰$H…ÀHIÐH‰T$ÆðI  H‹$HƒÄÃ€    HƒìH‰ç1öº   èí¯ °†ÅI „ÀtH=ºI è%  H‹$H‹D$H…I H‰ÖfHNHFH‹6H9Öuð1ÒH…ÉHHÊH‰$H…ÀHIÐH‰T$ÆpI  H‹D$HƒÄÃfD  ¸   Ãf.„     ¸   Ãf.„     H‰øÃfff.„     USP1íH»ÿÿÿÿÿÿÿ H!ût-H=Å8	 H‰ÞèmúÿÿH9ØuH=±8	 H‰ÞèYôÿÿ1íHƒ8@—Å‰èHƒÄ[]ÃfD  SH»ÿÿÿÿÿÿÿ H!ûtH=y8	 H‰Þè!úÿÿH9Øt1À[Ã1À[ÃH=]8	 H‰ÞèôÿÿH‹ HÁè[Ãfff.„     AWAVATSPI‰ÏH‰ÐH…Òº   HEÐH‰ÐHÈs"Hç	 H‹0H=F, 1Û1ÀL‰ùè±ü éû   I‰öI‰øH‰ÐIƒÿ	rIOÿL…ù…  HÑL‰øH÷ØH!ÈIÿ   w"H=   wH=   w9HƒÀHÁèH…Àu\éì   I¸À IÀ0 L‰ÆL‰ùè0  H‰ÃIƒÿ	syé   H½ÐJþH‰ÆHÓî¿ÿÿÿÿÓçƒæ÷×!øƒøHD–ðHƒØÿH…À„•   Hƒø6ƒ¨   I‰ÄIÁä
K&K‹&H…ÉtBHAÿH‰H‹DËH‹\Ë K‹D&I†Ø  Iƒÿ	rIƒÇÿI!ß…‚   H‰ØHƒÄ[A\A^A_ÃL‰÷H‰ÞL‰ÂH‰ÁèA  „ÀtH‹ë¤1ÛIƒÿ	sÂëÍH=­* è~ èm1 H=, H˜, ¾¡   1ÉE1Àè02 H=ö+ H“, ¾¢   A¸6   H‰Áè2 H=+ H“+ ¾D   E1ÀL‰ùèñ1 UAWAVAUATSPHiÿH…Í…¬  I‰ÌI‰þH‹HHÿH…Á…³  I‰ÕHÑH‰ÂH÷ÚH!Ê1ÛL9àIBÜHÃHÓL9ës#HØ	 H‹0H=Ö/ 1ÀH‰ÚL‰áè¡ú é  I‰÷H¢	 H‹0H‰ßè·å H…À„ó   I‹HJÿH…Á…P  H4H‰÷H!ïI)üH…ÿLDçIôI…ì…M  I…Ì…a  K,H9Á‚q  I‰ÀIØL9Á‡}  L‰åH)ÕL‰mH‰E H‰]H…Û„z  °A††h  „ÀtI¾h  è  I‹F8H=   ƒn  L½ëI9F0teHHI‰N8H‰EI‹NH‰,ÁAÆF@ IƒFHI‹FXHØI‰FXI‹N`H9ÁHGÁI‰F`KƒDîhI_I_AÆ†h   ëE1äL‰àHƒÄ[A\A]A^A_]ÃI~HÁàIFº   H‰Æè}L IF0 @  I‹F8éqÿÿÿH=À- HC. ¾U   1ÉE1Àè0 H=^( è³{ è/ H=’- H™. ¾d   1ÉE1Àèá/ H=u- H¦. ¾j   1ÉE1ÀèÄ/ H=X- H®. ¾k   1ÉE1Àè§/ H=;- H·. ¾l   I‰ÀèŒ/ H= - Hº. ¾m   èt/ H=* HŠ* ¾R  1ÉE1ÀèW/ H=ë, HÇ. ¾+   A¸   H‰Áè6/ fD  AWAVATSPI‰ÌI‰ÖH‰óI‰ÿHƒ~ „'  I· Ø  L‰÷L‰úL‰áè  H…À„  L‹@M…À„Õ  Iƒøv*HK JÀHƒÂH9Ê†¹   JÃHƒÁ HPH9Ñ†¤   1ÒD‰Æ)ÖH‰ÑH÷ÑLÁHƒæt$H÷Þf.„      H‹|ÐH‰|Ó HƒÂHƒÆuìHƒù‚Y  fH‹LÐH‰LÓ H‹LÐH‰LÓ(H‹LÐ H‰LÓ0H‹LÐ(H‰LÓ8H‹LÐ0H‰LÓ@H‹LÐ8H‰LÓHH‹LÐ@H‰LÓPH‹LÐHH‰LÓXHƒÂI9Ðu§éù   L‰ÂHƒâüHzüH‰ùHÁéHƒÁ‰ÎƒæHƒÿs1ÿH…ö…Ž   é¿   ¿   H)ÏH>HƒÁÿ1ÿf.