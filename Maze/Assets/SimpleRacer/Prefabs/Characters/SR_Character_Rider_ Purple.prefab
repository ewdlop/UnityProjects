e number of characters in the pattern, or -1 if null-terminated.
 * @param status A pointer to an UErrorCode to receive any errors
 * @return A pointer to a UDateFormat to use for formatting dates and times, or 0 if
 * an error occurred.
 * @stable ICU 2.0
 */
U_STABLE UDateFormat* U_EXPORT2 
udat_open(UDateFormatStyle  timeStyle,
          UDateFormatStyle  dateStyle,
          const char        *locale,
          const UChar       *tzID,
          int32_t           tzIDLength,
          const UChar       *pattern,
          int32_t           patternLength,
          UErrorCode        *status);


/**
* Close a UDateFormat.
* Once closed, a UDateFormat may no longer be used.
* @param format The formatter to close.
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_close(UDateFormat* format);


/* Dont hide UDateFormatBooleanAttribute type with #ifndef U_HIDE_DRAFT_API, needed by virtual methods */
/* Also don't hide UDAT_BOOLEAN_ATTRIBUTE_COUNT, needed by template class EnumSet<UDateFormatBooleanAttribute,...> */
/**
 * DateFormat boolean attributes
 * 
 * @draft ICU 53
 */
typedef enum UDateFormatBooleanAttribute {
#ifndef U_HIDE_DRAFT_API
   /**
     * indicates whether whitespace is allowed. Includes trailing dot tolerance.
     * @draft ICU 53
     */
    UDAT_PARSE_ALLOW_WHITESPACE = 0,
    /**
     * indicates tolerance of numeric data when String data may be assumed. eg: UDAT_YEAR_NAME_FIELD,
     * 		UDAT_STANDALONE_MONTH_FIELD, UDAT_DAY_OF_WEEK_FIELD
     * @draft ICU 53
     */
    UDAT_PARSE_ALLOW_NUMERIC = 1,
    /**
     * indicates tolerance of a partial literal match
     * @draft ICU 53
     */
    UDAT_PARSE_PARTIAL_MATCH = 2,
    /**  
     * indicates tolerance of pattern mismatch between input data and specified format pattern. 
     * e.g. accepting "September" for a month pattern of MMM ("Sep")   
     * @draft ICU 53
     */ 
    UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
#endif /* U_HIDE_DRAFT_API */
    /**
     * count boolean date format constants
     * @draft ICU 53
     */
    UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4
} UDateFormatBooleanAttribute;

#ifndef U_HIDE_DRAFT_API
/**
 * Get a boolean attribute associated with a UDateFormat.
 * An example would be a true value for a key of UDAT_PARSE_ALLOW_WHITESPACE indicating allowing whitespace leniency.
 * If the formatter does not understand the attribute, -1 is returned.
 * @param fmt The formatter to query.
 * @param attr The attribute to query; e.g. UDAT_PARSE_ALLOW_WHITESPACE.
 * @param status A pointer to an UErrorCode to receive any errors
 * @return The value of attr.
 * @draft ICU 53
 */
U_DRAFT UBool U_EXPORT2
udat_getBooleanAttribute(const UDateFormat* fmt, UDateFormatBooleanAttribute attr, UErrorCode* status);

/**
 * Set a boolean attribute associated with a UDateFormat.
 * An example of a boolean attribute is parse leniency control.  If the formatter does not understand
 * the attribute, the call is ignored.
 * @param fmt The formatter to set.
 * @param attr The attribute to set; one of UDAT_PARSE_ALLOW_WHITESPACE or UDAT_PARSE_ALLOW_NUMERIC
 * @param newValue The new value of attr.
 * @param status A pointer to an UErrorCode to receive any errors
 * @draft ICU 53
 */
U_DRAFT void U_EXPORT2
udat_setBooleanAttribute(UDateFormat *fmt, UDateFormatBooleanAttribute attr, UBool newValue, UErrorCode* status);

#endif /* U_HIDE_DRAFT_API */



#if U_SHOW_CPLUSPLUS_API

U_NAMESPACE_BEGIN

/**
 * \class LocalUDateFormatPointer
 * "Smart pointer" class, closes a UDateFormat via udat_close().
 * For most methods see the LocalPointerBase base class.
 *
 * @see LocalPointerBase
 * @see LocalPointer
 * @stable ICU 4.4
 */
U_DEFINE_LOCAL_OPEN_POINTER(LocalUDateFormatPointer, UDateFormat, udat_close);

U_NAMESPACE_END

#endif

/**
 * Open a copy of a UDateFormat.
 * This function performs a deep copy.
 * @param fmt The format to copy
 * @param status A pointer to an UErrorCode to receive any errors.
 * @return A pointer to a UDateFormat identical to fmt.
 * @stable ICU 2.0
 */
U_STABLE UDateFormat* U_EXPORT2 
udat_clone(const UDateFormat *fmt,
       UErrorCode *status);

/**
* Format a date using an UDateFormat.
* The date will be formatted using the conventions specified in {@link #udat_open }
* @param format The formatter to use
* @param dateToFormat The date to format
* @param result A pointer to a buffer to receive the formatted number.
* @param resultLength The maximum size of result.
* @param position A pointer to a UFieldPosition.  On input, position->field
* is read.  On output, position->beginIndex and position->endIndex indicate
* the beginning and ending indices of field number position->field, if such
* a field exists.  This parameter may be NULL, in which case no field
* position data is returned.
* @param status A pointer to an UErrorCode to receive any errors
* @return The total buffer size needed; if greater than resultLength, the output was truncated.
* @see udat_parse
* @see UFieldPosition
* @stable ICU 2.0
*/
U_STABLE int32_t U_EXPORT2 
udat_format(    const    UDateFormat*    format,
                        UDate           dateToFormat,
                        UChar*          result,
                        int32_t         resultLength,
                        UFieldPosition* position,
                        UErrorCode*     status);

/**
* Parse a string into an date/time using a UDateFormat.
* The date will be parsed using the conventions specified in {@link #udat_open }.
* <P>
* Note that the normal date formats associated with some calendars - such
* as the Chinese lunar calendar - do not specify enough fields to enable
* dates to be parsed unambiguously. In the case of the Chinese lunar
* calendar, while the year within the current 60-year cycle is specified,
* the number of such cycles since the start date of the calendar (in the
* UCAL_ERA field of the UCalendar object) is not normally part of the format,
* and parsing may assume the wrong era. For cases such as this it is
* recommended that clients parse using udat_parseCalendar with the UCalendar
* passed in set to the current date, or to a date within the era/cycle that
* should be assumed if absent in the format.
*
* @param format The formatter to use.
* @param text The text to parse.
* @param textLength The length of text, or -1 if null-terminated.
* @param parsePos If not 0, on input a pointer to an integer specifying the offset at which
* to begin parsing.  If not 0, on output the offset at which parsing ended.
* @param status A pointer to an UErrorCode to receive any errors
* @return The value of the parsed date/time
* @see udat_format
* @stable ICU 2.0
*/
U_STABLE UDate U_EXPORT2 
udat_parse(const    UDateFormat*    format,
           const    UChar*          text,
                    int32_t         textLength,
                    int32_t         *parsePos,
                    UErrorCode      *status);

/**
* Parse a string into an date/time using a UDateFormat.
* The date will be parsed using the conventions specified in {@link #udat_open }.
* @param format The formatter to use.
* @param calendar A calendar set on input to the date and time to be used for
*                 missing values in the date/time string being parsed, and set
*                 on output to the parsed date/time. When the calendar type is
*                 different from the internal calendar held by the UDateFormat
*                 instance, the internal calendar will be cloned to a work
*                 calendar set to the same milliseconds and time zone as this
*                 calendar parameter, field values will be parsed based on the
*                 work calendar, then the result (milliseconds and time zone)
*                 will be set in this calendar.
* @param text The text to parse.
* @param textLength The length of text, or -1 if null-terminated.
* @param parsePos If not 0, on input a pointer to an integer specifying the offset at which
* to begin parsing.  If not 0, on output the offset at which parsing ended.
* @param status A pointer to an UErrorCode to receive any errors
* @see udat_format
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_parseCalendar(const    UDateFormat*    format,
                            UCalendar*      calendar,
                   const    UChar*          text,
                            int32_t         textLength,
                            int32_t         *parsePos,
                            UErrorCode      *status);

/**
* Determine if an UDateFormat will perform lenient parsing.
* With lenient parsing, the parser may use heuristics to interpret inputs that do not
* precisely match the pattern. With strict parsing, inputs must match the pattern.
* @param fmt The formatter to query
* @return TRUE if fmt is set to perform lenient parsing, FALSE otherwise.
* @see udat_setLenient
* @stable ICU 2.0
*/
U_STABLE UBool U_EXPORT2 
udat_isLenient(const UDateFormat* fmt);

/**
* Specify whether an UDateFormat will perform lenient parsing.
* With lenient parsing, the parser may use heuristics to interpret inputs that do not
* precisely match the pattern. With strict parsing, inputs must match the pattern.
* @param fmt The formatter to set
* @param isLenient TRUE if fmt should perform lenient parsing, FALSE otherwise.
* @see dat_isLenient
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_setLenient(    UDateFormat*    fmt,
                    UBool          isLenient);

/**
* Get the UCalendar associated with an UDateFormat.
* A UDateFormat uses a UCalendar to convert a raw value to, for example,
* the day of the week.
* @param fmt The formatter to query.
* @return A pointer to the UCalendar used by fmt.
* @see udat_setCalendar
* @stable ICU 2.0
*/
U_STABLE const UCalendar* U_EXPORT2 
udat_getCalendar(const UDateFormat* fmt);

/**
* Set the UCalendar associated with an UDateFormat.
* A UDateFormat uses a UCalendar to convert a raw value to, for example,
* the day of the week.
* @param fmt The formatter to set.
* @param calendarToSet A pointer to an UCalendar to be used by fmt.
* @see udat_setCalendar
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_setCalendar(            UDateFormat*    fmt,
                    const   UCalendar*      calendarToSet);

/**
* Get the UNumberFormat associated with an UDateFormat.
* A UDateFormat uses a UNumberFormat to format numbers within a date,
* for example the day number.
* @param fmt The formatter to query.
* @return A pointer to the UNumberFormat used by fmt to format numbers.
* @see udat_setNumberFormat
* @stable ICU 2.0
*/
U_STABLE const UNumberFormat* U_EXPORT2 
udat_getNumberFormat(const UDateFormat* fmt);

/**
* Set the UNumberFormat associated with an UDateFormat.
* A UDateFormat uses a UNumberFormat to format numbers within a date,
* for example the day number.
* @param fmt The formatter to set.
* @param numberFormatToSet A pointer to the UNumberFormat to be used by fmt to format numbers.
* @see udat_getNumberFormat
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_setNumberFormat(            UDateFormat*    fmt,
                        const   UNumberFormat*  numberFormatToSet);

/**
* Get a locale for which date/time formatting patterns are available.
* A UDateFormat in a locale returned by this function will perform the correct
* formatting and parsing for the locale.
* @param localeIndex The index of the desired locale.
* @return A locale for which date/time formatting patterns are available, or 0 if none.
* @see udat_countAvailable
* @stable ICU 2.0
*/
U_STABLE const char* U_EXPORT2 
udat_getAvailable(int32_t localeIndex);

/**
* Determine how many locales have date/time  formatting patterns available.
* This function is most useful as determining the loop ending condition for
* calls to {@link #udat_getAvailable }.
* @return The number of locales for which date/time formatting patterns are available.
* @see udat_getAvailable
* @stable ICU 2.0
*/
U_STABLE int32_t U_EXPORT2 
udat_countAvailable(void);

/**
* Get the year relative to which all 2-digit years are interpreted.
* For example, if the 2-digit start year is 2100, the year 99 will be
* interpreted as 2199.
* @param fmt The formatter to query.
* @param status A pointer to an UErrorCode to receive any errors
* @return The year relative to which all 2-digit years are interpreted.
* @see udat_Set2DigitYearStart
* @stable ICU 2.0
*/
U_STABLE UDate U_EXPORT2 
udat_get2DigitYearStart(    const   UDateFormat     *fmt,
                                    UErrorCode      *status);

/**
* Set the year relative to which all 2-digit years will be interpreted.
* For example, if the 2-digit start year is 2100, the year 99 will be
* interpreted as 2199.
* @param fmt The formatter to set.
* @param d The year relative to which all 2-digit years will be interpreted.
* @param status A pointer to an UErrorCode to receive any errors
* @see udat_Set2DigitYearStart
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_set2DigitYearStart(    UDateFormat     *fmt,
                            UDate           d,
                            UErrorCode      *status);

/**
* Extract the pattern from a UDateFormat.
* The pattern will follow the pattern syntax rules.
* @param fmt The formatter to query.
* @param localized TRUE if the pattern should be localized, FALSE otherwise.
* @param result A pointer to a buffer to receive the pattern.
* @param resultLength The maximum size of result.
* @param status A pointer to an UErrorCode to receive any errors
* @return The total buffer size needed; if greater than resultLength, the output was truncated.
* @see udat_applyPattern
* @stable ICU 2.0
*/
U_STABLE int32_t U_EXPORT2 
udat_toPattern(    const   UDateFormat     *fmt,
                        UBool          localized,
                        UChar           *result,
                        int32_t         resultLength,
                        UErrorCode      *status);

/**
* Set the pattern used by an UDateFormat.
* The pattern should follow the pattern syntax rules.
* @param format The formatter to set.
* @param localized TRUE if the pattern is localized, FALSE otherwise.
* @param pattern The new pattern
* @param patternLength The length of pattern, or -1 if null-terminated.
* @see udat_toPattern
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_applyPattern(            UDateFormat     *format,
                            UBool          localized,
                    const   UChar           *pattern,
                            int32_t         patternLength);

/** 
 * The possible types of date format symbols 
 * @stable ICU 2.6
 */
typedef enum UDateFormatSymbolType {
    /** The era names, for example AD */
    UDAT_ERAS,
    /** The month names, for example February */
    UDAT_MONTHS,
    /** The short month names, for example Feb. */
    UDAT_SHORT_MONTHS,
    /** The CLDR-style format "wide" weekday names, for example Monday */
    UDAT_WEEKDAYS,
    /**
     * The CLDR-style format "abbreviated" (not "short") weekday names, for example "Mon."
     * For the CLDR-style format "short" weekday names, use UDAT_SHORTER_WEEKDAYS.
     */
    UDAT_SHORT_WEEKDAYS,
    /** The AM/PM names, for example AM */
    UDAT_AM_PMS,
    /** The localized characters */
    UDAT_LOCALIZED_CHARS,
    /** The long era names, for example Anno Domini */
    UDAT_ERA_NAMES,
    /** The narrow month names, for example F */
    UDAT_NARROW_MONTHS,
    /** The CLDR-style format "narrow" weekday names, for example "M" */
    UDAT_NARROW_WEEKDAYS,
    /** Standalone context versions of months */
    UDAT_STANDALONE_MONTHS,
    UDAT_STANDALONE_SHORT_MONTHS,
    UDAT_STANDALONE_NARROW_MONTHS,
    /** The CLDR-style stand-alone "wide" weekday names */
    UDAT_STANDALONE_WEEKDAYS,
    /**
     * The CLDR-style stand-alone "abbreviated" (not "short") weekday names.
     * For the CLDR-style stand-alone "short" weekday names, use UDAT_STANDALONE_SHORTER_WEEKDAYS.
     */
    UDAT_STANDALONE_SHORT_WEEKDAYS,
    /** The CLDR-style stand-alone "narrow" weekday names */
    UDAT_STANDALONE_NARROW_WEEKDAYS,
    /** The quarters, for example 1st Quarter */
    UDAT_QUARTERS,
    /** The short quarter names, for example Q1 */
    UDAT_SHORT_QUARTERS,
    /** Standalone context versions of quarters */
    UDAT_STANDALONE_QUARTERS,
    UDAT_STANDALONE_SHORT_QUARTERS,
    /**
     * The CLDR-style short weekday names, e.g. "Su", Mo", etc.
     * These are named "SHORTER" to contrast with the constants using _SHORT_
     * above, which actually get the CLDR-style *abbreviated* versions of the
     * corresponding names.
     * @stable ICU 51
     */
    UDAT_SHORTER_WEEKDAYS,
    /**
     * Standalone version of UDAT_SHORTER_WEEKDAYS.
     * @stable ICU 51
     */
    UDAT_STANDALONE_SHORTER_WEEKDAYS
} UDateFormatSymbolType;

struct UDateFormatSymbols;
/** Date format symbols.
 *  For usage in C programs.
 *  @stable ICU 2.6
 */
typedef struct UDateFormatSymbols UDateFormatSymbols;

/**
* Get the symbols associated with an UDateFormat.
* The symbols are what a UDateFormat uses to represent locale-specific data,
* for example month or day names.
* @param fmt The formatter to query.
* @param type The type of symbols to get.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
* UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
* @param symbolIndex The desired symbol of type type.
* @param result A pointer to a buffer to receive the pattern.
* @param resultLength The maximum size of result.
* @param status A pointer to an UErrorCode to receive any errors
* @return The total buffer size needed; if greater than resultLength, the output was truncated.
* @see udat_countSymbols
* @see udat_setSymbols
* @stable ICU 2.0
*/
U_STABLE int32_t U_EXPORT2 
udat_getSymbols(const   UDateFormat             *fmt,
                        UDateFormatSymbolType   type,
                        int32_t                 symbolIndex,
                        UChar                   *result,
                        int32_t                 resultLength,
                        UErrorCode              *status);

/**
* Count the number of particular symbols for an UDateFormat.
* This function is most useful as for detemining the loop termination condition
* for calls to {@link #udat_getSymbols }.
* @param fmt The formatter to query.
* @param type The type of symbols to count.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
* UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
* @return The number of symbols of type type.
* @see udat_getSymbols
* @see udat_setSymbols
* @stable ICU 2.0
*/
U_STABLE int32_t U_EXPORT2 
udat_countSymbols(    const    UDateFormat                *fmt,
                            UDateFormatSymbolType    type);

/**
* Set the symbols associated with an UDateFormat.
* The symbols are what a UDateFormat uses to represent locale-specific data,
* for example month or day names.
* @param format The formatter to set
* @param type The type of symbols to set.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
* UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
* @param symbolIndex The index of the symbol to set of type type.
* @param value The new value
* @param valueLength The length of value, or -1 if null-terminated
* @param status A pointer to an UErrorCode to receive any errors
* @see udat_getSymbols
* @see udat_countSymbols
* @stable ICU 2.0
*/
U_STABLE void U_EXPORT2 
udat_setSymbols(    UDateFormat             *format,
                    UDateFormatSymbolType   type,
                    int32_t                 symbolIndex,
                    UChar                   *value,
                    int32_t                 valueLength,
                    UErrorCode              *status);

/**
 * Get the locale for this date format object.
 * You can choose between valid and actual locale.
 * @param fmt The formatter to get the locale from
 * @param type type of the locale we're looking for (valid or actual) 
 * @param status error code for the operation
 * @return the locale name
 * @stable ICU 2.8
 */
U_STABLE const char* U_EXPORT2
udat_getLocaleByType(const UDateFormat *fmt,
                     ULocDataLocaleType type,
                     UErrorCode* status); 

/**
 * Set a particular UDisplayContext value in the formatter, such as
 * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
 * @param fmt The formatter for which to set a UDisplayContext value.
 * @param value The UDisplayContext value to set.
 * @param status A pointer to an UErrorCode to receive any errors
 * @stable ICU 51
 */
U_DRAFT void U_EXPORT2
udat_setContext(UDateFormat* fmt, UDisplayContext value, UErrorCode* status);

#ifndef U_HIDE_DRAFT_API
/**
 * Get the formatter's UDisplayContext value for the specified UDisplayContextType,
 * such as UDISPCTX_TYPE_CAPITALIZATION.
 * @param fmt The formatter to query.
 * @param type The UDisplayContextType whose value to return
 * @param status A pointer to an UErrorCode to receive any errors
 * @return The UDisplayContextValue for the specified type.
 * @draft ICU 53
 */
U_DRAFT UDisplayContext U_EXPORT2
udat_getContext(const UDateFormat* fmt, UDisplayContextType type, UErrorCode* status);

#endif  /* U_HIDE_DRAFT_API */

#ifndef U_HIDE_INTERNAL_API
/**
* Extract the date pattern from a UDateFormat set for relative date formatting.
* The pattern will follow the pattern syntax rules.
* @param fmt The formatter to query.
* @param result A pointer to a buffer to receive the pattern.
* @param resultLength The maximum size of result.
* @param status A pointer to a UErrorCode to receive any errors
* @return The total buffer size needed; if greater than resultLength, the output was truncated.
* @see udat_applyPatternRelative
* @internal ICU 4.2 technology preview
*/
U_INTERNAL int32_t U_EXPORT2 
udat_toPatternRelativeDate(const UDateFormat *fmt,
                           UChar             *result,
                           int32_t           resultLength,
                           UErrorCode        *status);

/**
* Extract the time pattern from a UDateFormat set for relative date formatting.
* The pattern will follow the pattern syntax rules.
* @param fmt The formatter to query.
* @param result A pointer to a buffer to receive the pattern.
* @param resultLength The maximum size of result.
* @param status A pointer to a UErrorCode to receive any errors
* @return The total buffer size needed; if greater than resultLength, the output was truncated.
* @see udat_applyPatternRelative
* @internal ICU 4.2 technology preview
*/
U_INTERNAL int32_t U_EXPORT2 
udat_toPatternRelativeTime(const UDateFormat *fmt,
                           UChar             *result,
                           int32_t           resultLength,
                           UErrorCode        *status);

/**
* Set the date & time patterns used by a UDateFormat set for relative date formatting.
* The patterns should follow the pattern syntax rules.
* @param format The formatter to set.
* @param datePattern The new date pattern
* @param datePatternLength The length of datePattern, or -1 if null-terminated.
* @param timePattern The new time pattern
* @param timePatternLength The length of timePattern, or -1 if null-terminated.
* @param status A pointer to a UErrorCode to receive any errors
* @see udat_toPatternRelativeDate, udat_toPatternRelativeTime
* @internal ICU 4.2 technology preview
*/
U_INTERNAL void U_EXPORT2 
udat_applyPatternRelative(UDateFormat *format,
                          const UChar *datePattern,
                          int32_t     datePatternLength,
                          const UChar *timePattern,
                          int32_t     timePatternLength,
                          UErrorCode  *status);

/**
 * @internal
 * @see udat_open
 */
typedef UDateFormat* (U_EXPORT2 *UDateFormatOpener) (UDateFormatStyle  timeStyle,
                                                    UDateFormatStyle  dateStyle,
                                                    const char        *locale,
                                                    const UChar       *tzID,
                                                    int32_t           tzIDLength,
                                                    const UChar       *pattern,
                                                    int32_t           patternLength,
                                                    UErrorCode        *status);

/**
 * Register a provider factory
 * @internal ICU 49
 */
U_INTERNAL void U_EXPORT2
udat_registerOpener(UDateFormatOpener opener, UErrorCode *status);

/**
 * Un-Register a provider factory
 * @internal ICU 49
 */
U_INTERNAL UDateFormatOpener U_EXPORT2
udat_unregisterOpener(UDateFormatOpener opener, UErrorCode *status);
#endif  /* U_HIDE_INTERNAL_API */


#endif /* #if !UCONFIG_NO_FORMATTING */

#endif
                                                                                                                                                                        üÿ{¢k√2‚W:°¯∑]ı£rtìºïj≥4ˇéF¨h≤|∞»óB+Œ≠‚%ZXCo ib)Pâ=Õ!s5ï”◊Å¸‰Ï*ø]C´æ_Na≈`Ë¢º•¡7ZÚÒ»[Õøu9∂Œ!7írTø≠Mj™ÚÅ#¢üa˘c&:Ù}1Àa"ö≤?Ï‰Ù≠IZp	*b'ÏwåˆÂ”£ïˆdPÁŒée—ú∫qí◊ÔÍ˙Æ5ıM2å„&è)
 uˆÒËYÍ–=·®–Í —æ¿›¬ˆO^4]¬ƒ⁄r*°∞B‹SŒF∏b?KHGêà¬GWÃÈéåŸ°õ≠O-k,Õ<!Y{<EojaÌn0vB‰∑QRD«ÑFv(6˛§€Sç∂„≥C¡äd-∏Ú˛ë¬ö“©ﬂ≈G%^Ø2QK¶k÷©ı>§ÿˇÄ˝◊¡H»HäQèPZê§C[ˆ—lP™∑]Ÿª«
JA%˚¸z◊%7î¯©:*ŒÒf˚1$Gç j)˘j)T¿í˛àÃ˘à(M•Ï~V±œóùÌÒÒ9U÷áèá 9‡‚èòTl∆ÅL¶·€ä
N»’«JéoJ“(Æ£rlu"¸v…À›!ynÙ=ÎªîÌjz;SÎâƒÄ -–ç]ú«öëπ©AÎ4\°ñ÷W√/mÜ˚%°$vR,†≥ëñÈ‰dÏ[«©⁄⁄ó+◊ö≈ˆ˜Ê€rZötg¶zQÌS¶ºª˚uÙúa¿noÓ†~_^öW8êá6ªØÊT·qj¬ï°k|¿+€ù>•Ã˛$Í∫Wé˘p?JOÜ€	óÜ\°ógÊD˝O≤ì>√Éé˝hÆê-·u”º\˘ÍµÃ)R˘c!¡≥˚˜7‘¡òN‰ãF¬™πû†o˘Ä`ï]åg YÓgΩπYäe|–*˜xäMŒ7ea:‘'N∞†≠¸°jÎ€féÄsﬂM∞IS\<æ‡á4-∂•1∑]%ïR@ Ù¶rœ|^IÈÏØê≈ı~Î¶g≠OíPºı¸√e˙ëeÏØˇ§Ä∏ñˇ®2cäœ+‘6±Æ&6›“ÈtÜ–Qu}Ì)·≠oyó{C~xf
)»À÷Â&5–PA›}ﬂß”¨y∂Ù≥hBE¯ño›Ò≤€Öt≈Uäp≤ìøoíSçÎUø∏xŒÇ*∏†á ww|rË±†âpeuPJuà¡CÀ‘~ÔÈvXà]òOîŸ‡eN 7¢∞)üÁ∂å|y6yΩ—uÊeXπÜ\t∑¨Ñ˘äD˚‚O)‚9tﬁ√]ÿÔ^†Ìçéçªù÷3æÜRΩâ HπØ„Äõò∏ΩøöÖ»5VbÁ∫§ô∞Çÿ~TÒ®7&ªπ1e}-b≥ÓåıÂúÌbçL·ŒΩ πø<‚˛í$ Á¡ıXZíQ∑sgÊ„’i!ä<¯áhU®ßé¯YNwùç#J–G¯™ºm i˝µéM≈ù^EeØ7cÛ'˚¢5ÅUÍ¸wÇæ©¢m)¢@Ûä_ˆÂ1áõZ≠v™'±º—´3îh°/vrEÊ ;íüπÂ úâßŒ¸1˘
ΩÔrh0hv9?„Ù¯FÏdX¨—€v	MYW◊zØA‹´ÔLuAx˘$âπ‹Ωún¸)“›˙Û,µMÎ∑⁄÷˛†4«ˇÇ∆ä…ÖR5⁄ M”q¡oí¬¸g´π.à^jrÓùêQ˜Ïˆ≠ƒË+ˆDÅNÔ¢7oY$O…Õ§Úò<Œ5F%\22ï‹^‹‚g&‡à‚"⁄mMæYä;Â6ëùó9†‡àïÒ◊‚Áâ÷UL®ÒxK'r∞p∂]mHef©`ùnê§Õhå,Via úoÁ®◊Öa⁄€∫rÁ?8ı˛Xh7n
5*Õrrø÷î‡‚∆€ˆ.±∑§“câ±4tµCÿ5¢'◊ı÷'?œ’◊C0mt·≤‰ u[»Ihª ÷v¿ΩÚÊ«Ω A
˛T6l}&¬π_êÂ%∂úUP#˙5Í®∂Æºﬁ˛M3PÄ,W.¿±—è?nFÜ÷œTd 1áîY´ò?Txñ(º'^ﬁ¯™ ÊLKüﬁœ$lv°ÃjÜaEƒ≠Ï˙ õK≠@ÇñF›Å÷QB{D8ÈÊ(#v?+ÂPîOW¬ÜvY–ﬂ¢_bÁì>%‘—û>ä_±¶œ§/dÛ√<¿=≥–e<?Ú0`J7≠€
Ây+b{ìÕÙ@2ûE¶]WøX€N<|¯÷£5ﬁ-BPpz1/SœÁE≈ßß≈N|BU 
Cv%gíYT:	Kw›ªŒBˆùÀÎZîbv˚>‘›≥“jE" 1t´¯h„ã˛‚RZñzÁ≥M4Á»@±?Y˙–™Km¿Bs≤ºLÄ@õπAiC˝s=leŸï£@Âq0¡Å˛ïà[î1…ˆ√l>;I›÷ú¸µˆ¬ˇ[òl∫˘§Ÿ]LßùeÊ‘?˚êU¶ı.T/3ã]Û˛¨wÀû€xôºÛ=8/)ôój3pÑÁ∫8{i€‘4Èoæ≈ÉÚ <Œ»¡ö3©·ïª›!»GÜÀ3ã7a˛¶[Ô∞∂Õ~è§∞ÿ∑¶Ömoµ≥µ$µ!â±Â¯zæ…A’Ã?Ä´[~8…Ü•â)øπNpQnÀà∫≤πI»‡®{ÚêwºNª&VuÇ) À/9˜uj˘ç“{¸ìåÊÖsì´]≤G±∞IJÂë€ï:~µì@-Uåƒ}Ω_7∏+ÙNûOsÓ
p"«◊çËxLqÃK≠n¡R9·ﬂÉëÛcæÂw
Jπ\'S7O*ÕQ›–ïÔ\˛AMﬁ„˜õÎ≤.¿ÃÓÑ:ÒR]®˙‚Ò$≤ë◊ ÎxÆ™¯#Bÿv?Î,â± $MÄ9ê‡ïq£ËZ›–¯ê›™ 4‚wﬁ{‡ö0^BëæÿÜIZ˙Hj§⁄/µP0v!”{ï…∂]ﬂdÍt8∑Üöß‚9á˛ßÜ]ˇÉ`pÂê·≠µ®°ºÛ4ÆZZõó„¸èfﬁ»›údÁ¢º	iª&_ÚÆ{{M≤ZØ»d5.££32”ä)a#≠s≤]PX¬]¥¬&¿?ﬁxzKßN¬…éÙ0 rYßìÉ√π<hﬁœÂ“œêqºƒÆ√/ˇ˚Ú0hGt•1j≥≥ª æ.iVâj…ë√ﬁ¯2ÍPì64ÓÍ…‡◊~¨zÓá√µ_aU≠Ú,Ö.à≈ÃPÙV"ª¡ﬂ/|úÕ¢–ìﬂ4û€_rõ¥’‘õù€íÅÙæB~˜_⁄*ﬁ∏a∆—˘!£—¥·∂©hú≠wÈˇSü¡‡'ŒÁ’7’‘`T1U∫°–Ò#Pµe]’Ï¶ïˇœ\†>é_ó6˜◊-Ç#ëøø6ëVÛ&>B:¨0ã{ÙU†y
Ç°Á≤√ŒÎﬁÍﬁa++Íã>SÕá¯†O “qáƒ!©hµ`&à¢1ñ„µQÀ^ÂÆmﬁS}”~Ω2_ (‘
w—èfwæã!´'(êõn∫à DkπE Û–Yé„=–ä*ø&ˇ¿Ó(√¡Ék$–i?—Èª∫ÅòN|aØ∞‹‘@C+îÁoQÃc{∑√c&êw„§√^Õî:Q1‘*ï¬Æ√«|«ai•R‰£wﬂ\πËÚÓÇ.9SasÈàﬂ‰Éu >"‘wÙª¨ãŸ·ÜºjŒxﬂ√v¿5 F¨õ¡£µ§Qì‹®\HÍå3ûˆ∏‡Ò2c;°Ω!ËÁ·”u«4ÓÈ>ÜÏudKÄ ÖˇäØí˝`M`œ†—ÈÚ‡<Ø’RÏŒèYbxÃe≤÷∆ÜMì'ëîÕk´7bΩå“4óXÎZÔæ∏¢&£Êãı”µ£[ì√Î9îVÆ™êI.åLû%∫”ãw<4	Çn÷\‰ÖNÀ1Å0r*Íq8/0äU±∆”˚&'~r≠πé*‰ﬁuePÇπºGû3Là”Â˘ñÌ-‹!íf·ö\',õR∫n∫Û2≈~OÄ∫ˇñ¡"™vÓÑˇ^ÌºØ~à>ÚÎå™ç±6SEJÆ1±Ì÷˘õú1ãî5€u.É wö¶˙…YÃÿ˘N