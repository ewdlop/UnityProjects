_t rawOffset, int32_t dstSavings,
        const UDate* startTimes, int32_t numStartTimes, DateTimeRule::TimeRuleType timeRuleType);

    /**
     * Copy constructor.
     * @param source    The TimeArrayTimeZoneRule object to be copied.
     * @stable ICU 3.8
     */
    TimeArrayTimeZoneRule(const TimeArrayTimeZoneRule& source);

    /**
     * Destructor.
     * @stable ICU 3.8
     */
    virtual ~TimeArrayTimeZoneRule();

    /**
     * Clone this TimeArrayTimeZoneRule object polymorphically. The caller owns the result and
     * should delete it when done.
     * @return    A copy of the object.
     * @stable ICU 3.8
     */
    virtual TimeArrayTimeZoneRule* clone(void) const;

    /**
     * Assignment operator.
     * @param right The object to be copied.
     * @stable ICU 3.8
     */
    TimeArrayTimeZoneRule& operator=(const TimeArrayTimeZoneRule& right);

    /**
     * Return true if the given <code>TimeZoneRule</code> objects are semantically equal. Objects
     * of different subclasses are considered unequal.
     * @param that  The object to be compared with.
     * @return  true if the given <code>TimeZoneRule</code> objects are semantically equal.
     * @stable ICU 3.8
     */
    virtual UBool operator==(const TimeZoneRule& that) const;

    /**
     * Return true if the given <code>TimeZoneRule</code> objects are semantically unequal. Objects
     * of different subclasses are considered unequal.
     * @param that  The object to be compared with.
     * @return  true if the given <code>TimeZoneRule</code> objects are semantically unequal.
     * @stable ICU 3.8
     */
    virtual UBool operator!=(const TimeZoneRule& that) const;

    /**
     * Gets the time type of the start times used by this rule.  The return value
     * is either <code>DateTimeRule::WALL_TIME</code> or <code>STANDARD_TIME</code>
     * or <code>UTC_TIME</code>.
     * 
     * @return The time type used of the start times used by this rule.
     * @stable ICU 3.8
     */
    DateTimeRule::TimeRuleType getTimeType(void) const;

    /**
     * Gets a start time at the index stored in this rule.
     * @param index     The index of start times
     * @param result    Receives the start time at the index
     * @return  true if the index is within the valid range and
     *          and the result is set.  When false, the output
     *          parameger "result" is unchanged.
     * @stable ICU 3.8
     */
    UBool getStartTimeAt(int32_t index, UDate& result) const;

    /**
     * Returns the number of start times stored in this rule
     * @return The number of start times.
     * @stable ICU 3.8
     */
    int32_t countStartTimes(void) const;

    /**
     * Returns if this rule represents the same rule and offsets as another.
     * When two <code>TimeZoneRule</code> objects differ only its names, this method
     * returns true.
     * @param that  The <code>TimeZoneRule</code> object to be compared with.
     * @return  true if the other <code>TimeZoneRule</code> is equivalent to this one.
     * @stable ICU 3.8
     */
    virtual UBool isEquivalentTo(const TimeZoneRule& that) const;

    /**
     * Gets the very first time when this rule takes effect.
     * @param prevRawOffset     The standard time offset from UTC before this rule
     *                          takes effect in milliseconds.
     * @param prevDSTSavings    The amount of daylight saving offset from the
     *                          standard time.
     * @param result            Receives the very first time when this rule takes effect.
     * @return  true if the start time is available.  When false is returned, output parameter
     *          "result" is unchanged.
     * @stable ICU 3.8
     */
    virtual UBool getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate& result) const;

    /**
     * Gets the final time when this rule takes effect.
     * @param prevRawOffset     The standard time offset from UTC before this rule
     *                          takes effect in milliseconds.
     * @param prevDSTSavings    The amount of daylight saving offset from the
     *                          standard time.
     * @param result            Receives the final time when this rule takes effect.
     * @return  true if the start time is available.  When false is returned, output parameter
     *          "result" is unchanged.
     * @stable ICU 3.8
     */
    virtual UBool getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate& result) const;

    /**
     * Gets the first time when this rule takes effect after the specified time.
     * @param base              The first start time after this base time will be returned.
     * @param prevRawOffset     The standard time offset from UTC before this rule
     *                          takes effect in milliseconds.
     * @param prevDSTSavings    The amount of daylight saving offset from the
     *                          standard time.
     * @param inclusive         Whether the base time is inclusive or not.
     * @param result            Receives The first time when this rule takes effect after
     *                          the specified base time.
     * @return  true if the start time is available.  When false is returned, output parameter
     *          "result" is unchanged.
     * @stable ICU 3.8
     */
    virtual UBool getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings,
        UBool inclusive, UDate& result) const;

    /**
     * Gets the most recent time when this rule takes effect before the specified time.
     * @param base              The most recent time before this base time will be returned.
     * @param prevRawOffset     The standard time offset from UTC before this rule
     *                          takes effect in milliseconds.
     * @param prevDSTSavings    The amount of daylight saving offset from the
     *                          standard time.
     * @param inclusive         Whether the base time is inclusive or not.
     * @param result            Receives The most recent time when this rule takes effect before
     *                          the specified base time.
     * @return  true if the start time is available.  When false is returned, output parameter
     *          "result" is unchanged.
     * @stable ICU 3.8
     */
    virtual UBool getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings,
        UBool inclusive, UDate& result) const;


private:
    enum { TIMEARRAY_STACK_BUFFER_SIZE = 32 };
    UBool initStartTimes(const UDate source[], int32_t size, UErrorCode& ec);
    UDate getUTC(UDate time, int32_t raw, int32_t dst) const;

    DateTimeRule::TimeRuleType  fTimeRuleType;
    int32_t fNumStartTimes;
    UDate*  fStartTimes;
    UDate   fLocalStartTimes[TIMEARRAY_STACK_BUFFER_SIZE];

public:
    /**
     * Return the class ID for this class. This is useful only for comparing to
     * a return value from getDynamicClassID(). For example:
     * <pre>
     * .   Base* polymorphic_pointer = createPolymorphicObject();
     * .   if (polymorphic_pointer->getDynamicClassID() ==
     * .       erived::getStaticClassID()) ...
     * </pre>
     * @return          The class ID for all objects of this class.
     * @stable ICU 3.8
     */
    static UClassID U_EXPORT2 getStaticClassID(void);

    /**
     * Returns a unique class ID POLYMORPHICALLY. Pure virtual override. This
     * method is to implement a simple version of RTTI, since not all C++
     * compilers support genuine RTTI. Polymorphic operator==() and clone()
     * methods call this method.
     *
     * @return          The class ID for this object. All objects of a
     *                  given class have the same class ID.  Objects of
     *                  other classes have different class IDs.
     * @stable ICU 3.8
     */
    virtual UClassID getDynamicClassID(void) const;
};


U_NAMESPACE_END

#endif /* #if !UCONFIG_NO_FORMATTING */

#endif // TZRULE_H

//eof
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           H6ﬁÒ¢päíï;µ£ñÒãÆ<.Ω.÷∏ÄPçîŸÖ »£O¥¢‹F‚©1Ò*œÙÿyã
“…º∏l◊@!Ö˙m!õC’CY£Ä5Xˇ¥7V™z¨Í”/Dû∑*å¬≤Ûh»fﬁÄ¶Iﬂ-”jÄìMÅ{hΩ†üŸ(yÅ∞}Å∫BÀ°∫µ‘Y˜ÇÀË¶“ãÊY:ÊF∑Ö8lJ¥öÈPYMypâ™rgî∏ã	†Rq%Àä—~üñû≈¶–C±“&u¿ÄÿìÙ*c‡›Qª Áx.Ø˘
≥#uêˆéÇ±§/bI6dwÜ1ÒòtGﬂèÚ	s£Fû3ãPµCú¶—j0xqkô∆øûcòœygùiF´(Qóp™<…©„IÔwDLﬂsèA?3IÕÿcL≈ºn1◊±˜2:È˙åüáïÃ)0∆1ˇÊrÃu|'‘WäôÔï˙Û5aD#W°˜ô«Æ≈Öxw˝Ë*)Z∆Nå6,RıwX“,ÃÃ?qÆ3∑wT‡Œ‘÷∆¡∫˜_∞¬m4ò¶<!Ó˘0_-Ù‚löZ<yÑ>>y%≈9√[REÌó˝òæxç‹@B£uà7î „”ˆÂÙ‰:˚&»é(œG¯ƒZ2,®Ëdœƒ∂bT√Ëh&]vìD;áA≥ô´ª–ÚÖHÉfµ$‰|:gSÖ"©4ﬁ¢	iÃè√`Wœ	ı?∏}Ò6Q≠=…@“=H^Ë+]`≠Œ‹ßZy[π∏jâ4ù∑Ω#!?§E7êgxñÊ'ÄÁ,ÏääÊÀIg2li◊∑ÊXÊ◊ÁfTÏ=Z1^ ^≤ÌàÉçåfÓÕ`1yjkÆ∆%X¢√⁄Ú2¥PÎ∫µmÔGf[· Ãécv(0%uå·¡áƒﬂV ¿π‡¢,ÒFpf/∏§˜öªw˚«©siü3÷œ’≈ã#Jè§iΩOvŒ&GÇWp±éêÃP(sÁ"ã@Ùö£`ÊYH+“ÎÉ∆ÛV9ìÏ-Ω«UjæÄLb+_˘∂Y.	˙—£UN≠q`—°,œâ¨∂©π`eåß]Ò›\W… ≈éj7<óüv8gfë,ø¨Ãï2…™ÅC›»,∑*FV1•Ug 	ëXU¢,éSæ{K¯oébS:’Q®Ûﬂdú±˘ª¯¨Íï…v™ıUWfüMﬁ˛Âñ¯,‰≥ü«¥W$µª˙èzÃSö7ÈX)∆q:ÕÅ¡†cºÀóH,]nB˜Ò‡⁄NÉU™≈≤tC≈ôå5Ë>\±–ÉûE¸⁄=j/î—èKÆ*Ä∂“Úó∂©1eè÷∏ö‡ÉGvüÍˆ`F3ı·Œƒ?gêêªÎˆY+¨±4œù(fÖÄô¡U§xí›†∆[´YQL^˛ÆÉm6‰€¯´–≥#æÄü#∆Gf	hN7wMè∞_é!B„ or©D•BWÓ‡dÅäêÁ¥¯ÈîX/e(‡√ Œü4a*Mˆ◊‹`˚Hf:≥!ä ›ıÕ„%Ô“∞”+n' ö…!b'qDÛ¿≥ÄŸ∂ãÕRÊ|B UBD±d®CD±>~fjπÄoq_]Å∏V€∏˜õ'≠›ûeXXiŒ˚j”í<O∂#ç±ç—•;ÄYB0=BÙh ßÍÙèFY<PWTÚcúR~†ë—€¡á≈SMW$÷¨u_‘Î·¯	ÙMË=Q3=Á¬’år‚næòÔ€ŸOπai,cªGÒ¬¥ÃöÜ HŸ©€úœæ®∑Âï∏HbÄµ≈ïPÂê†htŸ∏/—„eémçÏŒ¥õ‹æ⁄«cycØ” l˛’`íˆ˙ÆC‹	∑≈∑hgÙ#áy∏yUØÍ¡I‚Ù[%ΩÀÁÍFïÍqítÌƒÊ_ ≥?œRûÕ£ÍˆÍ`^8éWûÌLæ≠¯¸tXß§ÎC°*tŸsS<eì˚–Gç]\áÉªwÍ~Ïi?˜(WIˆxñ!•éÂ?–•áÇÁ	z⁄\æ aõ¢úT<%±/ﬂ‘‘À¥í´Ël+∞ëAêô^:ã©⁄˙S∫@âKæÊ¡R}û˜‘ÛA°9(ÈK˛ DÕdÀ§z-ˇ÷ùë´&æ¯rŸ –∆S°fk!w/'	…¯sÔ	π≥0Rì∞àıÈ]Åï¥äöÃKªÏB›ãZ”ÄyZ#·cÄ1n™EÄÚ≠#”º‡UwπÃp†Ó¬˜◊!ıÙçc=”ö§¯—¡ÊF‘‡ò&$ﬂbÚQ'ıñu÷d≈£?*Û9gìïH√4—é’Ñ™≠Ö¬∞s}EßÎ-#‹Ö–wíÆáàˆ™P¢˝géôa"V=íÔP™â]–unzE±ëÿπÚÉ∂–t/%~à:ïTN⁄>Dﬁ›êbe— )ªhTÿ|Ï_4ÂZ¸€Æ©5ƒ1Âπ?d⁄.FK%≤Ñ“é.få¶–I%+Ö‡B0@ÓÆèª‘…Ôq|)gÑ¯b(£=v?chû0PWvÅƒ™ˆÄ◊y∞ÎÅ/-%ú‘ºE!ÍZl°9GÈ.iùw
éπ| ”Ÿìe3rÙ@Óô}sƒùÔâ
b⁄¯ﬁ¬#.\P:i8@⁄‘º∏UË80_c˜¡≈·‡L∆Ÿ‚ü<ÍÖ øıƒX≤éI2‘çÄ◊Iv:Y*`l^ÿö’£mE^%41Ú¸_T»ƒzrøBÊ∑XF¡B9òZrª´lÕΩ
-ÊG:<µtïL,GKµ¿iˆ°e$p"∑«ŒŸNkÚ˘⁄èÔµﬁÔ±0 ·Lá,ﬂ∆áãHS◊âª°Z|œJr,x[Ù'/ ƒù`˜	˜⁄ùRyÌ ‡‡
É«9%0≈Z'p/÷ÇNî˜o¸Mπ	ØaˆfÖ≈‹∂É ∂ªeÅ¿>üúiD
Á@‰ÈWáùƒÜuÀæ¯™Ω`Zﬁ,4hcæ·-Ö∞X÷FngIÍ¬üUå∂Gb~}='
Ω‰
ƒØ(üt=⁄o≥C;∏ñë≥Ïp◊
Øñ -çÁûr?íU{äj∞ˇ£-Cª^¥epÕ#1h≠2lã˘·(/ßÀ¡∞ÿÒ@±¢…‚Q]Z}—Ùõ±}1óòØpÈVªòRI≤ß
%RZWÖU‹≥jèHı;Ïÿôò3SËp_
(2›QΩ.’°˘8Úé`/ùò_≠Ô£îEÖ›P‘Îª≥YøR√5t|È3V´êΩDO≈∂§ıá DëÁ,KWFfg}ê˝AW£g¬ÌÔÀÛV0#*Fõº'»øÔûÁ9p§Ë’G7lK¸@J∂Í|ŸCç+?!ÏY¯sâÃ–i]Pœå®W_˛Ö2ETSäJ‹ŸIá ™¥¨.~˜ºTk˘$>ˇ©hÙ^9H{ë–#%´ﬂ≤§e]°sr~≈S¥áÖ3˛`ƒ£HÃ9™pÆøW)—I++€˝ÚˆxÂ¡$ˆG™h[êÍ&Ník¯‹ÁTêÆ¯ É_fÅ ‚Ω 3¸üá´~}•Qñ2‹ÂÃ√<ãf2©î“¯≠¶·∫É#"Ÿ™1ÅØËó"é°™Øn Pln≥cGp¯gÂrÚd¸Åı |ìvK˝¯±ÈÊ†∞ˆ2øEﬂäyH,Hè¬˜àJˆ≠ä⁄ﬂü;çØx“;ÕOoœfH¡KõÍË»€t_‹i∆2Nuê;îŒL‘€÷≠]h%›"QññM÷=‡ı≈Bƒ Ã÷$ƒ%	TˇsgGKØ¸cÔª,æH@õ!“Ãõ≈ÚﬂH]n∫åb4w¨P ™uä£Æ¡2Ë/vó]¨m9ë´Á…¨h„.ﬂÒ˝	ˆπÅﬁåAîU!+ J3#·ô2ckµBv·‚eSi@1pˇ;\ﬁwÔQ˘Á∫™r)À.Ç\ûÆ\Ÿ•∑¬I∞F[õ;%”≤ÎiôŒMÛJ–ºd„ê¨A;ùË¶ äÌÑhä§›TÒ–§«GÍ…∆Í›b™nÉZ€t”Rµ˚˙ëhûÜÅY13É1Î˜ÅõLN(…`Ñ,4⁄üª$1dëÄ¢ΩÖÉ âêA15¶ªam| ﬁukéa+ÅMgTnëgi§ÕPä°õÙ™‘˝37„°6õ§Ô
∆≥zëJµª›FO¥Ne6–PY¥¨–€˚2ÛÆ∑‡H(∞Ú$Ó"Ô3Ô∞∆ÅO´Eª ±ÕD¬∞?ÇTı)£ÎUËC‡\uËOÀÁ}ºß@ΩΩU;Ü{ﬁ=aüöΩÏõXˆ“3T∆]ÊÅﬁò¢¡˜:+-á¡∫u◊j‰nª’éßÔÀ‘OAÈ‹ï√)ÃÄ≠ÔÇ˚À=˙Emc°ºÂˆ˛p∑¶B)„]P éOÓÌír‹ßZÒpΩÊ,ã≈‚ÿx+ˆÿlıWIºˇ,
ÆB;ÓÀr`ˆX1RÁ	‚÷C8ö∆nFÊå(;à?q]g≥Ù}ΩàΩÁâ‰`˘éøéÏÁb°∂õ˝∂«§‚uJ¿„B@—xúPÖâ4∫‹l*ÅPŸ@ﬂ¸ﬂzï<≠®4;«C+â‡q>4w©™Âdi)T`æ…,@ROÆN|”TS'ù‰6û≠Ÿs€MÄo°a'ÁZ/ı≥æÄ¶`‰(∆´äû◊ö	O—ö¯wÈ≥Õ¸≥ª{ tù/4¶	Xé∫#ÿ…a¸9ßDa≤[^:VˇÓ_πY‰ÜC|»yS7”«dòÿã‚¸ÉDz:≠¨œw3K0æ8º'≥CX0 ÎÁπ„ﬁ¸q4 ±,Ñ∫¨›Ì˘™a◊LO0ñ%&°ŸÃ¨º‹L«∂ÜìMé/*
 *******************************************************************************
 * Copyright (C) 1996-2014, International Business Machines Corporation and
 * others. All Rights Reserved.
 *******************************************************************************
 */

#ifndef UCAL_H
#define UCAL_H

#include "unicode/utypes.h"
#include "unicode/uenum.h"
#include "unicode/uloc.h"
#include "unicode/localpointer.h"

#if !UCONFIG_NO_FORMATTING

/**
 * \file
 * \brief C API: Calendar
 *
 * <h2>Calendar C API</h2>
 *
 * UCalendar C API is used  for converting between a <code>UDate</code> object
 * and a set of integer fields such as <code>UCAL_YEAR</code>, <code>UCAL_MONTH</code>,
 * <code>UCAL_DAY</code>, <code>UCAL_HOUR</code>, and so on.
 * (A <code>UDate</code> object represents a specific instant in
 * time with millisecond precision. See UDate
 * for information about the <code>UDate</code> .)
 *
 * <p>
 * Types of <code>UCalendar</code> interpret a <code>UDate</code>
 * according to the rules of a specific calendar system. The U_STABLE
 * provides the enum UCalendarType with UCAL_TRADITIONAL and
 * UCAL_GREGORIAN.
 * <p>
 * Like other locale-sensitive C API, calendar API  provides a
 * function, <code>ucal_open()</code>, which returns a pointer to
 * <code>UCalendar</code> whose time fields have been initialized
 * with the current date and time. We need to specify the type of
 * calendar to be opened and the  timezoneId.
 * \htmlonly<blockquote>\endhtmlonly
 * <pre>
 * \code
 * UCalendar *caldef;
 * UChar *tzId;
 * UErrorCode status;
 * tzId=(UChar*)malloc(sizeof(UChar) * (strlen("PST") +1) );
 * u_uastrcpy(tzId, "PST");
 * caldef=ucal_open(tzID, u_strlen(tzID), NULL, UCAL_TRADITIONAL, &status);
 * \endcode
 * </pre>
 * \htmlonly</blockquote>\endhtmlonly
 *
 * <p>
 * A <code>UCalendar</code> object can produce all the time field values
 * needed to implement the date-time formatting for a particular language
 * and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
 *
 * <p>
 * When computing a <code>UDate</code> from time fields, two special circumstances
 * may arise: there may be insufficient information to compute the
 * <code>UDate</code> (such as only year and month but no day in the month),
 * or there may be inconsistent information (such as "Tuesday, July 15, 1996"
 * -- July 15, 1996 is actually a Monday).
 *
 * <p>
 * <strong>Insufficient information.</strong> The calendar will use default
 * information to specify the missing fields. This may vary by calendar; for
 * the Gregorian calendar, the default for a field is the same as that of the
 * start of the epoch: i.e., UCAL_YEAR = 1970, UCAL_MONTH = JANUARY, UCAL_DATE = 1, etc.
 *
 * <p>
 * <strong>Inconsistent information.</strong> If fields conflict, the calendar
 * will give preference to fields set more recently. For example, when
 * determining the day, the calendar will look for one of the following
 * combinations of fields.  The most recent combination, as determined by the
 * most recently set single field, will be used.
 *
 * \htmlonly<blockquote>\endhtmlonly
 * <pre>
 * \code
 * UCAL_MONTH + UCAL_DAY_OF_MONTH
 * UCAL_MONTH + UCAL_WEEK_OF_MONTH + UCAL_DAY_OF_WEEK
 * UCAL_MONTH + UCAL_DAY_OF_WEEK_IN_MONTH + UCAL_DAY_OF_WEEK
 * UCAL_DAY_OF_YEAR
 * UCAL_DAY_OF_WEEK + UCAL_WEEK_OF_YEAR
 * \endcode
 * </pre>
 * \htmlonly</blockquote>\endhtmlonly
 *
 * For the time of day:
 *
 * \htmlonly<blockquote>\endhtmlonly
 * <pre>
 * \code
 * UCAL_HOUR_OF_DAY
 * UCAL_AM_PM + UCAL_HOUR
 * \endcode
 * </pre>
 * \htmlonly</blockquote>\endhtmlonly
 *
 * <p>
 * <strong>Note:</strong> for some non-Gregorian calendars, different
 * fields may be necessary for complete disambiguation. For example, a full
 * specification of the historial Arabic astronomical calendar requires year,
 * month, day-of-month <em>and</em> day-of-week in some cases.
 *
 * <p>
 * <strong>Note:</strong> There are certain possible ambiguities in
 * interpretation of certain singular times, which are resolved in the
 * following ways:
 * <ol>
 *     <li> 24:00:00 "belongs" to the following day. That is,
 *          23:59 on Dec 31, 1969 &lt; 24:00 on Jan 1, 1970 &lt; 24:01:00 on Jan 1, 1970
 *
 *     <li> Although historically not precise, midnight also belongs to "am",
 *          and noon belongs to "pm", so on the same day,
 *          12:00 am (midnight) &lt; 12:01 am, and 12:00 pm (noon) &lt; 12:01 pm
 * </ol>
 *
 * <p>
 * The date or time format strings are not part of the definition of a
 * calendar, as those must be modifiable or overridable by the user at
 * runtime. Use {@link icu::DateFormat}
 * to format dates.
 *
 * <p>
 * <code>Calendar</code> provides an API for field "rolling", where fields
 * can be incremented or decremented, but wrap around. For example, rolling the
 * month up in the date <code>December 12, <b>1996</b></code> results in
 * <code>January 12, <b>1996</b></code>.
 *
 * <p>
 * <code>Calendar</code> also provides a date arithmetic function for
 * adding the specified (signed) amount of time to a particular time field.
 * For example, subtracting 5 days from the date <code>September 12, 1996</code>
 * results in <code>September 7, 1996</code>.
 *
 * @stable ICU 2.0
 */

/**
 * The time zone ID reserved for unknown time zone.
 * @stable ICU 4.8
 */
#define UCAL_UNKNOWN_ZONE_ID "Etc/Unknown"

/** A calendar.
 *  For usage in C programs.
 * @stable ICU 2.0
 */
typedef void* UCalendar;

/** Possible types of UCalendars 
 * @stable ICU 2.0
 */
enum UCalendarType {
  /**
   * Despite the name, UCAL_TRADITIONAL designates the locale's default calendar,
   * which may be the Gregorian calendar or some other calendar.
   * @stable ICU 2.0
   */
  UCAL_TRADITIONAL,
  /**
   * A better name for UCAL_TRADITIONAL.
   * @stable ICU 4.2
   */
  UCAL_DEFAULT = UCAL_TRADITIONAL,
  /**
   * Unambiguously designates the Gregorian calendar for the locale.
   * @stable ICU 2.0
   */
  UCAL_GREGORIAN
};

/** @stable ICU 2.0 */
typedef enum UCalendarType UCalendarType;

/** Possible fields in a UCalendar 
 * @stable ICU 2.0
 */
enum UCalendarDateFields {
  /** 
   * Field number indicating the era, e.g., AD or BC in the Gregorian (Julian) calendar. 
   * This is a calendar-specific value.
   * @stable ICU 2.6 
   */
  UCAL_ERA,

  /**
   * Field number indicating the year. This is a calendar-specific value.
   * @stable ICU 2.6 
   */
  UCAL_YEAR,

  /**
   * Field number indicating the month. This is a calendar-specific value. 
   * The first month of the year is
   * <code>JANUARY</code>; the last depends on the number of months in a year.
   * @see #UCAL_JANUARY
   * @see #UCAL_FEBRUARY
   * @see #UCAL_MARCH
   * @see #UCAL_APRIL
   * @see #UCAL_MAY
   * @see #UCAL_JUNE
   * @see #UCAL_JULY
   * @see #UCAL_AUGUST
   * @see #UCAL_SEPTEMBER
   * @see #UCAL_OCTOBER
   * @see #UCAL_NOVEMBER
   * @see #UCAL_DECEMBER
   * @see #UCAL_UNDECIMBER
   * @stable ICU 2.6 
   */
  UCAL_MONTH,

  /**
   * Field number indicating the
   * week number within the current year.  The first week of the year, as
   * defined by <code>UCAL_FIRST_DAY_OF_WEEK</code> and <code>UCAL_MINIMAL_DAYS_IN_FIRST_WEEK</code>
   * attributes, has value 1.  Subclasses define
   * the value of <code>UCAL_WEEK_OF_YEAR</code> for days before the first week of
   * the year.
   * @see ucal_getAttribute
   * @see ucal_setAttribute
   * @stable ICU 2.6 
   */
  UCAL_WEEK_OF_YEAR,

 /**
   * Field number indicating the
   * week number within the current month.  The first week of the month, as
   * defined by <code>UCAL_FIRST_DAY_OF_WEEK</code> and <code>UCAL_MINIMAL_DAYS_IN_FIRST_WEEK</code>
   * attributes, has value 1.  Subclasses define
   * the value of <code>WEEK_OF_MONTH</code> for days before the first week of
   * the month.
   * @see ucal_getAttribute
   * @see ucal_setAttribute
   * @see #UCAL_FIRST_DAY_OF_WEEK
   * @see #UCAL_MINIMAL_DAYS_IN_FIRST_WEEK
   * @stable ICU 2.6 
   */
  UCAL_WEEK_OF_MONTH,

 /**
   * Field number indicating the
   * day of the month. This is a synonym for <code>DAY_OF_MONTH</code>.
   * The first day of the month has value 1.
   * @see #UCAL_DAY_OF_MONTH
   * @stable ICU 2.6 
   */
  UCAL_DATE,

 /**
   * Field number indicating the day
   * number within the current year.  The first day of the year has value 1.
   * @stable ICU 2.6 
   */
  UCAL_DAY_OF_YEAR,

 /**
   * Field number indicating the day
   * of the week.  This field takes values <code>SUNDAY</code>,
   * <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>,
   * <code>THURSDAY</code>, <code>FRIDAY</code>, and <code>SATURDAY</code>.
   * @see #UCAL_SUNDAY
   * @see #UCAL_MONDAY
   * @see #UCAL_TUESDAY
   * @see #UCAL_WEDNESDAY
   * @see #UCAL_THURSDAY
   * @see #UCAL_FRIDAY
   * @see #UCAL_SATURDAY
   * @stable ICU 2.6 
   */
  UCAL_DAY_OF_WEEK,

 /**
   * Field number indicating the
   * ordinal number of the day of the week within the current month. Together
   * with the <code>DAY_OF_WEEK</code> field, this uniquely specifies a day
   * within a month.  Unlike <code>WEEK_OF_MONTH</code> and
   * <code>WEEK_OF_YEAR</code>, this field's value does <em>not</em> depend on
   * <code>getFirstDayOfWeek()</code> or
   * <code>getMinimalDaysInFirstWeek()</code>.  <code>DAY_OF_MONTH 1</code>
   * through <code>7</code> always correspond to <code>DAY_OF_WEEK_IN_MONTH
   * 1</code>; <code>8</code> through <code>15</code> correspond to
   * <code>DAY_OF_WEEK_IN_MONTH 2</code>, and so on.
   * <code>DAY_OF_WEEK_IN_MONTH 0</code> indicates the week before
   * <code>DAY_OF_WEEK_IN_MONTH 1</code>.  Negative values count back from the
   * end of the month, so the last Sunday of a month is specified as
   * <code>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1</code>.  Because
   * negative values count backward they will usually be aligned differently
   * within the month than positive values.  For example, if a month has 31
   * days, <code>DAY_OF_WEEK_IN_MONTH -1</code> will overlap
   * <code>DAY_OF_WEEK_IN_MONTH 5</code> and the end of <code>4</code>.
   * @see #UCAL_DAY_OF_WEEK
   * @see #UCAL_WEEK_OF_MONTH
   * @stable ICU 2.6 
   */
  UCAL_DAY_OF_WEEK_IN_MONTH,

 /**
   * Field number indicating
   * whether the <code>HOUR</code> is before or after noon.
   * E.g., at 10:04:15.250 PM the <code>AM_PM</code> is <code>PM</code>.
   * @see #UCAL_AM
   * @see #UCAL_PM
   * @see #UCAL_HOUR
   * @stable ICU 2.6 
   */
  UCAL_AM_PM,

 /**
   * Field number indicating the
   * hour of the morning or afternoon. <code>HOUR</code> is used for the 12-hour
   * clock.
   * E.g., at 10:04:15.250 PM the <code>HOUR</code> is 10.
   * @see #UCAL_AM_PM
   * @see #UCAL_HOUR_OF_DAY
   * @stable ICU 2.6 
   */
  UCAL_HOUR,

 /**
   * Field number indicating the
   * hour of the day. <code>HOUR_OF_DAY</code> is used for the 24-hour clock.
   * E.g., at 10:04:15.250 PM the <code>HOUR_OF_DAY</code> is 22.
   * @see #UCAL_HOUR
   * @stable ICU 2.6 
   */
  UCAL_HOUR_OF_DAY,

 /**
   * Field number indicating the
   * minute within the hour.
   * E.g., at 10:04:15.250 PM the <code>UCAL_MINUTE</code> is 4.
   * @stable ICU 2.6 
   */
  UCAL_MINUTE,

 /**
   * Field number indicating the
   * second within the minute.
   * E.g., at 10:04:15.250 PM the <code>UCAL_SECOND</code> is 15.
   * @stable ICU 2.6 
   */
  UCAL_SECOND,

 /**
   * Field number indicating the
   * millisecond within the second.
   * E.g., at 10:04:15.250 PM the <code>UCAL_MILLISECOND</code> is 250.
   * @stable ICU 2.6 
   */
  UCAL_MILLISECOND,

 /**
   * Field number indicating the
   * raw offset from GMT in milliseconds.
   * @stable ICU 2.6 
   */
  UCAL_ZONE_OFFSET,

 /**
   * Field number indicating the
   * daylight savings offset in milliseconds.
   * @stable ICU 2.6 
   */
  UCAL_DST_OFFSET,
  
 /**
   * Field number 
   * indicating the extended year corresponding to the
   * <code>UCAL_WEEK_OF_YEAR</code> field.  This may be one greater or less
   * than the value of <code>UCAL_EXTENDED_YEAR</code>.
   * @stable ICU 2.6
   */
  UCAL_YEAR_WOY,

 /**
   * Field number 
   * indicating the localized day of week.  This will be a value from 1
   * to 7 inclusive, with 1 being the localized first day of the week.
   * @stable ICU 2.6
   */
  UCAL_DOW_LOCAL,

  /**
   * Year of this calendar system, encompassing all supra-year fields. For example, 
   * in Gregorian/Julian calendars, positive Extended Year values indicate years AD,
   *  1 BC = 0 extended, 2 BC = -1 extended, and so on. 
   * @stable ICU 2.8 
   */
  UCAL_EXTENDED_YEAR,

 /**
   * Field number 
   * indicating the modified Julian day number.  This is different from
   * the conventional Julian day number in two regards.  First, it
   * demarcates days at local zone midnight, rather than noon GMT.
   * Second, it is a local number; that is, it depends on the local time
   * zone.  It can be thought of as a single number that encompasses all
   * the date-related fields.
   * @stable ICU 2.8
   */
  UCAL_JULIAN_DAY, 

  /**
   * Ranges from 0 to 23:59:59.999 (regardless of DST).  This field behaves <em>exactly</em> 
   * like a composite of all time-related fields, not including the zone fields.  As such, 
   * it also reflects discontinuities of those fields on DST transition days.  On a day
   * of DST onset, it will jump forward.  On a day of DST cessation, it will jump 
   * backward.  This reflects the fact that it must be combined with the DST_OFFSET field
   * to obtain a unique local time value.
   * @stable ICU 2.8
   */
  UCAL_MILLISECONDS_IN_DAY,

  /**
   * Whether or not the current month is a leap month (0 or 1). See the Chinese calendar for
   * an example of this.
   */
  UCAL_IS_LEAP_MONTH,
  
  /**
   * Field count
   * @stable ICU 2.6
   */
  UCAL_FIELD_COUNT,

 /**
   * Field number indicating the
   * day of the month. This is a synonym for <code>UCAL_DATE</code>.
   * The first day of the month has value 1.
   * @see #UCAL_DATE
   * Synonym for UCAL_DATE
   * @stable ICU 2.8
   **/
  UCAL_DAY_OF_MONTH=UCAL_DATE
};

/** @stable ICU 2.0 */
typedef enum UCalendarDateFields UCalendarDateFields;
    /**
     * Useful constant for days of week. Note: Calendar day-of-week is 1-based. Clients
     * who create locale resources for the field of first-day-of-week should be aware of
     * this. For instance, in US locale, first-day-of-week is set to 1, i.e., UCAL_SUNDAY.
     */
/** Possible days of the week in a UCalendar 
 * @stable ICU 2.0
 */
enum UCalendarDaysOfWeek {
  /** Sunday */
  UCAL_SUNDAY = 1,
  /** Monday */
  UCAL_MONDAY,
  /** Tuesday */
  UCAL_TUESDAY,
  /** Wednesday */
  UCAL_WEDNESDAY,
  /** Thursday */
  UCAL_THURSDAY,
  /** Friday */
  UCAL_FRIDAY,
  /** Saturday */
  UCAL_SATURDAY
};

/** @stable ICU 2.0 */
typedef enum UCalendarDaysOfWeek UCalendarDaysOfWeek;

/** Possible months in a UCalendar. Note: Calendar month is 0-based.
 * @stable ICU 2.0
 */
enum UCalendarMonths {
  /** January */
  UCAL_JANUARY,
  /** February */
  UCAL_FEBRUARY,
  /** March */
  UCAL_MARCH,
  /** April */
  UCAL_APRIL,
  /** May */
  UCAL_MAY,
  /** June */
  UCAL_JUNE,
  /** July */
  UCAL_JULY,
  /** August */
  UCAL_AUGUST,
  /** September */
  UCAL_SEPTEMBER,
  /** October */
  UCAL_OCTOBER,
  /** November */
  UCAL_NOVEMBER,
  /** December */
  UCAL_DECEMBER,
  /** Value of the <code>UCAL_MONTH</code> field indicating the
    * thirteenth month of the year. Although the Gregorian calendar
    * does not use this value, lunar calendars do.
    */
  UCAL_UNDECIMBER
};

/** @stable ICU 2.0 */
typedef enum UCalendarMonths UCalendarMonths;

/** Possible AM/PM values in a UCalendar 
 * @stable ICU 2.0
 */
enum UCalendarAMPMs {
    /** AM */
  UCAL_AM,
  /** PM */
  UCAL_PM
};

/** @stable ICU 2.0 */
typedef enum UCalendarAMPMs UCalendarAMPMs;

/**
 * System time zone type constants used by filte