ZERO_ERROR;
        DecimalFormat df(UnicodeString("0000",""),status);
        int64_t long_number = 1;
        UnicodeString expect = "0001";
        UnicodeString result;
        FieldPosition pos;
        df.format(long_number, result, pos);
        if(U_FAILURE(status)||expect!=result) {
            errcheckln(status, "FAIL: expected '"+expect+"' got '"+result+"' status "+UnicodeString(u_errorName(status),""));
        } else {
            logln("OK:  got expected '"+result+"' status "+UnicodeString(u_errorName(status),""));
        }
    }
    {
        UErrorCode status=U_ZERO_ERROR;
        DecimalFormat df(UnicodeString("0000000000000000000",""),status);
        int64_t long_number = U_INT64_MIN; // -9223372036854775808L;
        // uint8_t bits[8];
        // memcpy(bits,&long_number,8);
        // for(int i=0;i<8;i++) {
        //   logln("bits: %02X", (unsigned int)bits[i]);
        // }
        UnicodeString expect = "-9223372036854775808";
        UnicodeString result;
        FieldPosition pos;
        df.format(long_number, result, pos);
        if(U_FAILURE(status)||expect!=result) {
            errcheckln(status, "FAIL: expected '"+expect+"' got '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on -9223372036854775808");
        } else {
            logln("OK:  got expected '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on -9223372036854775808");
        }
    }
    {
        UErrorCode status=U_ZERO_ERROR;
        DecimalFormat df(UnicodeString("0000000000000000000",""),status);
        int64_t long_number = U_INT64_MAX; // -9223372036854775808L;
        // uint8_t bits[8];
        // memcpy(bits,&long_number,8);
        // for(int i=0;i<8;i++) {
        //   logln("bits: %02X", (unsigned int)bits[i]);
        // }
        UnicodeString expect = "9223372036854775807";
        UnicodeString result;
        FieldPosition pos;
        df.format(long_number, result, pos);
        if(U_FAILURE(status)||expect!=result) {
            errcheckln(status, "FAIL: expected '"+expect+"' got '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on U_INT64_MAX");
        } else {
            logln("OK:  got expected '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on U_INT64_MAX");
        }
    }
    {
        UErrorCode status=U_ZERO_ERROR;
        DecimalFormat df(UnicodeString("0000000000000000000",""),status);
        int64_t long_number = 0;
        // uint8_t bits[8];
        // memcpy(bits,&long_number,8);
        // for(int i=0;i<8;i++) {
        //   logln("bits: %02X", (unsigned int)bits[i]);
        // }
        UnicodeString expect = "0000000000000000000";
        UnicodeString result;
        FieldPosition pos;
        df.format(long_number, result, pos);
        if(U_FAILURE(status)||expect!=result) {
            errcheckln(status, "FAIL: expected '"+expect+"' got '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on 0");
        } else {
            logln("OK:  got expected '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on 0");
        }
    }
    {
        UErrorCode status=U_ZERO_ERROR;
        DecimalFormat df(UnicodeString("0000000000000000000",""),status);
        int64_t long_number = U_INT64_MIN + 1;
        UnicodeString expect = "-9223372036854775807";
        UnicodeString result;
        FieldPosition pos;
        df.format(long_number, result, pos);
        if(U_FAILURE(status)||expect!=result) {
            errcheckln(status, "FAIL: expected '"+expect+"' got '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on -9223372036854775807");
        } else {
            logln("OK:  got expected '"+result+"' status "+UnicodeString(u_errorName(status),"")+" on -9223372036854775807");
        }
    }
}


void NumberFormatTest::TestFormattableSize(void) {
  if(sizeof(FmtStackData) > UNUM_INTERNAL_STACKARRAY_SIZE) {
    errln("Error: sizeof(FmtStackData)=%d, UNUM_INTERNAL_STACKARRAY_SIZE=%d\n",
          sizeof(FmtStackData), UNUM_INTERNAL_STACKARRAY_SIZE);
  } else if(sizeof(FmtStackData) < UNUM_INTERNAL_STACKARRAY_SIZE) {
    logln("Warning: sizeof(FmtStackData)=%d, UNUM_INTERNAL_STACKARRAY_SIZE=%d\n",
        sizeof(FmtStackData), UNUM_INTERNAL_STACKARRAY_SIZE);
  } else {
    logln("sizeof(FmtStackData)=%d, UNUM_INTERNAL_STACKARRAY_SIZE=%d\n",
        sizeof(FmtStackData), UNUM_INTERNAL_STACKARRAY_SIZE);
  }
}

UBool NumberFormatTest::testFormattableAsUFormattable(const char *file, int line, Formattable &f) {
  UnicodeString fileLine = UnicodeString(file)+UnicodeString(":")+line+UnicodeString(": ");

  UFormattable *u = f.toUFormattable();
  logln();
  if (u == NULL) {
    errln("%s:%d: Error: f.toUFormattable() retuned NULL.");
    return FALSE;
  }
  logln("%s:%d: comparing Formattable with UFormattable", file, line);
  logln(fileLine + toString(f));

  UErrorCode status = U_ZERO_ERROR;
  UErrorCode valueStatus = U_ZERO_ERROR;
  UFormattableType expectUType = UFMT_COUNT; // invalid

  UBool triedExact = FALSE; // did we attempt an exact comparison?
  UBool exactMatch = FALSE; // was the exact comparison true?

  switch( f.getType() ) {
  case Formattable::kDate:
    expectUType = UFMT_DATE;
    exactMatch = (f.getDate()==ufmt_getDate(u, &valueStatus));
    triedExact = TRUE;
    break;
  case Formattable::kDouble:
    expectUType = UFMT_DOUBLE;
    exactMatch = (f.getDouble()==ufmt_getDouble(u, &valueStatus));
    triedExact = TRUE;
    break;
  case Formattable::kLong:
    expectUType = UFMT_LONG;
    exactMatch = (f.getLong()==ufmt_getLong(u, &valueStatus));
    triedExact = TRUE;
    break;
  case Formattable::kString:
    expectUType = UFMT_STRING;
    {
      UnicodeString str;
      f.getString(str);
      int32_t len;
      const UChar* uch = ufmt_getUChars(u, &len, &valueStatus);
      if(U_SUCCESS(valueStatus)) {
        UnicodeString str2(uch, len);
        assertTrue("UChar* NULL-terminated", uch[len]==0);
        exactMatch = (str == str2);
      }
      triedExact = TRUE;
    }
    break;
  case Formattable::kArray:
    expectUType = UFMT_ARRAY;
    triedExact = TRUE;
    {
      int32_t count = ufmt_getArrayLength(u, &valueStatus);
      int32_t count2;
      const Formattable *array2 = f.getArray(count2);
      exactMatch = assertEquals(fileLine + " array count", count, count2);

      if(exactMatch) {
        for(int i=0;U_SUCCESS(valueStatus) && i<count;i++) {
          UFormattable *uu = ufmt_getArrayItemByIndex(u, i, &valueStatus);
          if(*Formattable::fromUFormattable(uu) != (array2[i])) {
            errln("%s:%d: operator== did not match at index[%d] - %p vs %p", file, line, i,
                  (const void*)Formattable::fromUFormattable(uu), (const void*)&(array2[i]));
            exactMatch = FALSE;
          } else {
            if(!testFormattableAsUFormattable("(sub item)",i,*Formattable::fromUFormattable(uu))) {
              exactMatch = FALSE;
            }
          }
        }
      }
    }
    break;
  case Formattable::kInt64:
    expectUType = UFMT_INT64;
    exactMatch = (f.getInt64()==ufmt_getInt64(u, &valueStatus));
    triedExact = TRUE;
    break;
  case Formattable::kObject:
    expectUType = UFMT_OBJECT;
    exactMatch = (f.getObject()==ufmt_getObject(u, &valueStatus));
    triedExact = TRUE;
    break;
  }
  UFormattableType uType = ufmt_getType(u, &status);

  if(U_FAILURE(status)) {
    errln("%s:%d: Error calling ufmt_getType - %s", file, line, u_errorName(status));
    return FALSE;
  }

  if(uType != expectUType) {
    errln("%s:%d: got type (%d) expected (%d) from ufmt_getType", file, line, (int) uType, (int) expectUType);
  }

  if(triedExact) {
    if(U_FAILURE(valueStatus)) {
      errln("%s:%d: got err %s trying to ufmt_get...() for exact match check", file, line, u_errorName(valueStatus));
    } else if(!exactMatch) {
     errln("%s:%d: failed exact match for the Formattable type", file, line);
    } else {
      logln("%s:%d: exact match OK", file, line);
    }
  } else {
    logln("%s:%d: note, did not attempt exact match for this formattable type", file, line);
  }

  if( assertEquals(fileLine + " isNumeric()", f.isNumeric(), ufmt_isNumeric(u))
      && f.isNumeric()) {
    UErrorCode convStatus = U_ZERO_ERROR;

    if(uType != UFMT_INT64) { // may fail to compare
      assertTrue(fileLine + " as doubles ==", f.getDouble(convStatus)==ufmt_getDouble(u, &convStatus));
    }

    if( assertSuccess(fileLine + " (numeric conversion status)", convStatus) ) {
      StringPiece fDecNum = f.getDecimalNumber(convStatus);
#if 1
      int32_t len;
      const char *decNumChars = ufmt_getDecNumChars(u, &len, &convStatus);
#else
      // copy version
      char decNumChars[200];
      int32_t len = ufmt_getDecNumChars(u, decNumChars, 200, &convStatus);
#endif

      if( assertSuccess(fileLine + " (decNumbers conversion)", convStatus) ) {
        logln(fileLine + decNumChars);
        assertEquals(fileLine + " decNumChars length==", len, fDecNum.length());
        assertEquals(fileLine + " decNumChars digits", decNumChars, fDecNum.data());
      }

      UErrorCode int64ConversionF = U_ZERO_ERROR;
      int64_t l = f.getInt64(int64ConversionF);
      UErrorCode int64ConversionU = U_ZERO_ERROR;
      int64_t r = ufmt_getInt64(u, &int64ConversionU);

      if( (l==r) 
          && ( uType != UFMT_INT64 ) // int64 better not overflow
          && (U_INVALID_FORMAT_ERROR==int64ConversionU) 
          && (U_INVALID_FORMAT_ERROR==int64ConversionF) ) {
        logln("%s:%d: OK: 64 bit overflow", file, line);
      } else {
        assertEquals(fileLine + " as int64 ==", l, r);
        assertSuccess(fileLine + " Formattable.getnt64()", int64ConversionF);
        assertSuccess(fileLine + " ufmt_getInt64()", int64ConversionU);
      }
    }
  }
  return exactMatch || !triedExact;
}

void NumberFormatTest::TestUFormattable(void) {
  {
    // test that a default formattable is equal to Formattable()
    UErrorCode status = U_ZERO_ERROR;
    LocalUFormattablePointer defaultUFormattable(ufmt_open(&status));
    assertSuccess("calling umt_open", status);
    Formattable defaultFormattable;
    assertTrue((UnicodeString)"comparing ufmt_open() with Formattable()",
               (defaultFormattable
                == *(Formattable::fromUFormattable(defaultUFormattable.getAlias()))));
    assertTrue((UnicodeString)"comparing ufmt_open() with Formattable()",
               (defaultFormattable
                == *(Formattable::fromUFormattable(defaultUFormattable.getAlias()))));
    assertTrue((UnicodeString)"comparing Formattable() round tripped through UFormattable",
               (defaultFormattable
                == *(Formattable::fromUFormattable(defaultFormattable.toUFormattable()))));
    assertTrue((UnicodeString)"comparing &Formattable() round tripped through UFormattable",
               ((&defaultFormattable)
                == Formattable::fromUFormattable(defaultFormattable.toUFormattable())));
    assertFalse((UnicodeString)"comparing &Formattable() with ufmt_open()",
               ((&defaultFormattable)
                == Formattable::fromUFormattable(defaultUFormattable.getAlias())));
    testFormattableAsUFormattable(__FILE__, __LINE__, defaultFormattable);
  }
  // test some random Formattables
  {
    Formattable f(ucal_getNow(), Formattable::kIsDate);
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    Formattable f((double)1.61803398874989484820); // golden ratio
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    Formattable f((int64_t)80994231587905127LL); // weight of the moon, in kilotons http://solarsystem.nasa.gov/planets/profile.cfm?Display=Facts&Object=Moon
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    Formattable f((int32_t)4); // random number, source: http://www.xkcd.com/221/
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    Formattable f("Hello world."); // should be invariant?
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    UErrorCode status2 = U_ZERO_ERROR;
    Formattable f(StringPiece("73476730924573500000000.0"), status2); // weight of the moon, kg
    assertSuccess("Constructing a StringPiece", status2);
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    UErrorCode status2 = U_ZERO_ERROR;
    UObject *obj = new Locale();
    Formattable f(obj);
    assertSuccess("Constructing a Formattable from a default constructed Locale()", status2);
    testFormattableAsUFormattable(__FILE__, __LINE__,  f);
  }
  {
    const Formattable array[] = {
      Formattable(ucal_getNow(), Formattable::kIsDate),
      Formattable((int32_t)4),
      Formattable((double)1.234),
    };

    Formattable fa(array, 3);
    testFormattableAsUFormattable(__FILE__, __LINE__, fa);
  }
}

void NumberFormatTest::TestSignificantDigits(void) {
  double input[] = {
        0, 0,
        0.1, -0.1,
        123, -123,
        12345, -12345,
        123.45, -123.45,
        123.44501, -123.44501,
        0.001234, -0.001234,
        0.00000000123, -0.00000000123,
        0.0000000000000000000123, -0.0000000000000000000123,
        1.2, -1.2,
        0.0000000012344501, -0.0000000012344501,
        123445.01, -123445.01,
        12344501000000000000000000000000000.0, -12344501000000000000000000000000000.0,
    };
    const char* expected[] = {
        "0.00", "0.00",
        "0.100", "-0.100",
        "123", "-123",
        "12345", "-12345",
        "123.45", "-123.45",
        "123.45", "-123.45",
        "0.001234", "-0.001234",
        "0.00000000123", "-0.00000000123",
        "0.0000000000000000000123", "-0.0000000000000000000123",
        "1.20", "-1.20",
        "0.0000000012345", "-0.0000000012345",
        "123450", "-123450",
        "12345000000000000000000000000000000", "-12345000000000000000000000000000000",
    };

    UErrorCode status = U_ZERO_ERROR;
    Locale locale("en_US");
    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(
            NumberFormat::createInstance(locale, status)));
    CHECK_DATA(status,"NumberFormat::createInstance")

    numberFormat->setSignificantDigitsUsed(TRUE);
    numberFormat->setMinimumSignificantDigits(3);
    numberFormat->setMaximumSignificantDigits(5);
    numberFormat->setGroupingUsed(false);
    
    UnicodeString result;
    UnicodeString expectedResult;
    for (unsigned int i = 0; i < sizeof(input)/sizeof(double); ++i) {
        numberFormat->format(input[i], result);
        UnicodeString expectedResult(expected[i]);
        if (result != expectedResult) {
          errln((UnicodeString)"Expected: '" + expectedResult + "' got '" + result);
        }
        result.remove();
    }
}

void NumberFormatTest::TestShowZero() {
    UErrorCode status = U_ZERO_ERROR;
    Locale locale("en_US");
    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(
            NumberFormat::createInstance(locale, status)));
    CHECK_DATA(status, "NumberFormat::createInstance")

    numberFormat->setSignificantDigitsUsed(TRUE);
    numberFormat->setMaximumSignificantDigits(3);
    
    UnicodeString result;
    numberFormat->format(0.0, result);
    if (result != "0") {
        errln((UnicodeString)"Expected: 0, got " + result);
    }
}

void NumberFormatTest::TestBug9936() {
    UErrorCode status = U_ZERO_ERROR;
    Locale locale("en_US");
    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(
            NumberFormat::createInstance(locale, status)));
    if (U_FAILURE(status)) {
        dataerrln("File %s, Line %d: status = %s.\n", __FILE__, __LINE__, u_errorName(status));
        return;
    }
        
    if (numberFormat->areSignificantDigitsUsed() == TRUE) {
        errln("File %s, Line %d: areSignificantDigitsUsed() was TRUE, expected FALSE.\n", __FILE__, __LINE__);
    }
    numberFormat->setSignificantDigitsUsed(TRUE);
    if (numberFormat->areSignificantDigitsUsed() == FALSE) {
        errln("File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\n", __FILE__, __LINE__);
    }

    numberFormat->setSignificantDigitsUsed(FALSE);
    if (numberFormat->areSignificantDigitsUsed() == TRUE) {
        errln("File %s, Line %d: areSignificantDigitsUsed() was TRUE, expected FALSE.\n", __FILE__, __LINE__);
    }

    numberFormat->setMinimumSignificantDigits(3);
    if (numberFormat->areSignificantDigitsUsed() == FALSE) {
        errln("File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\n", __FILE__, __LINE__);
    }

    numberFormat->setSignificantDigitsUsed(FALSE);
    numberFormat->setMaximumSignificantDigits(6);
    if (numberFormat->areSignificantDigitsUsed() == FALSE) {
        errln("File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\n", __FILE__, __LINE__);
    }
 
}

void NumberFormatTest::TestParseNegativeWithFaLocale() {
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormat *test = (DecimalFormat *) NumberFormat::createInstance("fa", status);
    CHECK_DATA(status, "NumberFormat::createInstance")
    test->setLenient(TRUE);
    Formattable af;
    ParsePosition ppos;
    UnicodeString value("\\u200e-0,5");
    value = value.unescape();
    test->parse(value, af, ppos);
    if (ppos.getIndex() == 0) {
        errln("Expected -0,5 to parse for Farsi.");
    }
    delete test;
}

void NumberFormatTest::TestParseNegativeWithAlternateMinusSign() {
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormat *test = (DecimalFormat *) NumberFormat::createInstance("en", status);
    CHECK_DATA(status, "NumberFormat::createInstance")
    test->setLenient(TRUE);
    Formattable af;
    ParsePosition ppos;
    UnicodeString value("\\u208B0.5");
    value = value.unescape();
    test->parse(value, af, ppos);
    if (ppos.getIndex() == 0) {
        errln(UnicodeString("Expected ") + value + UnicodeString(" to parse."));
    }
    delete test;
}

void NumberFormatTest::TestCustomCurrencySignAndSeparator() {
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormatSymbols custom(Locale::getUS(), status);
    CHECK(status, "DecimalFormatSymbols constructor");

    custom.setSymbol(DecimalFormatSymbols::kCurrencySymbol, "*");
    custom.setSymbol(DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol, "^");
    custom.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, ":");

    UnicodeString pat(" #,##0.00");
    pat.insert(0, (UChar)0x00A4);

    DecimalFormat fmt(pat, custom, status);
    CHECK(status, "DecimalFormat constructor");

    UnicodeString numstr("* 1^234:56");
    expect2(fmt, (Formattable)((double)1234.56), numstr);
}

typedef struct {
    const char *   locale;
    UBool          lenient;
    UnicodeString  numString;
    double         value;
} SignsAndMarksItem;


void NumberFormatTest::TestParseSignsAndMarks() {
    const SignsAndMarksItem items[] = {
        // locale               lenient numString                                                       value
        { "en",                 FALSE,  CharsToUnicodeString("12"),                                      12 },
        { "en",                 TRUE,   CharsToUnicodeString("12"),                                      12 },
        { "en",                 FALSE,  CharsToUnicodeString("-23"),                                    -23 },
        { "en",                 TRUE,   CharsToUnicodeString("-23"),                                    -23 },
        { "en",                 TRUE,   CharsToUnicodeString("- 23"),                                   -23 },
        { "en",                 FALSE,  CharsToUnicodeString("\\u200E-23"),                             -23 },
        { "en",                 TRUE,   CharsToUnicodeString("\\u200E-23"),                             -23 },
        { "en",                 TRUE,   CharsToUnicodeString("\\u200E- 23"),                            -23 },

        { "en@numbers=arab",    FALSE,  CharsToUnicodeString("\\u0663\\u0664"),                          34 },
        { "en@numbers=arab",    TRUE,   CharsToUnicodeString("\\u0663\\u0664"),                          34 },
        { "en@numbers=arab",    FALSE,  CharsToUnicodeString("-\\u0664\\u0665"),                        -45 },
        { "en@numbers=arab",    TRUE,   CharsToUnicodeString("-\\u0664\\u0665"),                        -45 },
        { "en@numbers=arab",    TRUE,   CharsToUnicodeString("- \\u0664\\u0665"),                       -45 },
        { "en@numbers=arab",    FALSE,  CharsToUnicodeString("\\u200F-\\u0664\\u0665"),                 -45 },
        { "en@numbers=arab",    TRUE,   CharsToUnicodeString("\\u200F-\\u0664\\u0665"),                 -45 },
        { "en@numbers=arab",    TRUE,   CharsToUnicodeString("\\u200F- \\u0664\\u0665"),                -45 },

        { "en@numbers=arabext", FALSE,  CharsToUnicodeString("\\u06F5\\u06F6"),                          56 },
        { "en@numbers=arabext", TRUE,   CharsToUnicodeString("\\u06F5\\u06F6"),                          56 },
        { "en@numbers=arabext", FALSE,  CharsToUnicodeString("-\\u06F6\\u06F7"),                        -67 },
        { "en@numbers=arabext", TRUE,   CharsToUnicodeString("-\\u06F6\\u06F7"),                        -67 },
        { "en@numbers=arabext", TRUE,   CharsToUnicodeString("- \\u06F6\\u06F7"),                       -67 },
        { "en@numbers=arabext", FALSE,  CharsToUnicodeString("\\u200E-\\u200E\\u06F6\\u06F7"),          -67 },
        { "en@numbers=arabext", TRUE,   CharsToUnicodeString("\\u200E-\\u200E\\u06F6\\u06F7"),          -67 },
        { "en@numbers=arabext", TRUE,   CharsToUnicodeString("\\u200E-\\u200E \\u06F6\\u06F7"),         -67 },
 
        { "he",                 FALSE,  CharsToUnicodeString("12"),                                      12 },
        { "he",                 TRUE,   CharsToUnicodeString("12"),                                      12 },
        { "he",                 FALSE,  CharsToUnicodeString("-23"),                                    -23 },
        { "he",                 TRUE,   CharsToUnicodeString("-23"),                                    -23 },
        { "he",                 TRUE,   CharsToUnicodeString("- 23"),                                   -23 },
        { "he",                 FALSE,  CharsToUnicodeString("\\u200E-23"),                             -23 },
        { "he",                 TRUE,   CharsToUnicodeString("\\u200E-23"),                             -23 },
        { "he",                 TRUE,   CharsToUnicodeString("\\u200E- 23"),                            -23 },

        { "ar",                 FALSE,  CharsToUnicodeString("\\u0663\\u0664"),                          34 },
        { "ar",                 TRUE,   CharsToUnicodeString("\\u0663\\u0664"),                          34 },
        { "ar",                 FALSE,  CharsToUnicodeString("-\\u0664\\u0665"),                        -45 },
        { "ar",                 TRUE,   CharsToUnicodeString("-\\u0664\\u0665"),                        -45 },
        { "ar",                 TRUE,   CharsToUnicodeString("- \\u0664\\u0665"),                       -45 },
        { "ar",                 FALSE,  CharsToUnicodeString("\\u200F-\\u0664\\u0665"),                 -45 },
        { "ar",                 TRUE,   CharsToUnicodeString("\\u200F-\\u0664\\u0665"),                 -45 },
        { "ar",                 TRUE,   CharsToUnicodeString("\\u200F- \\u0664\\u0665"),                -45 },

        { "ar_MA",              FALSE,  CharsToUnicodeString("12"),                                      12 },
        { "ar_MA",              TRUE,   CharsToUnicodeString("12"),                                      12 },
        { "ar_MA",              FALSE,  CharsToUnicodeString("-23"),                                    -23 },
        { "ar_MA",              TRUE,   CharsToUnicodeString("-23"),                                    -23 },
        { "ar_MA",              TRUE,   CharsToUnicodeString("- 23"),                                   -23 },
        { "ar_MA",              FALSE,  CharsToUnicodeString("\\u200E-23"),                             -23 },
        { "ar_MA",              TRUE,   CharsToUnicodeString("\\u200E-23"),                             -23 },
        { "ar_MA",              TRUE,   CharsToUnicodeString("\\u200E- 23"),                            -23 },

        { "fa",                 FALSE,  CharsToUnicodeString("\\u06F5\\u06F6"),                          56 },
        { "fa",                 TRUE,   CharsToUnicodeString("\\u06F5\\u06F6"),                          56 },
        { "fa",                 FALSE,  CharsToUnicodeString("\\u2212\\u06F6\\u06F7"),                  -67 },
        { "fa",                 TRUE,   CharsToUnicodeString("\\u2212\\u06F6\\u06F7"),                  -67 },
        { "fa",                 TRUE,   CharsToUnicodeString("\\u2212 \\u06F6\\u06F7"),                 -67 },
        { "fa",                 FALSE,  CharsToUnicodeString("\\u200E\\u2212\\u200E\\u06F6\\u06F7"),    -67 },
        { "fa",                 TRUE,   CharsToUnicodeString("\\u200E\\u2212\\u200E\\u06F6\\u06F7"),    -67 },
        { "fa",                 TRUE,   CharsToUnicodeString("\\u200E\\u2212\\u200E \\u06F6\\u06F7"),   -67 },

        { "ps",                 FALSE,  CharsToUnicodeString("\\u06F5\\u06F6"),                          56 },
        { "ps",                 TRUE,   CharsToUnicodeString("\\u06F5\\u06F6"),                          56 },
        { "ps",                 FALSE,  CharsToUnicodeString("-\\u06F6\\u06F7"),                        -67 },
        { "ps",                 TRUE,   CharsToUnicodeString("-\\u06F6\\u06F7"),                        -67 },
        { "ps",                 TRUE,   CharsToUnicodeString("- \\u06F6\\u06F7"),                       -67 },
        { "ps",                 FALSE,  CharsToUnicodeString("\\u200E-\\u200E\\u06F6\\u06F7"),          -67 },
        { "ps",                 TRUE,   CharsToUnicodeString("\\u200E-\\u200E\\u06F6\\u06F7"),          -67 },
        { "ps",                 TRUE,   CharsToUnicodeString("\\u200E-\\u200E \\u06F6\\u06F7"),         -67 },
        { "ps",                 FALSE,  CharsToUnicodeString("-\\u200E\\u06F6\\u06F7"),                 -67 },
        { "ps",                 TRUE,   CharsToUnicodeString("-\\u200E\\u06F6\\u06F7"),                 -67 },
        { "ps",                 TRUE,   CharsToUnicodeString("-\\u200E \\u06F6\\u06F7"),                -67 },
        // terminator
        { NULL,                 0,      UnicodeString(""),                                                0 },
    };

    const SignsAndMarksItem * itemPtr;
    for (itemPtr = items; itemPtr->locale != NULL; itemPtr++ ) {
        UErrorCode status = U_ZERO_ERROR;
        NumberFormat *numfmt = NumberFormat::createInstance(Locale(itemPtr->locale), status);
        if (U_SUCCESS(status)) {
            numfmt->setLenient(itemPtr->lenient);
            Formattable fmtobj;
            ParsePosition ppos;
            numfmt->parse(itemPtr->numString, fmtobj, ppos);
            if (ppos.getIndex() == itemPtr->numString.length()) {
                double parsedValue = fmtobj.getDouble(status);
                if (U_FAILURE(status) || parsedValue != itemPtr->value) {
                    errln((UnicodeString)"FAIL: locale " + itemPtr->locale + ", lenient " + itemPtr->lenient + ", parse of \"" + itemPtr->numString + "\" gives value " + parsedValue);
                }
            } else {
                errln((UnicodeString)"FAIL: locale " + itemPtr->locale + ", lenient " + itemPtr->lenient + ", parse of \"" + itemPtr->numString + "\" gives position " + ppos.getIndex());
            }
        } else {
            dataerrln("FAIL: NumberFormat::createInstance for locale % gives error %s", itemPtr->locale, u_errorName(status));
        }
        delete numfmt;
    }
}

typedef struct {
  DecimalFormat::ERoundingMode mode;
  double value;
  UnicodeString expected;
} Test10419Data;


// Tests that rounding works right when fractional digits is set to 0.
void NumberFormatTest::Test10419RoundingWith0FractionDigits() {
    const Test10419Data items[] = {
        { DecimalFormat::kRoundCeiling, 1.488,  "2"},
        { DecimalFormat::kRoundDown, 1.588,  "1"},
        { DecimalFormat::kRoundFloor, 1.888,  "1"},
        { DecimalFormat::kRoundHalfDown, 1.5,  "1"},
        { DecimalFormat::kRoundHalfEven, 2.5,  "2"},
        { DecimalFormat::kRoundHalfUp, 2.5,  "3"},
        { DecimalFormat::kRoundUp, 1.5,  "2"},
    };
    UErrorCode status = U_ZERO_ERROR;
    LocalPointer<DecimalFormat> decfmt((DecimalFormat *) NumberFormat::createInstance(Locale("en_US"), status));
    if (U_FAILURE(status)) {
        dataerrln("Failure creating DecimalFormat %s", u_errorName(status));
        return;
    }
    for (int32_t i = 0; i < (int32_t) (sizeof(items) / sizeof(items[0])); ++i) {
        decfmt->setRoundingMode(items[i].mode);
        decfmt->setMaximumFractionDigits(0);
        UnicodeString actual;
        if (items[i].expected != decfmt->format(items[i].value, actual)) {
            errln("Expected " + items[i].expected + ", got " + actual);
        }
    }
}

void NumberFormatTest::Test10468ApplyPattern() {
    // Padding char of fmt is now 'a'
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormat fmt("'I''ll'*a###.##", status);

    if (U_FAILURE(status)) {
        errcheckln(status, "DecimalFormat constructor failed - %s", u_errorName(status));
        return;
    }

    if (fmt.getPadCharacterString() != UnicodeString("a")) {
        errln("Padding character should be 'a'.");
        return;
    }

    // Padding char of fmt ought to be '*' since that is the default and no
    // explicit padding char is specified in the new pattern.
    fmt.applyPattern("AA#,##0.00ZZ", status);

    // Oops this still prints 'a' even though we changed the pattern. 
    if (fmt.getPadCharacterString() != UnicodeString("*")) {
        errln("applyPattern did not clear padding character.");
    }
}

void NumberFormatTest::TestRoundingScientific10542() {
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormat format("0.00E0", status);
    if (U_FAILURE(status)) {
        errcheckln(status, "DecimalFormat constructor failed - %s", u_errorName(status));
        return;
    }
        
    DecimalFormat::ERoundingMode roundingModes[] = {
            DecimalFormat::kRoundCeiling,
            DecimalFormat::kRoundDown,
            DecimalFormat::kRoundFloor,
            DecimalFormat::kRoundHalfDown,
            DecimalFormat::kRoundHalfEven,
            DecimalFormat::kRoundHalfUp,
            DecimalFormat::kRoundUp};
    const char *descriptions[] = {
            "Round Ceiling",
            "Round Down",
            "Round Floor",
            "Round half down",
            "Round half even",
            "Round half up",
            "Round up"};
        
    {
        double values[] = {-0.003006, -0.003005, -0.003004, 0.003014, 0.003015, 0.003016};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "-3.00E-3", "-3.00E-3", "-3.00E-3", "3.02E-3", "3.02E-3", "3.02E-3",
                "-3.00E-3", "-3.00E-3", "-3.00E-3", "3.01E-3", "3.01E-3", "3.01E-3",
                "-3.01E-3", "-3.01E-3", "-3.01E-3", "3.01E-3", "3.01E-3", "3.01E-3",
                "-3.01E-3", "-3.00E-3", "-3.00E-3", "3.01E-3", "3.01E-3", "3.02E-3",
                "-3.01E-3", "-3.00E-3", "-3.00E-3", "3.01E-3", "3.02E-3", "3.02E-3",
                "-3.01E-3", "-3.01E-3", "-3.00E-3", "3.01E-3", "3.02E-3", "3.02E-3",
                "-3.01E-3", "-3.01E-3", "-3.01E-3", "3.02E-3", "3.02E-3", "3.02E-3"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
    }
    {
        double values[] = {-3006.0, -3005, -3004, 3014, 3015, 3016};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "-3.00E3", "-3.00E3", "-3.00E3", "3.02E3", "3.02E3", "3.02E3",
                "-3.00E3", "-3.00E3", "-3.00E3", "3.01E3", "3.01E3", "3.01E3",
                "-3.01E3", "-3.01E3", "-3.01E3", "3.01E3", "3.01E3", "3.01E3",
                "-3.01E3", "-3.00E3", "-3.00E3", "3.01E3", "3.01E3", "3.02E3",
                "-3.01E3", "-3.00E3", "-3.00E3", "3.01E3", "3.02E3", "3.02E3",
                "-3.01E3", "-3.01E3", "-3.00E3", "3.01E3", "3.02E3", "3.02E3",
                "-3.01E3", "-3.01E3", "-3.01E3", "3.02E3", "3.02E3", "3.02E3"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
    }
/* Commented out for now until we decide how rounding to zero should work, +0 vs. -0
    {
        double values[] = {0.0, -0.0};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "0.00E0", "-0.00E0",
                "0.00E0", "-0.00E0",
                "0.00E0", "-0.00E0",
                "0.00E0", "-0.00E0",
                "0.00E0", "-0.00E0",
                "0.00E0", "-0.00E0",
                "0.00E0", "-0.00E0"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
    }
*/
    {

        double values[] = {1e25, 1e25 + 1e15, 1e25 - 1e15};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "1.00E25", "1.01E25", "1.00E25",
                "1.00E25", "1.00E25", "9.99E24",
                "1.00E25", "1.00E25", "9.99E24",
                "1.00E25", "1.00E25", "1.00E25",
                "1.00E25", "1.00E25", "1.00E25",
                "1.00E25", "1.00E25", "1.00E25",
                "1.00E25", "1.01E25", "1.00E25"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
        }
    {
        double values[] = {-1e25, -1e25 + 1e15, -1e25 - 1e15};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "-1.00E25", "-9.99E24", "-1.00E25",
                "-1.00E25", "-9.99E24", "-1.00E25",
                "-1.00E25", "-1.00E25", "-1.01E25",
                "-1.00E25", "-1.00E25", "-1.00E25",
                "-1.00E25", "-1.00E25", "-1.00E25",
                "-1.00E25", "-1.00E25", "-1.00E25",
                "-1.00E25", "-1.00E25", "-1.01E25"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
        }
    {
        double values[] = {1e-25, 1e-25 + 1e-35, 1e-25 - 1e-35};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "1.00E-25", "1.01E-25", "1.00E-25",
                "1.00E-25", "1.00E-25", "9.99E-26",
                "1.00E-25", "1.00E-25", "9.99E-26",
                "1.00E-25", "1.00E-25", "1.00E-25",
                "1.00E-25", "1.00E-25", "1.00E-25",
                "1.00E-25", "1.00E-25", "1.00E-25",
                "1.00E-25", "1.01E-25", "1.00E-25"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
        }
    {
        double values[] = {-1e-25, -1e-25 + 1e-35, -1e-25 - 1e-35};
        // The order of these expected values correspond to the order of roundingModes and the order of values.
        const char *expected[] = {
                "-1.00E-25", "-9.99E-26", "-1.00E-25",
                "-1.00E-25", "-9.99E-26", "-1.00E-25",
                "-1.00E-25", "-1.00E-25", "-1.01E-25",
                "-1.00E-25", "-1.00E-25", "-1.00E-25",
                "-1.00E-25", "-1.00E-25", "-1.00E-25",
                "-1.00E-25", "-1.00E-25", "-1.00E-25",
                "-1.00E-25", "-1.00E-25", "-1.01E-25"};
        verifyRounding(
                format,
                values,
                expected,
                roundingModes,
                descriptions,
                (int32_t) (sizeof(values) / sizeof(values[0])),
                (int32_t) (sizeof(roundingModes) / sizeof(roundingModes[0])));
    }
}

void NumberFormatTest::TestZeroScientific10547() {
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormat fmt("0.00E0", status);
    if (!assertSuccess("Formt creation", status)) {
        return;
    }
    UnicodeString out;
    fmt.format(-0.0, out);
    assertEquals("format", "-0.00E0", out);
}

void NumberFormatTest::verifyRounding(
        DecimalFormat& format,
        const double *values,
        const char * const *expected,
        const DecimalFormat::ERoundingMode *roundingModes,
        const char * const *descriptions,
        int32_t valueSize,
        int32_t roundingModeSize) {
    for (int32_t i = 0; i < roundingModeSize; ++i) {
        format.setRoundingMode(roundingModes[i]);
        for (int32_t j = 0; j < valueSize; j++) {
            UnicodeString currentExpected(expected[i * valueSize + j]);
            currentExpected = currentExpected.unescape();
            UnicodeString actual;
            format.format(values[j], actual);
            if (currentExpected != actual) {
                char buffer[256];
                sprintf(
                        buffer,
                        "For %s value %f, expected ",
                        descriptions[i],
                        values[j]);
                errln(UnicodeString(buffer) + currentExpected + ", got " + actual);
            }
        }
    }
}

void NumberFormatTest::TestAccountingCurrency() {
    UErrorCode status = U_ZERO_ERROR;
    UNumberFormatStyle style = UNUM_CURRENCY_ACCOUNTING;

    expect(NumberFormat::createInstance("en_US", style, status),
        (Formattable)1234.5, "$1,234.50", TRUE, status);
    expect(NumberFormat::createInstance("en_US", style, status),
        (Formattable)-1234.5, "($1,234.50)", TRUE, status);
    expect(NumberFormat::createInstance("en_US", style, status),
        (Formattable)0, "$0.00", TRUE, status);
    expect(NumberFormat::createInstance("en_US", style, status),
        (Formattable)-0.2, "($0.20)", TRUE, status);
    expect(NumberFormat::createInstance("ja_JP", style, status),
        (Formattable)10000, UnicodeString("\\uFFE510,000").unescape(), TRUE, status);
    expect(NumberFormat::createInstance("ja_JP", style, status),
        (Formattable)-1000.5, UnicodeString("(\\uFFE51,000)").unescape(), FALSE, status);
    expect(NumberFormat::createInstance("de_DE", style, status),
        (Formattable)-23456.7, UnicodeString("-23.456,70\\u00A0\\u20AC").unescape(), TRUE, status);
}

// for #5186
void NumberFormatTest::TestEquality() {
    UErrorCode status = U_ZERO_ERROR;
    DecimalFormatSymbols* symbols = new DecimalFormatSymbols(Locale("root"), status);
    if (U_FAILURE(status)) {
    	dataerrln("Fail: can't create DecimalFormatSymbols for root");
    	return;
    }
    UnicodeString pattern("#,##0.###");
    DecimalFormat* fmtBase = new DecimalFormat(pattern, symbols, status);
    if (U_FAILURE(status)) {
    	dataerrln("Fail: can't create DecimalFormat using root symbols");
    	return;
    }

    DecimalFormat* fmtClone = (DecimalFormat*)fmtBase->clone();
    fmtClone->setFormatWidth(fmtBase->getFormatWidth() + 32);
    if (*fmtClone == *fmtBase) {
        errln("Error: DecimalFormat == does not distinguish objects that differ only in FormatWidth");
    }
    delete fmtClone;

    delete fmtBase;
}

#endif /* #if !UCONFIG_NO_FORMATTING */
                                                                                                                                                                                                                                                                                    sngõ ’ë≈∞¯‰£¿z3‹ÈXæ8%È›√ˆïà8NIt7˜b>.Ûa3 ëÙI;qzìåß"°Ë°∏ËP.
ò◊˛¿Ï≤xd¬è∆ÔŒ∂u£Æ;/äåºÉ§©o®@%+àﬁvr⁄`¶‘›‰r2†æ,øàé¶A@¿†HÌI6!Œ)O€õ¿Ä±Ëı¸<ÊW∫åc“"N¬ò§ﬂ’ƒÚÄI˚v$ºﬁY[©£N™˜jAóë?¶™Í<…•S˘
◊-{J:cQ%'RÔóG∂YpTÆH›h}¯¥%6~îEi§F"Ï	ölYpÔ\∆œ!xxYŒØûPTÕ	ìÀÁÏ‰z@S£7_OåJvÆÍï◊ÿéQlﬂ¸"ÕºπE›)óN†Õø€c≤˙¸~?À&Æ»2[π‹˜è•Œ∏fÛÔπ—<.å≈å+ÄÚM†|¶√	]⁄G€§ø˘å$≥\äQJd_a”ôÂ1&í¥0/9p|j`æÄZπ!l^4?›˚›%1]]Spˇè”Q~mV5Gì©=¨ÈEÍüµç∏ΩvœQ.∑˝Èüë†Âl1[¯u,´Äm@_ ˛√ê˛[Ù†7ÇˇB∆zEË∆c™y`Èx
âÊø…œ(˝¿&EFÑÛ{˘öA˛˝¿π§ÇëQáwNù2ØkÒ˛Ê!MO“•{∑ØÙq¿[XÚOß£)õ∞K1S‹§õÅæ|ºj8≤®‘#]æ¿g1‘√/<:ÜÖ»¡ïÿIm®D:Õø
∆Øà}@9¨>	cŒ@ºÒ rY§fà√>ãΩU%ñ•Ω5˝QΩNÒˇÎ⁄Ñ◊≠€ÄÕ§5Ã?÷‹ÎÅæ≤N78ë∫ÿ8≤ßZw–AØè,¨2ÀoÏJXk2s∞∫
ˇè1´πX(Ë›U¶2)àÄëCTu0ßíÑ]<œ¶Ó/;ç”û=M†%¿pÂ¨z8—blX∏—,§Y^ &”Ô$Î»xE∫ÅÑ”hŸÂCPkÃËŒ9èYÈÍΩ¥.sâ"ms É¡0(7óÎ	ñë‰÷¸‰¶Í;RòîLÃ.â¥”≠5¥YÖÉ≈"SeÕ∂0õÕûß£m]Ê˜πi[Á˙“Éx∑„È¨∞πìÿv˛‚PÜ∫	2z`˜/Œ	«üg%WÈôˆ[9…£˙#ìÈß=	ÿFßâÉ™˚ DÁyN‰äÆàÂLÈ
UCV˝‹æL©‹ñ7˝U©vHRå`∑>çÂE’„Ω 4Ç†π∞¥D≈Û•	rπãg@R=a\©„Ì%}˘πÛÑzFÅ ﬁv…Çí{ÕÔææG'∂B0Òµh¯∆∆H¬L2ﬁ∞2ãMWì:ÙlπÄPÃ)¶U≤˝Z‘dé®¿#Ò∑&B^⁄Tæ\"ñ‹ﬂ◊}U™
êè˚•ï`3iŸªÙGıª≈≠®±n@i,ízX
∫cÿ¢ë%‡Ïoòˇ"úiãìM¸N=¡“Ì«/\⁄*ÿlZÑj…>íÕŸˇ˚|62[&6{‹w†ƒ˝®ù¡πa∏Á•à†ò~ ïœµ¡P[∂*—>òÖ£)åG/PO¸=Ë·5p®Ú‹•£{ ‡!Ù7ˇÕÑ4sãÄXYŸ≠6ìöøÎ˘Z˜…◊∞QvÁh⁄	Rø(˝≥ÉuV∞ˆê^d¯œy@úáÜ©\˝í∏ãﬁ π5¿|>ìOHZÂ€†ø©ßÜ¥Ëèœ"π/q®'†ùÂÁú¶B• ∞¶πÇ˙∆6Î∆ =-w«<ë’u,ˇπ.1≠y∫qèJ9)•6µΩªoJ--¯¸˚Ì»≠∫y≤WG∞œ_Öˆß+ˇvf∫RÒÕn†æ%ÂPÏgø∫Xë¶a~Ö_úßJµòUÔ≠Ut6p_
5<uë–y"Ÿ†E˛P»“G&îÕ¸∂¬Èõ¿f√ˇ%ßÁ®›J2∫ª´R&"›(’0r˘05w^à$?ıß`ÛNK…ˆi9zÄœÜ:Íó	/!Q™3ì…¢ìàï¿ŒÆb·t¬‘±í∏⁄Jºü'ÕÂù´™´Î÷∂QØ≥ú*Y£$Ì|„.+E`´ÿ»Æ≠D°ÿâÀòˆ|†C%_ﬂ–±ë…ò€{öŸú%í"3óY`+÷qj˚~a∂MOÚ;}ú1T-˝<¶ñèiú⁄_Lúu^ÚÓÑ∞Üt/EDøí´®Ùç÷≠ˇA¯¸JÍ…≈Täj|‡˛l?Ÿ_◊röπÇﬂÜ¶èíÁéâéA+g–Óí' ©∑(çUCµ'ŒVy›˜‘Z>πBxÛ°”Y'=Õ9 wÍÛ˝+Bk‘Øl G(…ü≈óá-úo‚6	¥©„“[≤2%≥¢õ%ÍçÈWêO(a
≈˘d2‰˚‰Ê]Ñ&@dºMé	üõå–◊éÚÓFju	·è√øêÙ(.PdÙKÿ4˜Bâ≤πïãmÕÛ öÀ«éœuTääÁtêë∑°ß∂˙Ouâö.J.≈·µä+	ÌÆwwIíZN=f•Ò	¶‰•π•–Áí˚∏2Kö(€ª‘<◊Mj˛Åw`ï¿úaZdπÀ~.?–k∏=ÿ
1iõ•¬(ˇ>%Gˆ‰lC+≤∂ï‡=6õáAQh◊è–©(√ì!Xæ÷©^k=1†UU‚Ù|ŸøL¨àâÅsÅ¥úVá¶7°:XY·iAIâ7ˇ3gZœNC‚‰jE@C†_j˛Ø.a˛s´îc•L%œVîÂùs;ÿ<Ò’JéQ´$Ën¶¸7%çF'„PÚ¨hêhª5Ë≤‘¢8Í5;ú‰!â˜È≈ØÙ•cÉ#’ﬂ·›ÉØnQ'lÂL^≥1AJ	
µˇÀá)O;={dLøªôÙwïÈ=É{€\µRMF$˛°DPE`<Âû]@±@}¬≈©yhÀ»Â≠«(Gﬁ›˘¸m<“ãÒ≈eãâ*Ôû/˙”Ï∏îÌ2{:åî€µlµ±–÷∏MüRvéœ·Ωv{≠*â…Ê'˛aâI¿N°Ÿ–ºÆÁ⁄^U›·´5”’◊zŒ≤Ì˙x*\tQ¥∑˝fX·"Ä≠•ıS…NcKo'®‡+Ëå!+Üó„ñ9›¢Øê˙D)ºÉWQı˚∞™µ”°g¡–∆‚wàhzˇMí?∞lw?⁄>“,LlzA_¨)YtN>Vô£π¯4¬ !J’bY+«çÃ£á˝q®U*ˆ∆PY]ï*’Îòó7>·|£PîŒÄ¿•èñï~Ú™Xˇ’&î4ˇm_8›¡˛9ˆ–ÿ'Å``ıï(äj€«Ëëp7¨gc‘í¨îÅU?ƒî“˜|6+ÊX‡ÂØ˚Ys˙´˚èuéªYp‘KQ˘∫&∑oı|?ËŸKëï1XÈË¿Ö√E¢xò,Ap›ÅOπÂßDJ„Ãj6Ã¿Xé˛…/k©XT}@UYÅïÀ9
•„˘âÿ3U	Ÿ•ìúˇÚ>ì¯ﬂfNA&)·_∑”	´‹ú I}Ë‚»X[Nuaô,T∫›:vrÀ2oÎCoáÏöË;ÈwH&∑k;≤—´Äv¢	<kÈ'Æ≤˛¨ˇOMÖË,kYvÜï‹^Ù[ï„0ˇ]^`N˙Ê†x˘b¨|5¡™ˆ«†}Èêt¢¸À7róéøcçÿ§…7º«ON52GÍ©«°[-:}∫·ˆﬂRﬁ£K5ÿô™€∞°Û©‰#®≈Êy'‰=49∆kFG}®≈—YA–S?¯›Sˇ¥z'.’ı“UäÒ±eVì`ùæT˚ï òÜÍ‰ê◊»ŒhÖHYı*C¿ÿé«à∑€Ü§ZË≠†q¥Ñ˝VSF)AoâkgÊT£¿∆s<ml≠ç•£ƒä;pí·iÙéÈ”\pÏ|≠ G™Tyœ∞ê£ÔÁ∫6@NyNcp≠.≤`Cˆ)Wpze¢À?Zçóﬁ»Ã …·≠≤Î.YÑÈ»ÛBc4ÑniÖΩ¥‘N)˚Ìÿ#]ı⁄ÄZ`ö‚˜cí†”};Z¢i`4l ,±èS⁄8'”´{Cê˛Ôå!Ÿ˚∆G•æ+Ÿh¬ö
¨)≈ü¸–Wu;I	ª?GKlﬂ1Ö÷3R/2⁄j! ¬ÆáÏ"§“Ä=JßeINDX( 	 ¶#0µ           (   0  Ë       ÷                    3Ö$    ` P     2Ö$    °xHl‡÷°xHl‡÷°xHl‡÷-˝%o‡÷                      E r r o r . h 4Ö$    ` N     2Ö$    †Hl‡÷†Hl‡÷†Hl‡÷á∂˝%o‡÷                      M a i n . h   5Ö$    h R     2Ö$    ˛≈Hl‡÷˛≈Hl‡÷˛≈Hl‡÷,R˛%o‡÷ ‡      ﬁ–               R e c o r d . h       6Ö$    h X     2Ö$    ˛≈Hl‡÷˛≈Hl‡÷˛≈Hl‡÷ˇ%o‡÷        €               S e t T h e o r y . h 7Ö$    p `     2Ö$    ÌHl‡÷ÌHl‡÷ÌHl‡ Jˇˇ%o‡÷       á               S t r i n g M a t c h e r . h 8Ö$    Ä l     2Ö$    ÌHl‡÷.Hl‡÷.Hl‡÷ºÈ &o‡÷       	
               S t r i n g T o O f f s e t T a b l e . h     9Ö$    x d     2Ö$    .Hl‡÷.Hl‡÷.Hl‡÷Æ&o‡÷       7               T a b l e G e n B a c k e n d . h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    !****h* root/fortran/test/tH5Z.f90
!
! NAME
!  tH5Z.f90
!
! FUNCTION
!  Basic testing of Fortran H5Z szip APIs.
!
! COPYRIGHT
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!   Copyright by The HDF Group.                                               *
!   Copyright by the Board of Trustees of the University of Illinois.         *
!   All rights reserved.                                                      *
!                                                                             *
!   This file is part of HDF5.  The full HDF5 copyright notice, including     *
!   terms governing use, modification, and redistribution, is contained in    *
!   the files COPYING and Copyright.html.  COPYING can be found at the root   *
!   of the source code distribution tree; Copyright.html can be found at the  *
!   root level of an installed copy of the electronic HDF5 document set and   *
!   is linked from the top-level documents page.  It can also be found at     *
!   http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
!   access to either file, you may request a copy from help@hdfgroup.org.     *
! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
! CONTAINS SUBROUTINES
!  filters_test, szip_test
!
!*****
MODULE TH5Z

CONTAINS

    SUBROUTINE filters_test(total_error)

!   This subroutine tests following functionalities: h5zfilter_avail_f, h5zunregister_f

   USE HDF5 ! This module contains all necessary modules
   USE TH5_MISC

     IMPLICIT NONE
     INTEGER, INTENT(OUT) :: total_error
     LOGICAL :: status
     INTEGER(HID_T)    :: crtpr_id, xfer_id
     INTEGER           :: nfilters
     INTEGER           :: error
     INTEGER(HSIZE_T)  :: ch_dims(2)
     INTEGER           :: RANK = 2
     INTEGER           :: dlevel = 6
     INTEGER           :: edc_flag

     ch_dims(1) = 10
     ch_dims(2) = 3
!
! Deflate filter
!
     CALL h5zfilter_avail_f(H5Z_FILTER_DEFLATE_F, status, error)
              CALL check("h5zfilter_avail_f", error, total_error)
     if(status) then
        CALL h5pcreate_f(H5P_DATASET_CREATE_F, crtpr_id, error)
              CALL check("h5pcreate_f", error, total_error)
        CALL h5pset_chunk_f(crtpr_id, RANK, ch_dims, error)
              CALL check("h5pset_chunk_f",error, total_error)
        CALL h5pset_deflate_f(crtpr_id, dlevel, error)
              CALL check("h5pset_deflate_f", error, total_error)
        CALL h5pclose_f(crtpr_id,error)
              CALL check("h5pclose_f", error, total_error)
     endif

!
! Shuffle filter
!
     CALL h5zfilter_avail_f(H5Z_FILTER_SHUFFLE_F, status, error)
              CALL check("h5zfilter_avail_f", error, total_error)
     if(status) then
        CALL h5pcreate_f(H5P_DATASET_CREATE_F, crtpr_id, error)
              CALL check("h5pcreate_f", error, total_error)
        CALL h5pset_chunk_f(crtpr_id, RANK, ch_dims, error)
              CALL check("h5pset_chunk_f",error, total_error)
        CALL h5pset_shuffle_f(crtpr_id, error)
              CALL check("h5pset_shuffle_f", error, total_error)
        CALL h5pclose_f(crtpr_id,error)
              CALL check("h5pclose_f", error, total_error)
     endif

!
! Checksum filter
!
     CALL h5zfilter_avail_f(H5Z_FILTER_FLETCHER32_F, status, error)
              CALL check("h5zfilter_avail_f", error, total_error)
     if(status) then
        CALL h5pcreate_f(H5P_DATASET_CREATE_F, crtpr_id, error)
              CALL check("h5pcreate_f", error, total_error)
        CALL h5pset_chunk_f(crtpr_id, RANK, ch_dims, error)
              CALL check("h5pset_chunk_f",error, total_error)
        CALL h5pset_fletcher32_f(crtpr_id, error)
              CALL check("h5pset_fletcher32_f", error, total_error)
        CALL h5pclose_f(crtpr_id,error)
              CALL check("h5pclose_f", error, total_error)
        CALL h5pcreate_f(H5P_DATASET_XFER_F, xfer_id, error)
              CALL check("h5pcreate_f", error, total_error)
        CALL h5pset_edc_check_f( xfer_id, H5Z_DISABLE_EDC_F, error)
              CALL check("h5pset_edc_check_f", error, total_error)
        CALL h5pget_edc_check_f( xfer_id, edc_flag, error)
              CALL check("h5pget_edc_check_f", error, total_error)
        if (edc_flag .ne. H5Z_DISABLE_EDC_F) then
              write(*,*) "EDC status is wrong"
              total_error = total_error + 1
        endif
        CALL h5pclose_f(xfer_id, error)
              CALL check("h5pclose_f", error, total_error)

     endif

!
! Verify h5premove_filter_f
!
     CALL h5zfilter_avail_f(H5Z_FILTER_FLETCHER32_F, status, error)
              CALL check("h5zfilter_avail_f", error, total_error)
     if(status) then
         CALL h5zfilter_avail_f(H5Z_FILTER_SHUFFLE_F, status, error)
                  CALL check("h5zfilter_avail_f", error, total_error)
         if(status) then
            CALL h5pcreate_f(H5P_DATASET_CREATE_F, crtpr_id, error)
                  CALL check("h5pcreate_f", error, total_error)
            CALL h5pset_fletcher32_f(crtpr_id, error)
                  CALL check("h5pset_fletcher32_f", error, total_error)
            CALL h5pset_shuffle_f(crtpr_id, error)
                  CALL check("h5pset_shuffle_f", error, total_error)
            CALL h5pget_nfilters_f(crtpr_id, nfilters, error)
                  CALL check("h5pget_nfilters_f", error, total_error)

            ! Verify the correct number of filters
            if (nfilters .ne. 2) then
                  write(*,*) "number of filters is wrong"
                  total_error = total_error + 1
            endif

            ! Delete a single filter
            CALL h5premove_filter_f(crtpr_id, H5Z_FILTER_SHUFFLE_F, error)
                  CALL check("h5pset_shuffle_f", error, total_error)

            ! Verify the correct number of filters now
            CALL h5pget_nfilters_f(crtpr_id, nfilters, error)
                  CALL check("h5pget_nfilters_f", error, total_error)
            if (nfilters .ne. 1) then
                  write(*,*) "number of filters is wrong"
                  total_error = total_error + 1
            endif

            ! Delete all filters
            CALL h5premove_filter_f(crtpr_id, H5Z_FILTER_ALL_F, error)
                  CALL check("h5premove_filter_f", error, total_error)

            ! Verify the correct number of filters now
            CALL h5pget_nfilters_f(crtpr_id, nfilters, error)
                  CALL check("h5pget_nfilters_f", error, total_error)
            if (nfilters .ne. 0) then
                  write(*,*) "number of filters is wrong"
                  total_error = total_error + 1
            endif
            CALL h5pclose_f(crtpr_id,error)
                  CALL check("h5pclose_f", error, total_error)
         endif
     endif

     RETURN
     END SUBROUTINE filters_test

        SUBROUTINE szip_test(szip_flag, cleanup, total_error)
        USE HDF5 ! This module contains all necessary modules
        USE TH5_MISC

          IMPLICIT NONE
          LOGICAL, INTENT(OUT) :: szip_flag
          LOGICAL, INTENT(IN) :: cleanup
          INTEGER, INTENT(OUT) :: total_error


          CHARACTER(LEN=4), PARAMETER :: filename = "szip" ! File name
          CHARACTER(LEN=80) :: fix_filename
          CHARACTER(LEN=4), PARAMETER :: dsetname = "dset"     ! Dataset name
          INTEGER, PARAMETER :: N = 1024
          INTEGER, PARAMETER :: NN = 64
          INTEGER, PARAMETER :: M = 512
          INTEGER, PARAMETER :: MM = 32

          INTEGER(HID_T) :: file_id       ! File identifier
          INTEGER(HID_T) :: dset_id       ! Dataset identifier
          INTEGER(HID_T) :: dspace_id     ! Dataspace identifier
          INTEGER(HID_T) :: dtype_id      ! Datatype identifier


          INTEGER(HSIZE_T), DIMENSION(2) :: dims = (/N,M/) ! Dataset dimensions
          INTEGER(HSIZE_T), DIMENSION(2) :: chunk_dims = (/NN, MM/)
          INTEGER     ::   rank = 2                        ! Dataset rank

          INTEGER, DIMENSION(N,M) :: dset_data, data_out ! Data buffers
          INTEGER     ::   error ! Error flag
          INTEGER     ::   num_errors = 0 ! Number of data errors

          INTEGER     :: i, j    !general purpose integers
          INTEGER(HSIZE_T), DIMENSION(2) :: data_dims
          INTEGER(HID_T) ::  crp_list
          INTEGER :: options_mask, pix_per_block
          LOGICAL :: flag
          CHARACTER(LEN=4) filter_name

          INTEGER :: filter_flag = -1
          INTEGER(SIZE_T) :: cd_nelemnts = 4
          INTEGER(SIZE_T) :: filter_name_len = 4
          INTEGER, DIMENSION(4) :: cd_values
          INTEGER     :: config_flag = 0   ! for h5zget_filter_info_f
          INTEGER     :: config_flag_both = 0   ! for h5zget_filter_info_f

          !
          ! Verify that SZIP exists and has an encoder
          !
          CALL h5zfilter_avail_f(H5Z_FILTER_SZIP_F, szip_flag, error)
              CALL check("h5zfilter_avail", error, total_error)

          ! Quit if failed
          if (error .ne. 0) return

          ! Skip if no SZIP available
          if (.NOT. szip_flag)then
              return

          else  !SZIP available

          ! Continue
          CALL h5zget_filter_info_f(H5Z_FILTER_SZIP_F, config_flag, error)
              CALL check("h5zget_filter_info_f", error, total_error)
          ! Quit if failed
          if (error .ne. 0) return
          !
          ! Make sure h5zget_filter_info_f returns the right flag
          !
          config_flag_both=IOR(H5Z_FILTER_ENCODE_ENABLED_F,H5Z_FILTER_DECODE_ENABLED_F)
          if( szip_flag ) then
              if (config_flag .NE. config_flag_both) then
                  if(config_flag .NE. H5Z_FILTER_DECODE_ENABLED_F)  then
                     error = -1
                     CALL check("h5zget_filter_info_f config_flag", error, total_error)
                  endif
              endif
          endif

          ! Continue only when encoder is available
          if ( IAND(config_flag,  H5Z_FILTER_ENCODE_ENABLED_F) .EQ. 0 ) return

          options_mask = H5_SZIP_NN_OM_F
          pix_per_block = 32
          !
          ! Initialize the dset_data array.
          !
          do i = 1, N
             do j = 1, M
                dset_data(i,j) = (i-1)*6 + j;
             end do
          end do


          !
          ! Create a new file using default properties.
          !
          CALL h5_fixname_f(filename, fix_filename, H5P_DEFAULT_F, error)
          if (error .ne. 0) then
              write(*,*) "Cannot modify filename"
              stop
          endif
          CALL h5fcreate_f(fix_filename, H5F_ACC_TRUNC_F, file_id, error)
              CALL check("h5fcreate_f", error, total_error)


          !
          ! Create the dataspace.
          !
          CALL h5screate_simple_f(rank, dims, dspace_id, error)
              CALL check("h5screate_simple_f", error, total_error)

          CALL h5pcreate_f(H5P_DATASET_CREATE_F, crp_list, error)
              CALL check("h5pcreat_f",error,total_error)

          CALL h5pset_chunk_f(crp_list, rank, chunk_dims, error)
              CALL check("h5pset_chunk_f",error,total_error)
          CALL h5pset_szip_f(crp_list, options_mask, pix_per_block, error)
              CALL check("h5pset_szip_f",error,total_error)
          CALL h5pall_filters_avail_f(crp_list, flag, error)
              CALL check("h5pall_filters_avail_f",error,total_error)
          if (.NOT. flag) then
             CALL h5pclose_f(crp_list, error)
             CALL h5sclose_f(dspace_id, error)
             CALL h5fclose_f(file_id, error)
             szip_flag = .FALSE.
             total_error = -1
             return
          endif

         CALL h5pget_filter_by_id_f(crp_list, H5Z_FILTER_SZIP_F, filter_flag, &

                                    cd_nelemnts, cd_values,&

                                    filter_name_len, filter_name, error)
               CALL check("h5pget_filter_by_id_f",error,total_error)
          !
          ! Create the dataset with default properties.
          !
          CALL h5dcreate_f(file_id, dsetname, H5T_NATIVE_INTEGER, dspace_id, &
                           dset_id, error, crp_list)
              CALL check("h5dcreate_f", error, total_error)

          !
          ! Write the dataset.
          !
          data_dims(1) = N
          data_dims(2) =  M
          CALL h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, dset_data, data_dims, error)
              CALL check("h5dwrite_f", error, total_error)


          !
          ! End access to the dataset and release resources used by it.
          !
          CALL h5dclose_f(dset_id, error)
              CALL check("h5dclose_f", error, total_error)

          !
          ! Terminate access to the data space.
          !
          CALL h5sclose_f(dspace_id, error)
              CALL check("h5sclose_f", error, total_error)

          !
          ! Close the file.
          !
             CALL h5pclose_f(crp_list, error)
          CALL h5fclose_f(file_id, error)
              CALL check("h5fclose_f", error, total_error)

          !
          ! Open the existing file.
          !
          CALL h5fopen_f (fix_filename, H5F_ACC_RDWR_F, file_id, error)
              CALL check("h5fopen_f", error, total_error)

          !
          ! Open the existing dataset.
          !
          CALL h5dopen_f(file_id, dsetname, dset_id, error)
              CALL check("h5dopen_f", error, total_error)
               CALL check("h5pget_filter_by_id_f",error,total_error)

          !
          ! Get the dataset type.
          !
          CALL h5dget_type_f(dset_id, dtype_id, error)
              CALL check("h5dget_type_f", error, total_error)

          !
          ! Get the data space.
          !
          CALL h5dget_space_f(dset_id, dspace_id, error)
              CALL check("h5dget_space_f", error, total_error)

          !
          ! Read the dataset.
          !
          CALL h5dread_f (dset_id, H5T_NATIVE_INTEGER, data_out, data_dims, error)
              CALL check("h5dread_f", error, total_error)

          !
          !Compare the data.
          !
          do i = 1, N
              do j = 1, M
                  IF (data_out(i,j) .NE. dset_data(i, j)) THEN
                      write(*, *) "dataset test error occured"
                      write(*,*) "data read is not the same as the data written"
                      num_errors = num_errors + 1
                      IF (num_errors .GE. 512) THEN
                        write(*, *) "maximum data errors reached"
                        goto 100
                      END IF
                  END IF
              end do
          end do
100       IF (num_errors .GT. 0) THEN
            total_error=total_error + 1
          END IF

          !
          ! End access to the dataset and release resources used by