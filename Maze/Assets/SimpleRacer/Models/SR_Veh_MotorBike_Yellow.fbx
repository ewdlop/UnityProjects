/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright by The HDF Group.                                               *
 * Copyright by the Board of Trustees of the University of Illinois.         *
 * All rights reserved.                                                      *
 *                                                                           *
 * This file is part of HDF5.  The full HDF5 copyright notice, including     *
 * terms governing use, modification, and redistribution, is contained in    *
 * the files COPYING and Copyright.html.  COPYING can be found at the root   *
 * of the source code distribution tree; Copyright.html can be found at the  *
 * root level of an installed copy of the electronic HDF5 document set and   *
 * is linked from the top-level documents page.  It can also be found at     *
 * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
 * access to either file, you may request a copy from help@hdfgroup.org.     *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifdef OLD_HEADER_FILENAME
#include <iostream.h>
#else
#include <iostream>
#endif
#include <string>

#include "H5Include.h"
#include "H5Exception.h"
#include "H5IdComponent.h"
#include "H5PropList.h"
#include "H5DataSpace.h"
#include "H5Object.h"
#include "H5FaccProp.h"
#include "H5FcreatProp.h"
#include "H5OcreatProp.h"
#include "H5DcreatProp.h"
#include "H5DxferProp.h"
#include "H5CommonFG.h"
#include "H5DataType.h"
#include "H5AtomType.h"
#include "H5PredType.h"
#include "H5private.h"
#include "H5AbstractDs.h"
#include "H5DataSet.h"
#include "H5File.h"
#include "H5Attribute.h"

namespace H5 {
#ifndef H5_NO_STD
    using std::cerr;
    using std::endl;
#endif  // H5_NO_STD

//--------------------------------------------------------------------------
// Function:	DataType default constructor
///\brief	Default constructor: Creates a stub datatype
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
DataType::DataType() : H5Object(), id(H5I_INVALID_HID) {}

//--------------------------------------------------------------------------
// Function:	DataType overloaded constructor
///\brief	Creates a datatype using an existing datatype's id
///\param	existing_id - IN: Id of the existing datatype
// Description
//		Constructor creates a copy of an existing DataType using
//		its id.
// Programmer	Binh-Minh Ribler - 2000
// Modification
//	Dec, 2005
//		Removed second argument, "predefined", after changing to the
//		new ref counting mechanism that relies on C's ref counting.
//--------------------------------------------------------------------------
DataType::DataType(const hid_t existing_id) : H5Object(), id(existing_id)
{
    incRefCount(); // increment number of references to this id
}

//--------------------------------------------------------------------------
// Function:	DataType overloaded constructor
///\brief	Creates a object given its class and size
///\param	type_class - IN: Class of datatype to create
///\param	size       - IN: Number of bytes in the datatype to create
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
DataType::DataType( const H5T_class_t type_class, size_t size ) : H5Object()
{
   // Call C routine to create the new datatype
   id = H5Tcreate( type_class, size );
   if( id < 0 )
   {
      throw DataTypeIException("DataType constructor", "H5Tcreate failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType overload constructor - dereference
///\brief	Given a reference, ref, to an hdf5 group, creates a
///		DataType object
///\param       loc - IN: Location referenced object is in
///\param	ref - IN: Reference pointer
///\param	ref_type - IN: Reference type - default to H5R_OBJECT
///\exception	H5::ReferenceException
// Programmer	Binh-Minh Ribler - Oct, 2006
// Modification
//	Jul, 2008
//		Added for application convenience.
//--------------------------------------------------------------------------
DataType::DataType(const H5Location& loc, const void* ref, H5R_type_t ref_type) : H5Object(), id(H5I_INVALID_HID)
{
    id = H5Location::p_dereference(loc.getId(), ref, ref_type, "constructor - by dereference");
}

//--------------------------------------------------------------------------
// Function:	DataType overload constructor - dereference
///\brief	Given a reference, ref, to an hdf5 group, creates a
///		DataType object
///\param       attr - IN: Specifying location where the referenced object is in
///\param	ref - IN: Reference pointer
///\param	ref_type - IN: Reference type - default to H5R_OBJECT
///\exception	H5::ReferenceException
// Programmer	Binh-Minh Ribler - Oct, 2006
// Modification
//	Jul, 2008
//		Added for application convenience.
//--------------------------------------------------------------------------
DataType::DataType(const Attribute& attr, const void* ref, H5R_type_t ref_type) : H5Object()
{
    id = H5Location::p_dereference(attr.getId(), ref, ref_type, "constructor - by dereference");
}

//--------------------------------------------------------------------------
// Function:	DataType copy constructor
///\brief	Copy constructor: makes a copy of the original DataType object.
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
DataType::DataType(const DataType& original) : H5Object(), id(original.id)
{
    incRefCount(); // increment number of references to this id
}

//--------------------------------------------------------------------------
// Function:    DataType overloaded constructor
///\brief       Creates a DataType instance using a predefined type
///\param       pred_type - IN: Predefined datatype
///\exception   H5::DataTypeIException
// Programmer   Binh-Minh Ribler - 2015
// Description
//		Copying the type so that when a predefined type is passed in,
//		a copy of it is made, not just a duplicate of the HDF5 id.
//		Note: calling DataType::copy will invoke DataType::close()
//		unnecessarily and will produce undefined behavior.
//		-BMR, Apr 2015
//--------------------------------------------------------------------------
DataType::DataType(const PredType& pred_type) : H5Object()
{
    // call C routine to copy the datatype
    id = H5Tcopy( pred_type.getId() );
    if (id < 0)
	throw DataTypeIException("DataType constructor", "H5Tcopy failed");
}

//--------------------------------------------------------------------------
// Function:	DataType::copy
///\brief	Copies an existing datatype to this datatype object
///\param	like_type - IN: Datatype to be copied
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
// Modification
//		- Replaced resetIdComponent() with decRefCount() to use C
//		library ID reference counting mechanism - BMR, Jun 1, 2004
//		- Replaced decRefCount with close() to let the C library
//		handle the reference counting - BMR, Jun 1, 2006
//--------------------------------------------------------------------------
void DataType::copy( const DataType& like_type )
{
    // close the current data type before copying like_type to this object
    try {
	close();
    }
    catch (Exception& close_error) {
	throw DataTypeIException(inMemFunc("copy"), close_error.getDetailMsg());
    }

    // call C routine to copy the datatype
    id = H5Tcopy( like_type.getId() );
    if( id < 0 )
	throw DataTypeIException(inMemFunc("copy"), "H5Tcopy failed");
}

//--------------------------------------------------------------------------
// Function:	DataType::copy
///\brief	Copies the datatype of the given dataset to this datatype object
///\param	dset - IN: Dataset
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - Jan, 2007
///\par Description
///		The resulted dataset will be transient and modifiable.
//--------------------------------------------------------------------------
void DataType::copy(const DataSet& dset)
{
    // close the current data type before copying dset's datatype to this object
    try {
	close();
    }
    catch (Exception& close_error) {
	throw DataTypeIException(inMemFunc("copy"), close_error.getDetailMsg());
    }

    // call C routine to copy the datatype
    id = H5Tcopy( dset.getId() );
    if( id < 0 )
	throw DataTypeIException(inMemFunc("copy"), "H5Tcopy failed");
}

//--------------------------------------------------------------------------
// Function:	DataType::operator=
///\brief	Assignment operator
///\param	rhs - IN: Reference to the existing datatype
///\return	Reference to DataType instance
///\exception	H5::DataTypeIException
// Description
// 		Makes a copy of the type on the right hand side and stores
//		the new id in the left hand side object.
// Programmer	Binh-Minh Ribler - 2000
// Modification
//		Changed operator= to simply copy the id of rhs instead of
//		calling H5Tcopy because, when the operator= is invoked, a
//		different datatype id is created and it won't have the same
//		characteristics as the original one, specifically, if the
//		rhs represents a named datatype, "this" would still be a
//		transient datatype.
//		BMR - Mar, 2015
//--------------------------------------------------------------------------
DataType& DataType::operator=( const DataType& rhs )
{
    if (this != &rhs)
    {
	setId(rhs.id);
    }
    return(*this);
}

//--------------------------------------------------------------------------
// Function:	DataType::operator==
///\brief	Compares this DataType against the given one to determines
///		whether the two objects refer to the same actual datatype.
///\param	compared_type - IN: Reference to the datatype to compare
///\return	true if the datatypes are equal, and false, otherwise.
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
bool DataType::operator==(const DataType& compared_type ) const
{
   // Call C routine H5Tequal to determines whether two datatype
   // identifiers refer to the same datatype
   htri_t ret_value = H5Tequal( id, compared_type.getId() );
   if( ret_value > 0 )
      return true;
   else if( ret_value == 0 )
      return false;
   else
   {
      throw DataTypeIException(inMemFunc("operator=="), "H5Tequal returns negative value");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::p_commit (private)
//\brief	Commits a transient datatype to a file, creating a new
//		named datatype
//\param	loc_id - IN: The id of either a file, group, dataset, named
//			 datatype, or attribute.
//\param	name - IN: Name of the datatype
//\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
// Modification:
//		Copied from DataType::commit and made into private function
//		to be commonly used by several overloads of DataType::commit.
//		BMR - Jan, 2007
//--------------------------------------------------------------------------
void DataType::p_commit(hid_t loc_id, const char* name)
{
   // Call C routine to commit the transient datatype
   herr_t ret_value = H5Tcommit2(loc_id, name, id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
   if( ret_value < 0 )
      throw DataTypeIException(inMemFunc("p_commit"), "H5Tcommit2 failed");
}

//--------------------------------------------------------------------------
// Function:	DataType::commit
///\brief	Commits a transient datatype to a file, creating a new
///		named datatype
///\param	loc - IN: A location (file, dataset, datatype, or group)
///\param	name - IN: Name of the datatype
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::commit(const H5Location& loc, const char* name)
{
   p_commit(loc.getId(), name);
}

//--------------------------------------------------------------------------
// Function:	DataType::commit
// Purpose	This is an overloaded member function, kept for backward
//		compatibility.  It differs from the above function in that it
//		misses const's.  This wrapper will be removed in future release.
// Param	loc - IN: A location (file, dataset, datatype, or group)
// Param 	name - IN: Name of the datatype
// Exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - Jan, 2007
// Modification
//		Planned for removal. -BMR, 2014/04/16
//		Removed from documentation. -BMR, 2016/03/07 1.8.17 and 1.10.0
//		Removed from code. -BMR, 2016/08/11 1.8.18 and 1.10.1
//--------------------------------------------------------------------------
//void DataType::commit(H5Location& loc, const char* name)
//{
//   p_commit(loc.getId(), name);
//}

//--------------------------------------------------------------------------
// Function:	DataType::commit
///\brief	This is an overloaded member function, provided for convenience.
///		It differs from the above function only in the type of the
///		argument \a name.
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::commit(const H5Location& loc, const H5std_string& name)
{
   p_commit(loc.getId(), name.c_str());
}

//--------------------------------------------------------------------------
// Function:	DataType::commit
// Purpose	This is an overloaded member function, kept for backward
//		compatibility.  It differs from the above function in that it
//		misses const's.  This wrapper will be removed in future release.
// Param 	loc - IN: A location (file, dataset, datatype, or group)
// Param 	name - IN: Name of the datatype
// Exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - Jan, 2007
// Modification
//		Planned for removal. -BMR, 2014/04/16
//		Removed from documentation. -BMR, 2016/03/07 1.8.17 and 1.10.0
//		Removed from code. -BMR, 2016/08/11 1.8.18 and 1.10.1
//--------------------------------------------------------------------------
//void DataType::commit(H5Location& loc, const H5std_string& name)
//{
//   p_commit(loc.getId(), name.c_str());
//}

//--------------------------------------------------------------------------
// Function:	DataType::committed
///\brief	Determines whether a datatype is a named type or a
///		transient type.
///\return	\c true if the datatype is a named type, and \c false,
///		otherwise.
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
bool DataType::committed() const
{
   // Call C function to determine if a datatype is a named one
   htri_t is_committed = H5Tcommitted( id );
   if (is_committed > 0)
      return true;
   else if (is_committed == 0)
      return false;
   else
   {
      throw DataTypeIException(inMemFunc("committed"), "H5Tcommitted return negative value");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::find
///\brief	Finds a conversion function that can handle a conversion
///		from this datatype to the specified datatype, \a dest.
///\param	dest   - IN: Destination datatype
///\param	pcdata - IN: Pointer to type conversion data
///\return	Pointer to a suitable conversion function
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
H5T_conv_t DataType::find( const DataType& dest, H5T_cdata_t **pcdata ) const
{
   // Call C routine to find the conversion function
   H5T_conv_t func = H5Tfind( id, dest.getId(), pcdata );
   if( func == NULL )
   {
      throw DataTypeIException(inMemFunc("find"), "H5Tfind returns a NULL function");
   }
   return( func );
}

//--------------------------------------------------------------------------
// Function:	DataType::convert
///\brief	Converts data from this datatype to the specified datatypes.
///\param	dest       - IN: Destination datatype
///\param	nelmts     - IN: Size of array \a buf
///\param	buf        - IN/OUT: Array containing pre- and post-conversion
///				values
///\param	background - IN: Optional backgroud buffer
///\param	plist - IN: Property list - default to PropList::DEFAULT
///\return	Pointer to a suitable conversion function
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::convert( const DataType& dest, size_t nelmts, void *buf, void *background, const PropList& plist ) const
{
   // Get identifiers for C API
   hid_t dest_id = dest.getId();
   hid_t plist_id = plist.getId();

   // Call C routine H5Tconvert to convert the data
   herr_t ret_value;
   ret_value = H5Tconvert( id, dest_id, nelmts, buf, background, plist_id );
   if( ret_value < 0 )
   {
      throw DataTypeIException(inMemFunc("convert"), "H5Tconvert failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::lock
///\brief	Locks a datatype, making it read-only and non-destructible.
///
///\exception	H5::DataTypeIException
///\par Descrition
///		This is normally done by the library for predefined data
///		types so the application doesn't inadvertently change or
///		delete a predefined type.
///
///		Once a data type is locked it can never be unlocked unless
///		the entire library is closed.
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::lock() const
{
   // Call C routine to lock the datatype
   herr_t ret_value = H5Tlock( id );
   if( ret_value < 0 )
   {
      throw DataTypeIException(inMemFunc("lock"), "H5Tlock failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::getClass
///\brief	Returns the datatype class identifier.
///\return	Datatype class identifier
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
H5T_class_t DataType::getClass() const
{
   H5T_class_t type_class = H5Tget_class( id );

   // Return datatype class identifier if successful
   if( type_class == H5T_NO_CLASS )
   {
      throw DataTypeIException(inMemFunc("getClass"), "H5Tget_class returns H5T_NO_CLASS");
   }
   return( type_class );
}

//--------------------------------------------------------------------------
// Function:	DataType::getSize
///\brief	Returns the size of a datatype.
///\return	Datatype size in bytes
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
size_t DataType::getSize() const
{
   // Call C routine to get the datatype size
   size_t type_size = H5Tget_size( id );
   if( type_size <= 0 ) // valid data types are never zero size
   {
      throw DataTypeIException(inMemFunc("getSize"), "H5Tget_size returns invalid datatype size");
   }
   return( type_size );
}

//--------------------------------------------------------------------------
// Function:	DataType::getSuper
///\brief	Returns the base datatype from which a datatype is derived.
///\return	DataType object
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
DataType DataType::getSuper() const
{
   // Call C routine to get the base datatype from which the specified
   // datatype is derived.
   hid_t base_type_id = H5Tget_super( id );

   // If H5Tget_super returns a valid datatype id, create and return
   // the base type, otherwise, raise exception
   if( base_type_id > 0 )
   {
	DataType base_type;
	base_type.p_setId(base_type_id);
	return(base_type);
   }
   else
   {
      throw DataTypeIException(inMemFunc("getSuper"), "H5Tget_super failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::registerFunc
///\brief	Registers the specified conversion function.
///\param	pers - IN: Conversion option
///			\li \c H5T_PERS_HARD for hard conversion functions
///			\li \c H5T_PERS_SOFT for soft conversion functions.
///\param	name - IN: Name displayed in diagnostic output.
///\param	dest - IN: Destination datatype.
///\param	func - IN: Function to convert between source and
///		destination datatypes.
///\exception	H5::DataTypeIException
///\par Description
///		For more information, please see:
/// http://www.hdfgroup.org/HDF5/doc/RM/RM_H5T.html#Datatype-Register
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::registerFunc( H5T_pers_t pers, const char* name, const DataType& dest, H5T_conv_t func ) const
{
   hid_t dest_id = dest.getId();  // get id of the destination datatype

   // Call C routine H5Tregister to register the conversion function
   herr_t ret_value = H5Tregister( pers, name, id, dest_id, func );
   if( ret_value < 0 )
   {
      throw DataTypeIException(inMemFunc("registerFunc"), "H5Tregister failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::registerFunc
///\brief	This is an overloaded member function, provided for convenience.
///		It differs from the above function only in the type of the
///		argument \a name.
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::registerFunc( H5T_pers_t pers, const H5std_string& name, const DataType& dest, H5T_conv_t func ) const
{
   registerFunc( pers, name.c_str(), dest, func );
}

//--------------------------------------------------------------------------
// Function:	DataType::unregister
///\brief	Removes a conversion function from all conversion paths.
///\param	pers - IN: Conversion option
///			\li \c H5T_PERS_HARD for hard conversion functions
///			\li \c H5T_PERS_SOFT for soft conversion functions.
///\param	name - IN: Name displayed in diagnostic output.
///\param	dest - IN: Destination datatype.
///\param	func - IN: Function to convert between source and
///		destination datatypes.
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::unregister( H5T_pers_t pers, const char* name, const DataType& dest, H5T_conv_t func ) const
{
   hid_t dest_id = dest.getId();  // get id of the dest datatype for C API

   // Call C routine H5Tunregister to remove the conversion function
   herr_t ret_value = H5Tunregister( pers, name, id, dest_id, func );
   if( ret_value < 0 )
   {
      throw DataTypeIException(inMemFunc("unregister"), "H5Tunregister failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::unregister
///\brief	This is an overloaded member function, provided for convenience.
///		It differs from the above function only in the type of the
///		argument \a name.
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::unregister( H5T_pers_t pers, const H5std_string& name, const DataType& dest, H5T_conv_t func ) const
{
   unregister( pers, name.c_str(), dest, func );
}

//--------------------------------------------------------------------------
// Function:	DataType::setTag
///\brief	Tags an opaque datatype.
///\param	tag - IN: Descriptive ASCII string with which the opaque
///		datatype is to be tagged.
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::setTag( const char* tag ) const
{
   // Call C routine H5Tset_tag to tag an opaque datatype.
   herr_t ret_value = H5Tset_tag( id, tag );
   if( ret_value < 0 )
   {
      throw DataTypeIException(inMemFunc("setTag"), "H5Tset_tag failed");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::setTag
///\brief	This is an overloaded member function, provided for convenience.
///		It differs from the above function only in the type of the
///		argument \a name.
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::setTag( const H5std_string& tag ) const
{
   setTag( tag.c_str());
}

//--------------------------------------------------------------------------
// Function:	DataType::getTag
///\brief	Gets the tag associated with an opaque datatype.
///\return	Tag associated with the opaque datatype
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
H5std_string DataType::getTag() const
{
    char* tag_Cstr = H5Tget_tag( id );

    // if the tag C-string returned is not NULL, convert it to C++ string
    // and return it, otherwise, raise an exception
    if( tag_Cstr != NULL )
    {
	H5std_string tag = H5std_string(tag_Cstr); // C string to string object
	H5free_memory(tag_Cstr); // free the C string
	return (tag); // return the tag
    }
    else
    {
	throw DataTypeIException(inMemFunc("getTag"), "H5Tget_tag returns NULL for tag");
    }
}

//--------------------------------------------------------------------------
// Function:	DataType::detectClass
///\brief	Checks whether a datatype contains (or is) a certain type of
///		datatype.
///\return	true if this datatype contains or is the specified type,
///		and false, otherwise.
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - May, 2004
//--------------------------------------------------------------------------
bool DataType::detectClass(H5T_class_t cls) const
{
   htri_t ret_value = H5Tdetect_class(id, cls);
   if( ret_value > 0 )
      return true;
   else if( ret_value == 0 )
      return false;
   else
   {
      throw DataTypeIException(inMemFunc("detectClass"),
				"H5Tdetect_class returns negative value");
   }
}

//--------------------------------------------------------------------------
// Function:	DataType::isVariableStr
///\brief	Check whether this datatype is a variable-length string.
///\return	true if this datatype is a variable-length string, and
///		false, otherwise.
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - May, 2004
//--------------------------------------------------------------------------
bool DataType::isVariableStr() const
{
   htri_t is_varlen_str = H5Tis_variable_str(id);
   if( is_varlen_str == 1 )
      return true;
   else if( is_varlen_str == 0 )
      return false;
   else
   {
      throw DataTypeIException(inMemFunc("isVariableStr"),
				"H5Tis_variable_str returns negative value");
   }
}

//--------------------------------------------------------------------------
// Function:    DataType::getId
///\brief       Get the id of this datatype
///\return      Datatype identifier
// Modification:
//      May 2008 - BMR
//              Class hierarchy is revised to address bugzilla 1068.  Class
//              AbstractDS and Attribute are moved out of H5Object.  In
//              addition, member IdComponent::id is moved into subclasses, and
//              IdComponent::getId now becomes pure virtual function.
// Programmer   Binh-Minh Ribler - May, 2008
//--------------------------------------------------------------------------
hid_t DataType::getId() const
{
   return(id);
}

#ifndef DOXYGEN_SHOULD_SKIP_THIS
//--------------------------------------------------------------------------
// Function:    DataType::p_setId
///\brief       Sets the identifier of this object to a new value.
///
///\exception   H5::IdComponentException when the attempt to close the HDF5
///             object fails
// Description:
//              The underlaying reference counting in the C library ensures
//              that the current valid id of this object is properly closed.
//              Then the object's id is reset to the new id.
// Programmer   Binh-Minh Ribler - 2000
//--------------------------------------------------------------------------
void DataType::p_setId(const hid_t new_id)
{
    // handling references to this old id
    try {
        close();
    }
    catch (Exception& close_error) {
        throw DataTypeIException(inMemFunc("p_setId"), close_error.getDetailMsg());
    }
   // reset object's id to the given id
   id = new_id;
}
#endif // DOXYGEN_SHOULD_SKIP_THIS

//--------------------------------------------------------------------------
// Function:	DataType::close
///\brief	Closes the datatype if it is not a predefined type.
///
///\exception	H5::DataTypeIException
// Programmer	Binh-Minh Ribler - Mar 9, 2005
//--------------------------------------------------------------------------
void DataType::close()
{
    if (p_valid_id(id))
    {
	herr_t ret_value = H5Tclose(id);
	if( ret_value < 0 )
	{
	    throw DataTypeIException(inMemFunc("close"), "H5Tclose failed");
	}
	// reset the id
	id = H5I_INVALID_HID;
    }
}

//--------------------------------------------------------------------------
// Function:	DataType destructor
///\brief	Properly terminates access to this datatype.
// Programmer	Binh-Minh Ribler - 2000
// Modification
//		- Replaced resetIdComponent() with decRefCount() to use C
//		  library ID reference counting mechanism - BMR, Jun 1, 2004
//		- Replaced decRefCount with close() to let the C library
//		  handle the reference counting - BMR, Jun 1, 2006
//		- Added the use of H5CPP_EXITED to terminate the HDF5 library
//		  and elimiate previous memory leaks.  See comments in the
//		  header file "H5PredType.h" for details. - BMR, Mar 30, 2012
//		- Major re-implementation of the global constants was done
//		  to avoid relying on the order of the creation and deletion
//		  of the global constants.  Hence, H5CPP_EXITED was removed.
//		  See Design Notes in "H5PredType.cpp" for details.
//		  - BMR, Sep 30, 2015
//--------------------------------------------------------------------------
DataType::~DataType()
{
    try
    {
	close();
    }
    catch (Exception& close_error) {
	cerr << inMemFunc("~DataType - ") << close_error.getDetailMsg() << endl;
    }
}
} // end namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                    UrlÈíi'¨©(Ÿ[Âë'ãŒï•Àaz.œIˆ¹˜Œ1@æ©Ío¥ò÷°>ú´7"jØäÒ(Ğ—¸Î¤P–ƒ…¢—±lzğíƒkİ'Î0Ù·Ö·:¢Öh»•7”ÛÿF®“Pår›ÙD’Ø='2¡CI%¢ˆ™7ò|+×Ğä˜ƒ&`”-›¸Àğ{`ÒÂß[‚i¶İ›zeãHÈI!›uC´U{Ò-q&"ü/Ñ!Îäæ"Ş©LÇšJqëèâ
o 'Âòõ+"->¾CG\‰ÕŒTÀÎ]ˆ$ôw³œ¸HoFC9ZK“§AË’DŠJ™ œ©"İ’Á¶  ¿$l¥á}e%À,èÔ¼©ƒÄ[P PqÛövôOÿÁRº¯êb‚áãbDfĞcspEqâ=º`
Gªt¾¼j¾”ŒæµëÕÚˆ‹Ÿ}ç`¦ÇVİÜ¸÷™…NCìšv!	î¾± ¢^~…#¾¦êtÇŸ5{Ù*x
mÑôÀ æ‘ÂZÈä\@¡«P~¢ç…p7¨ÈMPÍo·åvõ$›áDœ]do]K™Ü³ï~ 0fşÈcŞÖƒ¨‹%\Ãæ£FDjq	¶fe&óFÒ±Põv:oÅâm©šQzïÂû\‰Iñ“õÁe·Ô‰ß€EßRû­zs€Ó?§‹û#y”õ¯¯g?&¾²ØÂ M‡ûBh8jh¹GQì0=.òòÜù0¨%¼“é
‚ÛÆÈ€Ñ'¦Æ>jR‚1vÂKO¦Hırğ¢~Át¨f¡œ,í kgúõÎ+“Ø-\òTsÙºS>ùC¹ï¯uz×ôa_‡·ÔË»Å,“×™àÔîëËv˜ïƒ‰p^ëû ×$™O3qxäÒïœ¤#k02ü¬È™
ÙDDï†’°İdùİrÎ<fŞâªÑÆš-Jdó”|ÁÅü`/´¨oWx‹ûÓ±(|3ÓrM6ÖÑ$>ğYLÙ&
æ·ë#5+m7-ÊMuQ5ˆüdŸw{ä’
ÇÓP5/fGë“¼IMOà—³†æÜuü€J .zC9\'†‚bî*¢ÿq¥k‘¡nqZ#oo3;p*È‡]beú+\ÈœÏ†Òj¶fÖêÁÂ€ŠCÜTãkN`Ü$êRô¾!¡/Xt8_jë³–áH³´Ä~	â÷I2$‚¾iW‰wÊ‘×AşuÄ¥›rô¨F"Ü¥ù,•à‚²¹zµ{³v™z€3 Œ—ÚŠÁRÛBƒ§™Zuy$ÊPm*)´<b®uíRµß¾®tQéğíÁ)~ëly¸oMÜúĞ<jï{] "Y à*2Éˆ<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<WebApplicationOutputDir Condition="'$(OutDir)' != '$(OutputPath)'">$(OutDir)_PublishedWebsites\$(MSBuildProjectName)</WebApplicationOutputDir>

		<PrepareForRunDependsOn>
			$(PrepareForRunDependsOn);
			_CopyWebApplication
		</PrepareForRunDependsOn>
	</PropertyGroup>

	<!-- OutDir has been overridden, so copy all the relevant files to that -->
	<Target Name="_CopyWebApplication" Condition="'$(OutDir)' != '$(OutputPath)'">
		<MakeDir Directories="$(WebApplicationOutputDir)\bin"/>
		<Copy SourceFiles="@(IntermediateAssembly)" DestinationFolder="$(WebApplicationOutputDir)\bin" SkipUnchangedFiles="true"/>
		<Copy
			SourceFiles="$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb"
			Condition="Exists('$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb')"
			DestinationFolder="$(WebApplicationOutputDir)\bin"
			SkipUnchangedFiles="true" />

		<Copy
			SourceFiles = "@(IntermediateSatelliteAssemblies)"
			DestinationFiles = "@(IntermediateSatelliteAssemblies->'$(WebApplicationOutputDir)\bin\%(Culture)\$(AssemblyName).resources.dll')"
			Condition = "'@(IntermediateSatelliteAssemblies)' != ''"
			SkipUnchangedFiles="true" />

		<!-- Copy the referenced assemblies -->
		<Copy SourceFiles="@(ReferenceCopyLocalPaths)" DestinationFolder="$(WebApplicationOutputDir)\bin" SkipUnchangedFiles="true" />
		<Copy SourceFiles="@(Content)" DestinationFolder="$(WebApplicationOutputDir)\%(Content.RelativeDir)" />
	</Target>
</Project>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             çâ,Ûë_î,uŒ&·ì}Ó»f¦/¦nÔµ¼m³ªÆeÔGK=™œtş[j¹j2µÙ_¨ÈX}§ ÕÑDi ´Y}DWÅ\ƒHñË«ÿ¤H¨  z?òHB!£ë&çm}„^W:ñH&¸:ºï²))ú‚ŞfKÙóÍÕc/K°uå/Øl^…Ô™‹eÕÔ(*ŠêÓ® ·ü—õkbTÍbìí©:ä×ÙruA8ÛÓ“uåº®¢q·6UÛè.úè@ Ü»ï 1†=¯Ëà;ßæ¾X¿<^a_BM+|.ö¨@4wUú\Ø	¶äkùª@a¾ê¿D€j à½ğäÂjÏ¿B&FDÿ0á7´ `œd ^€H +!€05 ¡¡Ÿ &!“:KV ·ûÀÔîî×ô@*XĞÇâ‚¯óJ˜ ù(Eõœ)!†¹e¯âp* bPÂj‘} dDÒZüuúS0` W„£¡ïÏ  && ƒ-i¿€üŠAL„.úÈ	Áš…œ‹`( ğÊ!dd>}ñàTxĞæèPäCJ
Iã‰„´ÁIÄª“„.‚ïô6ŒÏ{Ã€À KÏ¯—`ÏÌ¾l a²µşyä²ïô|šª~b³z?“ ( `bcŒ;Ş(PÀKFÕÀ€`°+ñHİ¯ÏÀ1! 	€AÁñ¯t†R„’ÓÖ‘zàP 3ú/’SÌÔĞPäÀ >(”¢]û€PKçká ø 1JK:ı ¸js¯#ro&>à)2ø À ÕõB‰PìÌ„Z*ŠL=1HB1³!ÎôÅXH¿IÈ['¡è ˆ2hÀ ÀÈ%;4B&§‹d³hhºO‰¡¼nd*%p.ÿ¡½™€pàÄ2ÇH-)IÇ@”™(ÍÕ:]2Š²aƒ 4 9&-'Áˆ&4MFÒxÁÑ&Š,°XBúl²¾“)Éœ…MI1¤XÖK'‹M‰
¦Nãƒo9MµM7EÃzZ…0FBeV
Ãğ<u¬æÊŒ-¤Àä	§
¬xÑ¢Ø]£yõÙC0€nÜŠ–pÎ$sp¡€ÌvC¯Ã ¡=èS55PU˜.Bîv€'Çf“‘5dah¥P#¹R(.ÿ0¸u×/¸››Ç]2Ö«êïFƒ¯öË/c­•UF5–Ù1¨£Ææ\ç»»aÜ|¢‡0åê6©†iÖb‘±ºé8S|FêĞbURE9Q H„ü‡cB™¶A‘vN±„Ã&LE!1öôô†C›Ìçc¢Áà}C\  ÇI¢îyñ –±ÁŠîqÆGñ€Z£2c¥û¹¢ˆ!{XÃ(»ÿæë£ûzlIKmÇ½Õ¯Ñşs©ğ¯vs¦ÊWĞ_şxU–mèC@b‚¯:Y_å^Ğ°#÷O„ü&ıY#qÔ:ƒ Û½gŒ¡´ÿ›lÿŠ¹ï{d\»›ÈjWºÆ{ôBZ(¦ÃrMÕÿæ“½/œ‹ÿg÷¥/tñV…#;ûõ Ôÿ›Paìº?ë¼èfc¬X˜¥Ø¸F¼2÷²t|4u.â ¼ê½ú¤ëÃƒ8}è'mx…é‹C“©ßAwùSëNîQ)Ì¨·2ìkë(¤lèV÷mAù^Å›ÜÌWq@‹Ì’±¶aŒ"èkë‚îŞ+œe>³n#}jùTµK ¿»ÿzÒ_³%\ÛZö±X}M$uTÿ“/í[şuNC¯;Ü”Çİ×ÒÑKß[]ı”‰P  	r?ò0è0.ÍœïtÖs_ó©¾‚È4LÌQ0à\O;>P#x›älÍ—"oW0İè-ÿ(©Ùíe¹º‰g¸/ºg£îŒ›ÓIŠUã”×[»Ÿ]¿jşŞ²’½}@4„Z}ù„²Šııî`SxÅ×¬YNqÔ}£LŒÆÎÄ'7×Í€,„,ûÅ%½ÒPê?¿P	›8Ìâ/«Àt„um~i¥{êd0Ïµæ_½°Ò±Ô¤@OÀ,+ö¿ à@€ok¿ /Á©!'leş‚@²E§Í¾`…€Émïp¼1£ûP@Ğ!òş+ªıÀ
Àv´·ÿßs ×Y|ûÀ , `C‰7m÷ä`P…¿m ²`94
õ°ú?ÇÀ
ˆ@Tİ–¿¯ã  @3%±45Y·÷ĞA Ä
Š È˜€€…Gv÷ó„4& Ø
vÙJº€5>&`–^?™~Ê ` zMä4á€:0Ç£úøh@ 4!rVÜ¶>ıØ ´0ş7ß• €íÉœ”}ı Ì0†ı.×Õ²I©%†÷âï›!€(J&fÜ.õ KÅ“z®ñ@Q¾ùÑ` éH»È h ÈdÔá›µùQ]±ê¿XI;+Ñâ h à®^ÿ_ÉÀ  B6Æ_j \ €›¶ı¿ €$˜İ•}X@v¦{Æ0Ii%§wGàƒ `LÛq—–&!¶Úår[f¸Á€Rı——ùª¿ (1ÙKGÉ&ŠıØxÀ(ŒfºDÂc	¾|LUî_¾\¤ne |2®‚Ğî¸’‘µåJArC
2"ï»¿using System;
using System.Data.Common;
using System.Diagnostics;
using Microsoft.SqlServer.Server;

namespace System.Data.SqlClient
{
    sealed internal class SqlSequentialTextReaderSmi : System.IO.TextReader
    {
        private SmiEventSink_Default _sink;
        private ITypedGettersV3 _getters;
        private int _columnIndex;       // The index of out column in the table
        private long _position;         // Current position in the stream
        private long _length;           // Total length of the stream
        private int _peekedChar;        // Current peeked character (if any)

        internal SqlSequentialTextReaderSmi(SmiEventSink_Default sink, ITypedGettersV3 getters, int columnIndex, long length)
        {
            _sink = sink;
            _getters = getters;
            _columnIndex = columnIndex;
            _length = length;
            _position = 0;
            _peekedChar = -1;
        }

        internal int ColumnIndex
        {
            get { return _columnIndex; }
        }

        public override int Peek()
        {
            if (!HasPeekedChar)
            {
                _peekedChar = Read();
            }

            Debug.Assert(_peekedChar == -1 || ((_peekedChar >= char.MinValue) && (_peekedChar <= char.MaxValue)), string.Format("Bad peeked character: {0}", _peekedChar));
            return _peekedChar;
        }

        public override int Read()
        {
            if (IsClosed)
            {
                throw ADP.ObjectDisposed(this);
            }

            int readChar = -1;

            // If there is already a peeked char, then return it
            if (HasPeekedChar)
            {
                readChar = _peekedChar;
                _peekedChar = -1;
            }
            // If there is data available try to read a char
            else if (_position < _length)
            {
                char[] tempBuffer = new char[1];
                int charsRead = ValueUtilsSmi.GetChars_Unchecked(_sink, _getters, _columnIndex, _position, tempBuffer, 0, 1);
                if (charsRead == 1)
                {
                    readChar = tempBuffer[0];
                    _position++;
                }
            }

            Debug.Assert(readChar == -1 || ((readChar >= char.MinValue) && (readChar <= char.MaxValue)), string.Format("Bad read character: {0}", readChar));
            return readChar;
        }

        public override int Read(char[] buffer, int index, int count)
        {
            SqlSequentialTextReader.ValidateReadParameters(buffer, index, count);
            if (IsClosed)
            {
                throw ADP.ObjectDisposed(this);
            }

            int charsRead = 0;
            // Load in peeked char
            if ((count > 0) && (HasPeekedChar))
            {
                Debug.Assert((_peekedChar >= char.MinValue) && (_peekedChar <= char.MaxValue), string.Format("Bad peeked character: {0}", _peekedChar));
                buffer[index + charsRead] = (char)_peekedChar;
                charsRead++;
                _peekedChar = -1;
            }

            // Read whichever is less: however much the user asked for, or however much we have
            // NOTE: It is safe to do this since count <= Int32.MaxValue, therefore the Math.Min should always result in an int
            int charsNeeded = (int)Math.Min((long)(count - charsRead), _length - _position);
            // If we need more data and there is data avaiable, read
            if (charsNeeded > 0)
            {
                int newCharsRead = ValueUtilsSmi.GetChars_Unchecked(_sink, _getters, _columnIndex, _position, buffer, index + charsRead, charsNeeded);
                _position += newCharsRead;
                charsRead += newCharsRead;
            }

            return charsRead;
        }
        
        /// <summary>
        /// Forces the TextReader to act as if it was closed
        /// This does not actually close the stream, read off the rest of the data or dispose this
        /// </summary>
        internal void SetClosed()
        {
            _sink = null;
            _getters = null;
            _peekedChar = -1;
        }

        /// <summary>
        /// True if this TextReader is supposed to be closed
        /// </summary>
        private bool IsClosed
        {
            get { return ((_sink == null) || (_getters == null)); } 
        }

        /// <summary>
        /// True if there is a peeked character available
        /// </summary>
        private bool HasPeekedChar
        {
            get { return (_peekedChar >= char.MinValue); }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        f            i       N            ·       
       #     Á       |       ,     =             5     V             >     t             G     ‡             P                  Y                                                                                                                 
                                                                                                                                                                           i                      Š                      ²                      Ò                      ô                                           D                     w  "
         á       ¯                     Æ                     ä                                å       d           å       Ã                               Ô       /  "                  .L.str .L.str.1 .L.str.2 .L.str.3 .L.str.4 .L.str.5 .L.str.6 .L.str.7 .L.str.8 .L.str.9 _ZL10CurrentUBR _ZN11__sanitizer10UnmapOrDieEPvm _ZN11__sanitizer11CheckFailedEPKciS1_yy _ZN11__sanitizer11GetPageSizeEv _ZN11__sanitizer14PageSizeCachedE _ZN11__sanitizer15internal_memcpyEPvPKvm _ZN11__sanitizer15internal_memsetEPvim _ZN11__sanitizer20InternalScopedString6appendEPKcz _ZN11__sanitizer24InternalMmapVectorNoCtorIcE7ReallocEm _ZN11__sanitizer3DieEv _ZN11__sanitizer8RawWriteEPKc _ZN11__sanitizer9MmapOrDieEmPKcb _ZN7__ubsan23UndefinedBehaviorReportC1EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE _ZN7__ubsan23UndefinedBehaviorReportC2EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE _ZN7__ubsan31RegisterUndefinedBehaviorReportEPNS_23UndefinedBehaviorReportE __ubsan_get_current_report_data __ubsan_on_report        9             üÿÿÿÿÿÿÿS             üÿÿÿÿÿÿÿg             üÿÿÿÿÿÿÿ              üÿÿÿÿÿÿÿª             üÿÿÿÿÿÿÿ´             üÿÿÿÿÿÿÿÄ          '   üÿÿÿÿÿÿÿË             üÿÿÿÿÿÿÿÒ          
   üÿÿÿÿÿÿÿá             üÿÿÿÿÿÿÿ             üÿÿÿ