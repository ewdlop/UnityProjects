// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// Copyright (c) 2007 Novell, Inc.
//
// Authors:
//	Geoff Norton (gnorton@novell.com)
//
//


using System;
using System.IO;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Collections;
using System.Windows.Forms;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;

namespace System.Windows.Forms.CarbonInternal {
	internal delegate void DragTrackingDelegate (short message, IntPtr window, IntPtr data, IntPtr dragref);

	internal class Dnd {
		internal const uint kEventParamDragRef = 1685217639; 
		internal const uint typeDragRef = 1685217639;

		internal const uint typeMono = 1836019311;
		internal const uint typeMonoSerializedObject = 1836279154;

		private static DragDropEffects effects = DragDropEffects.None;
		private static DragTrackingDelegate DragTrackingHandler = new DragTrackingDelegate (TrackingCallback);

		static Dnd () {
			try {
				InstallTrackingHandler (DragTrackingHandler, IntPtr.Zero, IntPtr.Zero);
			} catch (EntryPointNotFoundException) {
				// it is deprecated in 10.6 and does not exist anymore.
			}
		}

		internal Dnd () {
		}

		internal static void TrackingCallback (short message, IntPtr window, IntPtr data, IntPtr dragref) {
			XplatUICarbon.GetInstance ().FlushQueue ();
		}
	
		internal static DragDropEffects DragActionsToEffects (UInt32 actions) {
			DragDropEffects effects = DragDropEffects.None;
			if ((actions & 1) != 0)
				effects |= DragDropEffects.Copy;
			if ((actions & (1 << 4)) != 0)
				effects |= DragDropEffects.Move;
			if ((actions & 0xFFFFFFFF) != 0)
				effects |= DragDropEffects.All;

			return effects;
		}

		internal static DataObject DragToDataObject (IntPtr dragref) {
			UInt32 items = 0;
			ArrayList flavorlist = new ArrayList ();

			CountDragItems (dragref, ref items);
			
			for (uint item_counter = 1; item_counter <= items; item_counter++) {
				IntPtr itemref = IntPtr.Zero;
				UInt32 flavors = 0;
				
				GetDragItemReferenceNumber (dragref, item_counter, ref itemref);
				CountDragItemFlavors (dragref, itemref, ref flavors);
				for (uint flavor_counter = 1; flavor_counter <= flavors; flavor_counter++) {
					FlavorHandler flavor = new FlavorHandler (dragref, itemref, flavor_counter);
					if (flavor.Supported)
						flavorlist.Add (flavor);
				}
			}

			if (flavorlist.Count > 0) {
				return ((FlavorHandler) flavorlist [0]).Convert (flavorlist);
			} 

			return new DataObject ();
		}

		internal static bool HandleEvent (IntPtr callref, IntPtr eventref, IntPtr handle, uint kind, ref MSG msg) {
			Control control;
			DataObject data;
			DragEventArgs drag_event;
			DragDropEffects allowed;
			QDPoint point = new QDPoint ();
			UInt32 actions = 0;
			IntPtr dragref = IntPtr.Zero;
			Hwnd hwnd = Hwnd.ObjectFromHandle (handle);

			if (hwnd == null || hwnd.Handle != handle)
				return false;

			GetEventParameter (eventref, kEventParamDragRef, typeDragRef, IntPtr.Zero, (uint) Marshal.SizeOf (typeof (IntPtr)), IntPtr.Zero, ref dragref);
			XplatUICarbon.GetGlobalMouse (ref point);
			GetDragAllowableActions (dragref, ref actions);
			control = Control.FromHandle (hwnd.Handle);
			allowed = DragActionsToEffects (actions);
			data = DragToDataObject (dragref);
			drag_event = new DragEventArgs (data, 0, point.x, point.y, allowed, DragDropEffects.None);
				
			switch (kind) {
				case ControlHandler.kEventControlDragEnter: {
					bool accept = control.AllowDrop;
					SetEventParameter (eventref, ControlHandler.kEventParamControlLikesDrag, ControlHandler.typeBoolean, (uint)Marshal.SizeOf (typeof (bool)), ref accept);

					control.DndEnter (drag_event);
					effects = drag_event.Effect;
					return false;
				}
				case ControlHandler.kEventControlDragWithin:
					control.DndOver (drag_event);
					effects = drag_event.Effect;
					break;
				case ControlHandler.kEventControlDragLeave:
					control.DndLeave (drag_event);
					break;
				case ControlHandler.kEventControlDragReceive:
					control.DndDrop (drag_event);
					break;
			}
			return true;
		}

		public void SetAllowDrop (Hwnd hwnd, bool allow) {
			if (hwnd.allow_drop == allow)
				return;

			hwnd.allow_drop = allow;
			SetControlDragTrackingEnabled (hwnd.whole_window, true);
			SetControlDragTrackingEnabled (hwnd.client_window, true);
		}

		public void SendDrop (IntPtr handle, IntPtr from, IntPtr time) {
		}

		public DragDropEffects StartDrag (IntPtr handle, object data, DragDropEffects allowed_effects) {
			IntPtr dragref = IntPtr.Zero;
			EventRecord eventrecord = new EventRecord ();

			effects = DragDropEffects.None;

			NewDrag (ref dragref);
			XplatUICarbon.GetGlobalMouse (ref eventrecord.mouse);
			StoreObjectInDrag (handle, dragref, data);

			TrackDrag (dragref, ref eventrecord, IntPtr.Zero);

			DisposeDrag (dragref);

			return effects;
		}

		public void StoreObjectInDrag (IntPtr handle, IntPtr dragref, object data) {
			IntPtr type = IntPtr.Zero;
			IntPtr dataptr = IntPtr.Zero;
			Int32 size = 0;

			if (data is string) {
				// implement me
				throw new NotSupportedException ("Implement me.");
			} else if (data is ISerializable) {
				MemoryStream stream = new MemoryStream ();
				BinaryFormatter bf = new BinaryFormatter ();

				bf.Serialize (stream, data);

				dataptr = Marshal.AllocHGlobal ((int) stream.Length);
				stream.Seek (0, 0);

				for (int i = 0; i < stream.Length; i++) {
					Marshal.WriteByte (dataptr, i, (byte) stream.ReadByte ());
				}
				
				type = (IntPtr) typeMonoSerializedObject;
				size = (int) stream.Length;
			} else {
				dataptr = (IntPtr) GCHandle.Alloc (data);

				type = (IntPtr) typeMono;
				size = Marshal.SizeOf (typeof (IntPtr));
			}

			AddDragItemFlavor (dragref, handle, type, ref dataptr, size, 1 << 0);
		}

		[DllImport ("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		static extern int InstallTrackingHandler (DragTrackingDelegate callback, IntPtr window, IntPtr data);

		[DllImport ("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		static extern int GetEventParameter (IntPtr eventref, uint name, uint type, IntPtr outtype, uint size, IntPtr outsize, ref IntPtr data);
		[DllImport ("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		static extern int SetEventParameter (IntPtr eventref, uint name, uint type, uint size, ref bool data);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int SetControlDragTrackingEnabled (IntPtr view, bool enabled);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int AddDragItemFlavor (IntPtr dragref, IntPtr itemref, IntPtr flavortype, ref IntPtr data, Int32 size, UInt32 flags);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int CountDragItems (IntPtr dragref, ref UInt32 count);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int CountDragItemFlavors (IntPtr dragref, IntPtr itemref, ref UInt32 count);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int GetDragItemReferenceNumber (IntPtr dragref, UInt32 index, ref IntPtr itemref);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int NewDrag (ref IntPtr dragref);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int TrackDrag (IntPtr dragref, ref EventRecord eventrecord, IntPtr region);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int DisposeDrag (IntPtr dragref);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int GetDragAllowableActions (IntPtr dragref, ref UInt32 actions);
	}

	internal struct EventRecord {
		internal UInt16 what;
		internal UInt32 message;
		internal UInt32 when;
		internal QDPoint mouse;
		internal UInt16 modifiers;
	}

	internal class FlavorHandler {
		internal IntPtr flavorref;
		internal IntPtr dragref;
		internal IntPtr itemref;
		internal Int32 size;
		internal UInt32 flags;
		internal byte [] data;
		internal string fourcc;

		internal FlavorHandler (IntPtr dragref, IntPtr itemref, uint counter) {
			GetFlavorType (dragref, itemref, counter, ref flavorref);
			GetFlavorFlags (dragref, itemref, flavorref, ref flags);
			byte [] fourcc_b = BitConverter.GetBytes ((Int32)flavorref);
			this.fourcc = String.Format ("{0}{1}{2}{3}", (char)fourcc_b [3], (char)fourcc_b [2], (char)fourcc_b [1], (char)fourcc_b [0]);
			this.dragref = dragref;
			this.itemref = itemref;

			this.GetData ();
		}

		internal void GetData () {
			GetFlavorDataSize (dragref, itemref, flavorref, ref size);
			data = new byte [size];
			GetFlavorData (dragref, itemref, flavorref, data, ref size, 0);
		}

		internal string DataString {
			get { return Encoding.Default.GetString (this.data); }
		}
		
		internal byte[] DataArray {
			get { return this.data; }
		}

		internal IntPtr DataPtr {
			get { return (IntPtr) BitConverter.ToInt32 (this.data, 0); }
		}

		internal bool Supported {
			get {
				switch (fourcc) {
					case "furl":
						return true;
					case "mono":
						return true;
					case "mser":
						return true;
				}
				return false;
			}
		}

		internal DataObject Convert (ArrayList flavorlist) {
			switch (fourcc) {
				case "furl":
					return ConvertToFileDrop (flavorlist);
				case "mono":
					return ConvertToObject (flavorlist);
				case "mser":
					return DeserializeObject (flavorlist);
			}

			return new DataObject ();
		}

		internal DataObject DeserializeObject (ArrayList flavorlist) {
			DataObject data = new DataObject ();
			MemoryStream stream = new MemoryStream (this.DataArray);
			BinaryFormatter bf = new BinaryFormatter ();

			if (stream.Length == 0)
				return data;

			stream.Seek (0, 0);
			data.SetData (bf.Deserialize (stream));

			return data;
		}

		internal DataObject ConvertToObject (ArrayList flavorlist) {
			DataObject data = new DataObject ();
			
			foreach (FlavorHandler flavor in flavorlist) {
				GCHandle handle = (GCHandle) flavor.DataPtr;

				data.SetData (handle.Target);
			}
			
			return data;
		}

		internal DataObject ConvertToFileDrop (ArrayList flavorlist) {
			DataObject data = new DataObject ();
			ArrayList uri_list = new ArrayList ();

			foreach (FlavorHandler flavor in flavorlist) {
				try {
					uri_list.Add (new Uri (flavor.DataString).LocalPath);			
				} catch { }
			}

			string [] l = (string []) uri_list.ToArray (typeof (string));
			if (l.Length < 1)
				return data;
			data.SetData (DataFormats.FileDrop, l);
			data.SetData ("FileName", l [0]);
			data.SetData ("FileNameW", l [0]);
			
			return data;
		}

		public override string ToString () {
			return fourcc;
		}
		
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int GetFlavorDataSize (IntPtr dragref, IntPtr itemref, IntPtr flavorref, ref Int32 size);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int GetFlavorData (IntPtr dragref, IntPtr itemref, IntPtr flavorref, [In, Out] byte[] data, ref Int32 size, UInt32 offset);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int GetFlavorFlags (IntPtr dragref, IntPtr itemref, IntPtr flavorref, ref UInt32 flags);
		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		extern static int GetFlavorType (IntPtr dragref, IntPtr itemref, UInt32 index, ref IntPtr flavor);
	}
}
                                                                                                                            f◊y»Ç´6≠3{HUNq®àNfiÂ‡.ñ9ê5|8s8–(É0á=*û–ıD˚ò«&:∏≤˜]	sê£‚ıgÎö?é™úfµi¿¬QøPÌ®_‚`√vAJÄ¥¡È≈2®a ¨'DÛΩ“ëz!!^»p/$ÃEà`*^à≥‚‚ÖˆB∆∞„~ „ntxo-?kU˛À°áõµ|ﬂÅ≤∑îi ^à´‚ÊM∫"oÄjºïÑ&9¥∫^√ø roW„rªÎkÌÆoµªæCàF¢q0Àrbµ#çõe∞ùh∞"îV‰À≠ ◊Zïoµ*ﬂéR‡Î˜ãÉO_Û2≥zÌmÉËˆyõÄËˆCaø 	¢
B‰Kà‚†≈UáüA{hœ÷=U àÓ{(|Ô›—Ü¬ao
—Ñ¬Ao—Ä¬µ5|p πf˝Ä≤E/†k`ô‡@pL g
®8Ù0<∂óz‡ @tPhÄeˇù∞∫ˆÑ»ÑîÕÆŒ3Xùg-≤ºﬁ;8„ÌÆÛ>»Å^“™úhÃ–“‡8Ápîµªﬁ–Íö{¢L4∫]çÚv◊UÌZlS”≠1≠ Ω€¸±ü]·VNy´Ú‚ÉÎ›ä\ﬁ™\E¥Ú¨Ÿô¯¡L¸Z˙˝úk8«⁄]P\ÛµIçLv+ŒgZï≠*grèŸ^"°óH+πïº,◊∑@oèX£–‚õ◊›’’¥‹ÆÆ∞ÿÑÍúAÊ∞∫Úòc√™¨˘eXÛÀ¨¸
Ö_YÖ∫
Ö´ﬁbDw
WX•ªÖk¨“˝Ö_º	Dw	
ó,˙Â |≈4›¡¢Á7†
 —›Ñ¬MËˇ2€±Ñ„®ø&#≠≈[2å–-ôÿû;ÄPL(≥ÅÔ◊d–õ⁄ÅhÂ©BóÆÌΩÏàÓ.ÓÇˆ.ÜõîCÑóΩ˚à D˜ 
ÿÈ=Ñ¬CoD˜
èº›P¯ÉùÁ}(‹gÁy
˜`(ØÄïª√»~&I=‚sñÁK(ºd•

ØXVØ°öÂ
/XB·O∂ªgPxlz8Ù∞gπºÉÎwl„∑PxÀ≤˚
Açû⁄b;®BCo ÑF°Ä≤lˇÖ*ˇzª"∫ˇ†ü˜ ÑF‡¬vÙ(ÔŸé˛Å¬?j´c´´røä¿⁄◊A∑ÊÛœ¯Êï7ﬂe;≤&∂ﬁ#∫ ¥
Bñø 
VŸÃÃæ0a2yOàW’aèââQ(ˆ∂!Ë†µ',Z
˙
*|áõk—¢≈ˇB)`#‡≥Ur`’LXv7÷T¡˘i˙†G:ËW—ñ1+``
ò/-áÇISP†XquáBw‡X…é„å„NÀ8ŒÄo	ﬂ·Ê∑Ñ(	˙9jëN>(L)†# Ü©”
†Á∂KX›:êlªd?@·h
æ‘6∂ˆÄ∑nóy	l,mØCìÎ b›S(<eô<Å¬¬ëfU› !øp∞üRÄ´ío†“vUˇÜ¬ﬂﬁç√‰pvâ∏P‡≤Û∆†ÄyODhxÊn[,>k˜¨~SKŸÅÍ∫ÄL˚ÄÑY¡ÅbÄ•ºS⁄
éP£?ú'¨∞Ep-u£ªB°´∑Ná–b(âaät7(tÛ÷öÑ	˙JK† Ò÷-Gh'(9yköÄÒA°¨Ó_ÀÄAΩ:ﬁÖ¡∑ßõ∫éUÅú°=A†@/Ä?aı	ëﬁ©˘⁄ï†F£Ñg⁄’ï‰/x¢=∆AàFxvúÉÙ`?OpêâI5rêL¯åÄw¢ñ√gc‹Éœgë|ß	E|&¬Û?¯|6	û´¡'1ûÎ¡ßa
<Oc?ß¬≥òfxé7û¡'˚+óâs\˙Œ∞‰˝.†;˚úÂ9ª è¸a#»3ô˝Ò
”Ô0bˇp+˚≥IÏ/gøÿ ´iÖ»>!à˘wÌ\ÿ∑‚8âòÔR∑VÙ˛PÓ›»π˙eŒ‘Ó±)‡ä•>˚≈˛|ÕM£‡ˆ]\kΩ÷tvúapm≈∏V|º }·z,`%«\üÌ∑7îù°¿æa˚’ 5”Úπ˙µ÷kMg˚u≠ÄÂj”o)ÙQ¯€“/Kgﬂ!~ -„¥éá˝}€†‡€j<= ß-¥ÃV„±÷kMZxX±«2ñæ V4¥¢≥e+ÿ~¨Î2∆ˆãÇ¨Ü∂o∞/m[æ¬	⁄¿.∆c≠◊öŒÚ<¨¯€ÓCølŸ
˚t∂lÖ§ù-[°hEgÀV|d°≥_Ä#Ä; πEŒ˝{D¡zå‡:‡
ﬁ õÀ6ﬂ	~æ∑Õ±øÍêDd:ˆù—]áäíkíênMdúsΩK7∑DŸ‘Óª∫;R≥®TÅ‚¢r¥{Æ«èæûè=_x}„=ªg∏0ûøÁ"ﬁ±Ç)êó{ıPÖ3wîcpœM3T+rG#ºPÂ	√à–TúŸ<LjÀ„#&˜aÚ=0$Åƒ1$Üœìß*ãï3&é*ÄúäÂøÆEä∏\ €Q\∏.
‘Ê‰`<O'uœ…HÆ‹GAq	§Á ’ ¡Oo‰`eLd¶ZäÌŸ46sê7∆€Ä€cˆ®©ŒP!JÒ“p4ç'(N§¬+˜LÛIã√x3:·0	„9ÕG
x®|ÖôÔ÷éÕTC£pÏ<QG∏Ú4•%-OïN3 iXYQdföî∑	∆ö;ﬂ[9Õ'◊z(‚qÂc≤—<¥Íû)Ú)WüäRÏl˜å–và≤w”X-Ñ»>«Æ¡;vÙ:¶Ûˆco?r-åú/ãƒ?Æ‹ó·£úaD<∂ﬁ6påOî3≥ã⁄„Ö$zÊ¬ÀWï A¥¡P¨ETŸ∏‹◊∏[~åBP\L‡Ç ,Pä6è–.B¶¡r0\u§x+-'¬/KDU*ﬁ(u\ûæ¿p¡C˘©vÆüròO±cÜ ≠ùÄ”|)XõÅπaè·≈µä0ˆÕ“$¨›……∂À≤ø˝öìÕp5«$	Qí/"‘+µHä «P‹ÉÂ”:)‹W¢ü"…&µ∞c3ï•pgÍåJ	ÁP¨¢&"3Dhã…cïÒ B~,çÖª…N,VåbmyõvèÕ45û’±Òc{7ﬁ'R¡· ùïÒ+Ä•ﬂç†Ú<˝ü¨±lÔ†<Kï"6€¥õ»å]ÄÛ‚π{Å
ì«(Än|ò"Ré_xÆ≥F+·]
å+/1¬Í™©ÍH‚¬ìV.°ÿﬁBÎ≤ ﬂŸîa“±X•¨ÛÆ›¯˛‹≥-SGQgéefïM
-í ÁÀ rπ0ß/5≠∂:¬ÚKC¥O5_@‘ˆa
ï©jfØÇóe«pP‘´)“"9∏äHTf´j´)i:s¡#tH_Í∏gl8í„gp!ó˚›]FïrQd`6Ëb#√â	´›…è]{Aâ†XnÇ-VT8Áá£à&óá*•™⁄rOmed∆R°ﬁX—Æ‰L$&ï"TKè„1Ω`ÎôYÏûêì®Ω&Áf†3ë$T>àBáõ¡êB1˘«∆b/ËnïâÕvÜˇ∏‘i∏…÷±∂Êlâ ó§†ˆx‰PxÕ!é r§∏qØXk“ãI±∞≤›®L\ê…ì£$√Ï	‘YDÉÅ¯f˜•0Œ . gÿç%‡cr©2VÍC°R,?òv%≠ $.6õ0˙öÂRß\êßÃôŸ`–ÃÄ•Úÿèb°quöà¬√∞≤ó√µoõ∆˚ºÕW˚í_Véıë¡k2kcÇr#ŸÌ0éÍ-Sq-¶≥Ø…tNá}U`L‹DΩ∏ΩeªπY&±Ùb≈RD Œ*æ<-ç9*o‰3en,¬Öq6ç–vóπΩà®@n'¶…}ärù±≤¶ÌÂ≤Ö`}X+” /a#¨6¶S†(Ù@!Uú£†p)ŒŒ∏,P;∏vÏER&íWòfK‘ˆç0å◊ËQÃMOAûÚT≠m›.∑Í–ﬁè±À/ùküOÆ-\Óïë"""Unit tests for collections.defaultdict."""

import os
import copy
import pickle
import tempfile
import unittest

from collections import defaultdict

def foobar():
    return list

class TestDefaultDict(unittest.TestCase):

    def test_basic(self):
        d1 = defaultdict()
        self.assertEqual(d1.default_factory, None)
        d1.default_factory = list
        d1[12].append(42)
        self.assertEqual(d1, {12: [42]})
        d1[12].append(24)
        self.assertEqual(d1, {12: [42, 24]})
        d1[13]
        d1[14]
        self.assertEqual(d1, {12: [42, 24], 13: [], 14: []})
        self.assertTrue(d1[12] is not d1[13] is not d1[14])
        d2 = defaultdict(list, foo=1, bar=2)
        self.assertEqual(d2.default_factory, list)
        self.assertEqual(d2, {"foo": 1, "bar": 2})
        self.assertEqual(d2["foo"], 1)
        self.assertEqual(d2["bar"], 2)
        self.assertEqual(d2[42], [])
        self.assertIn("foo", d2)
        self.assertIn("foo", d2.keys())
        self.assertIn("bar", d2)
        self.assertIn("bar", d2.keys())
        self.assertIn(42, d2)
        self.assertIn(42, d2.keys())
        self.assertNotIn(12, d2)
        self.assertNotIn(12, d2.keys())
        d2.default_factory = None
        self.assertEqual(d2.default_factory, None)
        try:
            d2[15]
        except KeyError as err:
            self.assertEqual(err.args, (15,))
        else:
            self.fail("d2[15] didn't raise KeyError")
        self.assertRaises(TypeError, defaultdict, 1)

    def test_missing(self):
        d1 = defaultdict()
        self.assertRaises(KeyError, d1.__missing__, 42)
        d1.default_factory = list
        self.assertEqual(d1.__missing__(42), [])

    def test_repr(self):
        d1 = defaultdict()
        self.assertEqual(d1.default_factory, None)
        self.assertEqual(repr(d1), "defaultdict(None, {})")
        self.assertEqual(eval(repr(d1)), d1)
        d1[11] = 41
        self.assertEqual(repr(d1), "defaultdict(None, {11: 41})")
        d2 = defaultdict(int)
        self.assertEqual(d2.default_factory, int)
        d2[12] = 42
        self.assertEqual(repr(d2), "defaultdict(<class 'int'>, {12: 42})")
        def foo(): return 43
        d3 = defaultdict(foo)
        self.assertTrue(d3.default_factory is foo)
        d3[13]
        self.assertEqual(repr(d3), "defaultdict(%s, {13: 43})" % repr(foo))

    def test_print(self):
        d1 = defaultdict()
        def foo(): return 42
        d2 = defaultdict(foo, {1: 2})
        # NOTE: We can't use tempfile.[Named]TemporaryFile since this
        # code must exercise the tp_print C code, which only gets
        # invoked for *real* files.
        tfn = tempfile.mktemp()
        try:
            f = open(tfn, "w+")
            try:
                print(d1, file=f)
                print(d2, file=f)
                f.seek(0)
                self.assertEqual(f.readline(), repr(d1) + "\n")
                self.assertEqual(f.readline(), repr(d2) + "\n")
            finally:
                f.close()
        finally:
            os.remove(tfn)

    def test_copy(self):
        d1 = defaultdict()
        d2 = d1.copy()
        self.assertEqual(type(d2), defaultdict)
        self.assertEqual(d2.default_factory, None)
        self.assertEqual(d2, {})
        d1.default_factory = list
        d3 = d1.copy()
        self.assertEqual(type(d3), defaultdict)
        self.assertEqual(d3.default_factory, list)
        self.assertEqual(d3, {})
        d1[42]
        d4 = d1.copy()
        self.assertEqual(type(d4), defaultdict)
        self.assertEqual(d4.default_factory, list)
        self.assertEqual(d4, {42: []})
        d4[12]
        self.assertEqual(d4, {42: [], 12: []})

        # Issue 6637: Copy fails for empty default dict
        d = defaultdict()
        d['a'] = 42
        e = d.copy()
        self.assertEqual(e['a'], 42)

    def test_shallow_copy(self):
        d1 = defaultdict(foobar, {1: 1})
        d2 = copy.copy(d1)
        self.assertEqual(d2.default_factory, foobar)
        self.assertEqual(d2, d1)
        d1.default_factory = list
        d2 = copy.copy(d1)
        self.assertEqual(d2.default_factory, list)
        self.assertEqual(d2, d1)

    def test_deep_copy(self):
        d1 = defaultdict(foobar, {1: [1]})
        d2 = copy.deepcopy(d1)
        self.assertEqual(d2.default_factory, foobar)
        self.assertEqual(d2, d1)
        self.assertTrue(d1[1] is not d2[1])
        d1.default_factory = list
        d2 = copy.deepcopy(d1)
        self.assertEqual(d2.default_factory, list)
        self.assertEqual(d2, d1)

    def test_keyerror_without_factory(self):
        d1 = defaultdict()
        try:
            d1[(1,)]
        except KeyError as err:
            self.assertEqual(err.args[0], (1,))
        else:
            self.fail("expected KeyError")

    def test_recursive_repr(self):
        # Issue2045: stack overflow when default_factory is a bound method
        class sub(defaultdict):
            def __init__(self):
                self.default_factory = self._factory
            def _factory(self):
                return []
        d = sub()
        self.assertRegex(repr(d),
            r"sub\(<bound method .*sub\._factory "
            r"of sub\(\.\.\., \{\}\)>, \{\}\)")
