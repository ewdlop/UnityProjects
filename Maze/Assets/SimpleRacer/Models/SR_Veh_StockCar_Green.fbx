 stream, string name) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor initializes the <see cref="P:System.Diagnostics.TraceListener.Name" /> property to the value of the <paramref name="name" /> parameter, or to an empty string ("") if the <paramref name="name" /> parameter is null.  The <see cref="P:System.Diagnostics.TraceListener.Name" /> property can be used as an index into the Listeners collection to programmatically change the properties for the listener. For example, the following code sets the <see cref="P:System.Diagnostics.DelimitedListTraceListener.Delimiter" /> property for the instance of <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> that has the name "delimListener":   </para>
          <code>((DelimitedListTraceListener)Trace.Listeners["delimListener"]).Delimiter = ":"</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> class that writes to the specified output stream and has the specified name. </para>
        </summary>
        <param name="stream">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.IO.Stream" /> to receive the output.</param>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the new instance of the trace listener. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DelimitedListTraceListener (System.IO.TextWriter writer, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer, string name) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor initializes the <see cref="P:System.Diagnostics.TraceListener.Name" /> property to the value of the <paramref name="name" /> parameter, or to an empty string ("") if the <paramref name="name" /> parameter is null. The <see cref="P:System.Diagnostics.TraceListener.Name" /> property can be used as an index into the Listeners collection to programmatically change the properties for the listener. For example the following code sets the <see cref="P:System.Diagnostics.DelimitedListTraceListener.Delimiter" /> property for the instance of <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> that has the name "delimListener":   </para>
          <code>((DelimitedListTraceListener)Trace.Listeners["delimListener"]).Delimiter = ":"</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> class that writes to the specified text writer and has the specified name. </para>
        </summary>
        <param name="writer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.IO.TextWriter" /> to receive the output.</param>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the new instance of the trace listener. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DelimitedListTraceListener (string fileName, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string name) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor initializes a new instance of the <see cref="T:System.IO.StreamWriter" /> class for the specified file on the specified path, using <see cref="P:System.Text.Encoding.UTF8" /> encoding. If the file exists, it is appended to. If the file does not exist, a new file is created.</para>
          <block subset="none" type="note">
            <para>To reduce the chance of an exception, any character that might invalidate the output is replaced with a "?" character.</para>
          </block>
          <para>The <see cref="P:System.Diagnostics.TraceListener.Name" /> property is set to the value of the <paramref name="name" /> parameter, or to an empty string ("") if the <paramref name="name" /> parameter is null. The <see cref="P:System.Diagnostics.TraceListener.Name" /> property can be used as an index into the Listeners collection to programmatically change the properties for the listener. For example, the following code sets the <see cref="P:System.Diagnostics.DelimitedListTraceListener.Delimiter" /> property for the instance of <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> that has the name "delimListener":   </para>
          <code>((DelimitedListTraceListener)Trace.Listeners["delimListener"]).Delimiter = ":"</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> class that writes to the specified file and has the specified name. </para>
        </summary>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file to receive the output. </param>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the new instance of the trace listener. </param>
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public string Delimiter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Delimiter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default delimiter is ";" (semicolon). The following configuration file example shows the setting of the <see cref="P:System.Diagnostics.DelimitedListTraceListener.Delimiter" /> property using the delimiter attribute in a configuration file:</para>
          <code>&lt;configuration&gt;
  &lt;system.diagnostics&gt;
    &lt;trace autoflush="false" indentsize="4"&gt;
      &lt;listeners&gt;
        &lt;add name="delimitedListener" 
          type="System.Diagnostics.DelimitedListTraceListener" 
          delimiter=":" 
          initializeData="delimitedOutput.txt" 
          traceOutputOptions="ProcessId, DateTime" /&gt;
        &lt;remove name="Default" /&gt;
      &lt;/listeners&gt;
    &lt;/trace&gt;
  &lt;/system.diagnostics&gt;
&lt;/configuration&gt;
</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the delimiter for the delimited list.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedAttributes">
      <MemberSignature Language="C#" Value="protected override string[] GetSupportedAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance string[] GetSupportedAttributes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A custom attribute is an attribute that is not inherited from the base class that can be used to set a property for the class. The custom attribute for <see cref="T:System.Diagnostics.DelimitedListTraceListener" /> is used to set the <see cref="P:System.Diagnostics.DelimitedListTraceListener.Delimiter" /> property. The following configuration file example shows the use of the delimiter attribute to set the <see cref="P:System.Diagnostics.DelimitedListTraceListener.Delimiter" /> property:</para>
          <code>&lt;configuration&gt;
  &lt;system.diagnostics&gt;
    &lt;trace autoflush="false" indentsize="4"&gt;
      &lt;listeners&gt;
        &lt;add name="delimitedListener" 
          type="System.Diagnostics.DelimitedListTraceListener" 
<codeFeaturedElement>          delimiter=":" </codeFeaturedElement>
          initializeData="delimitedOutput.txt" 
          traceOutputOptions="ProcessId, DateTime" /&gt;
        &lt;remove name="Default" /&gt;
      &lt;/listeners&gt;
    &lt;/trace&gt;
  &lt;/system.diagnostics&gt;
&lt;/configuration&gt;</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the custom configuration file attribute supported by the delimited trace listener.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string array that contains the single value "delimiter".</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The values of the <paramref name="source" />, <paramref name="eventType" />, and <paramref name="id" /> parameters are written as a header. The data object is converted to a string using the ToString method of the object. The <paramref name="eventCache" /> data is written as a footer whose content depends on the value of the <see cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" /> property.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Diagnostics.DelimitedListTraceListener.TraceData" /> method is not intended to be called by application code. It is called by methods of the <see cref="T:System.Diagnostics.Debug" />, <see cref="T:System.Diagnostics.Trace" />, and <see cref="T:System.Diagnostics.TraceSource" /> classes to write trace data.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes trace information, a data object, and event information to the output file or stream.</para>
        </summary>
        <param name="eventCache">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Diagnostics.TraceEventCache" /> object that contains the current process ID, thread ID, and stack trace information.</param>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />A name used to identify the output, typically the name of the application that generated the trace event.</param>
        <param name="eventType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Diagnostics.TraceEventType" /> values specifying the type of event that has caused the trace.</param>
        <param name="id">
          <attribution license="cc4" from="Microsoft" modified="false" />A numeric identifier for the event.</param>
        <param name="data">
          <attribution license="cc4" from="Microsoft" modified="false" />A data object to write to the output file or stream.</param>
      </Docs>
    </Member>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object[] data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The values of the <paramref name="source" />, <paramref name="eventType" />, and <paramref name="id" /> parameters are written as a header. The data objects are converted to strings using the ToString method of each object. The <paramref name="eventCache" /> data is written as a footer whose content depends on the value of the <see cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" /> property.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Diagnostics.DelimitedListTraceListener.TraceData" /> method is not intended to be called by application code. It is called by methods of the <see cref="T:System.Diagnostics.Debug" />, <see cref="T:System.Diagnostics.Trace" />, and <see cref="T:System.Diagnostics.TraceSource" /> classes to write trace data.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes trace information, an array of data objects, and event information to the output file or stream.</para>
        </summary>
        <param name="eventCache">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Diagnostics.TraceEventCache" /> object that contains the current process ID, thread ID, and stack trace information.</param>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />A name used to identify the output, typically the name of the application that generated the trace event.</param>
        <param name="eventType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Diagnostics.TraceEventType" /> values specifying the type of event that has caused the trace.</param>
        <param name="id">
          <attribution license="cc4" from="Microsoft" modified="false" />A numeric identifier for the event.</param>
        <param name="data">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of data objects to write to the output file or stream.</param>
      </Docs>
    </Member>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The values of the <paramref name="source" />, <paramref name="eventType" />, and <paramref name="id" /> parameters are written as a header, followed by the <paramref name="message" /> data. The <paramref name="eventCache" /> data is written as a footer whose content depends on the value of the <see cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" /> property.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Diagnostics.DelimitedListTraceListener.TraceEvent" /> method is not intended to be called by application code. It is called by methods of the <see cref="T:System.Diagnostics.Debug" />, <see cref="T:System.Diagnostics.Trace" />, and <see cref="T:System.Diagnostics.TraceSource" /> classes to write trace data.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes trace information, a message, and event information to the output file or stream.</para>
        </summary>
        <param name="eventCache">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Diagnostics.TraceEventCache" /> object that contains the current process ID, thread ID, and stack trace information.</param>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />A name used to identify the output, typically the name of the application that generated the trace event.</param>
        <param name="eventType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Diagnostics.TraceEventType" /> values specifying the type of event that has caused the trace.</param>
        <param name="id">
          <attribution license="cc4" from="Microsoft" modified="false" />A numeric identifier for the event.</param>
        <param name="message">
          <attribution license="cc4" from="Microsoft" modified="false" />The trace message to write to the output file or stream.</param>
      </Docs>
    </Member>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string format, object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The values of the <paramref name="source" />, <paramref name="eventType" />, and <paramref name="id" /> parameters are written as a header. The <paramref name="args" /> object array is converted to a string using the <see cref="M:System.String.Format(System.String,System.Object[])" /> method, passing the <paramref name="format" /> string and <paramref name="args" /> array to format the string as the message portion of the trace. The <paramref name="eventCache" /> data is written as a footer whose content depends on the value of the <see cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" /> property.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Diagnostics.DelimitedListTraceListener.TraceEvent" /> method is not intended to be called by application code. It is called by methods of the <see cref="T:System.Diagnostics.Debug" />, <see cref="T:System.Diagnostics.Trace" />, and <see cref="T:System.Diagnostics.TraceSource" /> classes to write trace data.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes trace information, a formatted array of objects, and event information to the output file or stream.</para>
        </summary>
        <param name="eventCache">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Diagnostics.TraceEventCache" /> object that contains the current process ID, thread ID, and stack trace information.</param>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />A name used to identify the output, typically the name of the application that generated the trace event.</param>
        <param name="eventType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Diagnostics.TraceEventType" /> values specifying the type of event that has caused the trace.</param>
        <param name="id">
          <attribution license="cc4" from="Microsoft" modified="false" />A numeric identifier for the event.</param>
        <param name="format">
          <attribution license="cc4" from="Microsoft" modified="false" />A format string that contains zero or more format items that correspond to objects in the <paramref name="args" /> array.</param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array containing zero or more objects to format.</param>
      </Docs>
    </Member>
  </Members>
</Type>                                                                                                                                                                                                                                                                 Ùæ¨Oµ7/i~Œc*¡6‘Z–jRBÜE8ﬁ“∑[%Ø6:∆Ø}Ù\ä#,˘Ú‹UÛ.ñûmúï&e8∂I¯ÆÇƒ˛Ãë1wŸoªæ0ÕÕÆ«›I¯™◊¬x{È˝2möúâ”ﬁIÓùküÈ„ bÓ˜Ø’óì*é1≥∂\—áíù‹y¯0Ïª‘Œ¸ﬁq‚¸†Ëâ/8G.·|,+ıü2Ñ6∏qHIªûËk£ã⁄ú3±ØÄ√`#Â‘æ˜÷!?iÇÊ—;¨ˇ˛Ró∏~ıM¥’©R°-LpSz˜ÜΩIŸx‰AñÚo„Èàf1c´ü¥7ÆÉ/¨fÿ˚,H¡ü±˜≤;·EÏÕæêΩÅÇ£R¶…7Í0ï∞<˝fª‰·ˇÒÈIa-· ﬁúï_b`7Fœ)G¯Øa˝øµwæf?w√•´¸¸ueI”ÊPã-àr9≤ˇVüúgõØÓJ¨í{∏2'ﬁ«π y◊TÑ”<ıyòfØmu©]ö@è "¶∏:d‰‡˝wCΩWôh{áq´üõù=⁄7ê∞≥=≤Ó’±:˘h‘Î#Î$ƒ¸&?ÎIïcßÔıª¬cöy»ãâî\ï≠ñ·éÆ∑`}„Ï∏â+Â†»¶^z>ÏDfsFCÜƒ‹∆O„g4g˜u&¸°·Œ*Ó∑¶#Íïd∂Á÷æΩ≤áY{◊CItæSBp‹ä‡fZ≈˙‡…™îOÍ∏ŸùGÀLD«4Yÿf˙Û.V3y¯9¥ˆOò≥ÙáútiE∫`>ÁF!a 0ÛmŸÍùÛ˝Ôˆ\xôWHV™2≠˜_)ƒ¨nÔÔ†Ø≥Í ˘Ûe[‹Niˇåç<πv‘^πùØ·§òË}ù◊2Ø´«õd>¬FöHÆ3îÿ·∆Ê√ÈÆ‘Ã;Îâ5QRd:é° —⁄tJùî’≈Úù±ŸA¯JﬂlŒ”µgÜWø«aΩ+~t[4ƒã7∫’d
Ó_Èä‘@ó⁄'Vıâˆ_(ª„RbE˚PKŒº¯XY~»ŸÛY«˘›œ(&è-dÕ⁄ø¶6Î√æ;¢oÖÃ”Üå^å#ƒXÊ=ûØ|ﬂúh∆Hˇd≠ﬂÍ¯hˆ£ØÚ'7…Ysy5rÊ~«P§ ©I~π^,∑/^^>o2üDŒä˙B◊fÊ/#
≥ba20_b∆∞¬µ´©¡‡lC %éS≠≠'2ª?6ˆ>q?^Ú0,n Vük¬Ñ¿»≠ê0∑W	1◊VÒ∞RrW24$ŸìUI∫&∏-j6ÅñÅ∂xÇñÄ≈Z()jÄ-Ë¸W`¿4K"RlŸ7!ãﬁ'dãEä¸vëÉóá‡-t¿íºy”miKø˚`‰B∏⁄•;“o Õ∆%‘Æï?0›vCØºÁ€¶¡≥W”ÃQÁ”ZülLéÎÃ/>w&˜Hªì«®«’∑°òñx’ñá˘ôà·xƒ—é≥Œ]º)Ìe{3è≥NîØË÷@ä!uıHg;ü¡pÌW/\‘”ñ«À¡[=π2ˇ\M¸«wî≠xqBá@˛Œí8_CC∑4ó˚èûåhè±dq÷Ã‹ÔæÌò—·ÊQ‘ÁòæOüc}éØ«èuƒÓ“ÕçJN §eïŒ;˜-ÃZ>JµÎxmüX≤‚EF~äÙµÕ√≤ #lö{wÍ!{™&è\øs}ËTôH·”Ω#WÑ7gS$å`
Rb~\È0‰j ‚òö…á˛µ»a˘∑ÊÒ6òg·4fûÒÇ ü”–bÿ¶Rsä °®†ÇQt¯e˚y¨Aá=≤–Ê≤øˆ)§o‹ŒIŒéßŒπ€/∆shD.ôC°Ú,j£¥ô{û˚UI“–›ÏµM?©ëW§NÛ•"…Úmﬂ˛µ;eì|ï•‘nøA∂Zón¨f'fÓªËuﬂ~”…™¿F˘∑C∂ÿ0ﬂmµ?+˙ŒÔ).}⁄”9©2ËL}sGŸ˘¯≤ÌÎõ'ÓÚJîÀE∑9rùP≤H?AoÍ{ÎkÈ≠ÍÉI
ïôﬁÙ˙«k|º¨å>]π?8ÿ/£Ò@:'Üæêºæ”I∞RÆ0\∆`ëû˜X¯ «≠√.''GØ•nFÆ∑Vî-	£œ’Ál“U™|Q∂÷Nxî?Åhµ6øM=éAWzÉÅêºÍ:ÉÃn˘m∏ ˚√>õ
:µ˙`äò‡¸‚§A`(b,@∆∏ËçóËWò"˙ô˙∆ãçÍBßCEÉÀv\Ù÷ãö^˙Ì[/Ãí∂4"„^◊˙ùÌ$~<™´o´ïz[eÒrÁÒ“ÿ—Wö—ªÔ>À¢0€Ä¸q«o-»7]ÿ™ÕMÔƒ	>ê•ñé*30)¸ô‹ka…È…-¸{ö°Ê≈fí»j‡Eì*ﬂïg^ÜÕaÚ?bﬂˇ6i\t80-~/ñ∞¯f◊mªpKBÍÄ« ˜¥d„ï)±∞Ú&Ètíu*wˆF·]cB#É˚DòÕ/∫Hº¥RπΩ±\‹˘P∏∂‹ÎeNA˚e&ÒÔVI&òÔ˜,∏/M<@ËMΩØ8·T∆Wpê…’Ó˘yãäs˛ümÕ÷Vr˜w8ï…ƒÑÆï±„øÍ®6VyÔ€µ√ûºÓ&∆.ü≤∑Ê£€Ù.o≤ˇô'_øÿ<dÑe√]?zoÇ^Ò∂≥gø√˚N¬ÂÕÛí∏§O∑“éâµhÁj¯4…nkˇ®u;)é|∏åØ”#g`=•âG{%b5OûfLRÈ‚π¬XÈ£ó¶}˝è ÿˇ‡lÃæxƒ~:¡±Üö‡òõÕtàe»ˆ÷7)â≤5OèüTkóoÕ˝éEVD¿ä”	dQÁI√RK»\™È2VVUVí¡*baÂEiïWﬂvÏ™ÉÏ˙H¶∆D…‚ÿWäˇs)bÍDE√*hX˘?ü"^‘7≥€$¯»bÒZùJ∑&IïŸñ§Ú∆ã{π∞7©ç[ÛêÏ6|,∫‘¸‚Œqÿ◊î2º«#3»óí«x—*Æü2˛ì–l∫U»I. ºå1lÛ@Áû`dDk=GlŸ&Ï˚òK£ÏåOq¥ŸéE€"•º©≤®’⁄muJ¯èÃ∆+VòÚ‹WO<„7ºéørTøÀ/éÎ√ÜÒ'>ü:)ó_ªè¿∏F≠¸Å„ì™«l}R{6ÔEæ£ﬂˇ#KGÊÙ∆|°O∆(ÚöπNŒkÓ%¨ˇ|ÑâU„Æ›ò{6-È{ò√êE«DåØ… d'´”ˆU∑%tÍ√Õ¶û{eçoøncxbeÀ!ÂÎ_wÀ,\ó°T`Ël2k.H8¯ñ≥õM8¨∞§~ÚA®•ƒu‡aêûfÈø≥ÌõÁ8òJgXêê¿®PSJ”E%jÒ_Á‡øbª◊¨ÆÊ°Ónæ¸Œôú<V<n„ÒF˜QKΩùYQ~–nΩÀmjG+ÛÑ&&î>Óâﬂu3	IÕ≤÷˚j˜0ºîì)‘í·πîcÏkd‚µöæ´ı¡ıX!ˇc˜.DWñ2<j:–·≈}l}R≥‰¶wØ~(¶ÿ∂n3˙\±NÆ=∫⁄~”ó√ï2{…wdŒo–9¨oT«Ìf’(P#x”⁄ŸñÙ≈˝è5"ä]€NÁ'o?ª6Ú^{≈…~‘ó∂äUuqíLˆÙÔ~≤æè\©d≤ÚÙUÀ≠üN?yqêŸ0∏#⁄†ù˝è[ÉgÜÓD”::›™\∑5C\`áﬁKæUBDïªº
ë;c∑‰Óts	Ijá[íÖgŸÓ%H˜2IÜyz[ñá˛$5º({ÒKÍc!√µ∂πõ8ò„ËÏ—™qÏ÷ŒÊ4ûõˇ[ÜÛÃZ0YgXHçU¯O1‹o˙&√QôT£Eh¢í·®£pT‚ús‰PpT¨1{)$ÇÛ€Kô…ª]‰uÃqÚÆ7|†7YŒÉÏkŒ5G¬äBX¡ﬂòÌ ﬂP¡/u
J‘/Á3ﬂYQø˘"Cr"Çøp.`>Ú[3È]7π¢C™Ã€ƒæ1fSN|Q¸πNˆDÚ ˛æ⁄ñ⁄§ÜóäEO£™û	AW(K˚#BìÉ˚ë?æ}tœTàüs›Aúo8æ–ŸBœù·Â&u°§/p4wÉöÊÈN÷Û¢“˝˘ŸûÒbIM‰îÅlù\Ò56ÿ3‚«É5">D|[7}; RUN: llc -march=hexagon < %s | FileCheck %s

; Generator: vdeal(0x1f), vshuff(0x32), vshuff(0x24), vshuff(0x26), vshuff(0x08), vdeal(0x3a), vshuff(0x0c), vdeal(0x0e), vdeal(0x30), vdeal(0x22), vdeal(0x14), vdeal(0x36), vdeal(0x18), vdeal(0x0a), vdeal(0x3c)
; CHECK-LABEL: test_0000:
; CHECK-DAG: [[R00:r[0-9]+]] = #49
; CHECK-DAG: [[R01:r[0-9]+]] = #3
; CHECK: v[[H00:[0-9]+]]:[[L00:[0-9]+]] = vshuff(v1,v0,[[R00]])
; CHECK: v[[H01:[0-9]+]]:[[L01:[0-9]+]] = vdeal(v[[H00]],v[[L00]],[[R01]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0000(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 2, i32 32, i32 34, i32 4, i32 6, i32 36, i32 38, i32 8, i32 10, i32 40, i32 42, i32 12, i32 14, i32 44, i32 46, i32 1, i32 3, i32 33, i32 35, i32 5, i32 7, i32 37, i32 39, i32 9, i32 11, i32 41, i32 43, i32 13, i32 15, i32 45, i32 47, i32 16, i32 18, i32 48, i32 50, i32 20, i32 22, i32 52, i32 54, i32 24, i32 26, i32 56, i32 58, i32 28, i32 30, i32 60, i32 62, i32 17, i32 19, i32 49, i32 51, i32 21, i32 23, i32 53, i32 55, i32 25, i32 27, i32 57, i32 59, i32 29, i32 31, i32 61, i32 63, i32 64, i32 66, i32 96, i32 98, i32 68, i32 70, i32 100, i32 102, i32 72, i32 74, i32 104, i32 106, i32 76, i32 78, i32 108, i32 110, i32 65, i32 67, i32 97, i32 99, i32 69, i32 71, i32 101, i32 103, i32 73, i32 75, i32 105, i32 107, i32 77, i32 79, i32 109, i32 111, i32 80, i32 82, i32 112, i32 114, i32 84, i32 86, i32 116, i32 118, i32 88, i32 90, i32 120, i32 122, i32 92, i32 94, i32 124, i32 126, i32 81, i32 83, i32 113, i32 115, i32 85, i32 87, i32 117, i32 119, i32 89, i32 91, i32 121, i32 123, i32 93, i32 95, i32 125, i32 127>
  ret <128 x i8> %p
}

; Generator: vshuff(0x1e), vshuff(0x00), vdeal(0x12), vshuff(0x34), vshuff(0x0b), vshuff(0x2b), vdeal(0x16), vshuff(0x2e), vshuff(0x1a), vdeal(0x28), vshuff(0x2d), vdeal(0x15), vdeal(0x1d), vshuff(0x25), vshuff(0x0d)
; CHECK-LABEL: test_0001:
; CHECK-DAG: [[R10:r[0-9]+]] = #10
; CHECK-DAG: [[R11:r[0-9]+]] = #34
; CHECK-DAG: [[R12:r[0-9]+]] = #16
; CHECK: v[[H10:[0-9]+]]:[[L10:[0-9]+]] = vshuff(v1,v0,[[R10]])
; CHECK: v[[H11:[0-9]+]]:[[L11:[0-9]+]] = vshuff(v[[H10]],v[[L10]],[[R11]])
; CHECK: v[[H12:[0-9]+]]:[[L12:[0-9]+]] = vshuff(v[[H11]],v[[L11]],[[R12]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0001(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 1, i32 8, i32 9, i32 4, i32 5, i32 12, i32 13, i32 2, i32 3, i32 10, i32 11, i32 6, i32 7, i32 14, i32 15, i32 32, i32 33, i32 40, i32 41, i32 36, i32 37, i32 44, i32 45, i32 34, i32 35, i32 42, i32 43, i32 38, i32 39, i32 46, i32 47, i32 64, i32 65, i32 72, i32 73, i32 68, i32 69, i32 76, i32 77, i32 66, i32 67, i32 74, i32 75, i32 70, i32 71, i32 78, i32 79, i32 96, i32 97, i32 104, i32 105, i32 100, i32 101, i32 108, i32 109, i32 98, i32 99, i32 106, i32 107, i32 102, i32 103, i32 110, i32 111, i32 16, i32 17, i32 24, i32 25, i32 20, i32 21, i32 28, i32 29, i32 18, i32 19, i32 26, i32 27, i32 22, i32 23, i32 30, i32 31, i32 48, i32 49, i32 56, i32 57, i32 52, i32 53, i32 60, i32 61, i32 50, i32 51, i32 58, i32 59, i32 54, i32 55, i32 62, i32 63, i32 80, i32 81, i32 88, i32 89, i32 84, i32 85, i32 92, i32 93, i32 82, i32 83, i32 90, i32 91, i32 86, i32 87, i32 94, i32 95, i32 112, i32 113, i32 120, i32 121, i32 116, i32 117, i32 124, i32 125, i32 114, i32 115, i32 122, i32 123, i32 118, i32 119, i32 126, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x2c), vshuff(0x27), vshuff(0x07), vshuff(0x12), vdeal(0x04), vshuff(0x03), vshuff(0x23), vshuff(0x26), vdeal(0x06), vdeal(0x08), vdeal(0x01), vshuff(0x09), vdeal(0x11), vdeal(0x19), vshuff(0x21)
; CHECK-LABEL: test_0002:
; CHECK-DAG: [[R20:r[0-9]+]] = #5
; CHECK-DAG: [[R21:r[0-9]+]] = #18
; CHECK: v[[H20:[0-9]+]]:[[L20:[0-9]+]] = vdeal(v1,v0,[[R20]])
; CHECK: v[[H21:[0-9]+]]:[[L21:[0-9]+]] = vshuff(v[[H20]],v[[L20]],[[R21]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0002(<128 x i8> %v0) #0 {
; CHECK-NOT: v{{[0-9:]+}} =
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 4, i32 1, i32 5, i32 64, i32 68, i32 65, i32 69, i32 8, i32 12, i32 9, i32 13, i32 72, i32 76, i32 73, i32 77, i32 2, i32 6, i32 3, i32 7, i32 66, i32 70, i32 67, i32 71, i32 10, i32 14, i32 11, i32 15, i32 74, i32 78, i32 75, i32 79, i32 32, i32 36, i32 33, i32 37, i32 96, i32 100, i32 97, i32 101, i32 40, i32 44, i32 41, i32 45, i32 104, i32 108, i32 105, i32 109, i32 34, i32 38, i32 35, i32 39, i32 98, i32 102, i32 99, i32 103, i32 42, i32 46, i32 43, i32 47, i32 106, i32 110, i32 107, i32 111, i32 16, i32 20, i32 17, i32 21, i32 80, i32 84, i32 81, i32 85, i32 24, i32 28, i32 25, i32 29, i32 88, i32 92, i32 89, i32 93, i32 18, i32 22, i32 19, i32 23, i32 82, i32 86, i32 83, i32 87, i32 26, i32 30, i32 27, i32 31, i32 90, i32 94, i32 91, i32 95, i32 48, i32 52, i32 49, i32 53, i32 112, i32 116, i32 113, i32 117, i32 56, i32 60, i32 57, i32 61, i32 120, i32 124, i32 121, i32 125, i32 50, i32 54, i32 51, i32 55, i32 114, i32 118, i32 115, i32 119, i32 58, i32 62, i32 59, i32 63, i32 122, i32 126, i32 123, i32 127>
  ret <128 x i8> %p
}

; Generator: vshuff(0x11), vshuff(0x2b), vdeal(0x3d), vdeal(0x3e), vshuff(0x02), vdeal(0x1c), vdeal(0x2f), vdeal(0x0f), vshuff(0x36), vshuff(0x38), vdeal(0x35), vshuff(0x1b), vshuff(0x3b), vdeal(0x21), vdeal(0x15)
; CHECK-LABEL: test_0003:
; CHECK-DAG: [[R30:r[0-9]+]] = #34
; CHECK-DAG: [[R31:r[0-9]+]] = #10
; CHECK-DAG: [[R32:r[0-9]+]] = #5
; CHECK: v[[H30:[0-9]+]]:[[L30:[0-9]+]] = vshuff(v1,v0,[[R30]])
; CHECK: v[[H31:[0-9]+]]:[[L31:[0-9]+]] = vdeal(v[[H30]],v[[L30]],[[R31]])
; CHECK: v[[H32:[0-9]+]]:[[L32:[0-9]+]] = vdeal(v[[H31]],v[[L31]],[[R32]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0003(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 4, i32 8, i32 12, i32 64, i32 68, i32 72, i32 76, i32 32, i32 36, i32 40, i32 44, i32 96, i32 100, i32 104, i32 108, i32 16, i32 20, i32 24, i32 28, i32 80, i32 84, i32 88, i32 92, i32 48, i32 52, i32 56, i32 60, i32 112, i32 116, i32 120, i32 124, i32 2, i32 6, i32 10, i32 14, i32 66, i32 70, i32 74, i32 78, i32 34, i32 38, i32 42, i32 46, i32 98, i32 102, i32 106, i32 110, i32 18, i32 22, i32 26, i32 30, i32 82, i32 86, i32 90, i32 94, i32 50, i32 54, i32 58, i32 62, i32 114, i32 118, i32 122, i32 126, i32 1, i32 5, i32 9, i32 13, i32 65, i32 69, i32 73, i32 77, i32 33, i32 37, i32 41, i32 45, i32 97, i32 101, i32 105, i32 109, i32 17, i32 21, i32 25, i32 29, i32 81, i32 85, i32 89, i32 93, i32 49, i32 53, i32 57, i32 61, i32 113, i32 117, i32 121, i32 125, i32 3, i32 7, i32 11, i32 15, i32 67, i32 71, i32 75, i32 79, i32 35, i32 39, i32 43, i32 47, i32 99, i32 103, i32 107, i32 111, i32 19, i32 23, i32 27, i32 31, i32 83, i32 87, i32 91, i32 95, i32 51, i32 55, i32 59, i32 63, i32 115, i32 119, i32 123, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x0a), vdeal(0x10), vdeal(0x31), vshuff(0x30), vdeal(0x00), vdeal(0x39), vdeal(0x0e), vshuff(0x37), vshuff(0x17), vshuff(0x06), vshuff(0x07), vshuff(0x09), vshuff(0x3c), vshuff(0x33), vshuff(0x33)
; CHECK-LABEL: test_0004:
; CHECK-DAG: [[R40:r[0-9]+]] = #57
; CHECK-DAG: [[R41:r[0-9]+]] = #6
; CHECK-DAG: [[R42:r[0-9]+]] = #1
; CHECK: v[[H40:[0-9]+]]:[[L40:[0-9]+]] = vshuff(v1,v0,[[R40]])
; CHECK: v[[H41:[0-9]+]]:[[L41:[0-9]+]] = vshuff(v[[H40]],v[[L40]],[[R41]])
; CHECK: v[[H42:[0-9]+]]:[[L42:[0-9]+]] = vshuff(v[[H41]],v[[L41]],[[R42]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0004(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 4, i32 32, i32 36, i32 2, i32 6, i32 34, i32 38, i32 1, i32 5, i32 33, i32 37, i32 3, i32 7, i32 35, i32 39, i32 8, i32 12, i32 40, i32 44, i32 10, i32 14, i32 42, i32 46, i32 9, i32 13, i32 41, i32 45, i32 11, i32 15, i32 43, i32 47, i32 16, i32 20, i32 48, i32 52, i32 18, i32 22, i32 50, i32 54, i32 17, i32 21, i32 49, i32 53, i32 19, i32 23, i32 51, i32 55, i32 24, i32 28, i32 56, i32 60, i32 26, i32 30, i32 58, i32 62, i32 25, i32 29, i32 57, i32 61, i32 27, i32 31, i32 59, i32 63, i32 64, i32 68, i32 96, i32 100, i32 66, i32 70, i32 98, i32 102, i32 65, i32 69, i32 97, i32 101, i32 67, i32 71, i32 99, i32 103, i32 72, i32 76, i32 104, i32 108, i32 74, i32 78, i32 106, i32 110, i32 73, i32 77, i32 105, i32 109, i32 75, i32 79, i32 107, i32 111, i32 80, i32 84, i32 112, i32 116, i32 82, i32 86, i32 114, i32 118, i32 81, i32 85, i32 113, i32 117, i32 83, i32 87, i32 115, i32 119, i32 88, i32 92, i32 120, i32 124, i32 90, i32 94, i32 122, i32 126, i32 89, i32 93, i32 121, i32 125, i32 91, i32 95, i32 123, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x1c), vshuff(0x31), vdeal(0x1f), vshuff(0x29), vdeal(0x1a), vshuff(0x2a), vshuff(0x25), vshuff(0x05), vshuff(0x04), vshuff(0x23), vdeal(0x0d), vdeal(0x20), vshuff(0x29), vdeal(0x2f), vshuff(0x1d)
; CHECK-LABEL: test_0005:
; CHECK-DAG: [[R50:r[0-9]+]] = #33
; CHECK-DAG: [[R51:r[0-9]+]] = #12
; CHECK-DAG: [[R52:r[0-9]+]] = #1{{$}}
; CHECK: v[[H50:[0-9]+]]:[[L50:[0-9]+]] = vshuff(v1,v0,[[R50]])
; CHECK: v[[H51:[0-9]+]]:[[L51:[0-9]+]] = vshuff(v[[H50]],v[[L50]],[[R51]])
; CHECK: v[[H52:[0-9]+]]:[[L52:[0-9]+]] = vshuff(v[[H51]],v[[L51]],[[R52]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0005(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 8, i32 2, i32 10, i32 32, i32 40, i32 34, i32 42, i32 4, i32 12, i32 6, i32 14, i32 36, i32 44, i32 38, i32 46, i32 16, i32 24, i32 18, i32 26, i32 48, i32 56, i32 50, i32 58, i32 20, i32 28, i32 22, i32 30, i32 52, i32 60, i32 54, i32 62, i32 1, i32 9, i32 3, i32 11, i32 33, i32 41, i32 35, i32 43, i32 5, i32 13, i32 7, i32 15, i32 37, i32 45, i32 39, i32 47, i32 17, i32 25, i32 19, i32 27, i32 49, i32 57, i32 51, i32 59, i32 21, i32 29, i32 23, i32 31, i32 53, i32 61, i32 55, i32 63, i32 64, i32 72, i32 66, i32 74, i32 96, i32 104, i32 98, i32 106, i32 68, i32 76, i32 70, i32 78, i32 100, i32 108, i32 102, i32 110, i32 80, i32 88, i32 82, i32 90, i32 112, i32 120, i32 114, i32 122, i32 84, i32 92, i32 86, i32 94, i32 116, i32 124, i32 118, i32 126, i32 65, i32 73, i32 67, i32 75, i32 97, i32 105, i32 99, i32 107, i32 69, i32 77, i32 71, i32 79, i32 101, i32 109, i32 103, i32 111, i32 81, i32 89, i32 83, i32 91, i32 113, i32 121, i32 115, i32 123, i32 85, i32 93, i32 87, i32 95, i32 117, i32 125, i32 119, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x22), vshuff(0x24), vdeal(0x16), vdeal(0x18), vshuff(0x17), vdeal(0x2d), vshuff(0x38), vshuff(0x20), vshuff(0x37), vdeal(0x3f), vdeal(0x10), vdeal(0x32), vshuff(0x14), vshuff(0x13), vdeal(0x0b)
; CHECK-LABEL: test_0006:
; CHECK-DAG: [[R60:r[0-9]+]] = #3{{$}}
; CHECK-DAG: [[R61:r[0-9]+]] = #36
; CHECK: v[[H60:[0-9]+]]:[[L60:[0-9]+]] = vdeal(v1,v0,[[R60]])
; CHECK: v[[H61:[0-9]+]]:[[L61:[0-9]+]] = vshuff(v[[H60]],v[[L60]],[[R61]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0006(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 2, i32 64, i32 66, i32 1, i32 3, i32 65, i32 67, i32 8, i32 10, i32 72, i32 74, i32 9, i32 11, i32 73, i32 75, i32 16, i32 18, i32 80, i32 82, i32 17, i32 19, i32 81, i32 83, i32 24, i32 26, i32 88, i32 90, i32 25, i32 27, i32 89, i32 91, i32 4, i32 6, i32 68, i32 70, i32 5, i32 7, i32 69, i32 71, i32 12, i32 14, i32 76, i32 78, i32 13, i32 15, i32 77, i32 79, i32 20, i32 22, i32 84, i32 86, i32 21, i32 23, i32 85, i32 87, i32 28, i32 30, i32 92, i32 94, i32 29, i32 31, i32 93, i32 95, i32 32, i32 34, i32 96, i32 98, i32 33, i32 35, i32 97, i32 99, i32 40, i32 42, i32 104, i32 106, i32 41, i32 43, i32 105, i32 107, i32 48, i32 50, i32 112, i32 114, i32 49, i32 51, i32 113, i32 115, i32 56, i32 58, i32 120, i32 122, i32 57, i32 59, i32 121, i32 123, i32 36, i32 38, i32 100, i32 102, i32 37, i32 39, i32 101, i32 103, i32 44, i32 46, i32 108, i32 110, i32 45, i32 47, i32 109, i32 111, i32 52, i32 54, i32 116, i32 118, i32 53, i32 55, i32 117, i32 119, i32 60, i32 62, i32 124, i32 126, i32 61, i32 63, i32 125, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x0f), vdeal(0x01), vshuff(0x3b), vdeal(0x0c), vdeal(0x3f), vdeal(0x26), vshuff(0x28), vdeal(0x3a), vdeal(0x02), vdeal(0x1b), vshuff(0x0e), vdeal(0x03), vshuff(0x3d), vshuff(0x2c), vshuff(0x15)
; CHECK-LABEL: test_0007:
; CHECK-DAG: [[R70:r[0-9]+]] = #50
; CHECK-DAG: [[R71:r[0-9]+]] = #5{{$}}
; CHECK-DAG: [[R72:r[0-9]+]] = #8
; CHECK: v[[H70:[0-9]+]]:[[L70:[0-9]+]] = vshuff(v1,v0,[[R70]])
; CHECK: v[[H71:[0-9]+]]:[[L71:[0-9]+]] = vdeal(v[[H70]],v[[L70]],[[R71]])
; CHECK: v[[H72:[0-9]+]]:[[L72:[0-9]+]] = vshuff(v[[H71]],v[[L71]],[[R72]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0007(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 4, i32 64, i32 68, i32 32, i32 36, i32 96, i32 100, i32 1, i32 5, i32 65, i32 69, i32 33, i32 37, i32 97, i32 101, i32 2, i32 6, i32 66, i32 70, i32 34, i32 38, i32 98, i32 102, i32 3, i32 7, i32 67, i32 71, i32 35, i32 39, i32 99, i32 103, i32 16, i32 20, i32 80, i32 84, i32 48, i32 52, i32 112, i32 116, i32 17, i32 21, i32 81, i32 85, i32 49, i32 53, i32 113, i32 117, i32 18, i32 22, i32 82, i32 86, i32 50, i32 54, i32 114, i32 118, i32 19, i32 23, i32 83, i32 87, i32 51, i32 55, i32 115, i32 119, i32 8, i32 12, i32 72, i32 76, i32 40, i32 44, i32 104, i32 108, i32 9, i32 13, i32 73, i32 77, i32 41, i32 45, i32 105, i32 109, i32 10, i32 14, i32 74, i32 78, i32 42, i32 46, i32 106, i32 110, i32 11, i32 15, i32 75, i32 79, i32 43, i32 47, i32 107, i32 111, i32 24, i32 28, i32 88, i32 92, i32 56, i32 60, i32 120, i32 124, i32 25, i32 29, i32 89, i32 93, i32 57, i32 61, i32 121, i32 125, i32 26, i32 30, i32 90, i32 94, i32 58, i32 62, i32 122, i32 126, i32 27, i32 31, i32 91, i32 95, i32 59, i32 63, i32 123, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x1e), vdeal(0x19), vdeal(0x34), vdeal(0x07), vshuff(0x27), vdeal(0x1e), vdeal(0x21), vdeal(0x2b), vshuff(0x11), vdeal(0x35), vshuff(0x0a), vdeal(0x39), vdeal(0x0c), vdeal(0x17), vdeal(0x23)
; CHECK-LABEL: test_0008:
; CHECK-DAG: [[R80:r[0-9]+]] = #5
; CHECK-DAG: [[R81:r[0-9]+]] = #18
; CHECK-DAG: [[R82:r[0-9]+]] = #9
; CHECK: v[[H80:[0-9]+]]:[[L80:[0-9]+]] = vshuff(v1,v0,[[R80]])
; CHECK: v[[H81:[0-9]+]]:[[L81:[0-9]+]] = vshuff(v[[H80]],v[[L80]],[[R81]])
; CHECK: v[[H82:[0-9]+]]:[[L82:[0-9]+]] = vshuff(v[[H81]],v[[L81]],[[R82]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0008(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 16, i32 4, i32 20, i32 1, i32 17, i32 5, i32 21, i32 64, i32 80, i32 68, i32 84, i32 65, i32 81, i32 69, i32 85, i32 2, i32 18, i32 6, i32 22, i32 3, i32 19, i32 7, i32 23, i32 66, i32 82, i32 70, i32 86, i32 67, i32 83, i32 71, i32 87, i32 32, i32 48, i32 36, i32 52, i32 33, i32 49, i32 37, i32 53, i32 96, i32 112, i32 100, i32 116, i32 97, i32 113, i32 101, i32 117, i32 34, i32 50, i32 38, i32 54, i32 35, i32 51, i32 39, i32 55, i32 98, i32 114, i32 102, i32 118, i32 99, i32 115, i32 103, i32 119, i32 8, i32 24, i32 12, i32 28, i32 9, i32 25, i32 13, i32 29, i32 72, i32 88, i32 76, i32 92, i32 73, i32 89, i32 77, i32 93, i32 10, i32 26, i32 14, i32 30, i32 11, i32 27, i32 15, i32 31, i32 74, i32 90, i32 78, i32 94, i32 75, i32 91, i32 79, i32 95, i32 40, i32 56, i32 44, i32 60, i32 41, i32 57, i32 45, i32 61, i32 104, i32 120, i32 108, i32 124, i32 105, i32 121, i32 109, i32 125, i32 42, i32 58, i32 46, i32 62, i32 43, i32 59, i32 47, i32 63, i32 106, i32 122, i32 110, i32 126, i32 107, i32 123, i32 111, i32 127>
  ret <128 x i8> %p
}

; Generator: vshuff(0x1d), vshuff(0x18), vdeal(0x09), vshuff(0x2a), vdeal(0x03), vdeal(0x27), vdeal(0x25), vdeal(0x13), vshuff(0x3a), vshuff(0x19), vshuff(0x06), vshuff(0x0f), vshuff(0x3c), vshuff(0x2e), vshuff(0x36)
; CHECK-LABEL: test_0009:
; CHECK-DAG: [[R90:r[0-9]+]] = #17
; CHECK-DAG: [[R91:r[0-9]+]] = #40
; CHECK-DAG: [[R92:r[0-9]+]] = #6
; CHECK: v[[H90:[0-9]+]]:[[L90:[0-9]+]] = vdeal(v1,v0,[[R90]])
; CHECK: v[[H91:[0-9]+]]:[[L91:[0-9]+]] = vshuff(v[[H90]],v[[L90]],[[R91]])
; CHECK: v[[H92:[0-9]+]]:[[L92:[0-9]+]] = vdeal(v[[H91]],v[[L91]],[[R92]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_0009(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 16, i32 4, i32 20, i32 32, i32 48, i32 36, i32 52, i32 1, i32 17, i32 5, i32 21, i32 33, i32 49, i32 37, i32 53, i32 64, i32 80, i32 68, i32 84, i32 96, i32 112, i32 100, i32 116, i32 65, i32 81, i32 69, i32 85, i32 97, i32 113, i32 101, i32 117, i32 8, i32 24, i32 12, i32 28, i32 40, i32 56, i32 44, i32 60, i32 9, i32 25, i32 13, i32 29, i32 41, i32 57, i32 45, i32 61, i32 72, i32 88, i32 76, i32 92, i32 104, i32 120, i32 108, i32 124, i32 73, i32 89, i32 77, i32 93, i32 105, i32 121, i32 109, i32 125, i32 2, i32 18, i32 6, i32 22, i32 34, i32 50, i32 38, i32 54, i32 3, i32 19, i32 7, i32 23, i32 35, i32 51, i32 39, i32 55, i32 66, i32 82, i32 70, i32 86, i32 98, i32 114, i32 102, i32 118, i32 67, i32 83, i32 71, i32 87, i32 99, i32 115, i32 103, i32 119, i32 10, i32 26, i32 14, i32 30, i32 42, i32 58, i32 46, i32 62, i32 11, i32 27, i32 15, i32 31, i32 43, i32 59, i32 47, i32 63, i32 74, i32 90, i32 78, i32 94, i32 106, i32 122, i32 110, i32 126, i32 75, i32 91, i32 79, i32 95, i32 107, i32 123, i32 111, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x05), vshuff(0x10), vdeal(0x0d), vshuff(0x12), vdeal(0x08), vshuff(0x22), vdeal(0x24), vshuff(0x3e), vdeal(0x00), vshuff(0x14), vdeal(0x3b), vdeal(0x33), vshuff(0x2f), vdeal(0x13), vdeal(0x14)
; CHECK-LABEL: test_000a:
; CHECK-DAG: [[Ra0:r[0-9]+]] = #56
; CHECK-DAG: [[Ra1:r[0-9]+]] = #13
; CHECK-DAG: [[Ra2:r[0-9]+]] = #2
; CHECK: v[[Ha0:[0-9]+]]:[[La0:[0-9]+]] = vshuff(v1,v0,[[Ra0]])
; CHECK: v[[Ha1:[0-9]+]]:[[La1:[0-9]+]] = vdeal(v[[Ha0]],v[[La0]],[[Ra1]])
; CHECK: v[[Ha2:[0-9]+]]:[[La2:[0-9]+]] = vshuff(v[[Ha1]],v[[La1]],[[Ra2]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_000a(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 4, i32 1, i32 5, i32 64, i32 68, i32 65, i32 69, i32 32, i32 36, i32 33, i32 37, i32 96, i32 100, i32 97, i32 101, i32 8, i32 12, i32 9, i32 13, i32 72, i32 76, i32 73, i32 77, i32 40, i32 44, i32 41, i32 45, i32 104, i32 108, i32 105, i32 109, i32 16, i32 20, i32 17, i32 21, i32 80, i32 84, i32 81, i32 85, i32 48, i32 52, i32 49, i32 53, i32 112, i32 116, i32 113, i32 117, i32 24, i32 28, i32 25, i32 29, i32 88, i32 92, i32 89, i32 93, i32 56, i32 60, i32 57, i32 61, i32 120, i32 124, i32 121, i32 125, i32 2, i32 6, i32 3, i32 7, i32 66, i32 70, i32 67, i32 71, i32 34, i32 38, i32 35, i32 39, i32 98, i32 102, i32 99, i32 103, i32 10, i32 14, i32 11, i32 15, i32 74, i32 78, i32 75, i32 79, i32 42, i32 46, i32 43, i32 47, i32 106, i32 110, i32 107, i32 111, i32 18, i32 22, i32 19, i32 23, i32 82, i32 86, i32 83, i32 87, i32 50, i32 54, i32 51, i32 55, i32 114, i32 118, i32 115, i32 119, i32 26, i32 30, i32 27, i32 31, i32 90, i32 94, i32 91, i32 95, i32 58, i32 62, i32 59, i32 63, i32 122, i32 126, i32 123, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x12), vshuff(0x2c), vdeal(0x2d), vshuff(0x01), vshuff(0x1f), vshuff(0x30), vdeal(0x2a), vdeal(0x0b), vdeal(0x32), vshuff(0x08), vdeal(0x1b), vdeal(0x09), vshuff(0x1c), vshuff(0x16), vdeal(0x38)
; CHECK-LABEL: test_000b:
; CHECK-DAG: [[Rb0:r[0-9]+]] = #12
; CHECK-DAG: [[Rb1:r[0-9]+]] = #33
; CHECK-DAG: [[Rb2:r[0-9]+]] = #18
; CHECK: v[[Hb0:[0-9]+]]:[[Lb0:[0-9]+]] = vdeal(v1,v0,[[Rb0]])
; CHECK: v[[Hb1:[0-9]+]]:[[Lb1:[0-9]+]] = vdeal(v[[Hb0]],v[[Lb0]],[[Rb1]])
; CHECK: v[[Hb2:[0-9]+]]:[[Lb2:[0-9]+]] = vshuff(v[[Hb1]],v[[Lb1]],[[Rb2]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_000b(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 32, i32 1, i32 33, i32 8, i32 40, i32 9, i32 41, i32 64, i32 96, i32 65, i32 97, i32 72, i32 104, i32 73, i32 105, i32 2, i32 34, i32 3, i32 35, i32 10, i32 42, i32 11, i32 43, i32 66, i32 98, i32 67, i32 99, i32 74, i32 106, i32 75, i32 107, i32 4, i32 36, i32 5, i32 37, i32 12, i32 44, i32 13, i32 45, i32 68, i32 100, i32 69, i32 101, i32 76, i32 108, i32 77, i32 109, i32 6, i32 38, i32 7, i32 39, i32 14, i32 46, i32 15, i32 47, i32 70, i32 102, i32 71, i32 103, i32 78, i32 110, i32 79, i32 111, i32 16, i32 48, i32 17, i32 49, i32 24, i32 56, i32 25, i32 57, i32 80, i32 112, i32 81, i32 113, i32 88, i32 120, i32 89, i32 121, i32 18, i32 50, i32 19, i32 51, i32 26, i32 58, i32 27, i32 59, i32 82, i32 114, i32 83, i32 115, i32 90, i32 122, i32 91, i32 123, i32 20, i32 52, i32 21, i32 53, i32 28, i32 60, i32 29, i32 61, i32 84, i32 116, i32 85, i32 117, i32 92, i32 124, i32 93, i32 125, i32 22, i32 54, i32 23, i32 55, i32 30, i32 62, i32 31, i32 63, i32 86, i32 118, i32 87, i32 119, i32 94, i32 126, i32 95, i32 127>
  ret <128 x i8> %p
}

; Generator: vshuff(0x31), vdeal(0x29), vshuff(0x19), vshuff(0x39), vdeal(0x17), vshuff(0x28), vshuff(0x0f), vdeal(0x23), vdeal(0x2e), vshuff(0x3d), vdeal(0x1a), vdeal(0x02), vshuff(0x3e), vshuff(0x20), vshuff(0x3f)
; CHECK-LABEL: test_000c:
; CHECK-DAG: [[Rc0:r[0-9]+]] = #12
; CHECK-DAG: [[Rc1:r[0-9]+]] = #6
; CHECK-DAG: [[Rc2:r[0-9]+]] = #17
; CHECK-DAG: [[Rc3:r[0-9]+]] = #32
; CHECK: v[[Hc0:[0-9]+]]:[[Lc0:[0-9]+]] = vshuff(v1,v0,[[Rc0]])
; CHECK: v[[Hc1:[0-9]+]]:[[Lc1:[0-9]+]] = vdeal(v[[Hc0]],v[[Lc0]],[[Rc1]])
; CHECK: v[[Hc2:[0-9]+]]:[[Lc2:[0-9]+]] = vdeal(v[[Hc1]],v[[Lc1]],[[Rc2]])
; CHECK: v[[Hc3:[0-9]+]]:[[Lc3:[0-9]+]] = vshuff(v[[Hc2]],v[[Lc2]],[[Rc3]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_000c(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 16, i32 64, i32 80, i32 8, i32 24, i32 72, i32 88, i32 4, i32 20, i32 68, i32 84, i32 12, i32 28, i32 76, i32 92, i32 2, i32 18, i32 66, i32 82, i32 10, i32 26, i32 74, i32 90, i32 6, i32 22, i32 70, i32 86, i32 14, i32 30, i32 78, i32 94, i32 1, i32 17, i32 65, i32 81, i32 9, i32 25, i32 73, i32 89, i32 5, i32 21, i32 69, i32 85, i32 13, i32 29, i32 77, i32 93, i32 3, i32 19, i32 67, i32 83, i32 11, i32 27, i32 75, i32 91, i32 7, i32 23, i32 71, i32 87, i32 15, i32 31, i32 79, i32 95, i32 32, i32 48, i32 96, i32 112, i32 40, i32 56, i32 104, i32 120, i32 36, i32 52, i32 100, i32 116, i32 44, i32 60, i32 108, i32 124, i32 34, i32 50, i32 98, i32 114, i32 42, i32 58, i32 106, i32 122, i32 38, i32 54, i32 102, i32 118, i32 46, i32 62, i32 110, i32 126, i32 33, i32 49, i32 97, i32 113, i32 41, i32 57, i32 105, i32 121, i32 37, i32 53, i32 101, i32 117, i32 45, i32 61, i32 109, i32 125, i32 35, i32 51, i32 99, i32 115, i32 43, i32 59, i32 107, i32 123, i32 39, i32 55, i32 103, i32 119, i32 47, i32 63, i32 111, i32 127>
  ret <128 x i8> %p
}

; Generator: vdeal(0x3c), vdeal(0x24), vdeal(0x05), vdeal(0x37), vshuff(0x21), vdeal(0x11), vdeal(0x1d), vshuff(0x00), vshuff(0x34), vshuff(0x0d), vshuff(0x3a), vshuff(0x1f), vshuff(0x03), vshuff(0x1e), vdeal(0x29)
; CHECK-LABEL: test_000d:
; CHECK-DAG: [[Rd0:r[0-9]+]] = #40
; CHECK-DAG: [[Rd1:r[0-9]+]] = #28
; CHECK: v[[Hd0:[0-9]+]]:[[Ld0:[0-9]+]] = vshuff(v1,v0,[[Rd0]])
; CHECK: v[[Hd1:[0-9]+]]:[[Ld1:[0-9]+]] = vdeal(v[[Hd0]],v[[Ld0]],[[Rd1]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_000d(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 1, i32 2, i32 3, i32 64, i32 65, i32 66, i32 67, i32 16, i32 17, i32 18, i32 19, i32 80, i32 81, i32 82, i32 83, i32 32, i32 33, i32 34, i32 35, i32 96, i32 97, i32 98, i32 99, i32 48, i32 49, i32 50, i32 51, i32 112, i32 113, i32 114, i32 115, i32 8, i32 9, i32 10, i32 11, i32 72, i32 73, i32 74, i32 75, i32 24, i32 25, i32 26, i32 27, i32 88, i32 89, i32 90, i32 91, i32 40, i32 41, i32 42, i32 43, i32 104, i32 105, i32 106, i32 107, i32 56, i32 57, i32 58, i32 59, i32 120, i32 121, i32 122, i32 123, i32 4, i32 5, i32 6, i32 7, i32 68, i32 69, i32 70, i32 71, i32 20, i32 21, i32 22, i32 23, i32 84, i32 85, i32 86, i32 87, i32 36, i32 37, i32 38, i32 39, i32 100, i32 101, i32 102, i32 103, i32 52, i32 53, i32 54, i32 55, i32 116, i32 117, i32 118, i32 119, i32 12, i32 13, i32 14, i32 15, i32 76, i32 77, i32 78, i32 79, i32 28, i32 29, i32 30, i32 31, i32 92, i32 93, i32 94, i32 95, i32 44, i32 45, i32 46, i32 47, i32 108, i32 109, i32 110, i32 111, i32 60, i32 61, i32 62, i32 63, i32 124, i32 125, i32 126, i32 127>
  ret <128 x i8> %p
}

; Generator: vshuff(0x18), vdeal(0x36), vdeal(0x33), vdeal(0x26), vshuff(0x04), vshuff(0x2d), vshuff(0x35), vdeal(0x34), vdeal(0x2e), vdeal(0x25), vdeal(0x28), vshuff(0x0c), vdeal(0x07), vshuff(0x35), vshuff(0x01)
; CHECK-LABEL: test_000e:
; CHECK-DAG: [[Re0:r[0-9]+]] = #58
; CHECK: v[[He0:[0-9]+]]:[[Le0:[0-9]+]] = vshuff(v1,v0,[[Re0]])
; CHECK-NOT: v{{[0-9:]+}} =
define <128 x i8> @test_000e(<128 x i8> %v0) #0 {
  %p = shufflevector <128 x i8> %v0, <128 x i8> undef, <128 x i32><i32 0, i32 1, i32 64, i32 65, i32 4, i32 5, i32 68, i32 69, i32 2, i32 3, i32 66, i32 67, i32 6, i32 7, i32 70, i32 71, i32 8, i32 9, i32 72, i32 73, i32 12, i32 13, i32 76, i32 77, i32 10, i32 11, i32 74, i32 75, i32 14, i32 15, i32 78, i32 79, i32 16, i32 17, i32 80, i32 81, i32 20, i32 21, i32 84, i32 85, i32 18, i32 19, i32 82, i32 83, i32 22, i32 23, i32 86, i32 87, i32 24, i32 25, i32 88, i32 89, i32 28, i32 29, i32 92, i32 93, i32 26, i32 27, i32 90, i32 91, i32 30, i32 31, i32 94, i32 95, i32 32, i32 33, i32 96, i32 97, i32 36, i32 37, i32 100, i32 101, i32 34, i32 35, i32 98, i32 99, i32 38, i32 39, i32 102, i32 103, i32 40, i32 41, i32 104, i32 105, i32 44, i32 45, i32 108, i32 109, i32 42, i32 43, i32 106, i32 107, i32 46, i32 47, i32 110, i32 111, i32 48, i32 49, i32 112, i32 113, i32 52, i32 53, i32 116, i32 117, i32 50, i32 51, i32 114, i32 115, i32 54, i32 55, i32 118, i32 119, i32 56, i32 57, i32 120, i32 121, i32 60, i32 61, i32 124, i32 125, i32 58, i32 59, i32 122, i32 123, i32 62, i32 63, i32 126, i32 127>
 