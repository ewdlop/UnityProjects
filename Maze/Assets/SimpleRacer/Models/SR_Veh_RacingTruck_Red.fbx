// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using Test.Cryptography;
using Xunit;

namespace System.Security.Cryptography.Pkcs.Tests
{
    public static class TimestampTokenInfoTests
    {
        [Theory]
        [InlineData(nameof(TimestampTokenTestData.FreeTsaDotOrg1))]
        [InlineData(nameof(TimestampTokenTestData.Symantec1))]
        [InlineData(nameof(TimestampTokenTestData.DigiCert1))]
        public static void CreateFromParameters(string testDataName)
        {
            TimestampTokenTestData testData = TimestampTokenTestData.GetTestData(testDataName);

            Oid policyId = new Oid(testData.PolicyId, testData.PolicyId);
            Oid hashAlgorithmOid = new Oid(testData.HashAlgorithmId);
            byte[] messageHash = testData.HashBytes.ToArray();
            byte[] serial = testData.SerialNumberBytes.ToArray();
            DateTimeOffset nonUtcTimestamp = testData.Timestamp.ToOffset(TimeSpan.FromHours(-8));
            long? accuracyMicrosec = testData.AccuracyInMicroseconds;
            byte[] nonce = testData.NonceBytes?.ToArray();
            byte[] tsaNameBytes = testData.TsaNameBytes?.ToArray();

            ReadOnlyMemory<byte>? nonceMemory = null;
            ReadOnlyMemory<byte>? tsaMemory = null;

            if (nonce != null)
            {
                nonceMemory = nonce;
            }

            if (tsaNameBytes != null)
            {
                tsaMemory = tsaNameBytes;
            }

            var tokenInfo = new Rfc3161TimestampTokenInfo(
                policyId,
                hashAlgorithmOid,
                messageHash,
                serial,
                nonUtcTimestamp,
                accuracyMicrosec,
                testData.IsOrdering,
                nonceMemory,
                tsaMemory);

            // Since AssertEqual will check all the fields the remaining checks in this method are about
            // input/output value/reference associations.
            AssertEqual(testData, tokenInfo);

            Assert.NotSame(policyId, tokenInfo.PolicyId);
            Assert.NotSame(hashAlgorithmOid, tokenInfo.HashAlgorithmId);

            Assert.Equal(nonUtcTimestamp, tokenInfo.Timestamp);
            Assert.Equal(TimeSpan.Zero, tokenInfo.Timestamp.Offset);

            Assert.Equal(messageHash.ByteArrayToHex(), tokenInfo.GetMessageHash().ByteArrayToHex());
            // Detached from the original data
            messageHash[0] ^= 0xFF;
            Assert.NotEqual(messageHash.ByteArrayToHex(), tokenInfo.GetMessageHash().ByteArrayToHex());

            Assert.Equal(serial.ByteArrayToHex(), tokenInfo.GetSerialNumber().ByteArrayToHex());
            // Detached from the original data
            serial[1] ^= 0xFF;
            Assert.NotEqual(serial.ByteArrayToHex(), tokenInfo.GetSerialNumber().ByteArrayToHex());


            if (nonce != null)
            {
                ReadOnlyMemory<byte>? tokenNonce = tokenInfo.GetNonce();
                Assert.True(tokenNonce.HasValue, "tokenInfo.GetNonce().HasValue");

                Assert.Equal(nonce.ByteArrayToHex(), tokenNonce.Value.ByteArrayToHex());
                // Detached from the original data
                nonce[0] ^= 0xFF;
                Assert.NotEqual(nonce.ByteArrayToHex(), tokenNonce.Value.ByteArrayToHex());
            }

            ReadOnlyMemory<byte>? nameFromToken = tokenInfo.GetTimestampAuthorityName();

            if (tsaNameBytes != null)
            {
                Assert.True(nameFromToken.HasValue, "nameFromToken.HasValue");
                Assert.Equal(tsaNameBytes.ByteArrayToHex(), nameFromToken.Value.ByteArrayToHex());
                // Detached from the original data
                tsaNameBytes[5] ^= 0xFF;
                Assert.NotEqual(tsaNameBytes.ByteArrayToHex(), nameFromToken.Value.ByteArrayToHex());
            }

            if (testData.ExtensionsBytes == null)
            {
                Assert.False(tokenInfo.HasExtensions, "tokenInfo.HasExtensions");
                Assert.NotNull(tokenInfo.GetExtensions());
                Assert.Equal(0, tokenInfo.GetExtensions().Count);

                // GetExtensions always returns a new collection.
                Assert.NotSame(tokenInfo.GetExtensions(), tokenInfo.GetExtensions());
            }
            else
            {
                Assert.True(tokenInfo.HasExtensions, "tokenInfo.HasExtensions");
                Assert.NotNull(tokenInfo.GetExtensions());

                Assert.True(false, "A test handler has been written for extensions...");

                // GetExtensions always returns a new collection.
                Assert.NotSame(tokenInfo.GetExtensions(), tokenInfo.GetExtensions());
            }

            // Because the token is DER encoded, we should produce byte-for-byte the same value.
            Assert.Equal(testData.TokenInfoBytes.ByteArrayToHex(), tokenInfo.Encode().ByteArrayToHex());
        }

        [Theory]
        [InlineData(nameof(TimestampTokenTestData.FreeTsaDotOrg1), false)]
        [InlineData(nameof(TimestampTokenTestData.FreeTsaDotOrg1), true)]
        [InlineData(nameof(TimestampTokenTestData.Symantec1), false)]
        [InlineData(nameof(TimestampTokenTestData.Symantec1), true)]
        [InlineData(nameof(TimestampTokenTestData.DigiCert1), false)]
        [InlineData(nameof(TimestampTokenTestData.DigiCert1), true)]
        public static void CreateFromValue(string testDataName, bool viaTry)
        {
            TimestampTokenTestData testData = TimestampTokenTestData.GetTestData(testDataName);

            ValidateTokenInfo(
                testData.TokenInfoBytes,
                testData,
                viaTry ? testData.TokenInfoBytes.Length : (int?)null);
        }

        private static void ValidateTokenInfo(
            ReadOnlyMemory<byte> tokenInfoBytes,
            TimestampTokenTestData testData,
            int? lengthFromTry)
        {
            Rfc3161TimestampTokenInfo tokenInfo;

            Assert.True(
                Rfc3161TimestampTokenInfo.TryDecode(tokenInfoBytes, out tokenInfo, out int bytesRead),
                "Rfc3161TimestampTokenInfo.TryDecode");

            Assert.NotNull(tokenInfo);

            if (lengthFromTry != null)
            {
                Assert.Equal(lengthFromTry.Value, bytesRead);
            }
            
            AssertEqual(testData, tokenInfo);
        }

        [Fact]
        public static void TryDecode_LongerThanNeeded()
        {
            const int ExtraBytes = 11;
            ReadOnlyMemory<byte> inputTokenData = TimestampTokenTestData.Symantec1.TokenInfoBytes;
            int len = inputTokenData.Length + ExtraBytes;
            byte[] inputData = new byte[len];

            for (int i = inputTokenData.Length; i < len; i++)
            {
                inputData[i] = unchecked((byte)i);
            }

            inputTokenData.Span.CopyTo(inputData);

            ValidateTokenInfo(inputData, TimestampTokenTestData.Symantec1, inputTokenData.Length);
        }

        [Fact]
        public static void TryDecode_Invalid()
        {
            ReadOnlyMemory<byte> inputData = TimestampTokenTestData.Symantec1.TokenInfoBytes;

            Assert.False(
                Rfc3161TimestampTokenInfo.TryDecode(
                    inputData.Slice(0, inputData.Length - 1),
                    out Rfc3161TimestampTokenInfo tokenInfo,
                    out int bytesRead));

            Assert.Equal(0, bytesRead);
            Assert.Null(tokenInfo);
        }

        [Fact]
        public static void BuilderCtor_PolicyIdRequired()
        {
            AssertExtensions.Throws<ArgumentNullException>(
                "policyId",
                () => new Rfc3161TimestampTokenInfo(null, null, default, default, default));
        }

        [Fact]
        public static void BuilderCtor_HashAlgorithmIdRequired()
        {
            Oid policyId = new Oid("0.0", "0.0");

            AssertExtensions.Throws<ArgumentNullException>(
                "hashAlgorithmId",
                () => new Rfc3161TimestampTokenInfo(policyId, null, default, default, default));
        }

        [Fact]
        public static void BuilderCtor_TsaNameOptional()
        {
            Oid policyId = new Oid("0.0", "0.0");
            Oid hashAlgorithmId = new Oid(Oids.Sha256);

            var tokenInfo = new Rfc3161TimestampTokenInfo(
                policyId,
                hashAlgorithmId,
                new byte[256 / 8],
                new byte[] { 1 },
                DateTimeOffset.UtcNow);

            Assert.False(tokenInfo.GetTimestampAuthorityName().HasValue);

            Assert.True(Rfc3161TimestampTokenInfo.TryDecode(tokenInfo.Encode(), out tokenInfo, out _));
            Assert.False(tokenInfo.GetTimestampAuthorityName().HasValue);
        }

        [Fact]
        public static void BuilderCtor_AccuracyOptional()
        {
            Oid policyId = new Oid("0.0", "0.0");
            Oid hashAlgorithmId = new Oid(Oids.Sha256);

            var tokenInfo = new Rfc3161TimestampTokenInfo(
                policyId,
                hashAlgorithmId,
                new byte[256 / 8],
                new byte[] { 2 },
                DateTimeOffset.UtcNow);

            Assert.False(tokenInfo.AccuracyInMicroseconds.HasValue);

            Assert.True(Rfc3161TimestampTokenInfo.TryDecode(tokenInfo.Encode(), out tokenInfo, out _));
            Assert.False(tokenInfo.AccuracyInMicroseconds.HasValue);
        }

        [Fact]
        public static void TsaName_SameDataSecondInvocation()
        {
            const string InputHex =
                "3081F8020101060B6086480186F845010717033031300D060960864801650304" +
                "020105000420315F5BDB76D078C43B8AC0064E4A0164612B1FCE77C869345BFC" +
                "94C75894EDD302146C77B12D5FCF9F6DC1D4A481E935F446FBA376C4180F3230" +
                "3137313031303232303835325A300302011EA08186A48183308180310B300906" +
                "0355040613025553311D301B060355040A131453796D616E74656320436F7270" +
                "6F726174696F6E311F301D060355040B131653796D616E746563205472757374" +
                "204E6574776F726B3131302F0603550403132853796D616E7465632053484132" +
                "35362054696D655374616D70696E67205369676E6572202D204732";

            Rfc3161TimestampTokenInfo tokenInfo;
            Assert.True(Rfc3161TimestampTokenInfo.TryDecode(InputHex.HexToByteArray(), out tokenInfo, out _));

            ReadOnlyMemory<byte>? tsaName = tokenInfo.GetTimestampAuthorityName();
            Assert.True(tsaName.HasValue, "tsaName.HasValue");
            ReadOnlyMemory<byte> tsaName1 = tsaName.Value;
            ReadOnlyMemory<byte> tsaName2 = tokenInfo.GetTimestampAuthorityName().Value;

            Assert.Equal(tsaName1.Length, tsaName2.Length);

            Assert.True(
                Unsafe.AreSame(
                    ref MemoryMarshal.GetReference(tsaName1.Span),
                    ref MemoryMarshal.GetReference(tsaName2.Span)),
                "Second call to GetTimestampAuthorityName is over the same memory");
        }

        [Fact]
        public static void ExtensionsRoundtrips()
        {
            Oid policyId = new Oid("0.0", "0.0");
            Oid hashAlgorithmId = new Oid(Oids.Sha256);

            byte[] extensionValue = { 3, 1, 4, 1, 5, 9, 2, 7, 5, 8 };
            
            var tokenInfo = new Rfc3161TimestampTokenInfo(
                policyId,
                hashAlgorithmId,
                new byte[256 / 8],
                new byte[] { 3 },
                DateTimeOffset.UtcNow,
                extensions: new X509ExtensionCollection
                {
                    new X509Extension(new Oid("0.0.0", "0.0.0"), extensionValue, true),
                });

            Assert.True(tokenInfo.HasExtensions);

            Assert.True(Rfc3161TimestampTokenInfo.TryDecode(tokenInfo.Encode(), out tokenInfo, out _));

            Assert.True(tokenInfo.HasExtensions);
            X509ExtensionCollection extensions = tokenInfo.GetExtensions();

            Assert.Equal(1, extensions.Count);
            X509Extension extension = extensions[0];
            Assert.NotNull(extension);
            Assert.Equal("0.0.0", extension.Oid.Value);
            Assert.True(extension.Critical, "extension.Critical");
            Assert.Equal(extensionValue.ByteArrayToHex(), extension.RawData.ByteArrayToHex());
        }

        [Fact]
        public static void BuilderCtor_IsOrdering_Roundtrips()
        {
            Oid policyId = new Oid("0.0", "0.0");
            Oid hashAlgorithmId = new Oid(Oids.Sha256);

            var tokenInfo = new Rfc3161TimestampTokenInfo(
                policyId,
                hashAlgorithmId,
                new byte[256 / 8],
                new byte[] { 7 },
                DateTimeOffset.UtcNow,
                isOrdering: true);

            Assert.True(tokenInfo.IsOrdering, "tokenInfo.IsOrdering");

            Assert.True(Rfc3161TimestampTokenInfo.TryDecode(tokenInfo.Encode(), out tokenInfo, out _));
            Assert.True(tokenInfo.IsOrdering, "tokenInfo.IsOrdering");
        }

        [Fact]
        public static void BuilderCtor_Timestamp_KeepsSubSeconds()
        {
            // RFC 3161 says that the genTime value should omit fractions "when there is no need"
            //
            // We leave the trimming up to the caller, because there are multiple positions for
            // the accuracy+precision position.
            DateTimeOffset marker = new DateTimeOffset(2017, 12, 18, 17, 5, 34, TimeSpan.Zero);
            DateTimeOffset experiment = marker + TimeSpan.FromMilliseconds(17);

            Assert.NotEqual(marker, experiment);

            Oid policyId1 = new Oid("0.0", "0.0");
            Oid hashAlgorithmId1 = new Oid(Oids.Sha256);

            var tokenInfo = new Rfc3161TimestampTokenInfo(
                policyId1,
                hashAlgorithmId1,
                new byte[256 / 8],
                new byte[] { 6 },
                experiment);

            Assert.Equal(experiment, tokenInfo.Timestamp);
        }

        [Theory]
        [InlineData("No accuracy", "", true, null)]
        [InlineData("MicroSeconds = 0", "3003810100", false, null)]
        [InlineData("MicroSeconds = 1", "3003810101", true, 1L)]
        [InlineData("MicroSeconds = 999", "3004810203E7", true, 999L)]
        [InlineData("MicroSeconds = 1000", "3004810203E8", false, null)]
        [InlineData("MilliSeconds = 0", "3003800100", false, null)]
        [InlineData("MilliSeconds = 1", "3003800101", true, 1000L)]
        [InlineData("MilliSeconds = 999", "3004800203E7", true, 999000L)]
        [InlineData("MilliSeconds = 1000", "3004800203E8", false, null)]
        [InlineData("Seconds = 0", "3003020100", true, 0L)]
        [InlineData("Seconds = -1", "30030201FF", false, null)]
        public static void Accuracy_Bounds_ParsesAsExpected(
            string description,
            string accuracyHex,
            bool shouldParse,
            long? expectedTotalMicroseconds)
        {
            string inputHex =
                "305A0201010601003031300D0609608648016503040201050004200000000000" +
                "0000000000000000000000000000000000000000000000000000000201081817" +
                "32303137313231383138313235342E373438363336345A" + accuracyHex;

            byte[] inputData = inputHex.HexToByteArray();
            inputData[1] = checked((byte)(0x55 + accuracyHex.Length / 2));

            if (shouldParse)
            {
                int bytesRead;
                Rfc3161TimestampTokenInfo tokenInfo;

                Assert.True(Rfc3161TimestampTokenInfo.TryDecode(inputData, out tokenInfo, out bytesRead));
                Assert.Equal(inputData.Length, bytesRead);
                Assert.NotNull(tokenInfo);
                Assert.Equal(expectedTotalMicroseconds, tokenInfo.AccuracyInMicroseconds);
            }
            else
            {
                Assert.False(Rfc3161TimestampTokenInfo.TryDecode(inputData, out _, out _));
            }
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        [InlineData(1000)]
        [InlineData(1001)]
        [InlineData(1999)]
        [InlineData(999000)]
        [InlineData(999001)]
        [InlineData(999999)]
        [InlineData(1000000)]
        [InlineData(1000001)]
        [InlineData(1000999)]
        [InlineData(1001000)]
        [InlineData(1001001)]
        [InlineData(1999999)]
        public static void AccuracyRoundtrips(long totalMicroseconds)
        {
            Rfc3161TimestampTokenInfo info = new Rfc3161TimestampTokenInfo(
                new Oid("0.0", "0.0"),
                new Oid(Oids.Sha256),
                new byte[256 / 8],
                new byte[] { 1 },
                DateTimeOffset.UtcNow,
                accuracyInMicroseconds: totalMicroseconds);

            Assert.True(info.AccuracyInMicroseconds.HasValue);
            Assert.Equal(totalMicroseconds, info.AccuracyInMicroseconds.Value);

            byte[] encoded = info.Encode();

            Rfc3161TimestampTokenInfo info2;
            int bytesConsumed;

            Assert.True(
                Rfc3161TimestampTokenInfo.TryDecode(encoded, out info2, out bytesConsumed));

            Assert.Equal(encoded.Length, bytesConsumed);
            Assert.NotNull(info2);
            Assert.True(info2.AccuracyInMicroseconds.HasValue);
            Assert.Equal(totalMicroseconds, info2.AccuracyInMicroseconds.Value);
        }

        [Fact]
        public static void NegativeAccuracyThrows()
        {
            AssertExtensions.Throws<ArgumentOutOfRangeException>(
                "accuracyInMicroseconds",
                () => new Rfc3161TimestampTokenInfo(
                    new Oid("0.0", "0.0"),
                    new Oid(Oids.Sha256),
                    new byte[256 / 8],
                    new byte[] { 2 },
                    DateTimeOffset.UtcNow,
                    accuracyInMicroseconds: -1));
        }

        internal static void AssertEqual(TimestampTokenTestData testData, Rfc3161TimestampTokenInfo tokenInfo)
        {
            Assert.Equal(testData.Version, tokenInfo.Version);
            Assert.Equal(testData.PolicyId, tokenInfo.PolicyId.Value);
            Assert.Equal(testData.HashAlgorithmId, tokenInfo.HashAlgorithmId.Value);
            // FriendlyName should be set for known digest algorithms
            Assert.NotEqual(tokenInfo.HashAlgorithmId.Value, tokenInfo.HashAlgorithmId.FriendlyName);
            Assert.Equal(testData.HashBytes.ByteArrayToHex(), tokenInfo.GetMessageHash().ByteArrayToHex());
            Assert.Equal(testData.SerialNumberBytes.ByteArrayToHex(), tokenInfo.GetSerialNumber().ByteArrayToHex());
            Assert.Equal(testData.Timestamp, tokenInfo.Timestamp);
            Assert.Equal(TimeSpan.Zero, tokenInfo.Timestamp.Offset);
            Assert.Equal(testData.AccuracyInMicroseconds, tokenInfo.AccuracyInMicroseconds);

            if (testData.IsOrdering)
            {
                Assert.True(tokenInfo.IsOrdering, "tokenInfo.IsOrdering");
            }
            else
            {
                Assert.False(tokenInfo.IsOrdering, "tokenInfo.IsOrdering");
            }

            Assert.Equal(testData.NonceBytes?.ByteArrayToHex(), tokenInfo.GetNonce()?.ByteArrayToHex());
            Assert.Equal(testData.TsaNameBytes?.ByteArrayToHex(), tokenInfo.GetTimestampAuthorityName()?.ByteArrayToHex());

            if (testData.ExtensionsBytes == null)
            {
                Assert.False(tokenInfo.HasExtensions, "tokenInfo.HasExtensions");
                Assert.NotNull(tokenInfo.GetExtensions());
                Assert.Equal(0, tokenInfo.GetExtensions().Count);

                // GetExtensions always returns a new collection.
                Assert.NotSame(tokenInfo.GetExtensions(), tokenInfo.GetExtensions());
            }
            else
            {
                Assert.True(tokenInfo.HasExtensions, "tokenInfo.HasExtensions");
                Assert.NotNull(tokenInfo.GetExtensions());

                Assert.True(false, "A test handler has been written for extensions...");

                // GetExtensions always returns a new collection.
                Assert.NotSame(tokenInfo.GetExtensions(), tokenInfo.GetExtensions());
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                s p o n s e M e s s a g e T e s t . c s p      y~&    q~&    (D≠   ∫<Õú‡÷  Ä            4 < H t t p R e s p o n s e M e s s a g e T e s t . c s p      z~&    q~&    òD≠   ∫<Õú‡÷           Ä   . < M u l t i p a r t C o n t e n t T e s t . c s       p      z~&    q~&    E≠   ∫<Õú‡÷  Ä            . < M u l t i p a r t C o n t e n t T e s t . c s       Ä      {~&    q~&    xE≠   ∫<Õú‡÷           Ä   > < M u l t i p a r t F o r m D a t a C o n t e n t T e s t . c s       Ä      {~&    q~&    ¯E≠   ∫<Õú‡÷  Ä            > < M u l t i p a r t F o r m D a t a C o n t e n t T e s t . c s       h      |~&    q~&    xF≠   ∫<Õú‡÷           Ä   ( < S t r e a m C o n t e n t T e s t . c s     h      |~&    q~&    ‡F≠   ∫<Õú‡÷  Ä            ( < S t r e a m C o n t e n t T e s t . c s     h      }~&    q~&    HG≠   ∫<Õú‡÷           Ä   ( < S t r i n g C o n t e n t T e s t . c s     h      }~&    q~&    ∞G≠   ∫<Õú‡÷  Ä            ( < S t r i n g C o n t e n t T e s t . c s     `      q~&    W~&    H≠   ∫<Õú‡÷               < S y s t e m . N e t . H t t p       `      q~&    W~&    xH≠   ∫<Õú‡÷  Ä            < S y s t e m . N e t . H t t p       Ä      Z~&    Y~&    ÿH≠   (·<Õú‡÷           Ä   @ < A u t h e n t i c a t i o n H e a d e r V a l u e T e s t . c s     Ä      Z~&    Y~&    XI≠   (·<Õú‡÷  Ä            @ < A u t h e n t i c a t i o n H e a d e r V a l u e T e s t . c s     x      [~&    Y~&    ÿI≠   (·<Õú‡÷           Ä   < < C a c h e C o n t r o l H e a d e r V a l u e T e s t . c s x      [~&    Y~&    PJ≠   (·<Õú‡÷  Ä            < < C a c h e C o n t r o l H e a d e r V a l u e T e s t . c s à      \~&    Y~&    »J≠   (·<Õú‡÷           Ä   H < C o n t e n t D i s p o s i t i o n H e a d e r V a l u e T e s t . c s     à      \~&    Y~&    PK≠   (·<Õú‡÷  Ä            H < C o n t e n t D i s p o s i t i o n H e a d e r V a l u e T e s t . c s     x      ]~&    Y~&    ÿK≠   (·<Õú‡÷           Ä   < < C o n t e n t R a n g e H e a d e r V a l u e T e s t . c s x      ]~&    Y~&    PL≠   (·<Õú‡÷  Ä            < < C o n t e n t R a n g e H e a d e r V a l u e T e s t . c s x      ^~&    Y~&    »L≠   (·<Õú‡÷           Ä   6 < E n t i t y T a g H e a d e r V a l u e T e s t . c s       x      ^~&    Y~&    @M≠   (·<Õú‡÷  Ä            6 < E n t i t y T a g H e a d e r V a l u e T e s t . c s       `      `~&    Y~&    ∏M≠   9=Õú‡÷           Ä   $ < H t t p H e a d e r s T e s t . c s `      `~&    Y~&    N≠   9=Õú‡÷  Ä            $ < H t t p H e a d e r s T e s t . c s x      _~&    Y~&    xN≠   9=Õú‡÷           Ä   8 < H t t p H e a d e r V a l u e C o l l e c t i o n . c s     x      _~&    Y~&    N≠   9=Õú‡÷  Ä            8 < H t t p H e a d e r V a l u e C o l l e c t i o n . c s     p      a~&    Y~&    hO≠   9=Õú‡÷           Ä   2 < H t t p R e q u e s t H e a d e r s T e s t . c s                                           // Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;
using Internal.Runtime.CompilerServices;

namespace System
{
	partial class String
	{
		[Intrinsic]
		public static readonly String Empty;

		public int Length {
			[Intrinsic]
			get => _stringLength;
		}

		[IndexerName ("Chars")]
		public char this [int index] {
			[Intrinsic]
			get => this [index];
		}

		public static String Intern (String str)
		{
			if (str == null)
				throw new ArgumentNullException(nameof(str));

			return InternalIntern (str);
		}

		public static String IsInterned (String str)
		{
			if (str == null)
				throw new ArgumentNullException(nameof(str));

			return InternalIsInterned (str);
		}

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		internal extern static String FastAllocateString (int length);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		extern static String InternalIsInterned (String str);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		extern static String InternalIntern (String str);

		// TODO: Should be pointing to Buffer instead
		#region Runtime method-to-ir dependencies

		static unsafe void memset (byte *dest, int val, int len)
		{
			if (len < 8) {
				while (len != 0) {
					*dest = (byte)val;
					++dest;
					--len;
				}
				return;
			}
			if (val != 0) {
				val = val | (val << 8);
				val = val | (val << 16);
			}
			// align to 4
			int rest = (int)dest & 3;
			if (rest != 0) {
				rest = 4 - rest;
				len -= rest;
				do {
					*dest = (byte)val;
					++dest;
					--rest;
				} while (rest != 0);
			}
			while (len >= 16) {
				((int*)dest) [0] = val;
				((int*)dest) [1] = val;
				((int*)dest) [2] = val;
				((int*)dest) [3] = val;
				dest += 16;
				len -= 16;
			}
			while (len >= 4) {
				((int*)dest) [0] = val;
				dest += 4;
				len -= 4;
			}
			// tail bytes
			while (len > 0) {
				*dest = (byte)val;
				dest++;
				len--;
			}
		}

		static unsafe void memcpy (byte *dest, byte *src, int size)
		{
			Buffer.Memcpy (dest, src, size);
		}

		/* Used by the runtime */
		internal static unsafe void bzero (byte *dest, int len) {
			memset (dest, 0, len);
		}

		internal static unsafe void bzero_aligned_1 (byte *dest, int len) {
			((byte*)dest) [0] = 0;
		}

		internal static unsafe void bzero_aligned_2 (byte *dest, int len) {
			((short*)dest) [0] = 0;
		}

		internal static unsafe void bzero_aligned_4 (byte *dest, int len) {
			((int*)dest) [0] = 0;
		}

		internal static unsafe void bzero_aligned_8 (byte *dest, int len) {
			((long*)dest) [0] = 0;
		}

		internal static unsafe void memcpy_aligned_1 (byte *dest, byte *src, int size) {
			((byte*)dest) [0] = ((byte*)src) [0];
		}

		internal static unsafe void memcpy_aligned_2 (byte *dest, byte *src, int size) {
			((short*)dest) [0] = ((short*)src) [0];
		}

		internal static unsafe void memcpy_aligned_4 (byte *dest, byte *src, int size) {
			((int*)dest) [0] = ((int*)src) [0];
		}

		internal static unsafe void memcpy_aligned_8 (byte *dest, byte *src, int size) {
			((long*)dest) [0] = ((long*)src) [0];
		}

		#endregion
	}
}                                                                                                                                                                                                                                                                                                                               †         #          ∞         3          ∏         ]          ¿         p          ‡                   Ë         ‘
                   ¢                    X                   ˛                                       Õ          0         ô          8                   @         e          `         ß          h         √
          p                   Ä         í          à         ˆ          ê                   †         Û          //------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

#pragma warning disable 1634, 1691
namespace System.Workflow.Activities
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Drawing;
    using System.Globalization;
    using System.Reflection;
    using System.Runtime;
    using System.ServiceModel;
    using System.ServiceModel.Channels;
    using System.Workflow.ComponentModel;
    using System.Workflow.ComponentModel.Compiler;
    using System.Workflow.ComponentModel.Design;
    using System.Workflow.Runtime.Hosting;

    [SR2Description(SR2DescriptionAttribute.SendActivityDescription)]
    [SR2Category(SR2CategoryAttribute.Standard)]
    [DesignerAttribute(typeof(SendActivityDesigner), typeof(IDesigner))]
    [ToolboxBitmap(typeof(SendActivity), "Design.Resources.SendActivity.png")]
    [ActivityValidator(typeof(SendActivityValidator))]
    [Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")]
    public sealed class SendActivity : Activity
    {
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
        public static readonly DependencyProperty AfterResponseEvent =
            DependencyProperty.Register("AfterResponse",
            typeof(EventHandler<SendActivityEventArgs>),
            typeof(SendActivity));

        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
        public static readonly DependencyProperty BeforeSendEvent =
            DependencyProperty.Register("BeforeSend",
            typeof(EventHandler<SendActivityEventArgs>),
            typeof(SendActivity));

        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
        public static readonly DependencyProperty CustomAddressProperty =
            DependencyProperty.Register("CustomAddress",
            typeof(string),
            typeof(SendActivity),
            new PropertyMetadata(null));

        public const string ReturnValuePropertyName = "(ReturnValue)";

        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
        internal static readonly DependencyProperty ChannelTokenProperty =
            DependencyProperty.Register("ChannelToken",
            typeof(ChannelToken),
            typeof(SendActivity),
            new PropertyMetadata(null, DependencyPropertyOptions.Metadata));

        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
        internal static readonly DependencyProperty ParameterBindingsProperty =
            DependencyProperty.Register("ParameterBindings",
            typeof(WorkflowParameterBindingCollection),
            typeof(SendActivity),
            new PropertyMetadata(DependencyPropertyOptions.Metadata | DependencyPropertyOptions.ReadOnly));

        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
        internal static readonly DependencyProperty ServiceOperationInfoProperty =
            DependencyProperty.Register("ServiceOperationInfo",
            typeof(TypedOperationInfo),
            typeof(SendActivity),
            new PropertyMetadata(DependencyPropertyOptions.Metadata));

        [NonSerialized]
        private SendOperationInfoHelper operationHelper;

        public SendActivity()
        {
            base.SetReadOnlyPropertyValue(SendActivity.ParameterBindingsProperty,
                new WorkflowParameterBindingCollection(this));
        }

        public SendActivity(String name)
            : base(name)
        {
            base.SetReadOnlyPropertyValue(SendActivity.ParameterBindingsProperty,
                new WorkflowParameterBindingCollection(this));
        }

        [SuppressMessage("Microsoft.Naming", "CA1713:EventsShouldNotHaveBeforeOrAfterPrefix")]
        [Browsable(true)]
        [SR2Category(SR2CategoryAttribute.Handlers)]
        [SR2Description(SR2DescriptionAttribute.Send_AfterResponse_Description)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public event EventHandler<SendActivityEventArgs> AfterResponse
        {
            add
            {
                base.AddHandler(SendActivity.AfterResponseEvent, value);
            }
            remove
            {
                base.RemoveHandler(SendActivity.AfterResponseEvent, value);
            }
        }

        [SuppressMessage("Microsoft.Naming", "CA1713:EventsShouldNotHaveBeforeOrAfterPrefix")]
        [Browsable(true)]
        [SR2Category(SR2CategoryAttribute.Handlers)]
        [SR2Description(SR2DescriptionAttribute.Send_BeforeSend_Description)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public event EventHandler<SendActivityEventArgs> BeforeSend
        {
            add
            {
                base.AddHandler(SendActivity.BeforeSendEvent, value);
            }
            remove
            {
                base.RemoveHandler(SendActivity.BeforeSendEvent, value);
            }
        }

        [DefaultValue(null)]
        [MergableProperty(false)]
        [RefreshProperties(RefreshProperties.All)]
        [SR2Category(SR2CategoryAttribute.Activity)]
        [SR2Description(SR2DescriptionAttribute.Send_ChannelToken_Description)]
        public ChannelToken ChannelToken
        {
            get
            {
                return (ChannelToken) this.GetValue(SendActivity.ChannelTokenProperty);
            }
            set
            {
                this.SetValue(SendActivity.ChannelTokenProperty, value);
            }
        }

        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public IDictionary<string, string> Context
        {
            get
            {
                if (this.ServiceOperationInfo == null)
                {
#pragma warning suppress 56503
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new InvalidOperationException(SR2.GetString(SR2.Error_ServiceOperationInfoNotSpecified, this.Name)));
                }

                return SendActivity.GetContext(this, this.ChannelToken, this.ServiceOperationInfo.ContractType);
            }
            set
            {
                if (this.ServiceOperationInfo == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new InvalidOperationException(SR2.GetString(SR2.Error_ServiceOperationInfoNotSpecified, this.Name)));
                }

                SendActivity.SetContext(this, this.ChannelToken, this.ServiceOperationInfo.ContractType, value);
            }
        }

        [DefaultValue(null)]
        [SR2Category(SR2CategoryAttribute.Activity)]
        [SR2Description(SR2DescriptionAttribute.Send_CustomAddress_Description)]
        public string CustomAddress
        {
            get
            {
                return (string) GetValue(CustomAddressProperty);
            }

            set
            {
                SetValue(CustomAddressProperty, value);
            }
        }

        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
        public WorkflowParameterBindingCollection ParameterBindings
        {
            get
            {
                return ((WorkflowParameterBindingCollection)(base.GetValue(SendActivity.ParameterBindingsProperty)));
            }
        }

        [Browsable(true)]
        [SR2Category(SR2CategoryAttribute.Activity)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        [SR2Description(SR2DescriptionAttribute.Send_OperationInfo_Description)]
        public TypedOperationInfo ServiceOperationInfo
        {
            get
            {
                return ((TypedOperationInfo)(base.GetValue(SendActivity.ServiceOperationInfoProperty)));
            }
            set
            {
                OperationInfoBase currentValue = ((OperationInfoBase)(base.GetValue(SendActivity.ServiceOperationInfoProperty)));
                if (value != null && currentValue != value)
                {
                    DependencyProperty ParentDependencyObjectProperty =
                        DependencyProperty.FromName("ParentDependencyObject", typeof(DependencyObject));

                    Activity currentParent = value.GetValue(ParentDependencyObjectProperty) as Activity;

                    if (currentParent != null)
                    {
                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(
                            "value",
                            SR2.GetString(SR2.Error_OperationIsAlreadyAssociatedWithActivity,
                            value,
                            currentParent.QualifiedName));
                    }

                    if (currentValue != null)
                    {
                        currentValue.SetValue(ParentDependencyObjectProperty, null);
                    }

                    value.SetValue(ParentDependencyObjectProperty, this);
                }

                if (this.DesignMode)
                {
                    Activity rootActivity = this.RootActivity;
                    rootActivity.RemoveProperty(DynamicContractTypeBuilder.DynamicContractTypesProperty);
                }

                base.SetValue(SendActivity.ServiceOperationInfoProperty, value);
            }
        }

        SendOperationInfoHelper OperationHelper
        {
            get
            {
                if (this.operationHelper == null)
                {
                    if (this.UserData.Contains(typeof(SendOperationInfoHelper)))
                    {
                        this.operationHelper = this.UserData[typeof(SendOperationInfoHelper)] as SendOperationInfoHelper;
                    }
                }

                if (this.operationHelper == null)
                {
                    this.operationHelper = new SendOperationInfoHelper(this.Site, this);
                    this.UserData[typeof(SendOperationInfoHelper)] = this.operationHelper;
                }

                return this.operationHelper;
            }
        }

        public static IDictionary<string, string> GetContext(Activity activity,
            ChannelToken endpoint,
            Type contractType)
        {
            if (activity == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
            }
            if (endpoint == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("endpoint");
            }
            if (contractType == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contractType");
            }

            return GetContext(activity, endpoint.Name, endpoint.OwnerActivityName, contractType);
        }

        public static IDictionary<string, string> GetContext(Activity activity,
            string endpointName,
            string ownerActivityName,
            Type contractType)
        {
            if (activity == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
            }
            if (string.IsNullOrEmpty(endpointName))
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument("endpointName",
                    SR2.GetString(SR2.Error_ArgumentValueNullOrEmptyString));
            }
            if (contractType == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contractType");
            }

            LogicalChannel logicalChannel = ChannelToken.GetLogicalChannel(activity, endpointName, ownerActivityName, contractType);
            if (logicalChannel != null)
            {
                return logicalChannel.Context;
            }

            return null;
        }

        public static void SetContext(Activity activity,
            ChannelToken endpoint,
            Type contractType,
            IDictionary<string, string> context)
        {
            if (activity == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
            }
            if (endpoint == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("endpoint");
            }
            if (contractType == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contractType");
            }

            SetContext(activity, endpoint.Name, endpoint.OwnerActivityName, contractType, context);
        }

        public static void SetContext(Activity activity,
            string endpointName,
            string ownerActivityName,
            Type contractType,
            IDictionary<string, string> context)
        {
            if (activity == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
            }
            if (string.IsNullOrEmpty(endpointName))
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument("endpointName",
                    SR2.GetString(SR2.Error_ArgumentValueNullOrEmptyString));
            }
            if (contractType == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contractType");
            }

            LogicalChannel logicalChannel = ChannelToken.GetLogicalChannel(activity, endpointName, ownerActivityName, contractType);
            if (logicalChannel != null)
            {
                if (context != null)
                {
                    logicalChannel.Context = context;
                }
                else
                {
                    logicalChannel.Context = ContextMessageProperty.Empty.Context;
                }
            }
        }

        protected internal override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {
            TypedOperationInfo serviceOperationInfo = this.ServiceOperationInfo;
            if (serviceOperationInfo == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                    new InvalidOperationException(SR2.GetString(SR2.Error_ServiceOperationInfoNotSpecified, this.Name)));
            }

            MethodInfo methodInfo = serviceOperationInfo.GetMethodInfo(executionContext);
            if (methodInfo == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                    new InvalidOperationException(SR2.GetString(SR2.Error_MethodInfoNotAvailable, this.Name)));
            }

            ChannelToken channelToken = this.ChannelToken;

            LogicalChannel logicalChannel = ChannelToken.Register(this, channelToken, serviceOperationInfo.ContractType);
            if (!logicalChannel.Initialized)
            {
                logicalChannel.Initialize(channelToken.EndpointName, this.CustomAddress);
            }

            using (ChannelManagerService.ChannelTicket leasedChannel = ChannelManagerService.Take(executionContext, this.WorkflowInstanceId, logicalChannel))
            {
                using (OperationContextScope scope = new OperationContextScope((IContextChannel) leasedChannel.Channel))
                {
                    EventHandler<SendActivityEventArgs>[] invocationList = this.GetInvocationList<EventHandler<SendActivityEventArgs>>(SendActivity.BeforeSendEvent);
                    if (invocationList != null && invocationList.Length > 0)
                    {
                        base.RaiseGenericEvent(SendActivity.BeforeSendEvent, this, new SendActivityEventArgs(this));
                    }

                    SendOperationInfoHelper helper = this.OperationHelper;
                    WorkflowParameterBindingCollection bindings = this.ParameterBindings;

                    object[] parameters = helper.GetInputs(this, bindings);
                    object returnValue = null;

                    bool isSessionless = ChannelManagerHelpers.IsSessionlessContract(logicalChannel.ContractType);
                    bool hasContext = (logicalChannel.Context != null && logicalChannel.Context.Count > 0);
                    bool fatalException = false;

                    if (!isSessionless && hasContext)
                    {
                        ChannelManagerService.ApplyLogicalChannelContext(logicalChannel);
                    }

                    try
                    {
                        returnValue = this.InvokeOperation(methodInfo, leasedChannel.Channel, parameters);
                    }
                    catch (Exception exception)
                    {
                        if (Fx.IsFatal(exception))
                        {
                            fatalException = true;
                        }
                        throw;
                    }
                    finally
                    {
                        if (!fatalException &&
                            !hasContext && !isSessionless && !helper.IsOneWay)
                        {
                            ChannelManagerService.UpdateLogicalChannelContext(logicalChannel);
                        }
                    }

                    helper.PopulateOutputs(this, bindings, parameters, returnValue);

                    invocationList = this.GetInvocationList<EventHandler<SendActivityEventArgs>>(SendActivity.AfterResponseEvent);
                    if (invocationList != null && invocationList.Length > 0)
                    {
                        base.RaiseGenericEvent(SendActivity.AfterResponseEvent, this, new SendActivityEventArgs(this));
                    }
                }
            }

            return ActivityExecutionStatus.Closed;
        }

        internal void GetParameterPropertyDescriptors(IDictionary properties)
        {
            if (properties == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("properties");
            }

            if (((IComponent) this).Site == null)
            {
                return;
            }

            TypedOperationInfo serviceOperationInfo = this.ServiceOperationInfo;
            if (serviceOperationInfo != null)
            {
                MethodInfo methodInfo = serviceOperationInfo.GetMethodInfo(((IComponent) this).Site);
                if (methodInfo != null)
                {
                    ArrayList paramInfo = new ArrayList(methodInfo.GetParameters());
                    if (!(methodInfo.ReturnType == typeof(void)))
                    {
                        paramInfo.Add(methodInfo.ReturnParameter);
                    }

                    foreach (ParameterInfo param in paramInfo)
                    {
                        if (param.ParameterType != null)
                        {
                            PropertyDescriptor prop =
                                new ParameterInfoBasedPropertyDescriptor(typeof(ReceiveActivity),
                                param, true, DesignOnlyAttribute.Yes);

                            properties[prop.Name] = prop;
                        }
                    }
                }
            }
        }

        protected override void InitializeProperties()
        {
            TypedOperationInfo serviceOperationInfo = this.ServiceOperationInfo;

            if (serviceOperationInfo == null)
            {
                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                    new InvalidOperationException(SR2.GetString(SR2.Error_ServiceOperationInfoNotSpecified, this.Name)));
            }

            OperationParameterInfoCollection parameters = null;

            Activity definitionRoot = base.RootActivity.GetValue(Activity.WorkflowDefinitionProperty) as Activity;
            if (definitionRoot != null)
            {
                SendActivity definition = definitionRoot.GetActivityByName(this.QualifiedName, true) as SendActivity;
                if ((definition != null) && definition.UserData.Contains(typeof(OperationParameterInfoCollection)))
                {
                    parameters = definition.UserData[typeof(OperationParameterInfoCollection)] as OperationParameterInfoCollection;
                }
            }

            if (parameters == null)
            {
                parameters = serviceOperationInfo.GetParameters(this.Site);
                this.UserData[typeof(OperationParameterInfoCollection)] = parameters;
            }

            WorkflowParameterBindingCollection parameterBindings = this.ParameterBindings;

            foreach (OperationParameterInfo parameterInfo in parameters)
            {
                if (!parameterBindings.Contains(parameterInfo.Name))
                {
                    parameterBindings.Add(new WorkflowParameterBinding(parameterInfo.Name));
                }
            }

            base.InitializeProperties();
        }

        object InvokeOperation(MethodInfo operation, IChannel channel, object[] parameters)
        {
            Guid workflowInstanceId = this.WorkflowInstanceId;
            string qualifiedName = this.QualifiedName;

            System.Workflow.Runtime.WorkflowTrace.Runtime.TraceEvent(TraceEventType.Verbose, 0,
                "Workflow Instance {0}, send activity {1} - invoking operation",
                workflowInstanceId, qualifiedName);

            try
            {
                object retVal = operation.ReflectedType.InvokeMember(operation.Name,
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.InvokeMethod,
                    null,
                    channel,
                    parameters,
                    CultureInfo.InvariantCulture);

                System.Workflow.Runtime.WorkflowTrace.Runtime.TraceEvent(TraceEventType.Verbose, 0,
                    "Workflow Instance {0}, send activity {1} - operation invoke succeeded",
                    workflowInstanceId, qualifiedName);

                return retVal;

            }
            catch (TargetInvocationException e)
            {
                if (e.InnerException != null)
                {
                    System.Workflow.Runtime.WorkflowTrace.Runtime.TraceEvent(TraceEventType.Error, 0,
                        "Workflow Instance {0}, send activity {1} - operation invoke failed with error: {2}",
                        workflowInstanceId, qualifiedName, e.InnerException.Message);

                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(e.InnerException);
                }
                else
                {
                    System.Workflow.Runtime.WorkflowTrace.Runtime.TraceEvent(TraceEventType.Error, 0,
                        "Workflow Instance {0}, send activity {1} - operation invoke failed with error: {2}",
                        workflowInstanceId, qualifiedName, e.Message);

                    throw;
                }
            }
        }

        [Serializable]
        class SendOperationInfoHelper
        {
            bool hasReturnValue = false;
            IList<KeyValuePair<int, string>> inputParameters;
            bool isOneWay = false;
            string operationName;
            IList<KeyValuePair<int, string>> outputParameters;
            int parameterCount = 0;

            public SendOperationInfoHelper(IServiceProvider serviceProvider, SendActivity activity)
            {
                outputParameters = new List<KeyValuePair<int, string>>();
                inputParameters = new List<KeyValuePair<int, string>>();
                hasReturnValue = false;

                if (activity == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
                }

                OperationInfoBase serviceOperationInfo = activity.ServiceOperationInfo;
                if (serviceOperationInfo == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new InvalidOperationException(SR2.GetString(SR2.Error_ServiceOperationInfoNotSpecified, activity.Name)));
                }

                MethodInfo methodInfo = serviceOperationInfo.GetMethodInfo(serviceProvider);
                if (methodInfo == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                        new InvalidOperationException(SR2.GetString(SR2.Error_MethodInfoNotAvailable, activity.Name)));
                }

                if (methodInfo.ReturnType != null && methodInfo.ReturnType != typeof(void))
                {
                    hasReturnValue = true;
                }

                foreach (ParameterInfo parameter in methodInfo.GetParameters())
                {
                    if (parameter.ParameterType.IsByRef ||
                        parameter.IsOut || (parameter.IsIn && parameter.IsOut))
                    {
                        outputParameters.Add(new KeyValuePair<int, string>(parameter.Position, parameter.Name));
                    }

                    if (!parameter.IsOut || (parameter.IsIn && parameter.IsOut))
                    {
                        inputParameters.Add(new KeyValuePair<int, string>(parameter.Position, parameter.Name));
                    }
                }

                this.parameterCount = methodInfo.GetParameters().Length;

                this.operationName = serviceOperationInfo.Name;

                object[] operationContractAttribs = methodInfo.GetCustomAttributes(typeof(OperationContractAttribute), true);

                if (operationContractAttribs != null && operationContractAttribs.Length > 0)
                {
                    if (operationContractAttribs[0] is OperationContractAttribute)
                    {
                        this.isOneWay = ((OperationContractAttribute) operationContractAttribs[0]).IsOneWay;
                    }
                }
            }

            public bool IsOneWay
            {
                get
                {
                    return this.isOneWay;
                }
            }

            public object[] GetInputs(SendActivity activity, WorkflowParameterBindingCollection bindings)
            {
                if (activity == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
                }

                object[] inputs = new object[this.parameterCount];

                if (inputParameters.Count > 0)
                {
                    for (int index = 0; index < inputParameters.Count; index++)
                    {
                        KeyValuePair<int, string> parameterInfo = inputParameters[index];

                        if (bindings.Contains(parameterInfo.Value))
                        {
                            inputs[parameterInfo.Key] = bindings[parameterInfo.Value].Value;
                        }
                        else
                        {
                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
                                new InvalidOperationException(SR2.GetString(SR2.Error_ParameterBindingMissing,
                                parameterInfo.Value,
                                this.operationName,
                                activity.Name)));
                        }
                    }
                }

                return inputs;
            }

            public void PopulateOutputs(SendActivity activity, WorkflowParameterBindingCollection bindings, object[] outputs, object returnValue)
            {
                if (activity == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("activity");
                }

                if (outputs == null)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("outputs");
                