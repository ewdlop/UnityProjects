// BZip2InputStream.cs
//
// Copyright (C) 2001 Mike Krueger
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
// 
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent
// modules, and to copy and distribute the resulting executable under
// terms of your choice, provided that you also meet, for each linked
// independent module, the terms and conditions of the license of that
// module.  An independent module is a module which is not derived from
// or based on this library.  If you modify this library, you may extend
// this exception to your version of the library, but you are not
// obligated to do so.  If you do not wish to do so, delete this
// exception statement from your version.

using System;
using System.IO;

using ICSharpCode.SharpZipLib.Checksums;

namespace ICSharpCode.SharpZipLib.BZip2 
{
	
	/// <summary>
	/// An input stream that decompresses files in the BZip2 format 
	/// </summary>
	[System.ObsoleteAttribute("This assembly has been deprecated. Please use https://www.nuget.org/packages/SharpZipLib/ instead.")]
	public class BZip2InputStream : Stream
	{
		/// <summary>
		/// Gets a value indicating if the stream supports reading
		/// </summary>
		public override bool CanRead {
			get {
				return baseStream.CanRead;
			}
		}
		
		/// <summary>
		/// Gets a value indicating whether the current stream supports seeking.
		/// </summary>
		public override bool CanSeek {
			get {
				return baseStream.CanSeek;
			}
		}
		
		/// <summary>
		/// Gets a value indicating whether the current stream supports writing.
		/// This property always returns false
		/// </summary>
		public override bool CanWrite {
			get {
				return false;
			}
		}
		
		/// <summary>
		/// Gets the length in bytes of the stream.
		/// </summary>
		public override long Length {
			get {
				return baseStream.Length;
			}
		}
		
		/// <summary>
		/// Gets or sets the streams position.
		/// Setting the position is not supported and will throw a NotSupportException
		/// </summary>
		/// <exception cref="NotSupportedException">Any attempt to set the position</exception>
		public override long Position {
			get {
				return baseStream.Position;
			}
			set {
				throw new NotSupportedException("BZip2InputStream position cannot be set");
			}
		}
		
		/// <summary>
		/// Flushes the stream.
		/// </summary>
		public override void Flush()
		{
			if (baseStream != null) {
				baseStream.Flush();
			}
		}
		
		/// <summary>
		/// Set the streams position.  This operation is not supported and will throw a NotSupportedException
		/// </summary>
		/// <exception cref="NotSupportedException">Any access</exception>
		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException("BZip2InputStream Seek not supported");
		}
		
		/// <summary>
		/// Sets the length of this stream to the given value.
		/// This operation is not supported and will throw a NotSupportedExceptionortedException
		/// </summary>
		/// <exception cref="NotSupportedException">Any access</exception>
		public override void SetLength(long val)
		{
			throw new NotSupportedException("BZip2InputStream SetLength not supported");
		}
		
		/// <summary>
		/// Writes a block of bytes to this stream using data from a buffer.
		/// This operation is not supported and will throw a NotSupportedException
		/// </summary>
		/// <exception cref="NotSupportedException">Any access</exception>
		public override void Write(byte[] array, int offset, int count)
		{
			throw new NotSupportedException("BZip2InputStream Write not supported");
		}
		
		/// <summary>
		/// Writes a byte to the current position in the file stream.
		/// This operation is not supported and will throw a NotSupportedException
		/// </summary>
		/// <exception cref="NotSupportedException">Any access</exception>
		public override void WriteByte(byte val)
		{
			throw new NotSupportedException("BZip2InputStream WriteByte not supported");
		}
		
		/// <summary>
		/// Read a sequence of bytes and advances the read position by one byte.
		/// </summary>
		/// <param name="b">Array of bytes to store values in</param>
		/// <param name="offset">Offset in array to begin storing data</param>
		/// <param name="count">The maximum number of bytes to read</param>
		/// <returns>The total number of bytes read into the buffer. This might be less
		/// than the number of bytes requested if that number of bytes are not 
		/// currently available or zero if the end of the stream is reached.
		/// </returns>
		public override int Read(byte[] b, int offset, int count)
		{
			for (int i = 0; i < count; ++i) {
				int rb = ReadByte();
				if (rb == -1) {
					return i;
				}
				b[offset + i] = (byte)rb;
			}
			return count;
		}
		
		/// <summary>
		/// Closes the stream, releasing any associated resources.
		/// </summary>
		public override void Close()
		{
			if (baseStream != null) {
				baseStream.Close();
			}
		}
		
		void MakeMaps() 
		{
			nInUse = 0;
			for (int i = 0; i < 256; ++i) {
				if (inUse[i]) {
					seqToUnseq[nInUse] = (byte)i;
					unseqToSeq[i] = (byte)nInUse;
					nInUse++;
				}
			}
		}
		
		/*--
		index of the last char in the block, so
		the block size == last + 1.
		--*/
		int last;
		
		/*--
		index in zptr[] of original string after sorting.
		--*/
		int origPtr;
		
		/*--
		always: in the range 0 .. 9.
		The current block size is 100000 * this number.
		--*/
		int blockSize100k;
		
		bool blockRandomised;
		
		int bsBuff;
		int bsLive;
		IChecksum mCrc = new StrangeCRC();
		
		bool[] inUse = new bool[256];
		int    nInUse;
		
		byte[] seqToUnseq = new byte[256];
		byte[] unseqToSeq = new byte[256];
		
		byte[] selector    = new byte[BZip2Constants.MAX_SELECTORS];
		byte[] selectorMtf = new byte[BZip2Constants.MAX_SELECTORS];
		
		int[] tt;
		byte[] ll8;
		
		/*--
		freq table collected to save a pass over the data
		during decompression.
		--*/
		int[] unzftab = new int[256];
		
		int[][] limit     = new int[BZip2Constants.N_GROUPS][];
		int[][] baseArray = new int[BZip2Constants.N_GROUPS][];
		int[][] perm      = new int[BZip2Constants.N_GROUPS][];
		int[] minLens     = new int[BZip2Constants.N_GROUPS];
		
		Stream baseStream;
		bool   streamEnd = false;
		
		int currentChar = -1;
		
		const int START_BLOCK_STATE = 1;
		const int RAND_PART_A_STATE = 2;
		const int RAND_PART_B_STATE = 3;
		const int RAND_PART_C_STATE = 4;
		const int NO_RAND_PART_A_STATE = 5;
		const int NO_RAND_PART_B_STATE = 6;
		const int NO_RAND_PART_C_STATE = 7;
		
		int currentState = START_BLOCK_STATE;
		
		int storedBlockCRC, storedCombinedCRC;
		int computedBlockCRC;
		uint computedCombinedCRC;
		
		int count, chPrev, ch2;
		int tPos;
		int rNToGo = 0;
		int rTPos  = 0;
		int i2, j2;
		byte z;
		
		/// <summary>
		/// Construct instance for reading from stream
		/// </summary>
		/// <param name="stream">Data source</param>
		public BZip2InputStream(Stream stream) 
		{
			// init arrays
			for (int i = 0; i < BZip2Constants.N_GROUPS; ++i) {
				limit[i] = new int[BZip2Constants.MAX_ALPHA_SIZE];
				baseArray[i]  = new int[BZip2Constants.MAX_ALPHA_SIZE];
				perm[i]  = new int[BZip2Constants.MAX_ALPHA_SIZE];
			}
			
			ll8 = null;
			tt  = null;
			BsSetStream(stream);
			Initialize();
			InitBlock();
			SetupBlock();
		}
		
		/// <summary>
		/// Read a byte from stream advancing position
		/// </summary>
		/// <returns>byte read or -1 on end of stream</returns>
		public override int ReadByte()
		{
			if (streamEnd) {
				return -1; // ok
			}
			
			int retChar = currentChar;
			switch (currentState) {
				case RAND_PART_B_STATE:
					SetupRandPartB();
					break;
				case RAND_PART_C_STATE:
					SetupRandPartC();
					break;
				case NO_RAND_PART_B_STATE:
					SetupNoRandPartB();
					break;
				case NO_RAND_PART_C_STATE:
					SetupNoRandPartC();
					break;
				case START_BLOCK_STATE:
				case NO_RAND_PART_A_STATE:
				case RAND_PART_A_STATE:
					break;
				default:
					break;
			}
			return retChar;
		}
		
		void Initialize() 
		{
			char magic1 = BsGetUChar();
			char magic2 = BsGetUChar();
			
			char magic3 = BsGetUChar();
			char magic4 = BsGetUChar();
			
			if (magic1 != 'B' || magic2 != 'Z' || magic3 != 'h' || magic4 < '1' || magic4 > '9') {
				streamEnd = true;
				return;
			}
			
			SetDecompressStructureSizes(magic4 - '0');
			computedCombinedCRC = 0;
		}
		
		void InitBlock() 
		{
			char magic1 = BsGetUChar();
			char magic2 = BsGetUChar();
			char magic3 = BsGetUChar();
			char magic4 = BsGetUChar();
			char magic5 = BsGetUChar();
			char magic6 = BsGetUChar();
			
			if (magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90) {
				Complete();
				return;
			}
			
			if (magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59) {
				BadBlockHeader();
				streamEnd = true;
				return;
			}
			
			storedBlockCRC  = BsGetInt32();
			
			blockRandomised = (BsR(1) == 1);
			
			GetAndMoveToFrontDecode();
			
			mCrc.Reset();
			currentState = START_BLOCK_STATE;
		}
		
		void EndBlock() 
		{
			computedBlockCRC = (int)mCrc.Value;
			
			/*-- A bad CRC is considered a fatal error. --*/
			if (storedBlockCRC != computedBlockCRC) {
				CrcError();
			}
			
			// 1528150659
			computedCombinedCRC = ((computedCombinedCRC << 1) & 0xFFFFFFFF) | (computedCombinedCRC >> 31);
			computedCombinedCRC = computedCombinedCRC ^ (uint)computedBlockCRC;
		}
		
		void Complete() 
		{
			storedCombinedCRC = BsGetInt32();
			if (storedCombinedCRC != (int)computedCombinedCRC) {
				CrcError();
			}
			
			streamEnd = true;
		}
		
		static void CompressedStreamEOF() 
		{
			throw new BZip2Exception("BZip2 input stream end of compressed stream");
		}
		
		static void BlockOverrun() 
		{
			throw new BZip2Exception("BZip2 input stream block overrun");
		}
		
		static void BadBlockHeader() 
		{
			throw new BZip2Exception("BZip2 input stream bad block header");
		}
		
		static void CrcError() 
		{
			throw new BZip2Exception("BZip2 input stream crc error");
		}
		
		
		void BsSetStream(Stream f) 
		{
			baseStream = f;
			bsLive = 0;
			bsBuff = 0;
		}
		
		void FillBuffer()
		{
			int thech = 0;
			
			try {
				thech = baseStream.ReadByte();
			} catch (Exception) {
				CompressedStreamEOF();
			}
			
			if (thech == -1) {
				CompressedStreamEOF();
			}
			
			bsBuff = (bsBuff << 8) | (thech & 0xFF);
			bsLive += 8;
		}
		
		int BsR(int n) 
		{
			while (bsLive < n) {
				FillBuffer();
			}
			
			int v = (bsBuff >> (bsLive - n)) & ((1 << n) - 1);
			bsLive -= n;
			return v;
		}
		
		char BsGetUChar() 
		{
			return (char)BsR(8);
		}
		
		int BsGetint() 
		{
			int u = 0;
			u = (u << 8) | BsR(8);
			u = (u << 8) | BsR(8);
			u = (u << 8) | BsR(8);
			u = (u << 8) | BsR(8);
			return u;
		}
		
		int BsGetIntVS(int numBits) 
		{
			return (int)BsR(numBits);
		}
		
		int BsGetInt32() 
		{
			return (int)BsGetint();
		}
		
		void HbCreateDecodeTables(int[] limit, int[] baseArray, int[] perm, char[] length, int minLen, int maxLen, int alphaSize) 
		{
			int pp = 0;
			
			for (int i = minLen; i <= maxLen; ++i) {
				for (int j = 0; j < alphaSize; ++j) {
					if (length[j] == i) {
						perm[pp] = j;
						++pp;
					}
				}
			}
			
			for (int i = 0; i < BZip2Constants.MAX_CODE_LEN; i++) {
				baseArray[i] = 0;
			}
			
			for (int i = 0; i < alphaSize; i++) {
				++baseArray[length[i] + 1];
			}
			
			for (int i = 1; i < BZip2Constants.MAX_CODE_LEN; i++) {
				baseArray[i] += baseArray[i - 1];
			}
			
			for (int i = 0; i < BZip2Constants.MAX_CODE_LEN; i++) {
				limit[i] = 0;
			}
			
			int vec = 0;
			
			for (int i = minLen; i <= maxLen; i++) {
				vec += (baseArray[i + 1] - baseArray[i]);
				limit[i] = vec - 1;
				vec <<= 1;
			}
			
			for (int i = minLen + 1; i <= maxLen; i++) {
				baseArray[i] = ((limit[i - 1] + 1) << 1) - baseArray[i];
			}
		}
		
		void RecvDecodingTables() 
		{
			char[][] len = new char[BZip2Constants.N_GROUPS][];
			for (int i = 0; i < BZip2Constants.N_GROUPS; ++i) {
				len[i] = new char[BZip2Constants.MAX_ALPHA_SIZE];
			}
			
			bool[] inUse16 = new bool[16];
			
			/*--- Receive the mapping table ---*/
			for (int i = 0; i < 16; i++) {
				inUse16[i] = (BsR(1) == 1);
			} 
			
			for (int i = 0; i < 16; i++) {
				if (inUse16[i]) {
					for (int j = 0; j < 16; j++) {
						inUse[i * 16 + j] = (BsR(1) == 1);
					}
				} else {
					for (int j = 0; j < 16; j++) {
						inUse[i * 16 + j] = false;
					}
				}
			}
			
			MakeMaps();
			int alphaSize = nInUse + 2;
			
			/*--- Now the selectors ---*/
			int nGroups    = BsR(3);
			int nSelectors = BsR(15);
			
			for (int i = 0; i < nSelectors; i++) {
				int j = 0;
				while (BsR(1) == 1) {
					j++;
				}
				selectorMtf[i] = (byte)j;
			}
			
			/*--- Undo the MTF values for the selectors. ---*/
			byte[] pos = new byte[BZip2Constants.N_GROUPS];
			for (int v = 0; v < nGroups; v++) {
				pos[v] = (byte)v;
			}
			
			for (int i = 0; i < nSelectors; i++) {
				int  v   = selectorMtf[i];
				byte tmp = pos[v];
				while (v > 0) {
					pos[v] = pos[v - 1];
					v--;
				}
				pos[0]      = tmp;
				selector[i] = tmp;
			}
			
			/*--- Now the coding tables ---*/
			for (int t = 0; t < nGroups; t++) {
				int curr = BsR(5);
				for (int i = 0; i < alphaSize; i++) {
					while (BsR(1) == 1) {
						if (BsR(1) == 0) {
							curr++;
						} else {
							curr--;
						}
					}
					len[t][i] = (char)curr;
				}
			}
			
			/*--- Create the Huffman decoding tables ---*/
			for (int t = 0; t < nGroups; t++) {
				int minLen = 32;
				int maxLen = 0;
				for (int i = 0; i < alphaSize; i++) {
					maxLen = Math.Max(maxLen, len[t][i]);
					minLen = Math.Min(minLen, len[t][i]);
				}
				HbCreateDecodeTables(limit[t], baseArray[t], perm[t], len[t], minLen, maxLen, alphaSize);
				minLens[t] = minLen;
			}
		}
		
		void GetAndMoveToFrontDecode() 
		{
			byte[] yy = new byte[256];
			int nextSym;
			
			int limitLast = BZip2Constants.baseBlockSize * blockSize100k;
			origPtr = BsGetIntVS(24);
			
			RecvDecodingTables();
			int EOB = nInUse+1;
			int groupNo = -1;
			int groupPos = 0;
			
			/*--
			Setting up the unzftab entries here is not strictly
			necessary, but it does save having to do it later
			in a separate pass, and so saves a block's worth of
			cache misses.
			--*/
			for (int i = 0; i <= 255; i++) {
				unzftab[i] = 0;
			}
			
			for (int i = 0; i <= 255; i++) {
				yy[i] = (byte)i;
			}
			
			last = -1;
			
			if (groupPos == 0) {
				groupNo++;
				groupPos = BZip2Constants.G_SIZE;
			}
			
			groupPos--;
			int zt = selector[groupNo];
			int zn = minLens[zt];
			int zvec = BsR(zn);
			int zj;
			
			while (zvec > limit[zt][zn]) {
				if (zn > 20) { // the longest code
					throw new BZip2Exception("Bzip data error");  // -jr- 17-Dec-2003 from bzip 1.02 why 20???
				}
				zn++;
				while (bsLive < 1) {
					FillBuffer();
				}
				zj = (bsBuff >> (bsLive-1)) & 1;
				bsLive--;
				zvec = (zvec << 1) | zj;
			}
			if (zvec - baseArray[zt][zn] < 0 || zvec - baseArray[zt][zn] >= BZip2Constants.MAX_ALPHA_SIZE) {
				throw new BZip2Exception("Bzip data error");  // -jr- 17-Dec-2003 from bzip 1.02
			}
			nextSym = perm[zt][zvec - baseArray[zt][zn]];
			
			while (true) {
				if (nextSym == EOB) {
					break;
				}
				
				if (nextSym == BZip2Constants.RUNA || nextSym == BZip2Constants.RUNB) {
					int s = -1;
					int n = 1;
					do {
						if (nextSym == BZip2Constants.RUNA) {
							s += (0 + 1) * n;
						} else if (nextSym == BZip2Constants.RUNB) {
							s += (1 + 1) * n;
						}

						n <<= 1;
						
						if (groupPos == 0) {
							groupNo++;
							groupPos = BZip2Constants.G_SIZE;
						}
						
						groupPos--;
						
						zt = selector[groupNo];
						zn = minLens[zt];
						zvec = BsR(zn);
						
						while (zvec > limit[zt][zn]) {
							zn++;
							while (bsLive < 1) {
								FillBuffer();
							}
							zj = (bsBuff >> (bsLive - 1)) & 1;
							bsLive--;
							zvec = (zvec << 1) | zj;
						}
						nextSym = perm[zt][zvec - baseArray[zt][zn]];
					} while (nextSym == BZip2Constants.RUNA || nextSym == BZip2Constants.RUNB);
					
					s++;
					byte ch = seqToUnseq[yy[0]];
					unzftab[ch] += s;
					
					while (s > 0) {
						last++;
						ll8[last] = ch;
						s--;
					}
					
					if (last >= limitLast) {
						BlockOverrun();
					}
					continue;
				} else {
					last++;
					if (last >= limitLast) {
						BlockOverrun();
					}
					
					byte tmp = yy[nextSym - 1];
					unzftab[seqToUnseq[tmp]]++;
					ll8[last] = seqToUnseq[tmp];
					
					for (int j = nextSym-1; j > 0; --j) {
						yy[j] = yy[j - 1];
					}
					yy[0] = tmp;
					
					if (groupPos == 0) {
						groupNo++;
						groupPos = BZip2Constants.G_SIZE;
					}
					
					groupPos--;
					zt = selector[groupNo];
					zn = minLens[zt];
					zvec = BsR(zn);
					while (zvec > limit[zt][zn]) {
						zn++;
						while (bsLive < 1) {
							FillBuffer();
						}
						zj = (bsBuff >> (bsLive-1)) & 1;
						bsLive--;
						zvec = (zvec << 1) | zj;
					}
					nextSym = perm[zt][zvec - baseArray[zt][zn]];
					continue;
				}
			}
		}
		
		void SetupBlock() 
		{
			int[] cftab = new int[257];
			
			cftab[0] = 0;
			Array.Copy(unzftab, 0, cftab, 1, 256);
			
			for (int i = 1; i <= 256; i++) {
				cftab[i] += cftab[i - 1];
			}
			
			for (int i = 0; i <= last; i++) {
				byte ch = ll8[i];
				tt[cftab[ch]] = i;
				cftab[ch]++;
			}
			
			cftab = null;
			
			tPos = tt[origPtr];
			
			count = 0;
			i2    = 0;
			ch2   = 256;   /*-- not a char and not EOF --*/
			
			if (blockRandomised) {
				rNToGo = 0;
				rTPos = 0;
				SetupRandPartA();
			} else {
				SetupNoRandPartA();
			}
		}
		
		void SetupRandPartA() 
		{
			if (i2 <= last) {
				chPrev = ch2;
				ch2  = ll8[tPos];
				tPos = tt[tPos];
				if (rNToGo == 0) {
					rNToGo = BZip2Constants.rNums[rTPos];
					rTPos++;
					if (rTPos == 512) {
						rTPos = 0;
					}
				}
				rNToGo--;
				ch2 ^= (int)((rNToGo == 1) ? 1 : 0);
				i2++;
				
				currentChar  = ch2;
				currentState = RAND_PART_B_STATE;
				mCrc.Update(ch2);
			} else {
				EndBlock();
				InitBlock();
				SetupBlock();
			}
		}
		
		void SetupNoRandPartA() 
		{
			if (i2 <= last) {
				chPrev = ch2;
				ch2  = ll8[tPos];
				tPos = tt[tPos];
				i2++;
				
				currentChar = ch2;
				currentState = NO_RAND_PART_B_STATE;
				mCrc.Update(ch2);
			} else {
				EndBlock();
				InitBlock();
				SetupBlock();
			}
		}
		
		void SetupRandPartB() 
		{
			if (ch2 != chPrev) {
				currentState = RAND_PART_A_STATE;
				count = 1;
				SetupRandPartA();
			} else {
				count++;
				if (count >= 4) {
					z = ll8[tPos];
					tPos = tt[tPos];
					if (rNToGo == 0) {
						rNToGo = BZip2Constants.rNums[rTPos];
						rTPos++;
						if (rTPos == 512) {
							rTPos = 0;
						}
					}
					rNToGo--;
					z ^= (byte)((rNToGo == 1) ? 1 : 0);
					j2 = 0;
					currentState = RAND_PART_C_STATE;
					SetupRandPartC();
				} else {
					currentState = RAND_PART_A_STATE;
					SetupRandPartA();
				}
			}
		}
		
		void SetupRandPartC() 
		{
			if (j2 < (int)z) {
				currentChar = ch2;
				mCrc.Update(ch2);
				j2++;
			} else {
				currentState = RAND_PART_A_STATE;
				i2++;
				count = 0;
				SetupRandPartA();
			}
		}
		
		void SetupNoRandPartB() 
		{
			if (ch2 != chPrev) {
				currentState = NO_RAND_PART_A_STATE;
				count = 1;
				SetupNoRandPartA();
			} else {
				count++;
				if (count >= 4) {
					z = ll8[tPos];
					tPos = tt[tPos];
					currentState = NO_RAND_PART_C_STATE;
					j2 = 0;
					SetupNoRandPartC();
				} else {
					currentState = NO_RAND_PART_A_STATE;
					SetupNoRandPartA();
				}
			}
		}
		
		void SetupNoRandPartC() 
		{
			if (j2 < (int)z) {
				currentChar = ch2;
				mCrc.Update(ch2);
				j2++;
			} else {
				currentState = NO_RAND_PART_A_STATE;
				i2++;
				count = 0;
				SetupNoRandPartA();
			}
		}
		
		void SetDecompressStructureSizes(int newSize100k) 
		{
			if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {
				throw new BZip2Exception("Invalid block size");
			}
			
			blockSize100k = newSize100k;
			
			if (newSize100k == 0) {
				return;
			}
			
			int n = BZip2Constants.baseBlockSize * newSize100k;
			ll8 = new byte[n];
			tt  = new int[n];
		}
	}
}
/* This file was derived from a file containing under this license:
 * 
 * This file is a part of bzip2 and/or libbzip2, a program and
 * library for lossless, block-sorting data compression.
 * 
 * Copyright (C) 1996-1998 Julian R Seward.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 
 * 2. The origin of this software must not be misrepresented; you must 
 * not claim that you wrote the original software.  If you use this 
 * software in a product, an acknowledgment in the product 
 * documentation would be appreciated but is not required.
 * 
 * 3. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 * 
 * 4. The name of the author may not be used to endorse or promote 
 * products derived from this software without specific prior written 
 * permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java version ported by Keiron Liddle, Aftex Software <keiron@aftexsw.com> 1999-2001
 */
                                                                                                                                                                                                                                                                                                             ELF          ¤            Ì   `   4     ( 
               @   < h @ ZÀ€I@? HTest %d
  QuIC LLVM Hexagon Clang version 7.2  .rela.text .comment .bss .shstrtab .strtab .symtab .data .rodata.str1.1                                                       @                                      0               4             T                                   T                      :      2       T   	                       0       ]   %                               ‚   I                  ,              \      	            $              ü                                                ñÿ                                                                                            ÿ               print main one test.c                        	                                                                                                                                                                                                           ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²[   à)J  f[IÒ¶Û€)JHBªªªªc[IB’  I)JHBªªªªcLÛ¤Ø„¼)JHBªªªªiN6ic[Ç)JHBªªªªcS?ó<µY)JHBªªªª_OíS?£õ)JHBªªªªNF¬/ö-:)JHBªªªªL@ä`S¾•[)JHBªªªª]N·³ñ)JHBªªªªkV)J')JHBªªªªp\äĞRv÷œ)JHBªªªªndú%£É>)JHBªªªªpT‰±c]?)JHBªªªª^S )r$÷?)JHBªªªª[RĞºÕ¤ÓÚ)JHBªªªªVOÂ_û~íü)JHBªªªªOH ú /6)JHBªªªªI=ĞªÑ£Cÿ)JHBªªªª@7€6»¶]?)JHBªªªªA7@nv{?)JHBªªªªO:¥àRw—›)JHBªªªªjKæğN7•w)JHBªªªª‹iæğ7S)JHBªªªª§¦pN/s)JHBªªªª¯¥Tj/·)JHBªªªªª˜¯5¢3:)JHBªªªª”{X: #:)JHBªªªªv` : :)JHBªªªª^P¯õXƒõ)JHBªªªªOI'’¢-')JHBªªªªSKí`“·³)JHBªªªªUM‚t·Iò')JHBªªªªRL€Ds‰ı“)JHBªªªªQN›ØÉ)JHBªªªªRJ›£9 ¨)JHBªªªªLE¬CÚc±)JHBªªªªG=c£‘m)JHBªªªªLD)NçĞ)JHBªªªªVM)ïpJ)JHBªªªª\T!H
%g—)JHBªªªªg[è‘wŸÛ)JHBªªªªh_Ù`r¶y»)JHBªªªªpf.ñR7•s)JHBªªªªƒq1)S)JHBªªªª“s¬Ç%ÜÎ	)JHBªªªª˜zä´m‘d@)JHBªªªª–‰#Œƒ8©)JHBªªªª‹tk£Ñ«)JHBªªªª|a}BÖZÑ)JHBªªªªeFp";j’)JHBªªªªVFI’$I )JHBªªªª²FI’I)J   @@@²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    ªªªª²²I’$I’$    <?xml version="1.0" encoding="utf-8"?>
<Type Name="SnapLine" FullName="System.Windows.Forms.Design.Behavior.SnapLine">
  <TypeSignature Language="C#" Value="public sealed class SnapLine" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The following table lists the common modes that visual design tools support to assist you with positioning and sizing controls on a design surface.</para>
      <list type="table">
        <listheader>
          <item>
            <term>
              <para>Mode</para>
            </term>
            <description>
              <para>Description</para>
            </description>
          </item>
        </listheader>
        <item>
          <term>
            <para>Freeform</para>
          </term>
          <description>
            <para>Enables you to freely lay out controls.</para>
          </description>
        </item>
        <item>
          <term>
            <para>Grid</para>
          </term>
          <description>
            <para>Displays a static overlaid grid that assists you in laying out controls.</para>
          </description>
        </item>
        <item>
          <term>
            <para>Snapline</para>
          </term>
          <description>
            <para>Displays guide lines that assist you in laying out the container's controls relative to each other. Snaplines originate from controls and their container.</para>
          </description>
        </item>
      </list>
      <para>The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> class and related types help support the Snapline mode. </para>
      <para>Snaplines are generated dynamically and automatically as a control edge moves near another control or near the boundaries of its container. This can occur when a control is added from the toolbox, or moved or resized by mouse operations or keyboard commands. Controls typically have both horizontal and vertical snaplines defined; for rectangular controls, these typically extend from all four edges. </para>
      <para>The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> class uses only a few properties to describe each snapline, as shown in the following table.</para>
      <list type="table">
        <listheader>
          <item>
            <term>
              <para>Property</para>
            </term>
            <description>
              <para>Description</para>
            </description>
          </item>
        </listheader>
        <item>
          <term>
            <para>
              <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.SnapLineType" />
            </para>
          </term>
          <description>
            <para>Specifies the location and direction of the line with respect to its associated control. Typically, only snaplines of similar types will auto-align to each other.</para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Offset" /> </para>
          </term>
          <description>
            <para>Specifies the distance in pixels from the origin, which is the upper-left corner of the control, to where the snapline starts.</para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Priority" /> </para>
          </term>
          <description>
            <para>Specifies the relative importance of the snapline. During any given layout decision point, only the snaplines that are active and have the highest priority are displayed. </para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Filter" /> </para>
          </term>
          <description>
            <para>Defines custom categories of snaplines. This is an optional string.</para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.IsHorizontal" /> and <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.IsVertical" /> </para>
          </term>
          <description>
            <para>Indicates whether a snapline has horizontal or vertical orientation, respectively.</para>
          </description>
        </item>
      </list>
      <para>The <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> class stores snaplines for its corresponding control type in the <see cref="P:System.Windows.Forms.Design.ControlDesigner.SnapLines" /> property. This base class handling of snaplines will suffice for the majority of controls, as it defines the <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Left" />, <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Right" />, <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Top" />, and <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Bottom" /> snaplines, which are aligned along the edges of the control. When you are developing a custom control, if this default organization does not suffice, override the <see cref="P:System.Windows.Forms.Design.ControlDesigner.SnapLines" /> property of the class derived from <see cref="T:System.Windows.Forms.Design.ControlDesigner" />. For example, you may want to align the horizontal snaplines of text-based controls, such as labels, with the top and base lines of the text (instead of the top and bottom edges of the control).</para>
      <para>The <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.SnapLineType" /> class cannot be derived from.</para>
      <para>There is extensive support for this feature in Visual Studio.</para>
      <para>
        <dynamicLink>
          <keyword>dl_WalkthroughArrangingControlsWindowsFormsUsingSnaplines</keyword>
        </dynamicLink>
      </para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents the horizontal and vertical line segments that are dynamically created in the user interface (UI) to assist in the design-time layout of controls in a container. This class cannot be inherited.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SnapLine (System.Windows.Forms.Design.Behavior.SnapLineType type, int offset);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Windows.Forms.Design.Behavior.SnapLineType" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor sets the <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Filter" /> property to null and the <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Priority" /> property to <see cref="F:System.Windows.Forms.Design.Behavior.SnapLinePriority.Low" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> class using the specified snapline type and offset.</para>
        </summary>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLineType" /> to create. Describes the relative position and orientation of the snapline.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the snapline, in pixels, relative to the upper-left origin of the owning control.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SnapLine (System.Windows.Forms.Design.Behavior.SnapLineType type, int offset, string filter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Windows.Forms.Design.Behavior.SnapLineType" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor sets the <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Priority" /> property to <see cref="F:System.Windows.Forms.Design.Behavior.SnapLinePriority.Low" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> class using the specified snapline type, offset, and filter name. </para>
        </summary>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLineType" /> to create. Describes the relative position and orientation of the snapline.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the snapline, in pixels, relative to the upper-left origin of the owning control.</param>
        <param name="filter">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.String" /> used to specify a programmer-defined category of snaplines.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SnapLine (System.Windows.Forms.Design.Behavior.SnapLineType type, int offset, System.Windows.Forms.Design.Behavior.SnapLinePriority priority);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Windows.Forms.Design.Behavior.SnapLineType" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="priority" Type="System.Windows.Forms.Design.Behavior.SnapLinePriority" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor sets the <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Filter" /> property to null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> class using the specified snapline type, offset, and priority. </para>
        </summary>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLineType" /> to create. Describes the relative position and orientation of the snapline.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the snapline, in pixels, relative to the upper-left origin of the owning control.</param>
        <param name="priority">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLinePriority" /> of the snapline.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SnapLine (System.Windows.Forms.Design.Behavior.SnapLineType type, int offset, string filter, System.Windows.Forms.Design.Behavior.SnapLinePriority priority);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Windows.Forms.Design.Behavior.SnapLineType" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="filter" Type="System.String" />
        <Parameter Name="priority" Type="System.Windows.Forms.Design.Behavior.SnapLinePriority" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor sets all of the properties of a snapline to programmer-supplied values.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> class using the specified snapline type, offset, filter name, and priority. </para>
        </summary>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLineType" /> to create. Describes the relative position and orientation of the snapline.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the snapline, in pixels, relative to the upper-left origin of the owning control.</param>
        <param name="filter">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.String" /> used to specify a programmer-defined category of snaplines.</param>
        <param name="priority">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLinePriority" /> of the snapline.</param>
      </Docs>
    </Member>
    <Member MemberName="AdjustOffset">
      <MemberSignature Language="C#" Value="public void AdjustOffset (int adjustment);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="adjustment" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The offset of a snapline is the distance, in pixels, that the snapline is located from the associated control's upper-left origin. Although the offset can be set to any integer value, typically the snaplines retain the spatial relationships implied by their <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.SnapLineType" /> property value.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Adjusts the <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Offset" /> property of the snapline.</para>
        </summary>
        <param name="adjustment">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of pixels to change the snapline offset by.</param>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Filter" /> property is used to define custom categories of snaplines. Only snaplines with the same filter name are able to snap to each other. This property can be used in custom control designers to expose different categories of snaplines depending upon the state of the control or the type of operation being performed. For example, round controls could offer a custom snapline with the filter value of "Center".</para>
          <para>This property is initialized during construction and cannot be changed thereafter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the programmer-defined filter category associated with this snapline.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsHorizontal">
      <MemberSignature Language="C#" Value="public bool IsHorizontal { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following snapline types are horizontal: <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Top" />, <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Bottom" />, <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Horizontal" />, and <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Baseline" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the snapline has a horizontal orientation.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsVertical">
      <MemberSignature Language="C#" Value="public bool IsVertical { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following snapline types are vertical: <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Left" />, <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Right" />, and <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Vertical" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the snapline has a vertical orientation.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public int Offset { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The origin of a control is the upper-left point of the control. A single offset can describe the position of a snapline, because vertical snaplines may have only a nonzero x-axis offset, whereas horizontal snaplines may only have a nonzero y-axis offset.</para>
          <para>The <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Offset" /> property is initialized at construction time, but it can be changed thereafter with the <see cref="M:System.Windows.Forms.Design.Behavior.SnapLine.AdjustOffset(System.Int32)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of pixels that the snapline is offset from the origin of the associated control.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Design.Behavior.SnapLinePriority Priority { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.SnapLinePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.Priority" /> property establishes categories of importance for the snaplines associated with a control. </para>
          <para>The Windows Forms Designer uses this property to determine which snaplines to display during a control addition, resize, or move operation. For more information, see the <see cref="T:System.Windows.Forms.Design.Behavior.SnapLinePriority" /> enumeration.</para>
          <para>This property is initialized during construction and cannot be changed thereafter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating the relative importance of the snapline.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ShouldSnap">
      <MemberSignature Language="C#" Value="public static bool ShouldSnap (System.Windows.Forms.Design.Behavior.SnapLine line1, System.Windows.Forms.Design.Behavior.SnapLine line2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="line1" Type="System.Windows.Forms.Design.Behavior.SnapLine" />
        <Parameter Name="line2" Type="System.Windows.Forms.Design.Behavior.SnapLine" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a value indicating whether the specified <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> should snap to another <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="line1" /> should snap to <paramref name="line2" />; otherwise, false.</para>
        </returns>
        <param name="line1">
          <attribution license="cc4" from="Microsoft" modified="false" />The specified <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" />.</param>
        <param name="line2">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> to which the specified <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> is expected to snap.</param>
      </Docs>
    </Member>
    <Member MemberName="SnapLineType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Design.Behavior.SnapLineType SnapLineType { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.SnapLineType</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Visual designers use the <see cref="P:System.Windows.Forms.Design.Behavior.SnapLine.SnapLineType" /> property to direct snap alignment operations. Typically only snaplines that are similarly oriented can snap to each other. For example, two snaplines of type <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Horizontal" /> can snap together, but a <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Horizontal" /> and a <see cref="F:System.Windows.Forms.Design.Behavior.SnapLineType.Vertical" /> 