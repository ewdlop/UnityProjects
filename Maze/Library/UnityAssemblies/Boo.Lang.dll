// Copyright 2011-2015 Xamarin Inc. All rights reserved.

using System;
using ObjCRuntimeInternal;

namespace Mono.AppleTls {

	// this is a subset of OSStatus -> SInt32 -> signed int - see CoreFoundation.framework/Headers/CFBase.h
	// values are defined in Security.framework/Headers/SecBase.h 
	enum SecStatusCode {
		Success 							= 0,
		Unimplemented 						= -4,
		DiskFull 							= -34,
		IO 									= -36,
		OpWr 								= -49,
		Param 								= -50,
		WritePermissions					= -61,
		Allocate 							= -108,
		UserCanceled 						= -128,
		BadReq 								= -909,
		InternalComponent	 				= -2070,
		CoreFoundationUnknown 				= -4960,
		NotAvailable 						= -25291,
		ReadOnly 							= -25292,
		AuthFailed 							= -25293,
		NoSuchKeyChain 						= -25294,
		InvalidKeyChain 					= -25295,
		DuplicateKeyChain	 				= -25296,
		DuplicateItem	 					= -25299,
		ItemNotFound 						= -25300,
		InteractionNotAllowed 				= -25308,
		Decode 								= -26275,
		DuplicateCallback					= -25297,
		InvalidCallback						= -25298,
		BufferTooSmall						= -25301,
		DataTooLarge						= -25302,
		NoSuchAttribute						= -25303,
		InvalidItemRef						= -25304,
		InvalidSearchRef					= -25305,
		NoSuchClass							= -25306,
		NoDefaultKeychain					= -25307,
		ReadOnlyAttribute					= -25309,
		WrongSecVersion						= -25310,
		KeySizeNotAllowed					= -25311,
		NoStorageModule 					= -25312,
		NoCertificateModule 				= -25313,
		NoPolicyModule 						= -25314,
		InteractionRequired 				= -25315,
		DataNotAvailable 					= -25316,
		DataNotModifiable 					= -25317,
		CreateChainFailed 					= -25318,
		InvalidPrefsDomain 					= -25319,
		InDarkWake 							= -25320,
		ACLNotSimple						= -25240,
		PolicyNotFound						= -25241,
		InvalidTrustSetting					= -25242,
		NoAccessForItem						= -25243,
		InvalidOwnerEdit 					= -25244,
		TrustNotAvailable 					= -25245,
		UnsupportedFormat 					= -25256,
		UnknownFormat 						= -25257,
		KeyIsSensitive 						= -25258,
		MultiplePrivateKeys 				= -25259,
		PassphraseRequired 					= -25260,
		InvalidPasswordRef 					= -25261,
		InvalidTrustSettings 				= -25262,
		NoTrustSettings 					= -25263,
		Pkcs12VerifyFailure 				= -25264,
		NotSigner 							= -26267,
		ServiceNotAvailable 				= -67585,
		InsufficientClientID 				= -67586,
		DeviceReset 						= -67587,
		DeviceFailed 						= -67588,
		AppleAddAppACLSubject 				= -67589,
		ApplePublicKeyIncomplete 			= -67590,
		AppleSignatureMismatch 				= -67591,
		AppleInvalidKeyStartDate 			= -67592,
		AppleInvalidKeyEndDate 				= -67593,
		ConversionError 					= -67594,
		AppleSSLv2Rollback 					= -67595,
		QuotaExceeded 						= -67596,
		FileTooBig 							= -67597,
		InvalidDatabaseBlob 				= -67598,
		InvalidKeyBlob 						= -67599,
		IncompatibleDatabaseBlob 			= -67600,
		IncompatibleKeyBlob 				= -67601,
		HostNameMismatch 					= -67602,
		UnknownCriticalExtensionFlag 		= -67603,
		NoBasicConstraints 					= -67604,
		NoBasicConstraintsCA 				= -67605,
		InvalidAuthorityKeyID 				= -67606,
		InvalidSubjectKeyID					= -67607,	/* The subject key ID is not valid. */
		InvalidKeyUsageForPolicy			= -67608,	/* The key usage is not valid for the specified policy. */
		InvalidExtendedKeyUsage				= -67609,	/* The extended key usage is not valid. */
		InvalidIDLinkage					= -67610,	/* The ID linkage is not valid. */
		PathLengthConstraintExceeded		= -67611,	/* The path length constraint was exceeded. */
		InvalidRoot							= -67612,	/* The root or anchor certificate is not valid. */
		CRLExpired							= -67613,	/* The CRL has expired. */
		CRLNotValidYet						= -67614,	/* The CRL is not yet valid. */
		CRLNotFound							= -67615,	/* The CRL was not found. */
		CRLServerDown						= -67616,	/* The CRL server is down. */
		CRLBadURI							= -67617,	/* The CRL has a bad Uniform Resource Identifier. */
		UnknownCertExtension				= -67618,	/* An unknown certificate extension was encountered. */
		UnknownCRLExtension					= -67619,	/* An unknown CRL extension was encountered. */
		CRLNotTrusted						= -67620,	/* The CRL is not trusted. */
		CRLPolicyFailed						= -67621,	/* The CRL policy failed. */
		IDPFailure							= -67622,	/* The issuing distribution point was not valid. */
		SMIMEEmailAddressesNotFound			= -67623,	/* An email address mismatch was encountered. */
		SMIMEBadExtendedKeyUsage			= -67624,	/* The appropriate extended key usage for SMIME was not found. */
		SMIMEBadKeyUsage					= -67625,	/* The key usage is not compatible with SMIME. */
		SMIMEKeyUsageNotCritical			= -67626,	/* The key usage extension is not marked as critical. */
		SMIMENoEmailAddress					= -67627,	/* No email address was found in the certificate. */
		SMIMESubjAltNameNotCritical			= -67628,	/* The subject alternative name extension is not marked as critical. */
		SSLBadExtendedKeyUsage				= -67629,	/* The appropriate extended key usage for SSL was not found. */
		OCSPBadResponse						= -67630,	/* The OCSP response was incorrect or could not be parsed. */
		OCSPBadRequest						= -67631,	/* The OCSP request was incorrect or could not be parsed. */
		OCSPUnavailable						= -67632,	/* OCSP service is unavailable. */
		OCSPStatusUnrecognized				= -67633,	/* The OCSP server did not recognize this certificate. */
		EndOfData							= -67634,	/* An end-of-data was detected. */
		IncompleteCertRevocationCheck		= -67635,	/* An incomplete certificate revocation check occurred. */
		NetworkFailure						= -67636,	/* A network failure occurred. */
		OCSPNotTrustedToAnchor				= -67637,	/* The OCSP response was not trusted to a root or anchor certificate. */
		RecordModified						= -67638,	/* The record was modified. */
		OCSPSignatureError					= -67639,	/* The OCSP response had an invalid signature. */
		OCSPNoSigner						= -67640,	/* The OCSP response had no signer. */
		OCSPResponderMalformedReq			= -67641,	/* The OCSP responder was given a malformed request. */
		OCSPResponderInternalError			= -67642,	/* The OCSP responder encountered an internal error. */
		OCSPResponderTryLater				= -67643,	/* The OCSP responder is busy, try again later. */
		OCSPResponderSignatureRequired		= -67644,	/* The OCSP responder requires a signature. */
		OCSPResponderUnauthorized			= -67645,	/* The OCSP responder rejected this request as unauthorized. */
		OCSPResponseNonceMismatch			= -67646,	/* The OCSP response nonce did not match the request. */
		CodeSigningBadCertChainLength		= -67647,	/* Code signing encountered an incorrect certificate chain length. */
		CodeSigningNoBasicConstraints		= -67648,	/* Code signing found no basic constraints. */
		CodeSigningBadPathLengthConstraint 	= -67649,	/* Code signing encountered an incorrect path length constraint. */
		CodeSigningNoExtendedKeyUsage		= -67650,	/* Code signing found no extended key usage. */
		CodeSigningDevelopment				= -67651,	/* Code signing indicated use of a development-only certificate. */
		ResourceSignBadCertChainLength		= -67652,	/* Resource signing has encountered an incorrect certificate chain length. */
		ResourceSignBadExtKeyUsage			= -67653,	/* Resource signing has encountered an error in the extended key usage. */
		TrustSettingDeny					= -67654,	/* The trust setting for this policy was set to Deny. */
		InvalidSubjectName					= -67655,	/* An invalid certificate subject name was encountered. */
		UnknownQualifiedCertStatement		= -67656,	/* An unknown qualified certificate statement was encountered. */
		MobileMeRequestQueued				= -67657,	/* The MobileMe request will be sent during the next connection. */
		MobileMeRequestRedirected			= -67658,	/* The MobileMe request was redirected. */
		MobileMeServerError					= -67659,	/* A MobileMe server error occurred. */
		MobileMeServerNotAvailable			= -67660,	/* The MobileMe server is not available. */
		MobileMeServerAlreadyExists			= -67661,	/* The MobileMe server reported that the item already exists. */
		MobileMeServerServiceErr			= -67662,	/* A MobileMe service error has occurred. */
		MobileMeRequestAlreadyPending		= -67663,	/* A MobileMe request is already pending. */
		MobileMeNoRequestPending			= -67664,	/* MobileMe has no request pending. */
		MobileMeCSRVerifyFailure			= -67665,	/* A MobileMe CSR verification failure has occurred. */
		MobileMeFailedConsistencyCheck		= -67666,	/* MobileMe has found a failed consistency check. */
		NotInitialized						= -67667,	/* A function was called without initializing CSSM. */
		InvalidHandleUsage					= -67668,	/* The CSSM handle does not match with the service type. */
		PVCReferentNotFound					= -67669,	/* A reference to the calling module was not found in the list of authorized callers. */
		FunctionIntegrityFail				= -67670,	/* A function address was not within the verified module. */
		InternalError						= -67671,	/* An internal error has occurred. */
		MemoryError							= -67672,	/* A memory error has occurred. */
		InvalidData							= -67673,	/* Invalid data was encountered. */
		MDSError							= -67674,	/* A Module Directory Service error has occurred. */
		InvalidPointer						= -67675,	/* An invalid pointer was encountered. */
		SelfCheckFailed						= -67676,	/* Self-check has failed. */
		FunctionFailed						= -67677,	/* A function has failed. */
		ModuleManifestVerifyFailed			= -67678,	/* A module manifest verification failure has occurred. */
		InvalidGUID							= -67679,	/* An invalid GUID was encountered. */
		InvalidHandle						= -67680,	/* An invalid handle was encountered. */
		InvalidDBList						= -67681,	/* An invalid DB list was encountered. */
		InvalidPassthroughID				= -67682,	/* An invalid passthrough ID was encountered. */
		InvalidNetworkAddress				= -67683,	/* An invalid network address was encountered. */
		CRLAlreadySigned					= -67684,	/* The certificate revocation list is already signed. */
		InvalidNumberOfFields				= -67685,	/* An invalid number of fields were encountered. */
		VerificationFailure					= -67686,	/* A verification failure occurred. */
		UnknownTag							= -67687,	/* An unknown tag was encountered. */
		InvalidSignature					= -67688,	/* An invalid signature was encountered. */
		InvalidName							= -67689,	/* An invalid name was encountered. */
		InvalidCertificateRef				= -67690,	/* An invalid certificate reference was encountered. */
		InvalidCertificateGroup				= -67691,	/* An invalid certificate group was encountered. */
		TagNotFound							= -67692,	/* The specified tag was not found. */
		InvalidQuery						= -67693,	/* The specified query was not valid. */
		InvalidValue						= -67694,	/* An invalid value was detected. */
		CallbackFailed						= -67695,	/* A callback has failed. */
		ACLDeleteFailed						= -67696,	/* An ACL delete operation has failed. */
		ACLReplaceFailed					= -67697,	/* An ACL replace operation has failed. */
		ACLAddFailed						= -67698,	/* An ACL add operation has failed. */
		ACLChangeFailed						= -67699,	/* An ACL change operation has failed. */
		InvalidAccessCredentials			= -67700,	/* Invalid access credentials were encountered. */
		InvalidRecord						= -67701,	/* An invalid record was encountered. */
		InvalidACL							= -67702,	/* An invalid ACL was encountered. */
		InvalidSampleValue					= -67703,	/* An invalid sample value was encountered. */
		IncompatibleVersion					= -67704,	/* An incompatible version was encountered. */
		PrivilegeNotGranted					= -67705,	/* The privilege was not granted. */
		InvalidScope						= -67706,	/* An invalid scope was encountered. */
		PVCAlreadyConfigured				= -67707,	/* The PVC is already configured. */
		InvalidPVC							= -67708,	/* An invalid PVC was encountered. */
		EMMLoadFailed						= -67709,	/* The EMM load has failed. */
		EMMUnloadFailed						= -67710,	/* The EMM unload has failed. */
		AddinLoadFailed						= -67711,	/* The add-in load operation has failed. */
		InvalidKeyRef						= -67712,	/* An invalid key was encountered. */
		InvalidKeyHierarchy					= -67713,	/* An invalid key hierarchy was encountered. */
		AddinUnloadFailed					= -67714,	/* The add-in unload operation has failed. */
		LibraryReferenceNotFound			= -67715,	/* A library reference was not found. */
		InvalidAddinFunctionTable			= -67716,	/* An invalid add-in function table was encountered. */
		InvalidServiceMask					= -67717,	/* An invalid service mask was encountered. */
		ModuleNotLoaded						= -67718,	/* A module was not loaded. */
		InvalidSubServiceID					= -67719,	/* An invalid subservice ID was encountered. */
		AttributeNotInContext				= -67720,	/* An attribute was not in the context. */
		ModuleManagerInitializeFailed		= -67721,	/* A module failed to initialize. */
		ModuleManagerNotFound				= -67722,	/* A module was not found. */
		EventNotificationCallbackNotFound 	= -67723,	/* An event notification callback was not found. */
		InputLengthError					= -67724,	/* An input length error was encountered. */
		OutputLengthError					= -67725,	/* An output length error was encountered. */
		PrivilegeNotSupported				= -67726,	/* The privilege is not supported. */
		DeviceError							= -67727,	/* A device error was encountered. */
		AttachHandleBusy					= -67728,	/* The CSP handle was busy. */
		NotLoggedIn							= -67729,	/* You are not logged in. */
		AlgorithmMismatch					= -67730,	/* An algorithm mismatch was encountered. */
		KeyUsageIncorrect					= -67731,	/* The key usage is incorrect. */
		KeyBlobTypeIncorrect				= -67732,	/* The key blob type is incorrect. */
		KeyHeaderInconsistent				= -67733,	/* The key header is inconsistent. */
		UnsupportedKeyFormat				= -67734,	/* The key header format is not supported. */
		UnsupportedKeySize					= -67735,	/* The key size is not supported. */
		InvalidKeyUsageMask					= -67736,	/* The key usage mask is not valid. */
		UnsupportedKeyUsageMask				= -67737,	/* The key usage mask is not supported. */
		InvalidKeyAttributeMask				= -67738,	/* The key attribute mask is not valid. */
		UnsupportedKeyAttributeMask			= -67739,	/* The key attribute mask is not supported. */
		InvalidKeyLabel						= -67740,	/* The key label is not valid. */
		UnsupportedKeyLabel					= -67741,	/* The key label is not supported. */
		InvalidKeyFormat					= -67742,	/* The key format is not valid. */
		UnsupportedVectorOfBuffers			= -67743,	/* The vector of buffers is not supported. */
		InvalidInputVector					= -67744,	/* The input vector is not valid. */
		InvalidOutputVector					= -67745,	/* The output vector is not valid. */
		InvalidContext						= -67746,	/* An invalid context was encountered. */
		InvalidAlgorithm					= -67747,	/* An invalid algorithm was encountered. */
		InvalidAttributeKey					= -67748,	/* A key attribute was not valid. */
		MissingAttributeKey					= -67749,	/* A key attribute was missing. */
		InvalidAttributeInitVector			= -67750,	/* An init vector attribute was not valid. */
		MissingAttributeInitVector			= -67751,	/* An init vector attribute was missing. */
		InvalidAttributeSalt				= -67752,	/* A salt attribute was not valid. */
		MissingAttributeSalt				= -67753,	/* A salt attribute was missing. */
		InvalidAttributePadding				= -67754,	/* A padding attribute was not valid. */
		MissingAttributePadding				= -67755,	/* A padding attribute was missing. */
		InvalidAttributeRandom				= -67756,	/* A random number attribute was not valid. */
		MissingAttributeRandom				= -67757,	/* A random number attribute was missing. */
		InvalidAttributeSeed				= -67758,	/* A seed attribute was not valid. */
		MissingAttributeSeed				= -67759,	/* A seed attribute was missing. */
		InvalidAttributePassphrase			= -67760,	/* A passphrase attribute was not valid. */
		MissingAttributePassphrase			= -67761,	/* A passphrase attribute was missing. */
		InvalidAttributeKeyLength			= -67762,	/* A key length attribute was not valid. */
		MissingAttributeKeyLength			= -67763,	/* A key length attribute was missing. */
		InvalidAttributeBlockSize			= -67764,	/* A block size attribute was not valid. */
		MissingAttributeBlockSize			= -67765,	/* A block size attribute was missing. */
		InvalidAttributeOutputSize			= -67766,	/* An output size attribute was not valid. */
		MissingAttributeOutputSize			= -67767,	/* An output size attribute was missing. */
		InvalidAttributeRounds				= -67768,	/* The number of rounds attribute was not valid. */
		MissingAttributeRounds				= -67769,	/* The number of rounds attribute was missing. */
		InvalidAlgorithmParms				= -67770,	/* An algorithm parameters attribute was not valid. */
		MissingAlgorithmParms				= -67771,	/* An algorithm parameters attribute was missing. */
		InvalidAttributeLabel				= -67772,	/* A label attribute was not valid. */
		MissingAttributeLabel				= -67773,	/* A label attribute was missing. */
		InvalidAttributeKeyType				= -67774,	/* A key type attribute was not valid. */
		MissingAttributeKeyType				= -67775,	/* A key type attribute was missing. */
		InvalidAttributeMode				= -67776,	/* A mode attribute was not valid. */
		MissingAttributeMode				= -67777,	/* A mode attribute was missing. */
		InvalidAttributeEffectiveBits		= -67778,	/* An effective bits attribute was not valid. */
		MissingAttributeEffectiveBits		= -67779,	/* An effective bits attribute was missing. */
		InvalidAttributeStartDate			= -67780,	/* A start date attribute was not valid. */
		MissingAttributeStartDate			= -67781,	/* A start date attribute was missing. */
		InvalidAttributeEndDate				= -67782,	/* An end date attribute was not valid. */
		MissingAttributeEndDate				= -67783,	/* An end date attribute was missing. */
		InvalidAttributeVersion				= -67784,	/* A version attribute was not valid. */
		MissingAttributeVersion				= -67785,	/* A version attribute was missing. */
		InvalidAttributePrime				= -67786,	/* A prime attribute was not valid. */
		MissingAttributePrime				= -67787,	/* A prime attribute was missing. */
		InvalidAttributeBase				= -67788,	/* A base attribute was not valid. */
		MissingAttributeBase				= -67789,	/* A base attribute was missing. */
		InvalidAttributeSubprime			= -67790,	/* A subprime attribute was not valid. */
		MissingAttributeSubprime			= -67791,	/* A subprime attribute was missing. */
		InvalidAttributeIterationCount		= -67792,	/* An iteration count attribute was not valid. */
		MissingAttributeIterationCount		= -67793,	/* An iteration count attribute was missing. */
		InvalidAttributeDLDBHandle			= -67794,	/* A database handle attribute was not valid. */
		MissingAttributeDLDBHandle			= -67795,	/* A database handle attribute was missing. */
		InvalidAttributeAccessCredentials 	= -67796,	/* An access credentials attribute was not valid. */
		MissingAttributeAccessCredentials	= -67797,	/* An access credentials attribute was missing. */
		InvalidAttributePublicKeyFormat		= -67798,	/* A public key format attribute was not valid. */
		MissingAttributePublicKeyFormat		= -67799,	/* A public key format attribute was missing. */
		InvalidAttributePrivateKeyFormat	= -67800,	/* A private key format attribute was not valid. */
		MissingAttributePrivateKeyFormat	= -67801,	/* A private key format attribute was missing. */
		InvalidAttributeSymmetricKeyFormat	= -67802,	/* A symmetric key format attribute was not valid. */
		MissingAttributeSymmetricKeyFormat	= -67803,	/* A symmetric key format attribute was missing. */
		InvalidAttributeWrappedKeyFormat	= -67804,	/* A wrapped key format attribute was not valid. */
		MissingAttributeWrappedKeyFormat	= -67805,	/* A wrapped key format attribute was missing. */
		StagedOperationInProgress			= -67806,	/* A staged operation is in progress. */
		StagedOperationNotStarted			= -67807,	/* A staged operation was not started. */
		VerifyFailed						= -67808,	/* A cryptographic verification failure has occurred. */
		QuerySizeUnknown					= -67809,	/* The query size is unknown. */
		BlockSizeMismatch					= -67810,	/* A block size mismatch occurred. */
		PublicKeyInconsistent				= -67811,	/* The public key was inconsistent. */
		DeviceVerifyFailed					= -67812,	/* A device verification failure has occurred. */
		InvalidLoginName					= -67813,	/* An invalid login name was detected. */
		AlreadyLoggedIn						= -67814,	/* The user is already logged in. */
		InvalidDigestAlgorithm				= -67815,	/* An invalid digest algorithm was detected. */
		InvalidCRLGroup						= -67816,	/* An invalid CRL group was detected. */
		CertificateCannotOperate			= -67817,	/* The certificate cannot operate. */
		CertificateExpired					= -67818,	/* An expired certificate was detected. */
		CertificateNotValidYet				= -67819,	/* The certificate is not yet valid. */
		CertificateRevoked					= -67820,	/* The certificate was revoked. */
		CertificateSuspended				= -67821,	/* The certificate was suspended. */
		InsufficientCredentials				= -67822,	/* Insufficient credentials were detected. */
		InvalidAction						= -67823,	/* The action was not valid. */
		InvalidAuthority					= -67824,	/* The authority was not valid. */
		VerifyActionFailed					= -67825,	/* A verify action has failed. */
		InvalidCertAuthority				= -67826,	/* The certificate authority was not valid. */
		InvalidCRLAuthority					= -67827,	/* The CRL authority was not valid. */
		[Obsolete ("Use InvalidCRLAuthority")]
		InvaldCRLAuthority					= InvalidCRLAuthority,
		InvalidCRLEncoding					= -67828,	/* The CRL encoding was not valid. */
		InvalidCRLType						= -67829,	/* The CRL type was not valid. */
		InvalidCRL							= -67830,	/* The CRL was not valid. */
		InvalidFormType						= -67831,	/* The form type was not valid. */
		InvalidID							= -67832,	/* The ID was not valid. */
		InvalidIdentifier					= -67833,	/* The identifier was not valid. */
		InvalidIndex						= -67834,	/* The index was not valid. */
		InvalidPolicyIdentifiers			= -67835,	/* The policy identifiers are not valid. */
		InvalidTimeString					= -67836,	/* The time specified was not valid. */
		InvalidReason						= -67837,	/* The trust policy reason was not valid. */
		InvalidRequestInputs				= -67838,	/* The request inputs are not valid. */
		InvalidResponseVector				= -67839,	/* The response vector was not valid. */
		InvalidStopOnPolicy					= -67840,	/* The stop-on policy was not valid. */
		InvalidTuple						= -67841,	/* The tuple was not valid. */
		MultipleValuesUnsupported			= -67842,	/* Multiple values are not supported. */
		NotTrusted							= -67843,	/* The trust policy was not trusted. */
		NoDefaultAuthority					= -67844,	/* No default authority was detected. */
		RejectedForm						= -67845,	/* The trust policy had a rejected form. */
		RequestLost							= -67846,	/* The request was lost. */
		RequestRejected						= -67847,	/* The request was rejected. */
		UnsupportedAddressType				= -67848,	/* The address type is not supported. */
		UnsupportedService					= -67849,	/* The service is not supported. */
		InvalidTupleGroup					= -67850,	/* The tuple group was not valid. */
		InvalidBaseACLs						= -67851,	/* The base ACLs are not valid. */
		InvalidTupleCredentials				= -67852,	/* The tuple credentials are not valid. */
		[Obsolete ("Use InvalidTupleCredentials")]
		InvalidTupleCredendtials			= InvalidTupleCredentials,
		InvalidEncoding						= -67853,	/* The encoding was not valid. */
		InvalidValidityPeriod				= -67854,	/* The validity period was not valid. */
		InvalidRequestor					= -67855,	/* The requestor was not valid. */
		RequestDescriptor					= -67856,	/* The request descriptor was not valid. */
		InvalidBundleInfo					= -67857,	/* The bundle information was not valid. */
		InvalidCRLIndex						= -67858,	/* The CRL index was not valid. */
		NoFieldValues						= -67859,	/* No field values were detected. */
		UnsupportedFieldFormat				= -67860,	/* The field format is not supported. */
		UnsupportedIndexInfo				= -67861,	/* The index information is not supported. */
		UnsupportedLocality					= -67862,	/* The locality is not supported. */
		UnsupportedNumAttributes			= -67863,	/* The number of attributes is not supported. */
		UnsupportedNumIndexes				= -67864,	/* The number of indexes is not supported. */
		UnsupportedNumRecordTypes			= -67865,	/* The number of record types is not supported. */
		FieldSpecifiedMultiple				= -67866,	/* Too many fields were specified. */
		IncompatibleFieldFormat				= -67867,	/* The field format was incompatible. */
		InvalidParsingModule				= -67868,	/* The parsing module was not valid. */
		DatabaseLocked						= -67869,	/* The database is locked. */
		DatastoreIsOpen						= -67870,	/* The data store is open. */
		MissingValue						= -67871,	/* A missing value was detected. */
		UnsupportedQueryLimits				= -67872,	/* The query limits are not supported. */
		UnsupportedNumSelectionPreds		= -67873,	/* The number of selection predicates is not supported. */
		UnsupportedOperator					= -67874,	/* The operator is not supported. */
		InvalidDBLocation					= -67875,	/* The database location is not valid. */
		InvalidAccessRequest				= -67876,	/* The access request is not valid. */
		InvalidIndexInfo					= -67877,	/* The index information is not valid. */
		InvalidNewOwner						= -67878,	/* The new owner is not valid. */
		InvalidModifyMode					= -67879,	/* The modify mode is not valid. */
		MissingRequiredExtension			= -67880,	/* A required certificate extension is missing. */
		ExtendedKeyUsageNotCritical			= -67881,	/* The extended key usage extension was not marked critical. */
		TimestampMissing					= -67882,	/* A timestamp was expected but was not found. */
		TimestampInvalid					= -67883,	/* The timestamp was not valid. */
		TimestampNotTrusted					= -67884,	/* The timestamp was not trusted. */
		TimestampServiceNotAvailable		= -67885,	/* The timestamp service is not available. */
		TimestampBadAlg						= -67886,	/* An unrecognized or unsupported Algorithm Identifier in timestamp. */
		TimestampBadRequest					= -67887,	/* The timestamp transaction is not permitted or supported. */
		TimestampBadDataFormat				= -67888,	/* The timestamp data submitted has the wrong format. */
		TimestampTimeNotAvailable			= -67889,	/* The time source for the Timestamp Authority is not available. */
		TimestampUnacceptedPolicy			= -67890,	/* The requested policy is not supported by the Timestamp Authority. */
		TimestampUnacceptedExtension		= -67891,	/* The requested extension is not supported by the Timestamp Authority. */
		TimestampAddInfoNotAvailable		= -67892,	/* The additional information requested is not available. */
		TimestampSystemFailure				= -67893,	/* The timestamp request cannot be handled due to system failure. */
		SigningTimeMissing					= -67894,	/* A signing time was expected but was not found. */
		TimestampRejection					= -67895,	/* A timestamp transaction was rejected. */
		TimestampWaiting                    = -67896,	/* A timestamp transaction is waiting. */
		TimestampRevocationWarning          = -67897,	/* A timestamp authority revocation warning was issued. */
		TimestampRevocationNotification     = -67898,	/* A timestamp authority revocation notification was issued. */
	}

	// typedef uint32_t SecTrustResultType;
	// values are defined in Security.framework/Headers/SecTrust.h 
	enum SecTrustResult {
		Invalid,
		Proceed,

		Confirm,
		Deny,
		Unspecified,
		RecoverableTrustFailure,
		FatalTrustFailure,
		ResultOtherError,
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    K      
      D      Q      
      R      W      
      «      ]      
      p      c      
      =      i      
      C      o      
      Y      u      
            {      
      	            
      É      ‡      
      Â            
      ê      “      
      O      ™      
      ‡       Ÿ      
            ¥      
      ê      «      
      x      ±      
      s      ·      
      ‡      ½      
            Ä      
      ¸	      Ð      
            Ü      
      í      é      
      :      ö      
      ’	            
      6             
      X            
      *      )      
      {      5      
      «      B      
      Š	      O      
      Ù      \      
      Ç      i      
            Ö      
            ë      
      t      ø      
      ò            
      ÿ            
      ÷            
      R      ,      
      k      9      
      $      F      # Copyright 2009 Brian Quinlan. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Implements ProcessPoolExecutor.

The follow diagram and text describe the data-flow through the system:

|======================= In-process =====================|== Out-of-process ==|

+----------+     +----------+       +--------+     +-----------+    +---------+
|          |  => | Work Ids |       |        |     | Call Q    |    | Process |
|          |     +----------+       |        |     +-----------+    |  Pool   |
|          |     | ...      |       |        |     | ...       |    +---------+
|          |     | 6        |    => |        |  => | 5, call() | => |         |
|          |     | 7        |       |        |     | ...       |    |         |
| Process  |     | ...      |       | Local  |     +-----------+    | Process |
|  Pool    |     +----------+       | Worker |                      |  #1..n  |
| Executor |                        | Thread |                      |         |
|          |     +----------- +     |        |     +-----------+    |         |
|          | <=> | Work Items | <=> |        | <=  | Result Q  | <= |         |
|          |     +------------+     |        |     +-----------+    |         |
|          |     | 6: call()  |     |        |     | ...       |    |         |
|          |     |    future  |     |        |     | 4, result |    |         |
|          |     | ...        |     |        |     | 3, except |    |         |
+----------+     +------------+     +--------+     +-----------+    +---------+

Executor.submit() called:
- creates a uniquely numbered _WorkItem and adds it to the "Work Items" dict
- adds the id of the _WorkItem to the "Work Ids" queue

Local worker thread:
- reads work ids from the "Work Ids" queue and looks up the corresponding
  WorkItem from the "Work Items" dict: if the work item has been cancelled then
  it is simply removed from the dict, otherwise it is repackaged as a
  _CallItem and put in the "Call Q". New _CallItems are put in the "Call Q"
  until "Call Q" is full. NOTE: the size of the "Call Q" is kept small because
  calls placed in the "Call Q" can no longer be cancelled with Future.cancel().
- reads _ResultItems from "Result Q", updates the future stored in the
  "Work Items" dict and deletes the dict entry

Process #1..n:
- reads _CallItems from "Call Q", executes the calls, and puts the resulting
  _ResultItems in "Result Q"
"""

__author__ = 'Brian Quinlan (brian@sweetapp.com)'

import atexit
import os
from concurrent.futures import _base
import queue
from queue import Full
import multiprocessing as mp
from multiprocessing.connection import wait
from multiprocessing.queues import Queue
import threading
import weakref
from functools import partial
import itertools
import sys
import traceback

# Workers are created as daemon threads and processes. This is done to allow the
# interpreter to exit when there are still idle processes in a
# ProcessPoolExecutor's process pool (i.e. shutdown() was not called). However,
# allowing workers to die with the interpreter has two undesirable properties:
#   - The workers would still be running during interpreter shutdown,
#     meaning that they would fail in unpredictable ways.
#   - The workers could be killed while evaluating a work item, which could
#     be bad if the callable being evaluated has external side-effects e.g.
#     writing to a file.
#
# To work around this problem, an exit handler is installed which tells the
# workers to exit when their work queues are empty and then waits until the
# threads/processes finish.

_threads_wakeups = weakref.WeakKeyDictionary()
_global_shutdown = False


class _ThreadWakeup:
    def __init__(self):
        self._reader, self._writer = mp.Pipe(duplex=False)

    def close(self):
        self._writer.close()
        self._reader.close()

    def wakeup(self):
        self._writer.send_bytes(b"")

    def clear(self):
        while self._reader.poll():
            self._reader.recv_bytes()


def _python_exit():
    global _global_shutdown
    _global_shutdown = True
    items = list(_threads_wakeups.items())
    for _, thread_wakeup in items:
        thread_wakeup.wakeup()
    for t, _ in items:
        t.join()

# Controls how many more calls than processes will be queued in the call queue.
# A smaller number will mean that processes spend more time idle waiting for
# work while a larger number will make Future.cancel() succeed less frequently
# (Futures in the call queue cannot be cancelled).
EXTRA_QUEUED_CALLS = 1


# On Windows, WaitForMultipleObjects is used to wait for processes to finish.
# It can wait on, at most, 63 objects. There is an overhead of two objects:
# - the result queue reader
# - the thread wakeup reader
_MAX_WINDOWS_WORKERS = 63 - 2

# Hack to embed stringification of remote traceback in local traceback

class _RemoteTraceback(Exception):
    def __init__(self, tb):
        self.tb = tb
    def __str__(self):
        return self.tb

class _ExceptionWithTraceback:
    def __init__(self, exc, tb):
        tb = traceback.format_exception(type(exc), exc, tb)
        tb = ''.join(tb)
        self.exc = exc
        self.tb = '\n"""\n%s"""' % tb
    def __reduce__(self):
        return _rebuild_exc, (self.exc, self.tb)

def _rebuild_exc(exc, tb):
    exc.__cause__ = _RemoteTraceback(tb)
    return exc

class _WorkItem(object):
    def __init__(self, future, fn, args, kwargs):
        self.future = future
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

class _ResultItem(object):
    def __init__(self, work_id, exception=None, result=None):
        self.work_id = work_id
        self.exception = exception
        self.result = result

class _CallItem(object):
    def __init__(self, work_id, fn, args, kwargs):
        self.work_id = work_id
        self.fn = fn
        self.args = args
        self.kwargs = kwargs


class _SafeQueue(Queue):
    """Safe Queue set exception to the future object linked to a job"""
    def __init__(self, max_size=0, *, ctx, pending_work_items):
        self.pending_work_items = pending_work_items
        super().__init__(max_size, ctx=ctx)

    def _on_queue_feeder_error(self, e, obj):
        if isinstance(obj, _CallItem):
            tb = traceback.format_exception(type(e), e, e.__traceback__)
            e.__cause__ = _RemoteTraceback('\n"""\n{}"""'.format(''.join(tb)))
            work_item = self.pending_work_items.pop(obj.work_id, None)
            # work_item can be None if another process terminated. In this case,
            # the queue_manager_thread fails all work_items with BrokenProcessPool
            if work_item is not None:
                work_item.future.set_exception(e)
        else:
            super()._on_queue_feeder_error(e, obj)


def _get_chunks(*iterables, chunksize):
    """ Iterates over zip()ed iterables in chunks. """
    it = zip(*iterables)
    while True:
        chunk = tuple(itertools.islice(it, chunksize))
        if not chunk:
            return
        yield chunk

def _process_chunk(fn, chunk):
    """ Processes a chunk of an iterable passed to map.

    Runs the function passed to map() on a chunk of the
    iterable passed to map.

    This function is run in a separate process.

    """
    return [fn(*args) for args in chunk]


def _sendback_result(result_queue, work_id, result=None, exception=None):
    """Safely send back the given result or exception"""
    try:
        result_queue.put(_ResultItem(work_id, result=result,
                                     exception=exception))
    except BaseException as e:
        exc = _ExceptionWithTraceback(e, e.__traceback__)
        result_queue.put(_ResultItem(work_id, exception=exc))


def _process_worker(call_queue, result_queue, initializer, initargs):
    """Evaluates calls from call_queue and places the results in result_queue.

    This worker is run in a separate process.

    Args:
        call_queue: A ctx.Queue of _CallItems that will be read and
            evaluated by the worker.
        result_queue: A ctx.Queue of _ResultItems that will written
            to by the worker.
        initializer: A callable initializer, or None
        initargs: A tuple of args for the initializer
    """
    if initializer is not None:
        try:
            initializer(*initargs)
        except BaseException:
            _base.LOGGER.critical('Exception in initializer:', exc_info=True)
            # The parent will notice that the process stopped and
            # mark the pool broken
            return
    while True:
        call_item = call_queue.get(block=True)
        if call_item is None:
            # Wake up queue management thread
            result_queue.put(os.getpid())
            return
        try:
            r = call_item.fn(*call_item.args, **call_item.kwargs)
        except BaseException as e:
            exc = _ExceptionWithTraceback(e, e.__traceback__)
            _sendback_result(result_queue, call_item.work_id, exception=exc)
        else:
            _sendback_result(result_queue, call_item.work_id, result=r)

        # Liberate the resource as soon as possible, to avoid holding onto
        # open files or shared memory that is not needed anymore
        del call_item


def _add_call_item_to_queue(pending_work_items,
                            work_ids,
                            call_queue):
    """Fills call_queue with _WorkItems from pending_work_items.

    This function never blocks.

    Args:
        pending_work_items: A dict mapping work ids to _WorkItems e.g.
            {5: <_WorkItem...>, 6: <_WorkItem...>, ...}
        work_ids: A queue.Queue of work ids e.g. Queue([5, 6, ...]). Work ids
            are consumed and the corresponding _WorkItems from
            pending_work_items are transformed into _CallItems and put in
            call_queue.
        call_queue: A multiprocessing.Queue that will be filled with _CallItems
            derived from _WorkItems.
    """
    while True:
        if call_queue.full():
            return
        try:
            work_id = work_ids.get(block=False)
        except queue.Empty:
            return
        else:
            work_item = pending_work_items[work_id]

            if work_item.future.set_running_or_notify_cancel():
                call_queue.put(_CallItem(work_id,
                                         work_item.fn,
                                         work_item.args,
                                         work_item.kwargs),
                               block=True)
            else:
                del pending_work_items[work_id]
                continue


def _queue_management_worker(executor_reference,
                             processes,
                             pending_work_items,
                             work_ids_queue,
                             call_queue,
                             result_queue,
                             thread_wakeup):
    """Manages the communication between this process and the worker processes.

    This function is run in a local thread.

    Args:
        executor_reference: A weakref.ref to the ProcessPoolExecutor that owns
            this thread. Used to determine if the ProcessPoolExecutor has been
            garbage collected and that this function can exit.
        process: A list of the ctx.Process instances used as
            workers.
        pending_work_items: A dict mapping work ids to _WorkItems e.g.
            {5: <_WorkItem...>, 6: <_WorkItem...>, ...}
        work_ids_queue: A queue.Queue of work ids e.g. Queue([5, 6, ...]).
        call_queue: A ctx.Queue that will be filled with _CallItems
            derived from _WorkItems for processing by the process workers.
        result_queue: A ctx.SimpleQueue of _ResultItems generated by the
            process workers.
        thread_wakeup: A _ThreadWakeup to allow waking up the
            queue_manager_thread from the main Thread and avoid deadlocks
            caused by permanently locked queues.
    """
    executor = None

    def shutting_down():
        return (_global_shutdown or executor is None
                or executor._shutdown_thread)

    def shutdown_worker():
        # This is an upper bound on the number of children alive.
        n_children_alive = sum(p.is_alive() for p in processes.values())
        n_children_to_stop = n_children_alive
        n_sentinels_sent = 0
        # Send the right number of sentinels, to make sure all children are
        # properly terminated.
        while n_sentinels_sent < n_children_to_stop and n_children_alive > 0:
            for i in range(n_children_to_stop - n_sentinels_sent):
                try:
                    call_queue.put_nowait(None)
                    n_sentinels_sent += 1
                except Full:
                    break
            n_children_alive = sum(p.is_alive() for p in processes.values())

        # Release the queue's resources as soon as possible.
        call_queue.close()
        # If .join() is not called on the created processes then
        # some ctx.Queue methods may deadlock on Mac OS X.
        for p in processes.values():
            p.join()

    result_reader = result_queue._reader
    wakeup_reader = thread_wakeup._reader
    readers = [result_reader, wakeup_reader]

    while True:
        _add_call_item_to_queue(pending_work_items,
                                work_ids_queue,
                                call_queue)

        # Wait for a result to be ready in the result_queue while checking
        # that all worker processes are still running, or for a wake up
        # signal send. The wake up signals come either from new tasks being
        # submitted, from the executor being shutdown/gc-ed, or from the
        # shutdown of the python interpreter.
        worker_sentinels = [p.sentinel for p in processes.values()]
        ready = wait(readers + worker_sentinels)

        cause = None
        is_broken = True
        if result_reader in ready:
            try:
                result_item = result_reader.recv()
                is_broken = False
            except BaseException as e:
                cause = traceback.format_exception(type(e), e, e.__traceback__)

        elif wakeup_reader in ready:
            is_broken = False
            result_item = None
        thread_wakeup.clear()
        if is_broken:
            # Mark the process pool broken so that submits fail right now.
            executor = executor_reference()
            if executor is not None:
                executor._broken = ('A child process terminated '
                                    'abruptly, the process pool is not '
                                    'usable anymore')
                executor._shutdown_thread = True
                executor = None
            bpe = BrokenProcessPool("A process in the process pool was "
                                    "terminated abruptly while the future was "
                                    "running or pending.")
            if cause is not None:
                bpe.__cause__ = _RemoteTraceback(
                    f"\n'''\n{''.join(cause)}'''")
            # All futures in flight must be marked failed
            for work_id, work_item in pending_work_items.items():
                work_item.future.set_exception(bpe)
                # Delete references to object. See issue16284
                del work_item
            pending_work_items.clear()
            # Terminate remaining workers forcibly: the queues or their
            # locks may be in a dirty state and block forever.
            for p in processes.values():
                p.terminate()
            shutdown_worker()
            return
        if isinstance(result_item, int):
            # Clean shutdown of a worker using its PID
            # (avoids marking the executor broken)
            assert shutting_down()
            p = processes.pop(result_item)
            p.join()
            if not processes:
                shutdown_worker()
                return
        elif result_item is not None:
            work_item = pending_work_items.pop(result_item.work_id, None)
            # work_item can be None if another process terminated (see above)
            if work_item is not None:
                if result_item.exception:
                    work_item.future.set_exception(result_item.exception)
                else:
                    work_item.future.set_result(result_item.result)
                # Delete references to object. See issue16284
                del work_item
            # Delete reference to result_item
            del result_item

        # Check whether we should start shutting down.
        executor = executor_reference()
        # No more work items can be added if:
        #   - The interpreter is shutting down OR
        #   - The executor that owns this worker has been collected OR
        #   - The executor that owns this worker has been shutdown.
        if shutting_down():
            try:
                # Flag the executor as shutting down as early as possible if it
                # is not gc-ed yet.
                if executor is not None:
                    executor._shutdown_thread = True
                # Since no new work items can be added, it is safe to shutdown
                # this thread if there are no pending work items.
                if not pending_work_items:
                    shutdown_worker()
                    return
            except Full:
                # This is not a problem: we will eventually be woken up (in
                # result_queue.get()) and be able to send a sentinel again.
                pass
        executor = None


_system_limits_checked = False
_system_limited = None


def _check_system_limits():
    global _system_limits_checked, _system_limited
    if _system_limits_checked:
        if _system_limited:
            raise NotImplementedError(_system_limited)
    _system_limits_checked = True
    try:
        nsems_max = os.sysconf("SC_SEM_NSEMS_MAX")
    except (AttributeError, ValueError):
        # sysconf not available or setting not available
        return
    if nsems_max == -1:
        # indetermined limit, assume that limit is determined
        # by available memory only
        return
    if nsems_max >= 256:
        # minimum number of semaphores available
        # according to POSIX
        return
    _system_limited = ("system provides too few semaphores (%d"
                       " available, 256 necessary)" % nsems_max)
    raise NotImplementedError(_system_limited)


def _chain_from_iterable_of_lists(iterable):
    """
    Specialized implementation of itertools.chain.from_iterable.
    Each item in *iterable* should be a list.  This function is
    careful not to keep references to yielded objects.
    """
    for element in iterable:
        element.reverse()
        while element:
            yield element.pop()


class BrokenProcessPool(_base.BrokenExecutor):
    """
    Raised when a process in a ProcessPoolExecutor terminated abruptly
    while a future was in the running state.
    """


class ProcessPoolExecutor(_base.Executor):
    def __init__(self, max_workers=None, mp_context=None,
                 initializer=None, initargs=()):
        """Initializes a new ProcessPoolExecutor instance.

        Args:
            max_workers: The maximum number of processes that can be used to
                execute the given calls. If None or not given then as many
                worker processes will be created as the machine has processors.
            mp_context: A multiprocessing context to launch the workers. This
                object should provide SimpleQueue, Queue and Process.
            initializer: A callable used to initialize worker processes.
            initargs: A tuple of arguments to pass to the initializer.
        """
        _check_system_limits()

        if max_workers is None:
            self._max_workers = os.cpu_count() or 1
            if sys.platform == 'win32':
                self._max_workers = min(_MAX_WINDOWS_WORKERS,
                                        self._max_workers)
        else:
            if max_workers <= 0:
                raise ValueError("max_workers must be greater than 0")
            elif (sys.platform == 'win32' and
                max_workers > _MAX_WINDOWS_WORKERS):
                raise ValueError(
                    f"max_workers must be <= {_MAX_WINDOWS_WORKERS}")

            self._max_workers = max_workers

        if mp_context is None:
            mp_context = mp.get_context()
        self._mp_context = mp_context

        if initializer is not None and not callable(initializer):
            raise TypeError("initializer must be a callable")
        self._initializer = initializer
        self._initargs = initargs

        # Management thread
        self._queue_management_thread = None

        # Map of pids to processes
        self._processes = {}

        # Shutdown is a two-step process.
        self._shutdown_thread = False
        self._shutdown_lock = threading.Lock()
        self._broken = False
        self._queue_count = 0
        self._pending_work_items = {}

        # Create communication channels for the executor
        # Make the call queue slightly larger than the number of processes to
        # prevent the worker processes from idling. But don't make it too big
        # because futures in the call queue cannot be cancelled.
        queue_size = self._max_workers + EXTRA_QUEUED_CALLS
        self._call_queue = _SafeQueue(
            max_size=queue_size, ctx=self._mp_context,
            pending_work_items=self._pending_work_items)
        # Killed worker processes can produce spurious "broken pipe"
        # tracebacks in the queue's own worker thread. But we detect killed
        # processes anyway, so silence the tracebacks.
        self._call_queue._ignore_epipe = True
        self._result_queue = mp_context.SimpleQueue()
        self._work_ids = queue.Queue()

        # _ThreadWakeup is a communication channel used to interrupt the wait
        # of the main loop of queue_manager_thread from another thread (e.g.
        # when calling executor.submit or executor.shutdown). We do not use the
        # _result_queue to send the wakeup signal to the queue_manager_thread
        # as it could result in a deadlock if a worker process dies with the
        # _result_queue write lock still acquired.
        self._queue_management_thread_wakeup = _ThreadWakeup()

    def _start_queue_management_thread(self):
        if self._queue_management_thread is None:
            # When the executor gets garbarge collected, the weakref callback
            # will wake up the queue management thread so that it can terminate
            # if there is no pending work item.
            def weakref_cb(_,
                           thread_wakeup=self._queue_management_thread_wakeup):
                mp.util.debug('Executor collected: triggering callback for'
                              ' QueueManager wakeup')
                thread_wakeup.wakeup()
            # Start the processes so that their sentinels are known.
            self._adjust_process_count()
            self._queue_management_thread = threading.Thread(
                target=_queue_management_worker,
                args=(weakref.ref(self, weakref_cb),
                      self._processes,
                      self._pending_work_items,
                      self._work_ids,
                      self._call_queue,
                      self._result_queue,
                      self._queue_management_thread_wakeup),
                name="QueueManagerThread")
            self._queue_management_thread.daemon = True
            self._queue_management_thread.start()
            _threads_wakeups[self._queue_management_thread] = \
                self._queue_management_thread_wakeup

    def _adjust_process_count(self):
        for _ in range(len(self._processes), self._max_workers):
            p = self._mp_context.Process(
                target=_process_worker,
                args=(self._call_queue,
                      self._result_queue,
                      self._initializer,
                      self._initargs))
            p.start()
            self._processes[p.pid] = p

    def submit(*args, **kwargs):
        if len(args) >= 2:
            self, fn, *args = args
        elif not args:
            raise TypeError("descriptor 'submit' of 'ProcessPoolExecutor' object "
                            "needs an argument")
        elif 'fn' in kwargs:
            fn = kwargs.pop('fn')
            self, *args = args
        else:
            raise TypeError('submit expected at least 1 positional argument, '
                            'got %d' % (len(args)-1))

        with self._shutdown_lock:
            if self._broken:
                raise BrokenProcessPool(self._broken)
            if self._shutdown_thread:
                raise RuntimeError('cannot schedule new futures after shutdown')
            if _global_shutdown:
                raise RuntimeError('cannot schedule new futures after '
                                   'interpreter shutdown')

            f = _base.Future()
            w = _WorkItem(f, fn, args, kwargs)

            self._pending_work_items[self._queue_count] = w
            self._work_ids.put(self._queue_count)
            self._queue_count += 1
            # Wake up queue management thread
            self._queue_management_thread_wakeup.wakeup()

            self._start_queue_management_thread()
            return f
    submit.__doc__ = _base.Executor.submit.__doc__

    def map(self, fn, *iterables, timeout=None, chunksize=1):
        """Returns an iterator equivalent to map(fn, iter).

        Args:
            fn: A callable that will take as many arguments as there are
                passed iterables.
            timeout: The maximum number of seconds to wait. If None, then there
                is no limit on the wait time.
            chunksize: If greater than one, the iterables will be chopped into
                chunks of size chunksize and submitted to the process pool.
                If set to one, the items in the list will be sent one at a time.

        Returns:
            An iterator equivalent to: map(func, *iterables) but the calls may
            be evaluated out-of-order.

        Raises:
            TimeoutError: If the entire result iterator could not be generated
                before the given timeout.
            Exception: If fn(*args) raises for any values.
        """
        if chunksize < 1:
            raise ValueError("chunksize must be >= 1.")

        results = super().map(partial(_process_chunk, fn),
                              _get_chunks(*iterables, chunksize=chunksize),
                              timeout=timeout)
        return _chain_from_iterable_of_lists(results)

    def shutdown(self, wait=True):
        with self._shutdown_lock:
            self._shutdown_thread = True
        if self._queue_management_thread:
            # Wake up queue management thread
            self._queue_management_thread_wakeup.wakeup()
            if wait:
                self._queue_management_thread.join()
        # To reduce the risk of opening too many files, remove references to
        # objects that use file descriptors.
        self._queue_management_thread = None
        if self._call_queue is not None:
            self._call_queue.close()
            if wait:
                self._call_queue.join_thread()
            self._call_queue = None
        self._result_queue = None
        self._processes = None

        if self._queue_management_thread_wakeup:
            self._queue_management_thread_wakeup.close()
            self._queue_management_thread_wakeup = None

    shutdown.__doc__ = _base.Executor.shutdown.__doc__

atexit.register(_python_exit)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wüå[¤ ¤¯jž°@¹µ½s+ç³|:€”Z†¯"	Ž3a$¢­šBñ2µ@7ìæÝƒÛ¾G!aÿ
õë	YùÍHåz~ú,Æçd
Šc%l-FíÛf<ïÞ´ïã{Dd³ä9¾ê !°OÖ	Ó7¢M¹úÍ–ä¶H&ßàlþÖ ¼Cõ&A›3¹‰<F‡'¬¤òŸe]nƒÀ¼Lœ0z¹ÚúíCÇÊO#(îôpPµ^œîy!I²W&ñ9:˜LCÎô¿FOÖIî{Ìº»¿î½/T¡'ê€ ©+ôzÀŒ‘dYƒc1/¤ÿ~$–3ÙûÏÝ»·þ=¦´ó¯Ÿ!¢PéèaPv‚Ú Y¶Y‘MJÛ5`6—ƒÐ¡«¶ÎWˆa²¶F¨–Û+~¥Ž>ü«€¸€çd¯ca÷ôDz®ˆŠ¤_®q2©ûì›µ$0€¶à˜³‚)¤s2ÌPê¹O¶²ö+øl ‹)uÌ‚ì#¾°éîÔ­]W°6_ËiðM«uhF¾øûäêƒî“ù¬)ÀÐìñ:'Ïð'—„hÆ—tì^ÅŽüû¨CøyM4ÑáR$´³›#;»Žî”ár?°ý@LÎV‘1j3xX‡±)¹ nH¢v§ófü†œéUÒ×Ö`"ˆ¬`Bà˜8P).Í€IÙäÖÞúdÜÖÛÉ(È~ßÇ.&1–M$úÚRq‘±ÄäÙÏé$|ºµ™bÓ·¶: g1W
@a„4Ns}+æ Ù®ÌÏû×&½û…žºgÑ›Î‹týSdTlŒ¢Üñ×†öwTzÔquqëV?¤e©K!(ž%º[‡ˆ•¶K­Í¥«P÷²XHá÷ 5ÁóJeû"fVb 4ËÕ½]ŠÝÖÎÊ{ˆñ•Ñ’ù«ëïßl¼ÁèY(§tÎAÊ -{†ˆ‡ñÜIP«9ŒÊÐI¶$\Áð>ßÔÂl æ>;jBæ}[_ØÇkF´7¢v)KT‘:ûX*IøusNÓ™ç„EÝÉc×\3÷Bm_•ŸOŒ²±|¤Ö„‚‡—´´QÌ-%²8Žé±oZz’4¬FÌ®­Ø1î8u'3œ9%P	PÂºÇŽïÕCêu»ö”ôYû¡‹žeuDCpLÌ&Ë9ô¸#­,ƒO_VÎùÓ2‚Êéß$erŽX{.vÃ›ÎãòÿÚ;‘
‘¢¬¦ñ?¨™=G×¡—Ós®8yÀÇta3ZFT§µ11)G…—[ãÂÏ2À‹Y¶ÐÄŸ[­Ç¸]°ŸÛÍÝ-¤`”?g­¹C¡ªKäª~¯?á5•´Ig{e<@°4mzF²	 ÝCzêMª(”…Éd©9=-ÁÃ4Ó‰&¥5tt¶TQ«‡p°Ë¶`ïeªûa*õâ#LÚƒ®,
Eõ`²YtÜÃ)Nº_lt“à‰ ¹DjC3 ÈéX˜r¬DOÌDJý…ã‹»0(”ºÑ²Ëe9eÞô!ƒ}„1lW.~Rü}Ëôü¶¯ª);4wZ“ÅÕ{•ðN7¸Ïçû‘ÇTÛlôIóô¾^PÊS<
¼bOl6;Úx©ß{1¬e|¦¢ßÀt³<ÑÕ=ŸŽcG6&OW—gãQ÷ÑœeW5'r¥CRÈdöñéy@N×5^k!Ý¥ÖIYOè)ý(A„Zªik¥$¨„¹‚VNÄ‚¤þTöhˆçÒ_¸Ãpu$ÂuI£S^»SZ†°™ÐNö®êÝãRžt™nâšI*|"~±‹¾BP-à‘ãcßH.‰pe<lTçw¾xÆ'z&µÇPrÖ¥É®‚ÖuX*¶†ºrÃi±ÇÛþcý Ú¤ºuç)wš¥	0÷²çÓsdî½×ì¹¤A½äžm“Ü¬Bìy=£B7ë30°ûÀ‰F¦-¦\‰Í`½ˆÈÝì™&#'iLÍwæá­‡“£5èàò¼§Z782Æó«D˜NÎê¨ÃÜ
Â%pe	žj5¹žá%îe˜»ÑEðù*t]Äð@9’ðØ
ÿ=[É:ˆ#ÿâèÍŒ®q….Ø F[Jj`ok,f®ö.Æum$À3æ–{rãÞ¾MÁa“W$¢Õ0²í=ýi›UF†(%2È5p”ÿ>ŸŸ¾-—xÐÂœóÿÔ?Tæm–&‘2jVwÐ"—¯'eÁÌ÷^è$ÏÉsZ—È¤?n´J¶&Ö“É¤wh¥¿§ìY'ý¯¦tdÕÊ1ÐcðJ§Ùs8v4nšè¦ÒˆÕTÎ˜-ŠÔÌtÍs$N-"•=øõ	“_XÍºVL&n­ýÇ­Ç"ñùŸ{H1 ËÔE ¦üÝ\`ìóÔËãûoôªžd7 jbm<JyK‡Ö89¸fØÆ ”Ü¹"wadÿ—KáÝxöÍÙ­ðŠBt^û¼*Ór‰$€ÈD`˜/’1¨Û}GUšî¿ü^sÝÄ¥ž9 ªÑê5KZ@õ±¹Ç‡¨ˆâEX«“ˆ·§¤8é0ëäøã¹X.šç«ùoI6Ré¹ËÆº³fcLBù¡ª~²PÑÞÊÍH¤ådFLÀè\öÉ|ªZ“k®qú˜&Bâ`†¹²•ˆZ3Ð›x­ÕÅª¦\T9´aÎ' ´ øÜYë0)`}~õæŠØa~q“4h”¢hYO¢k.¥« ­Ù¡LòõJLÚ,Cõ¸Ïê`I3°\ORßTæÀä®C}˜®¾«ËU¨}"½Ï†×çs¢)¸€Í£ÎÝ6‡å]Csðäy÷…	yæušou?ZÚ@)¾XÊOyP‰b‡Pßð+Ë hÚÿw>ÝN—ôµì¤I¯wNÏËVþ<Õ—.€¤X4Ô–ÁÆSiY˜\Ýêä”ˆ1£¨S–2!%TG8®ø†ˆr|"&Îþ4Û,¾˜åCŽÜU`Þûrûÿ˜F<ÑI,úë½ªeÚÊìðŒ£É¿ŠŸLÒ´ÈuÛ¶	ÍÓúS¡óÆøÀoÊ<ÁîäF¥~ÚÁ+€lL„<=[eX·¤“¾=?yÒï@áRCËë_G*ÆÒ{‚s‹I6‰•ÄRë¸KÜíêcfÀî¡› Õ– »äOñ³_È	7ý\çp æ±
zöº·'9W©/Ý¨–X¾AûAÏ‘÷õ¾²#Ëq¯!’3kŽÚÈ@N`s·?‡ïè„ãÛ à¯?œ–e#…-™3ï‘ˆ¨óaœ¤ç¡,Öj·Û²êõ‰4ÿÂIÿÔ›iîíÒ"p&T7é¨fäõ«yzèëßþFÿ"EÐ™ükÊVº‰dï ´
Ô$5[²y¾“tyO¸bi«GAÏ(SF>šË”‘ŽQ™"L@–„n ]wðCå´´ä8“Iybl«Us‘ñ'ñòy
qXÚ  q¼«©—Æìµ„¤:ƒ1¥÷ë‰
BÃÌ:qÖ	‹R6ô›:†q.yýuÎa¦{ÖŒ$J1'¡i ¶àˆø‚Ý~¨«"–'' ÆÕã~t“'fÐõ'WyhG‘ª¹ŠÁ OÜ·×QîçqOmIC7ÿXEmÜËŽÕšàÆ>ùŸxnv}½Ð{7Ç4U2Àr¿R%#â¡Ã¢>f*µãfÛ¤b,lë3½6bñUŒÆê(ÖÝ’jôq®ùåÖPêzB‹›šé•B	H2¶CÔÔ¤g~¸e58pÐdnd; Jœ½!‘þ×©ŸmFøˆFÚÚ¢n{-€Ô„¶Œs
`ýÚ4`~÷˜õÕyMÚ»˜ Èz,ÃF½•©ãì^˜§èµ—ˆ;¹ØÐ×	jÞý`÷T“Ò¦•²öF¨UöxpÎ9Í¡¥`…•Uã’ke M"6ñó¹š¶+×ÜOÛà@š0ÛBËó´@³Ê-j3h$š$š2Y†šÆ¥ó´5%LìœÑùÿT8Pê\½ú¨yÀéÚzZa3Š¡žC÷æ—
ÊÙ£¶?ª«á*cA$1¢wx6#>'8&¬$—§(!„i„óåÍ~Kœm}½h¢‘mLÎ_‰˜Wñ:é¥ÔëÜüRžZê¶‘WÏ4P4¼ßj©{@çnIÎ»»o1CjþËÎ2ˆlÒ</.ì…5"`…+õ,Rs'ãÍcz¼v`¾a£­ëzl•k™yXÊ¿	Ý­á+V¼Êð5ð4‚Ÿ¹‚12EÒ[ªIÿŒÛm&3ßf¿ˆ®¿8Ó¦ªž”xÄ»sºyO=£×ËÍB­CkR¹‚5]ËªdbÿArë¦99¹ÏE®KE¯£—vüƒìKµìæùDìxÝªj2mc¹¶„yvøødÐË#áŠH¶ª¤>oÉŸ	ŸK¸}9·ì…oæÛFì£.ÄP9C“^²´œ7!UÔÙïÐ»ñš*ý¹Üœ«%Ù¿­›5ÇgíúŠ…éäuV À†ªSrçW–O
š¼ãÅ¨¹Ý:÷ØÝ“W“¦`æˆ§HiÉ)p(ŸÕ\uR6o¤yÖà,3ø”µN‡,Â‘ËE‚L5-¬À¸‡'V,•ßSÛþ} /94–#nŽ×ºÊr@¤cñ2ßœùU9l?‹r#®ÆnÅB`s­¶Ë]$ÙÝ€úªÆ¢×iÀîR—ËudÅ¼.ÐXÕíÃºô#—ðåäcÂp1uÄX<Type Name="ListView+ListViewItemCollection" FullName="System.Windows.Forms.ListView+ListViewItemCollection">
  <TypeSignature Language="C#" Value="public class ListView.ListViewItemCollection : System.Collections.IList" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ListBindable(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ListViewItemCollection (System.Windows.Forms.ListView owner);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.ListView" />
      </Parameters>
      <Docs>
        <param name="owner">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Add (string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Add (System.Windows.Forms.ListViewItem value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.ListViewItem" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Add (string text, int imageIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <param name="imageIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Add (string text, string imageKey);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <param name="imageKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Add (string key, string text, int imageIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="text">To be added.</param>
        <param name="imageIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Add (string key, string text, string imageKey);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="text">To be added.</param>
        <param name="imageKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Windows.Forms.ListView.ListViewItemCollection items);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Windows.Forms.ListView+ListViewItemCollection" />
      </Parameters>
      <Docs>
        <param name="items">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Windows.Forms.ListViewItem[] items);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Windows.Forms.ListViewItem[]" />
      </Parameters>
      <Docs>
        <param name="items">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.ListViewItem item);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Windows.Forms.ListViewItem" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (string key);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array dest, int index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dest" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dest">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListViewItem[] Find (string key, bool searchAllSubItems);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="searchAllSubItems" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="searchAllSubItems">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (System.Windows.Forms.ListViewItem item);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Windows.Forms.ListViewItem" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (string key);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListViewItem Insert (int index, string text);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="text">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListViewItem Insert (int index, System.Windows.Forms.ListViewItem item);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Windows.Forms.ListViewItem" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListViewItem Insert (int index, string text, int imageIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="text">To be added.</param>
        <param name="imageIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListViewItem Insert (int index, string text, string imageKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="text">To be added.</param>
        <param name="imageKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Insert (int index, string key, string text, int imageIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="key">To be added.</param>
        <param name="text">To be added.</param>
        <param name="imageIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem Insert (int index, string key, string text, string imageKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="imageKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="key">To be added.</param>
        <param name="text">To be added.</param>
        <param name="imageKey">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem this[int index] { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ListViewItem this[string key] { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListViewItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (System.Windows.Forms.ListViewItem item);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Windows.Forms.ListViewItem" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RemoveByKey">
      <MemberSignature Language="C#" Value="public virtual void RemoveByKey (string key);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { set; get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        