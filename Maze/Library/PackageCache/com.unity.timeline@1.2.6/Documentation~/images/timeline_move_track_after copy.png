<?xml version="1.0" encoding="utf-8"?>
<Type Name="CngAlgorithm" FullName="System.Security.Cryptography.CngAlgorithm">
  <TypeSignature Language="C#" Value="public sealed class CngAlgorithm : IEquatable&lt;System.Security.Cryptography.CngAlgorithm&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit CngAlgorithm extends System.Object implements class System.IEquatable`1&lt;class System.Security.Cryptography.CngAlgorithm&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Security.Cryptography.CngAlgorithm&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The <see cref="T:System.Security.Cryptography.CngAlgorithm" /> class is a utility class. It consists of static properties, comparison methods, and a private, internally maintained, algorithm name string.</para>
      <para>The static properties return <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects. Each object's internal string is initialized to the algorithm name that corresponds to the name of the static property.</para>
      <para>You can also use this class to create objects for algorithm types that are not covered by the static properties.</para>
      <para>Several Cryptography Next Generation (CNG) classes (such as <see cref="T:System.Security.Cryptography.CngKey" />) accept <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects through an <paramref name="algorithm" /> parameter. When the class receives the <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object, it retrieves the embedded algorithm name by calling the object's <see cref="P:System.Security.Cryptography.CngAlgorithm.Algorithm" /> property.</para>
      <para>Therefore, <see cref="T:System.Security.Cryptography.CngAlgorithm" /> serves as an enumeration of well-known algorithms. It lets you specify a well-known algorithm by using a strongly typed value instead of a string. </para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Encapsulates the name of an encryption algorithm. </para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CngAlgorithm (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string algorithm) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Instances of the <see cref="T:System.Security.Cryptography.CngAlgorithm" /> class internally maintain the algorithm name that is specified by the <paramref name="algorithm" /> parameter.</para>
          <para>The primary purpose of this constructor is to provide a method for creating <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects for algorithm types that are not represented by the static properties of the <see cref="T:System.Security.Cryptography.CngAlgorithm" /> class. This capacity enables future dnprdnshort¬†releases, service packs, and third-party developers to add new algorithms, which can be accessed just like¬†the algorithms that are currently available.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngAlgorithm" /> class.</para>
        </summary>
        <param name="algorithm">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the algorithm to initialize.</param>
      </Docs>
    </Member>
    <Member MemberName="Algorithm">
      <MemberSignature Language="C#" Value="public string Algorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Algorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the algorithm name that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object specifies.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECDiffieHellmanP256">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm ECDiffieHellmanP256 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm ECDiffieHellmanP256" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-256 curve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECDiffieHellmanP384">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm ECDiffieHellmanP384 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm ECDiffieHellmanP384" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-384 curve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECDiffieHellmanP521">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm ECDiffieHellmanP521 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm ECDiffieHellmanP521" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-521 curve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECDsaP256">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm ECDsaP256 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm ECDsaP256" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-256 curve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECDsaP384">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm ECDsaP384 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm ECDsaP384" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-384 curve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ECDsaP521">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm ECDsaP521 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm ECDsaP521" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-521 curve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <paramref name="obj" /> parameter is a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> that specifies the same algorithm as the current object; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</param>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Security.Cryptography.CngAlgorithm other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Security.Cryptography.CngAlgorithm other) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.Cryptography.CngAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares the specified <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <paramref name="other" /> parameter specifies the same algorithm as the current object; otherwise, false.</para>
        </returns>
        <param name="other">
          <attribution license="cc4" from="Microsoft" modified="false" />An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</param>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Generates a hash value for the algorithm name that is embedded in the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash value of the embedded algorithm name.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="MD5">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm MD5 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm MD5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Message Digest 5 (MD5) hash algorithm.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Security.Cryptography.CngAlgorithm left, System.Security.Cryptography.CngAlgorithm right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Security.Cryptography.CngAlgorithm left, class System.Security.Cryptography.CngAlgorithm right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Security.Cryptography.CngAlgorithm" />
        <Parameter Name="right" Type="System.Security.Cryptography.CngAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects specify the same algorithm name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the two objects specify the same algorithm name; otherwise, false.</para>
        </returns>
        <param name="left">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that specifies an algorithm name.</param>
        <param name="right">
          <attribution license="cc4" from="Microsoft" modified="false" />A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Security.Cryptography.CngAlgorithm left, System.Security.Cryptography.CngAlgorithm right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Security.Cryptography.CngAlgorithm left, class System.Security.Cryptography.CngAlgorithm right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Security.Cryptography.CngAlgorithm" />
        <Parameter Name="right" Type="System.Security.Cryptography.CngAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects do not specify the same algorithm.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the two objects do not specify the same algorithm name; otherwise, false.</para>
        </returns>
        <param name="left">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that specifies an algorithm name.</param>
        <param name="right">
          <attribution license="cc4" from="Microsoft" modified="false" />A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
      </Docs>
    </Member>
    <Member MemberName="Sha1">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm Sha1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm Sha1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 1 (SHA-1) algorithm.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sha256">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm Sha256 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm Sha256" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 256 (SHA-256) algorithm.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sha384">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm Sha384 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm Sha384" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 384 (SHA-384) algorithm.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sha512">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.CngAlgorithm Sha512 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Cryptography.CngAlgorithm Sha512" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 512 (SHA-512) algorithm.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the algorithm that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object specifies.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The embedded algorithm name.</para>
        </returns>
      </Docs>
    </Member>
  </Members>
</Type>                                                                                          e(Expression e)
            {
                if (e.NodeType == ExpressionType.Constant)
                {
                    return e;
                }

#if ASTORIA_LIGHT
                LambdaExpression lambda = ExpressionHelpers.CreateLambda(e, new ParameterExpression[0]); 
#else
                LambdaExpression lambda = Expression.Lambda(e);
#endif
                Delegate fn = lambda.Compile();
                object constantValue = fn.DynamicInvoke(null);
                Debug.Assert(!//===- Format.h - Efficient printf-style formatting for streams -*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements the format() function, which can be used with other
// LLVM subsystems to provide printf-style formatting.  This gives all the power
// and risk of printf.  This can be used like this (with raw_ostreams as an
// example):
//
//    OS << "mynumber: " << format("%4.5f", 1234.412) << '\n';
//
// Or if you prefer:
//
//  OS << format("mynumber: %4.5f\n", 1234.412);
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_SUPPORT_FORMAT_H
#define LLVM_SUPPORT_FORMAT_H

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/DataTypes.h"
#include <cassert>
#include <cstdio>
#include <tuple>

namespace llvm {

/// This is a helper class used for handling formatted output.  It is the
/// abstract base class of a templated derived class.
class format_object_base {
protected:
  const char *Fmt;
  ~format_object_base() = default; // Disallow polymorphic deletion.
  format_object_base(const format_object_base &) = default;
  virtual void home(); // Out of line virtual method.

  /// Call snprintf() for this object, on the given buffer and size.
  virtual int snprint(char *Buffer, unsigned BufferSize) const = 0;

public:
  format_object_base(const char *fmt) : Fmt(fmt) {}

  /// Format the object into the specified buffer.  On success, this returns
  /// the length of the formatted string.  If the buffer is too small, this
  /// returns a length to retry with, which will be larger than BufferSize.
  unsigned print(char *Buffer, unsigned BufferSize) const {
    assert(BufferSize && "Invalid buffer size!");

    // Print the string, leaving room for the terminating null.
    int N = snprint(Buffer, BufferSize);

    // VC++ and old GlibC return negative on overflow, just double the size.
    if (N < 0)
      return BufferSize * 2;

    // Other implementations yield number of bytes needed, not including the
    // final '\0'.
    if (unsigned(N) >= BufferSize)
      return N + 1;

    // Otherwise N is the length of output (not including the final '\0').
    return N;
  }
};

/// These are templated helper classes used by the format function that
/// capture the object to be formatted and the format string. When actually
/// printed, this synthesizes the string into a temporary buffer provided and
/// returns whether or not it is big enough.

// Helper to validate that format() parameters are scalars or pointers.
template <typename... Args> struct validate_format_parameters;
template <typename Arg, typename... Args>
struct validate_format_parameters<Arg, Args...> {
  static_assert(std::is_scalar<Arg>::value,
                "format can't be used with non fundamental / non pointer type");
  validate_format_parameters() { validate_format_parameters<Args...>(); }
};
template <> struct validate_format_parameters<> {};

template <typename... Ts>
class format_object final : public format_object_base {
  std::tuple<Ts...> Vals;

  template <std::size_t... Is>
  int snprint_tuple(char *Buffer, unsigned BufferSize,
                    index_sequence<Is...>) const {
#ifdef _MSC_VER
    return _snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);
#else
    return snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);
#endif
  }

public:
  format_object(const char *fmt, const Ts &... vals)
      : format_object_base(fmt), Vals(vals...) {
    validate_format_parameters<Ts...>();
  }

  int snprint(char *Buffer, unsigned BufferSize) const override {
    return snprint_tuple(Buffer, BufferSize, index_sequence_for<Ts...>());
  }
};

/// These are helper functions used to produce formatted output.  They use
/// template type deduction to construct the appropriate instance of the
/// format_object class to simplify their construction.
///
/// This is typically used like:
/// \code
///   OS << format("%0.4f", myfloat) << '\n';
/// \endcode

template <typename... Ts>
inline format_object<Ts...> format(const char *Fmt, const Ts &... Vals) {
  return format_object<Ts...>(Fmt, Vals...);
}

/// This is a helper class for left_justify, right_justify, and center_justify.
class FormattedString {
public:
  enum Justification { JustifyNone, JustifyLeft, JustifyRight, JustifyCenter };
  FormattedString(StringRef S, unsigned W, Justification J)
      : Str(S), Width(W), Justify(J) {}

private:
  StringRef Str;
  unsigned Width;
  Justification Justify;
  friend class raw_ostream;
};

/// left_justify - append spaces after string so total output is
/// \p Width characters.  If \p Str is larger that \p Width, full string
/// is written with no padding.
inline FormattedString left_justify(StringRef Str, unsigned Width) {
  return FormattedString(Str, Width, FormattedString::JustifyLeft);
}

/// right_justify - add spaces before string so total output is
/// \p Width characters.  If \p Str is larger that \p Width, full string
/// is written with no padding.
inline FormattedString right_justify(StringRef Str, unsigned Width) {
  return FormattedString(Str, Width, FormattedString::JustifyRight);
}

/// center_justify - add spaces before and after string so total output is
/// \p Width characters.  If \p Str is larger that \p Width, full string
/// is written with no padding.
inline FormattedString center_justify(StringRef Str, unsigned Width) {
  return FormattedString(Str, Width, FormattedString::JustifyCenter);
}

/// This is a helper class used for format_hex() and format_decimal().
class FormattedNumber {
  uint64_t HexValue;
  int64_t DecValue;
  unsigned Width;
  bool Hex;
  bool Upper;
  bool HexPrefix;
  friend class raw_ostream;

public:
  FormattedNumber(uint64_t HV, int64_t DV, unsigned W, bool H, bool U,
                  bool Prefix)
      : HexValue(HV), DecValue(DV), Width(W), Hex(H), Upper(U),
        HexPrefix(Prefix) {}
};

/// format_hex - Output \p N as a fixed width hexadecimal. If number will not
/// fit in width, full number is still printed.  Examples:
///   OS << format_hex(255, 4)              => 0xff
///   OS << format_hex(255, 4, true)        => 0xFF
///   OS << format_hex(255, 6)              => 0x00ff
///   OS << format_hex(255, 2)              => 0xff
inline FormattedNumber format_hex(uint64_t N, unsigned Width,
                                  bool Upper = false) {
  assert(Width <= 18 && "hex width must be <= 18");
  return FormattedNumber(N, 0, Width, true, Upper, true);
}

/// format_hex_no_prefix - Output \p N as a fixed width hexadecimal. Does not
/// prepend '0x' to the outputted string.  If number will not fit in width,
/// full number is still printed.  Examples:
///   OS << format_hex_no_prefix(255, 2)              => ff
///   OS << format_hex_no_prefix(255, 2, true)        => FF
///   OS << format_hex_no_prefix(255, 4)              => 00ff
///   OS << format_hex_no_prefix(255, 1)              => ff
inline FormattedNumber format_hex_no_prefix(uint64_t N, unsigned Width,
                                            bool Upper = false) {
  assert(Width <= 16 && "hex width must be <= 16");
  return FormattedNumber(N, 0, Width, true, Upper, false);
}

/// format_decimal - Output \p N as a right justified, fixed-width decimal. If
/// number will not fit in width, full number is still printed.  Examples:
///   OS << format_decimal(0, 5)     => "    0"
///   OS << format_decimal(255, 5)   => "  255"
///   OS << format_decimal(-1, 3)    => " -1"
///   OS << format_decimal(12345, 3) => "12345"
inline FormattedNumber format_decimal(int64_t N, unsigned Width) {
  return FormattedNumber(0, N, Width, false, false, false);
}

class FormattedBytes {
  ArrayRef<uint8_t> Bytes;

  // If not None, display offsets for each line relative to starting value.
  Optional<uint64_t> FirstByteOffset;
  uint32_t IndentLevel;  // Number of characters to indent each line.
  uint32_t NumPerLine;   // Number of bytes to show per line.
  uint8_t ByteGroupSize; // How many hex bytes are grouped without spaces
  bool Upper;            // Show offset and hex bytes as upper case.
  bool ASCII;            // Show the ASCII bytes for the hex bytes to the right.
  friend class raw_ostream;

public:
  FormattedBytes(ArrayRef<uint8_t> B, uint32_t IL, Optional<uint64_t> O,
                 uint32_t NPL, uint8_t BGS, bool U, bool A)
      : Bytes(B), FirstByteOffset(O), IndentLevel(IL), NumPerLine(NPL),
        ByteGroupSize(BGS), Upper(U), ASCII(A) {

    if (ByteGroupSize > NumPerLine)
      ByteGroupSize = NumPerLine;
  }
};

inline FormattedBytes
format_bytes(ArrayRef<uint8_t> Bytes, Optional<uint64_t> FirstByteOffset = None,
             uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,
             uint32_t IndentLevel = 0, bool Upper = false) {
  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,
                        ByteGroupSize, Upper, false);
}

inline FormattedBytes
format_bytes_with_ascii(ArrayRef<uint8_t> Bytes,
                        Optional<uint64_t> FirstByteOffset = None,
                        uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,
                        uint32_t IndentLevel = 0, bool Upper = false) {
  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,
                        ByteGroupSize, Upper, true);
}

} // end namespace llvm

#endif
                                                                                                                                                                                                                                                                                                                                                                          1A·Ò¯>∫@Y2YØÏæ…v&›)ÂïZÓ”v.ﬁ≤aUH Bòn.≤Zy·à;∫ÆHd$π·L3åì7/gº∑÷“¨ßòouÄ¸&ıß(–û∂üπºÃ˜≤ì¯n7T∑v‹¬l1-ˆNX„1O“z5˘,êK>ÑZ∫°ÁïtAØ>:ÁtˆÇ~-Ù ì:Ú-4πû≥‘år_Å%‡ 1Çå’Îm˙jıˆÒàÏ@'èRF˛P^FâH.˛7K>ü3ã›«Ë‹éC†æ
WouG‹¯U=ﬂ±¿† íÁÈG~Õ&EBUŸ/ó÷ËÔ¿Ç∂ú;	¨-ÖKwã6"πöüIî¢Uí,ß≈÷tπ˙<∞∆15¯ƒò=©3.‚:YΩÌ˜ôÃÑV4{»◊74¯¿˜≠ÿ_3kÙlñk¿~L‹Ê2∞≥Ùˆ÷≠ì’ÍÉ8)3N6≥DÉ—83ËÓÉóun&üÇ æÍ#:Q’ö	a	√rñ6£ﬂﬂë-ñëÄ˛6z†@ëq7\P6∂êü:§#ácyﬂŒáá[¡∞l÷††-ò¿¥0≥&£^àìC/™y¬cUF≈˚yÅÍjB∂£à]œR∏Ò¨‚N∂ç◊˚3å°Vâ§Õh @)Ëo_?ôÔ@Ê)j·%îLzÃ+‘≥⁄á9/8Åºôeløî‰b“[=ƒÄ¿WDÅ“ÜﬁyIÎ4uH<\áE¡~?~Wm B!´`ápñÙÙkœá=¢<ﬂåô!EıCﬂ∞„î2}ã9ïé√(6t!d2≠‚õÉÔ!◊å1˚è.ˇè@1&ˆdÓ±dBYˆx,å˛qºØ„„o>^t¡ ¸!i¢ﬁë&ÎìNK<QÓc˝w¡PïZ–™∫—›ﬁ?ªS≠†ÈÃÒN±æ˚±g•®:õh_™ıVaµ~‡∏Œ3Ò`ÿßD˝$•·^ d‡ÍÁõ¿ÃıEîxg·≠ÈÚ¸µ3[πâj‰ñmá≤ÇØz/\_∫ª2}û(€≤ˆ˛.É§âò≥∆˚ò3Á0/˚, 9Á/+5n§ãæû•[®¨¨˝í˜ÁµÔ¥2È∑®]ØEœ{µòÀ‚∆møeÊ¢€«C¸YÖ*Wõå˘’q+÷•OãÊ3äCo˛∂Y@5Xzx–ì«ƒÖÚGá±Ä jS`a˜i◊ò,‹éœƒìéÄ∞∂˜eëNƒü+Àë˚…&ºˇ õî£ÁÀ'yfoG·ìÈêõ”Ã¥Öu;d,:—è˜•Î=íå)w÷√ÄÒìÍ∞Âm!°øLÅ±)îõ˛w”¡É•j˚π˙=aÚØBÛt¨vÿÛ∏—√ä‹ˇãQzﬁ8[.ÂÃlñ¸‡∏»Ï»“ØÇá3“ç√ iBâ6w^x.6Zs¨◊õ¯‰π∑>æ3¡Lµ°g$Ìh©Ás\ﬁ“ô]Êx9ˆy¶Ì…"´Æ8U®Ñ7z‹‘QÒÀ˛‡ˇÏç»»B\ó&8’À•kX*"Hé:Nd—®ÃÙ-[ﬁ'∏πåöÃ¢Ò¸¢ΩFVZmkäS Z@*˚v¬˛˝È–[ÓÚG¬›ÃxC,j¢€à{„]·y'|°ˆ&ä+Ø(ØÇf]ûõ%yÉD’Öñ+0≈«-C(5ËÅ∆ø§ï∫5¿ÖÆ±¬‘∏à'∫{ÔÛ–T€÷“√õleJFëv	æ1˙ù√¯˚jPí¡t:”È\»uµµ∏bf6îJ◊¶Å∂¿ıà©ÚrMˆ°Ök.+g]2ì3Ÿ…ênCZ’®üDg∫<”&á‹â•2Ü_(_≥ô€´sjWUq∏L‡¢ìÙY7¸ë‰ªpU?∂Û:tá“<xˇ≤ﬁ≥Øu≠pc”v°CÛã6É≥ÿ£5x.|êxÂô—dÌq;
Ö{¿¬[.√Û2´ìJz¡≈æ¯¡/√\˛≠=¶t©KÄ?⁄ÒG‹*~û≤èñaÇ*dùëQ”∞É	ÙÌS–èh∆™˙™¥Dü¶˛jf1∂÷£o¥e¬e&Çk•œ∂\gk-2Cjç…SÑJlåöl∂ù∂—Ì 9cn∆:ëÎ°.”¯Ññ{fänFªW€wÍ
V€¶å®∆—- ãUÓOyÇÍ∏\E«π9^>?¶°p‘G*$ñi´oÏ˚bUdçnÙ≈j·{Œhëú]°3uË=≥)yÛ¥Øäaâè’B√|1ÏoJ˜Q—‡_u"±~√Ö˜€f‹4<¸ˇco\Kíì4IÑaåOJ±ù±®Úl√v#/O¿Ixıôé¨1‡BÛÄê}YF0o Ã~k“ßRIqfE™»ÉèÖ<
Rv1le©ËOj7k¬}/>Ì¢>jÚ]ó€ˆáÒ∏⁄‹Rä~Ò∑65èÑC^H<_@ËkxêºÑÜêiÙ>£.d7*«Âˆü´÷9!6F¯∂9Æ9?	Uﬂô¡	∂˘"eæ<28∏ÑAﬁW¬Sû≤H«£ÁRsPcqq`§ÔK/o€√<ükö&ÈCƒØ+çbÁQúå∞8Ÿ`≈5‘Ω)âm˝dΩØo∞x∆ƒ˜Ò:„<¸hE—œp±d(wÍ∂¯DgÃeht{xæWxÒVtˆ–ø}MÎ˘1ã€&Íä@5ZÛ¶ÿÙ£ïo”w*∞Å¢Û6-Á4õër:w¯€&tô¥ZÜ•ÏZÀïlÒ=SÁ<⁄ﬁ[∂ˆßˆpAÁπL‰Ê–±	áßf
6¸≥bç
/*
 Copyright (c) 2003-2006 Niels Kokholm and Peter Sestoft
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/

using System;
using C5;
using NUnit.Framework;
using SCG = System.Collections.Generic;


namespace C5UnitTests.support
{
  namespace bases
  {
    [TestFixture]
    public class ArrayBaseTest
    {
      class ABT : ArrayBase<string>
      {
        public ABT() : base(8,NaturalEqualityComparer<string>.Default) { }

        public override string Choose() { if (size > 0) return array[0]; throw new NoSuchItemException(); }

        public string this[int i] { get { return array[i]; } set { array[i] = value; } }


        public int thesize { get { return size; } set { size = value; } }
      }


      [Test]
      public void Check()
      {
        ABT abt = new ABT();

        abt.thesize = 3;
        abt[2] = "aaa";
        // Assert.IsFalse(abt.Check());
        abt[0] = "##";
        abt[1] = "##";
        Assert.IsTrue(abt.Check());
      }
    }
  }

  namespace itemops
  {
    [TestFixture]
    public class Comparers
    {
      class dbl : IComparable<dbl>
      {
        double d;

        public dbl(double din) { d = din; }

        public int CompareTo(dbl that)
        {
          return d < that.d ? -1 : d == that.d ? 0 : 1;
        }
        public bool Equals(dbl that) { return d == that.d; }
      }

      [Test]
      [ExpectedException(typeof(NotComparableException))]
      public void NotComparable()
      {
        SCG.IComparer<object> foo = Comparer<object>.Default;
      }

      [Test]
      public void GenericC()
      {
        SCG.IComparer<dbl> h = new NaturalComparer<dbl>();
        dbl s = new dbl(3.4);
        dbl t = new dbl(3.4);
        dbl u = new dbl(7.4);

        Assert.AreEqual(0, h.Compare(s, t));
        Assert.IsTrue(h.Compare(s, u) < 0);
      }


      [Test]
      public void OrdinaryC()
      {
        SCG.IComparer<string> h = new NaturalComparerO<string>();
        string s = "bamse";
        string t = "bamse";
        string u = "bimse";

        Assert.AreEqual(0, h.Compare(s, t));
        Assert.IsTrue(h.Compare(s, u) < 0);
      }


      [Test]
      public void GenericCViaBuilder()
      {
        SCG.IComparer<dbl> h = Comparer<dbl>.Default;
        dbl s = new dbl(3.4);
        dbl t = new dbl(3.4);
        dbl u = new dbl(7.4);

        Assert.AreEqual(0, h.Compare(s, t));
        Assert.IsTrue(h.Compare(s, u) < 0);
        Assert.AreSame(h, Comparer<dbl>.Default);
      }


      [Test]
      public void OrdinaryCViaBuilder()
      {
        SCG.IComparer<string> h = Comparer<string>.Default;
        string s = "bamse";
        string t = "bamse";
        string u = "bimse";

        Assert.AreEqual(0, h.Compare(s, t));
        Assert.IsTrue(h.Compare(s, u) < 0);
        Assert.AreSame(h, Comparer<string>.Default);

      }

      public void ComparerViaBuilderTest<T>(T item1, T item2)
          where T : IComparable<T>
      {
        SCG.IComparer<T> h = Comparer<T>.Default;
        Assert.AreSame(h, Comparer<T>.Default);
        Assert.AreEqual(0, h.Compare(item1, item1));
        Assert.AreEqual(0, h.Compare(item2, item2));
        Assert.IsTrue(h.Compare(item1, item2) < 0);
        Assert.IsTrue(h.Compare(item2, item1) > 0);
        Assert.AreEqual(Math.Sign(item1.CompareTo(item2)), Math.Sign(h.Compare(item1, item2)));
        Assert.AreEqual(Math.Sign(item2.CompareTo(item1)), Math.Sign(h.Compare(item2, item1)));
      }

      [Test]
      public void PrimitiveComparersViaBuilder()
      {
        ComparerViaBuilderTest<char>('A', 'a');
        ComparerViaBuilderTest<sbyte>(-122, 126);
        ComparerViaBuilderTest<byte>(122, 126);
        ComparerViaBuilderTest<short>(-30000, 3);
        ComparerViaBuilderTest<ushort>(3, 50000);
        ComparerViaBuilderTest<int>(-10000000, 10000);
        ComparerViaBuilderTest<uint>(10000000, 3000000000);
        ComparerViaBuilderTest<long>(-1000000000000, 10000000);
        ComparerViaBuilderTest<ulong>(10000000000000UL, 10000000000004UL);
        ComparerViaBuilderTest<float>(-0.001F, 0.00001F);
        ComparerViaBuilderTest<double>(-0.001, 0.00001E-200);
        ComparerViaBuilderTest<decimal>(-20.001M, 19.999M);
      }

      // This test is obsoleted by the one above, but we keep it for good measure
      [Test]
      public void IntComparerViaBuilder()
      {
        SCG.IComparer<int> h = Comparer<int>.Default;
        int s = 4;
        int t = 4;
        int u = 5;

        Assert.AreEqual(0, h.Compare(s, t));
        Assert.IsTrue(h.Compare(s, u) < 0);
        Assert.AreSame(h, Comparer<int>.Default);
      }

      [Test]
      public void Nulls()
      {
        Assert.IsTrue(Comparer<string>.Default.Compare(null, "abe") < 0);
        Assert.IsTrue(Comparer<string>.Default.Compare(null, null) == 0);
        Assert.IsTrue(Comparer<string>.Default.Compare("abe", null) > 0);
      }
    }

    [TestFixture]
    public class EqualityComparers
    {
      [Test]
      public void ReftypeequalityComparer()
      {
        SCG.IEqualityComparer<string> h = NaturalEqualityComparer<string>.Default;
        string s = "bamse";
        string t = "bamse";
        string u = "bimse";

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
      }


      [Test]
      public void ValuetypeequalityComparer()
      {
        SCG.IEqualityComparer<double> h = NaturalEqualityComparer<double>.Default;
        double s = 3.4;
        double t = 3.4;
        double u = 5.7;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
      }

      internal class REHTest { public override int GetHashCode() { return 37; } }

      [Test]
      public void ReferenceEqualityEqualityComparerTest()
      {
        REHTest rehtest = new REHTest();
        SCG.IEqualityComparer<REHTest> equalityComparer = ReferenceEqualityComparer<REHTest>.Default;
        Assert.AreEqual(37, rehtest.GetHashCode());
        Assert.IsFalse(equalityComparer.GetHashCode(rehtest) == 37);
      }

      [Test]
      public void ReftypeequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<string> h = EqualityComparer<string>.Default;
        string s = "bamse";
        string t = "bamse";
        string u = "bimse";

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<string>.Default);
      }


      [Test]
      public void ValuetypeequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<double> h = EqualityComparer<double>.Default;
        double s = 3.4;
        double t = 3.4;
        double u = 5.7;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<double>.Default);
      }

      [Test]
      public void CharequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<char> h = EqualityComparer<char>.Default;
        char s = 'Â';
        char t = 'Â';
        char u = 'r';

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<char>.Default);
      }

      [Test]
      public void SbyteequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<sbyte> h = EqualityComparer<sbyte>.Default;
        sbyte s = 3;
        sbyte t = 3;
        sbyte u = -5;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<sbyte>.Default);
      }

      [Test]
      public void ByteequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<byte> h = EqualityComparer<byte>.Default;
        byte s = 3;
        byte t = 3;
        byte u = 5;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<byte>.Default);
      }

      [Test]
      public void ShortequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<short> h = EqualityComparer<short>.Default;
        short s = 3;
        short t = 3;
        short u = -5;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<short>.Default);
      }

      [Test]
      public void UshortequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<ushort> h = EqualityComparer<ushort>.Default;
        ushort s = 3;
        ushort t = 3;
        ushort u = 60000;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<ushort>.Default);
      }

      [Test]
      public void IntequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<int> h = EqualityComparer<int>.Default;
        int s = 3;
        int t = 3;
        int u = -5;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<int>.Default);
      }

      [Test]
      public void UintequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<uint> h = EqualityComparer<uint>.Default;
        uint s = 3;
        uint t = 3;
        uint u = 3000000000;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<uint>.Default);
      }

      [Test]
      public void LongequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<long> h = EqualityComparer<long>.Default;
        long s = 3;
        long t = 3;
        long u = -500000000000000L;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<long>.Default);
      }

      [Test]
      public void UlongequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<ulong> h = EqualityComparer<ulong>.Default;
        ulong s = 3;
        ulong t = 3;
        ulong u = 500000000000000UL;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<ulong>.Default);
      }

      [Test]
      public void FloatequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<float> h = EqualityComparer<float>.Default;
        float s = 3.1F;
        float t = 3.1F;
        float u = -5.2F;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<float>.Default);
      }

      [Test]
      public void DoubleequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<double> h = EqualityComparer<double>.Default;
        double s = 3.12345;
        double t = 3.12345;
        double u = -5.2;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<double>.Default);
      }

      [Test]
      public void DecimalequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<decimal> h = EqualityComparer<decimal>.Default;
        decimal s = 3.0001M;
        decimal t = 3.0001M;
        decimal u = -500000000000000M;

        Assert.AreEqual(s.GetHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<decimal>.Default);
      }

      [Test]
      public void UnseqequalityComparerViaBuilder()
      {
        SCG.IEqualityComparer<ICollection<int>> h = EqualityComparer<ICollection<int>>.Default;
        ICollection<int> s = new LinkedList<int>();
        ICollection<int> t = new LinkedList<int>();
        ICollection<int> u = new LinkedList<int>();
        s.Add(1); s.Add(2); s.Add(3);
        t.Add(3); t.Add(2); t.Add(1);
        u.Add(3); u.Add(2); u.Add(4);
        Assert.AreEqual(s.GetUnsequencedHashCode(), h.GetHashCode(s));
        Assert.IsTrue(h.Equals(s, t));
        Assert.IsFalse(h.Equals(s, u));
        Assert.AreSame(h, EqualityComparer<ICollection<int>>.Default);
      }

      [Test]
      public void SeqequalityComparerViaBuilder2()
      {
        SCG.IEqualityComparer<LinkedList<int>> h = EqualityComparer<LinkedList<int>>.Default;
        LinkedList<int> s = new LinkedList<int>();
        s.Add(1); s.Add(2); s.Add(3);
        Assert.AreEqual(CHC.sequencedhashcode(1, 2, 3), h.GetHashCode(s));
      }

      [Test]
      public void UnseqequalityComparerViaBuilder2()
      {
        SCG.IEqualityComparer<HashSet<int>> h = EqualityComparer<HashSet<int>>.Default;
        HashSet<int> s = new HashSet<int>();
        s.Add(1); s.Add(2); s.Add(3);
        Assert.AreEqual(CHC.unsequencedhashcode(1, 2, 3), h.GetHashCode(s));
      }

      //generic types implementing collection interfaces
      [Test]
      public void SeqequalityComparerViaBuilder3()
      {
        SCG.IEqualityComparer<IList<int>> h = EqualityComparer<IList<int>>.Default;
        IList<int> s = new LinkedList<int>();
        s.Add(1); s.Add(2); s.Add(3);
        Assert.AreEqual(CHC.sequencedhashcode(1, 2, 3), h.GetHashCode(s));
      }

      interface IFoo<T> : ICollection<T> { void Bamse();      }

      class Foo<T> : HashSet<T>, IFoo<T>
      {
        internal Foo() : base() { }
        public void Bamse() { }
      }

      [Test]
      public void UnseqequalityComparerViaBuilder3()
      {
        SCG.IEqualityComparer<IFoo<int>> h = EqualityComparer<IFoo<int>>.Default;
        IFoo<int> s = new Foo<int>();
        s.Add(1); s.Add(2); s.Add(3);
        Assert.AreEqual(CHC.unsequencedhashcode(1, 2, 3), h.GetHashCode(s));
      }

      //Nongeneric types implementing collection types:
      interface IBaz : ISequenced<int> { void Bamse(); }

      class Baz : LinkedList<int>, IBaz
      {
        internal Baz() : base() { }
        public void Bamse() { }
        //int ISequenced<int>.GetHashCode() { return sequencedhashcode(); }
        //bool ISequenced<int>.Equals(ISequenced<int> that) { return sequencedequals(that); }
      }

      [Test]
      public void SeqequalityComparerViaBuilder4()
      {
        SCG.IEqualityComparer<IBaz> h = EqualityComparer<IBaz>.Default;
        IBaz s = new Baz();
        s.Add(1); s.Add(2); s.Add(3);
        Assert.AreEqual(CHC.sequencedhashcode(1, 2, 3), h.GetHashCode(s));
      }

      interface IBar : ICollection<int>
      {
        void Bamse();
      }

      class Bar : HashSet<int>, IBar
      {
        internal Bar() : base() { }
        public void Bamse() { }

        //TODO: remove all this workaround stuff:
 
        bool ICollection<int>.ContainsAll<U>(System.Collections.Generic.IEnumerable<U> items) 
        {
          throw new NotImplementedException();
        }
 
        void ICollection<int>.RemoveAll<U>(System.Collections.Generic.IEnumerable<U> items) 
        {
          throw new NotImplementedException();
        }

        void ICollection<int>.RetainAll<U>(System.Collections.Generic.IEnumerable<U> items) 
        {
          throw new NotImplementedException();
        }

        void IExtensible<int>.AddAll<U>(System.Collections.Generic.IEnumerable<U> items) 
       