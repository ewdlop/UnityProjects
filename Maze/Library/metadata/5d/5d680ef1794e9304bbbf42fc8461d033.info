ST [TYPTYPE]
    internal byte[] mList;      // really a mlMethod type
  };

  //  type record for LF_BITFIELD

  internal struct LeafBitfield {
    // internal ushort leaf;      // LF_BITFIELD [TYPTYPE]
    internal uint type;       // (type index) type of bitfield
    internal byte length;
    internal byte position;
  };

  //  type record for dimensioned array with constant bounds

  internal struct LeafDimCon {
    // internal ushort leaf;      // LF_DIMCONU or LF_DIMCONLU [TYPTYPE]
    internal uint typ;        // (type index) type of index
    internal ushort rank;       // number of dimensions
    internal byte[] dim;        // array of dimension information with
    // either upper bounds or lower/upper bound
  };

  //  type record for dimensioned array with variable bounds

  internal struct LeafDimVar {
    // internal ushort leaf;      // LF_DIMVARU or LF_DIMVARLU [TYPTYPE]
    internal uint rank;       // number of dimensions
    internal uint typ;        // (type index) type of index
    internal uint[] dim;        // (type index) array of type indices for either
    // variable upper bound or variable
    // lower/upper bound.  The count of type
    // indices is rank or rank*2 depending on
    // whether it is LFDIMVARU or LF_DIMVARLU.
    // The referenced types must be
    // LF_REFSYM or T_VOID
  };

  //  type record for referenced symbol

  internal struct LeafRefSym {
    // internal ushort leaf;      // LF_REFSYM [TYPTYPE]
    internal byte[] Sym;        // copy of referenced symbol record
    // (including length)
  };

  //  the following are numeric leaves.  They are used to indicate the
  //  size of the following variable length data.  When the numeric
  //  data is a single byte less than 0x8000, then the data is output
  //  directly.  If the data is more the 0x8000 or is a negative value,
  //  then the data is preceeded by the proper index.
  //

  //  signed character leaf

  internal struct LeafChar {
    // internal ushort leaf;      // LF_CHAR [TYPTYPE]
    internal sbyte val;        // signed 8-bit value
  };

  //  signed short leaf

  internal struct LeafShort {
    // internal ushort leaf;      // LF_SHORT [TYPTYPE]
    internal short val;        // signed 16-bit value
  };

  //  ushort leaf

  internal struct LeafUShort {
    // internal ushort leaf;      // LF_ushort [TYPTYPE]
    internal ushort val;        // unsigned 16-bit value
  };

  //  signed (32-bit) long leaf

  internal struct LeafLong {
    // internal ushort leaf;      // LF_LONG [TYPTYPE]
    internal int val;        // signed 32-bit value
  };

  //  uint    leaf

  internal struct LeafULong {
    // internal ushort leaf;      // LF_ULONG [TYPTYPE]
    internal uint val;        // unsigned 32-bit value
  };

  //  signed quad leaf

  internal struct LeafQuad {
    // internal ushort leaf;      // LF_QUAD [TYPTYPE]
    internal long val;        // signed 64-bit value
  };

  //  unsigned quad leaf

  internal struct LeafUQuad {
    // internal ushort leaf;      // LF_UQUAD [TYPTYPE]
    internal ulong val;        // unsigned 64-bit value
  };

  //  signed int128 leaf

  internal struct LeafOct {
    // internal ushort leaf;      // LF_OCT [TYPTYPE]
    internal ulong val0;
    internal ulong val1;       // signed 128-bit value
  };

  //  unsigned int128 leaf

  internal struct LeafUOct {
    // internal ushort leaf;      // LF_UOCT [TYPTYPE]
    internal ulong val0;
    internal ulong val1;       // unsigned 128-bit value
  };

  //  real 32-bit leaf

  internal struct LeafReal32 {
    // internal ushort leaf;      // LF_REAL32 [TYPTYPE]
    internal float val;        // 32-bit real value
  };

  //  real 64-bit leaf

  internal struct LeafReal64 {
    // internal ushort leaf;      // LF_REAL64 [TYPTYPE]
    internal double val;        // 64-bit real value
  };

  //  real 80-bit leaf

  internal struct LeafReal80 {
    // internal ushort leaf;      // LF_REAL80 [TYPTYPE]
    internal FLOAT10 val;        // real 80-bit value
  };

  //  real 128-bit leaf

  internal struct LeafReal128 {
    // internal ushort leaf;      // LF_REAL128 [TYPTYPE]
    internal ulong val0;
    internal ulong val1;       // real 128-bit value
  };

  //  complex 32-bit leaf

  internal struct LeafCmplx32 {
    // internal ushort leaf;      // LF_COMPLEX32 [TYPTYPE]
    internal float val_real;   // real component
    internal float val_imag;   // imaginary component
  };

  //  complex 64-bit leaf

  internal struct LeafCmplx64 {
    // internal ushort leaf;      // LF_COMPLEX64 [TYPTYPE]
    internal double val_real;   // real component
    internal double val_imag;   // imaginary component
  };

  //  complex 80-bit leaf

  internal struct LeafCmplx80 {
    // internal ushort leaf;      // LF_COMPLEX80 [TYPTYPE]
    internal FLOAT10 val_real;   // real component
    internal FLOAT10 val_imag;   // imaginary component
  };

  //  complex 128-bit leaf

  internal struct LeafCmplx128 {
    // internal ushort leaf;      // LF_COMPLEX128 [TYPTYPE]
    internal ulong val0_real;
    internal ulong val1_real;  // real component
    internal ulong val0_imag;
    internal ulong val1_imag;  // imaginary component
  };

  //  variable length numeric field

  internal struct LeafVarString {
    // internal ushort leaf;      // LF_VARSTRING [TYPTYPE]
    internal ushort len;        // length of value in bytes
    internal byte[] value;      // value
  };

  //  index leaf - contains type index of another leaf
  //  a major use of this leaf is to allow the compilers to emit a
  //  long complex list (LF_FIELD) in smaller pieces.

  internal struct LeafIndex {
    // internal ushort leaf;      // LF_INDEX [TYPTYPE]
    internal ushort pad0;       // internal padding, must be 0
    internal uint index;      // (type index) type index of referenced leaf
  };

  //  subfield record for base class field

  internal struct LeafBClass {
    // internal ushort leaf;      // LF_BCLASS [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) attribute
    internal uint index;      // (type index) type index of base class
    internal byte[] offset;     // variable length offset of base within class
  };

  //  subfield record for direct and indirect virtual base class field

  internal struct LeafVBClass {
    // internal ushort leaf;      // LF_VBCLASS | LV_IVBCLASS [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) attribute
    internal uint index;      // (type index) type index of direct virtual base class
    internal uint vbptr;      // (type index) type index of virtual base pointer
    internal byte[] vbpoff;     // virtual base pointer offset from address point
    // followed by virtual base offset from vbtable
  };

  //  subfield record for friend class

  internal struct LeafFriendCls {
    // internal ushort leaf;      // LF_FRIENDCLS [TYPTYPE]
    internal ushort pad0;       // internal padding, must be 0
    internal uint index;      // (type index) index to type record of friend class
  };

  //  subfield record for friend function

  internal struct LeafFriendFcn {
    // internal ushort leaf;      // LF_FRIENDFCN [TYPTYPE]
    internal ushort pad0;       // internal padding, must be 0
    internal uint index;      // (type index) index to type record of friend function
    internal string name;       // name of friend function
  };

  //  subfield record for non-static data members

  internal struct LeafMember {
    // internal ushort leaf;      // LF_MEMBER [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t)attribute mask
    internal uint index;      // (type index) index of type record for field
    internal byte[] offset;     // variable length offset of field
    internal string name;       // length prefixed name of field
  };

  //  type record for static data members

  internal struct LeafSTMember {
    // internal ushort leaf;      // LF_STMEMBER [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) attribute mask
    internal uint index;      // (type index) index of type record for field
    internal string name;       // length prefixed name of field
  };

  //  subfield record for virtual function table pointer

  internal struct LeafVFuncTab {
    // internal ushort leaf;      // LF_VFUNCTAB [TYPTYPE]
    internal ushort pad0;       // internal padding, must be 0
    internal uint type;       // (type index) type index of pointer
  };

  //  subfield record for virtual function table pointer with offset

  internal struct LeafVFuncOff {
    // internal ushort leaf;      // LF_VFUNCOFF [TYPTYPE]
    internal ushort pad0;       // internal padding, must be 0.
    internal uint type;       // (type index) type index of pointer
    internal int offset;     // offset of virtual function table pointer
  };

  //  subfield record for overloaded method list

  internal struct LeafMethod {
    // internal ushort leaf;      // LF_METHOD [TYPTYPE]
    internal ushort count;      // number of occurrences of function
    internal uint mList;      // (type index) index to LF_METHODLIST record
    internal string name;       // length prefixed name of method
  };

  //  subfield record for nonoverloaded method

  internal struct LeafOneMethod {
    // internal ushort leaf;      // LF_ONEMETHOD [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) method attribute
    internal uint index;      // (type index) index to type record for procedure
    internal uint[] vbaseoff;   // offset in vfunctable if intro virtual
    internal string name;
  };

  //  subfield record for enumerate

  internal struct LeafEnumerate {
    // internal ushort leaf;      // LF_ENUMERATE [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) access
    internal byte[] value;      // variable length value field
    internal string name;
  };

  //  type record for nested (scoped) type definition

  internal struct LeafNestType {
    // internal ushort leaf;      // LF_NESTTYPE [TYPTYPE]
    internal ushort pad0;       // internal padding, must be 0
    internal uint index;      // (type index) index of nested type definition
    internal string name;       // length prefixed type name
  };

  //  type record for nested (scoped) type definition, with attributes
  //  new records for vC v5.0, no need to have 16-bit ti versions.

  internal struct LeafNestTypeEx {
    // internal ushort leaf;      // LF_NESTTYPEEX [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) member access
    internal uint index;      // (type index) index of nested type definition
    internal string name;       // length prefixed type name
  };

  //  type record for modifications to members

  internal struct LeafMemberModify {
    // internal ushort leaf;      // LF_MEMBERMODIFY [TYPTYPE]
    internal ushort attr;       // (CV_fldattr_t) the new attributes
    internal uint index;      // (type index) index of base class type definition
    internal string name;       // length prefixed member name
  };

  //  type record for pad leaf

  internal struct LeafPad {
    internal byte leaf;
  };

  //  Symbol definitions

  internal enum SYM {
    S_END=0x0006,  // Block, procedure, "with" or thunk end
    S_OEM=0x0404,  // OEM defined symbol

    S_REGISTER_ST=0x1001,  // Register variable
    S_CONSTANT_ST=0x1002,  // constant symbol
    S_UDT_ST=0x1003,  // User defined type
    S_COBOLUDT_ST=0x1004,  // special UDT for cobol that does not symbol pack
    S_MANYREG_ST=0x1005,  // multiple register variable
    S_BPREL32_ST=0x1006,  // BP-relative
    S_LDATA32_ST=0x1007,  // Module-local symbol
    S_GDATA32_ST=0x1008,  // Global data symbol
    S_PUB32_ST=0x1009,  // a internal symbol (CV internal reserved)
    S_LPROC32_ST=0x100a,  // Local procedure start
    S_GPROC32_ST=0x100b,  // Global procedure start
    S_VFTABLE32=0x100c,  // address of virtual function table
    S_REGREL32_ST=0x100d,  // register relative address
    S_LTHREAD32_ST=0x100e,  // local thread storage
    S_GTHREAD32_ST=0x100f,  // global thread storage

    S_LPROCMIPS_ST=0x1010,  // Local procedure start
    S_GPROCMIPS_ST=0x1011,  // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC=0x1012,  // extra frame and proc information
    S_COMPILE2_ST=0x1013,  // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2_ST=0x1014,  // multiple register variable
    S_LPROCIA64_ST=0x1015,  // Local procedure start (IA64)
    S_GPROCIA64_ST=0x1016,  // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT_ST=0x1017,  // local IL sym with field for local slot index
    S_PARAMSLOT_ST=0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION=0x1019,  // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC_ST=0x101a,  // Global proc
    S_LMANPROC_ST=0x101b,  // Local proc
    S_RESERVED1=0x101c,  // reserved
    S_RESERVED2=0x101d,  // reserved
    S_RESERVED3=0x101e,  // reserved
    S_RESERVED4=0x101f,  // reserved
    S_LMANDATA_ST=0x1020,
    S_GMANDATA_ST=0x1021,
    S_MANFRAMEREL_ST=0x1022,
    S_MANREGISTER_ST=0x1023,
    S_MANSLOT_ST=0x1024,
    S_MANMANYREG_ST=0x1025,
    S_MANREGREL_ST=0x1026,
    S_MANMANYREG2_ST=0x1027,
    S_MANTYPREF=0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE_ST=0x1029,  // Using namespace

    // Symbols w/ SZ name fields. All name fields contain utf8 encoded strings.
    S_ST_MAX=0x1100,  // starting point for SZ name symbols

    S_OBJNAME=0x1101,  // path to object file name
    S_THUNK32=0x1102,  // Thunk Start
    S_BLOCK32=0x1103,  // block start
    S_WITH32=0x1104,  // with start
    S_LABEL32=0x1105,  // code label
    S_REGISTER=0x1106,  // Register variable
    S_CONSTANT=0x1107,  // constant symbol
    S_UDT=0x1108,  // User defined type
    S_COBOLUDT=0x1109,  // special UDT for cobol that does not symbol pack
    S_MANYREG=0x110a,  // multiple register variable
    S_BPREL32=0x110b,  // BP-relative
    S_LDATA32=0x110c,  // Module-local symbol
    S_GDATA32=0x110d,  // Global data symbol
    S_PUB32=0x110e,  // a internal symbol (CV internal reserved)
    S_LPROC32=0x110f,  // Local procedure start
    S_GPROC32=0x1110,  // Global procedure start
    S_REGREL32=0x1111,  // register relative address
    S_LTHREAD32=0x1112,  // local thread storage
    S_GTHREAD32=0x1113,  // global thread storage

    S_LPROCMIPS=0x1114,  // Local procedure start
    S_GPROCMIPS=0x1115,  // Global procedure start
    S_COMPILE2=0x1116,  // extended compile flags and info
    S_MANYREG2=0x1117,  // multiple register variable
    S_LPROCIA64=0x1118,  // Local procedure start (IA64)
    S_GPROCIA64=0x1119,  // Global procedure start (IA64)
    S_LOCALSLOT=0x111a,  // local IL sym with field for local slot index
    S_SLOT=S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT=0x111b,  // local IL sym with field for parameter slot index

    // symbols to support managed code debugging
    S_LMANDATA=0x111c,
    S_GMANDATA=0x111d,
    S_MANFRAMEREL=0x111e,
    S_MANREGISTER=0x111f,
    S_MANSLOT=0x1120,
    S_MANMANYREG=0x1121,
    S_MANREGREL=0x1122,
    S_MANMANYREG2=0x1123,
    S_UNAMESPACE=0x1124,  // Using namespace

    // ref symbols with name fields
    S_PROCREF=0x1125,  // Reference to a procedure
    S_DATAREF=0x1126,  // Reference to data
    S_LPROCREF=0x1127,  // Local Reference to a procedure
    S_ANNOTATIONREF=0x1128,  // Reference to an S_ANNOTATION symbol
    S_TOKENREF=0x1129,  // Reference to one of the many MANPROCSYM's

    // continuation of managed symbols
    S_GMANPROC=0x112a,  // Global proc
    S_LMANPROC=0x112b,  // Local proc

    // short, light-weight thunks
    S_TRAMPOLINE=0x112c,  // trampoline thunks
    S_MANCONSTANT=0x112d,  // constants with metadata type info

    // native attributed local/parms
    S_ATTR_FRAMEREL=0x112e,  // relative to virtual frame ptr
    S_ATTR_REGISTER=0x112f,  // stored in a register
    S_ATTR_REGREL=0x1130,  // relative to register (alternate frame ptr)
    S_ATTR_MANYREG=0x1131,  // stored in >1 register

    // Separated code (from the compiler) support
    S_SEPCODE=0x1132,

    S_LOCAL=0x1133,  // defines a local symbol in optimized code
    S_DEFRANGE=0x1134,  // defines a single range of addresses in which symbol can be evaluated
    S_DEFRANGE2=0x1135,  // defines ranges of addresses in which symbol can be evaluated

    S_SECTION=0x1136,  // A COFF section in a PE executable
    S_COFFGROUP=0x1137,  // A COFF group
    S_EXPORT=0x1138,  // A export

    S_CALLSITEINFO=0x1139,  // Indirect call site information
    S_FRAMECOOKIE=0x113a,  // Security cookie information

    S_DISCARDED=0x113b,  // Discarded by LINK /OPT:REF (experimental, see richards)

    S_RECTYPE_MAX,              // one greater than last
    S_RECTYPE_LAST=S_RECTYPE_MAX - 1,

  };

  //  enum describing compile flag ambient data model

  internal enum CV_CFL_DATA {
    CV_CFL_DNEAR=0x00,
    CV_CFL_DFAR=0x01,
    CV_CFL_DHUGE=0x02
  };

  //  enum describing compile flag ambiant code model

  internal enum CV_CFL_CODE {
    CV_CFL_CNEAR=0x00,
    CV_CFL_CFAR=0x01,
    CV_CFL_CHUGE=0x02
  };

  //  enum describing compile flag target floating point package

  internal enum CV_CFL_FPKG {
    CV_CFL_NDP=0x00,
    CV_CFL_EMU=0x01,
    CV_CFL_ALT=0x02
  };

  // enum describing function return method

  [Flags]
  internal enum CV_PROCFLAGS : byte {
    CV_PFLAG_NOFPO=0x01, // frame pointer present
    CV_PFLAG_INT=0x02, // interrupt return
    CV_PFLAG_FAR=0x04, // far return
    CV_PFLAG_NEVER=0x08, // function does not return
    CV_PFLAG_NOTREACHED=0x10, // label isn't fallen into
    CV_PFLAG_CUST_CALL=0x20, // custom calling convention
    CV_PFLAG_NOINLINE=0x40, // function marked as noinline
    CV_PFLAG_OPTDBGINFO=0x80, // function has debug information for optimized code
  };

  // Extended proc flags
  //
  internal struct CV_EXPROCFLAGS {
    internal byte flags;      // (CV_PROCFLAGS)
    internal byte reserved;   // must be zero
  };

  // local variable flags
  [Flags]
  internal enum CV_LVARFLAGS : ushort {
    fIsParam=0x0001,   // variable is a parameter
    fAddrTaken=0x0002,   // address is taken
    fCompGenx=0x0004,   // variable is compiler generated
    fIsAggregate=0x0008,   // the symbol is splitted in temporaries,
    // which are treated by compiler as
    // independent entities
    fIsAggregated=0x0010,   // Counterpart of fIsAggregate - tells
    // that it is a part of a fIsAggregate symbol
    fIsAliased=0x0020,   // variable has multiple simultaneous lifetimes
    fIsAlias=0x0040,   // represents one of the multiple simultaneous lifetimes
  };

  // represents an address range, used for optimized code debug info
  internal struct CV_lvar_addr_range {       // defines a range of addresses
    internal uint offStart;
    internal ushort isectStart;
    internal uint cbRange;
  };

  // enum describing function data return method

  internal enum CV_GENERIC_STYLE {
    CV_GENERIC_VOID=0x00,   // void return type
    CV_GENERIC_REG=0x01,   // return data is in registers
    CV_GENERIC_ICAN=0x02,   // indirect caller allocated near
    CV_GENERIC_ICAF=0x03,   // indirect caller allocated far
    CV_GENERIC_IRAN=0x04,   // indirect returnee allocated near
    CV_GENERIC_IRAF=0x05,   // indirect returnee allocated far
    CV_GENERIC_UNUSED=0x06    // first unused
  };

  [Flags]
  internal enum CV_GENERIC_FLAG : ushort {
    cstyle=0x0001,       // true push varargs right to left
    rsclean=0x0002,       // true if returnee stack cleanup
  };

  // flag bitfields for separated code attributes

  [Flags]
  internal enum CV_SEPCODEFLAGS : uint {
    fIsLexicalScope=0x00000001,   // S_SEPCODE doubles as lexical scope
    fReturnsToParent=0x00000002,   // code frag returns to parent
  };

  // Generic layout for symbol records

  internal struct SYMTYPE {
    internal ushort reclen;     // Record length
    internal ushort rectyp;     // Record type
    // byte        data[CV_ZEROLEN];
    //  SYMTYPE *NextSym (SYMTYPE * pSym) {
    //  return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(ushort));
    //  }
  };

  //  non-model specific symbol types

  internal struct RegSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_REGISTER
    internal uint typind;     // (type index) Type index or Metadata token
    internal ushort reg;        // register enumerate
    internal string name;       // Length-prefixed name
  };

  internal struct AttrRegSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANREGISTER | S_ATTR_REGISTER
    internal uint typind;     // (type index) Type index or Metadata token
    internal uint offCod;     // first code address where var is live
    internal ushort segCod;
    internal ushort flags;      // (CV_LVARFLAGS)local var flags
    internal ushort reg;        // register enumerate
    internal string name;       // Length-prefixed name
  };

  internal struct ManyRegSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANYREG
    internal uint typind;     // (type index) Type index or metadata token
    internal byte count;      // count of number of registers
    internal byte[] reg;        // count register enumerates, most-sig first
    internal string name;       // length-prefixed name.
  };

  internal struct ManyRegSym2 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANYREG2
    internal uint typind;     // (type index) Type index or metadata token
    internal ushort count;      // count of number of registers,
    internal ushort[] reg;        // count register enumerates, most-sig first
    internal string name;       // length-prefixed name.
  };

  internal struct AttrManyRegSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANMANYREG
    internal uint typind;     // (type index) Type index or metadata token
    internal uint offCod;     // first code address where var is live
    internal ushort segCod;
    internal ushort flags;      // (CV_LVARFLAGS)local var flags
    internal byte count;      // count of number of registers
    internal byte[] reg;        // count register enumerates, most-sig first
    internal string name;       // utf-8 encoded zero terminate name
  };

  internal struct AttrManyRegSym2 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANMANYREG2 | S_ATTR_MANYREG
    internal uint typind;     // (type index) Type index or metadata token
    internal uint offCod;     // first code address where var is live
    internal ushort segCod;
    internal ushort flags;      // (CV_LVARFLAGS)local var flags
    internal ushort count;      // count of number of registers
    internal ushort[] reg;        // count register enumerates, most-sig first
    internal string name;       // utf-8 encoded zero terminate name
  };

  internal struct ConstSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_CONSTANT or S_MANCONSTANT
    internal uint typind;     // (type index) Type index (containing enum if enumerate) or metadata token
    internal ushort value;      // numeric leaf containing value
    internal string name;       // Length-prefixed name
  };

  internal struct UdtSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_UDT | S_COBOLUDT
    internal uint typind;     // (type index) Type index
    internal string name;       // Length-prefixed name
  };

  internal struct ManyTypRef {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANTYPREF
    internal uint typind;     // (type index) Type index
  };

  internal struct SearchSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_SSEARCH
    internal uint startsym;   // offset of the procedure
    internal ushort seg;        // segment of symbol
  };

  [Flags]
  internal enum CFLAGSYM_FLAGS : ushort {
    pcode=0x0001,   // true if pcode present
    floatprec=0x0006,   // floating precision
    floatpkg=0x0018,   // float package
    ambdata=0x00e0,   // ambient data model
    ambcode=0x0700,   // ambient code model
    mode32=0x0800,   // true if compiled 32 bit mode
  };

  internal struct CFlagSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_COMPILE
    internal byte machine;    // target processor
    internal byte language;   // language index
    internal ushort flags;      // (CFLAGSYM_FLAGS)
    internal string ver;        // Length-prefixed compiler version string
  };

  [Flags]
  internal enum COMPILESYM_FLAGS : uint {
    iLanguage=0x000000ff,   // language index
    fEC=0x00000100,   // compiled for E/C
    fNoDbgInfo=0x00000200,   // not compiled with debug info
    fLTCG=0x00000400,   // compiled with LTCG
    fNoDataAlign=0x00000800,   // compiled with -Bzalign
    fManagedPresent=0x00001000,   // managed code/data present
    fSecurityChecks=0x00002000,   // compiled with /GS
    fHotPatch=0x00004000,   // compiled with /hotpatch
    fCVTCIL=0x00008000,   // converted with CVTCIL
    fMSILModule=0x00010000,   // MSIL netmodule
  };

  internal struct CompileSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_COMPILE2
    internal uint flags;      // (COMPILESYM_FLAGS)
    internal ushort machine;    // target processor
    internal ushort verFEMajor; // front end major version #
    internal ushort verFEMinor; // front end minor version #
    internal ushort verFEBuild; // front end build version #
    internal ushort verMajor;   // back end major version #
    internal ushort verMinor;   // back end minor version #
    internal ushort verBuild;   // back end build version #
    internal string verSt;      // Length-prefixed compiler version string, followed
    internal string[] verArgs;    // block of zero terminated strings, ended by double-zero.
  };

  internal struct ObjNameSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_OBJNAME
    internal uint signature;  // signature
    internal string name;       // Length-prefixed name
  };

  internal struct EndArgSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_ENDARG
  };

  internal struct ReturnSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_RETURN
    internal CV_GENERIC_FLAG flags; // flags
    internal byte style;      // CV_GENERIC_STYLE return style
    // followed by return method data
  };

  internal struct EntryThisSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_ENTRYTHIS
    internal byte thissym;    // symbol describing this pointer on entry
  };

  internal struct BpRelSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_BPREL32
    internal int off;        // BP-relative offset
    internal uint typind;     // (type index) Type index or Metadata token
    internal string name;       // Length-prefixed name
  };

  internal struct FrameRelSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANFRAMEREL | S_ATTR_FRAMEREL
    internal int off;        // Frame relative offset
    internal uint typind;     // (type index) Type index or Metadata token
    internal uint offCod;     // first code address where var is live
    internal ushort segCod;
    internal ushort flags;      // (CV_LVARFLAGS)local var flags
    internal string name;       // Length-prefixed name
  };

  internal struct SlotSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_LOCALSLOT or S_PARAMSLOT
    internal uint index;      // slot index
    internal uint typind;     // (type index) Type index or Metadata token
    internal string name;       // Length-prefixed name
  };

  internal struct AttrSlotSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANSLOT
    internal uint index;      // slot index
    internal uint typind;     // (type index) Type index or Metadata token
    internal uint offCod;     // first code address where var is live
    internal ushort segCod;
    internal ushort flags;      // (CV_LVARFLAGS)local var flags
    internal string name;       // Length-prefixed name

  };

  internal struct AnnotationSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_ANNOTATION
    internal uint off;
    internal ushort seg;
    internal ushort csz;        // Count of zero terminated annotation strings
    internal string[] rgsz;       // Sequence of zero terminated annotation strings
  };

  internal struct DatasSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_LDATA32, S_GDATA32 or S_PUB32, S_LMANDATA, S_GMANDATA
    internal uint typind;     // (type index) Type index, or Metadata token if a managed symbol
    internal uint off;
    internal ushort seg;
    internal string name;       // Length-prefixed name
  };

  [Flags]
  internal enum CV_PUBSYMFLAGS : uint {
    fNone=0,
    fCode=0x00000001,     // set if internal symbol refers to a code address
    fFunction=0x00000002,     // set if internal symbol is a function
    fManaged=0x00000004,     // set if managed code (native or IL)
    fMSIL=0x00000008,     // set if managed IL code
  };

  internal struct PubSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_PUB32
    internal uint flags;      // (CV_PUBSYMFLAGS)
    internal uint off;
    internal ushort seg;
    internal string name;       // Length-prefixed name
  };

  internal struct ProcSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_GPROC32 or S_LPROC32
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint next;       // pointer to next symbol
    internal uint len;        // Proc length
    internal uint dbgStart;   // Debug start offset
    internal uint dbgEnd;     // Debug end offset
    internal uint typind;     // (type index) Type index
    internal uint off;
    internal ushort seg;
    internal byte flags;      // (CV_PROCFLAGS) Proc flags
    internal string name;       // Length-prefixed name
  };

  internal struct ManProcSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_GMANPROC, S_LMANPROC, S_GMANPROCIA64 or S_LMANPROCIA64
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint next;       // pointer to next symbol
    internal uint len;        // Proc length
    internal uint dbgStart;   // Debug start offset
    internal uint dbgEnd;     // Debug end offset
    internal uint token;      // COM+ metadata token for method
    internal uint off;
    internal ushort seg;
    internal byte flags;      // (CV_PROCFLAGS) Proc flags
    internal ushort retReg;     // Register return value is in (may not be used for all archs)
    internal string name;       // optional name field
  };

  internal struct ManProcSymMips {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_GMANPROCMIPS or S_LMANPROCMIPS
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint next;       // pointer to next symbol
    internal uint len;        // Proc length
    internal uint dbgStart;   // Debug start offset
    internal uint dbgEnd;     // Debug end offset
    internal uint regSave;    // int register save mask
    internal uint fpSave;     // fp register save mask
    internal uint intOff;     // int register save offset
    internal uint fpOff;      // fp register save offset
    internal uint token;      // COM+ token type
    internal uint off;
    internal ushort seg;
    internal byte retReg;     // Register return value is in
    internal byte frameReg;   // Frame pointer register
    internal string name;       // optional name field
  };

  internal struct ThunkSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_THUNK32
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint next;       // pointer to next symbol
    internal uint off;
    internal ushort seg;
    internal ushort len;        // length of thunk
    internal byte ord;        // THUNK_ORDINAL specifying type of thunk
    internal string name;       // Length-prefixed name
    internal byte[] variant;    // variant portion of thunk
  };

  internal enum TRAMP {             // Trampoline subtype
    trampIncremental,           // incremental thunks
    trampBranchIsland,          // Branch island thunks
  };

  internal struct TrampolineSym {   // Trampoline thunk symbol
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_TRAMPOLINE
    internal ushort trampType;  // trampoline sym subtype
    internal ushort cbThunk;    // size of the thunk
    internal uint offThunk;   // offset of the thunk
    internal uint offTarget;  // offset of the target of the thunk
    internal ushort sectThunk;  // section index of the thunk
    internal ushort sectTarget; // section index of the target of the thunk
  };

  internal struct LabelSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_LABEL32
    internal uint off;
    internal ushort seg;
    internal byte flags;      // (CV_PROCFLAGS) flags
    internal string name;       // Length-prefixed name
  };

  internal struct BlockSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_BLOCK32
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint len;        // Block length
    internal uint off;        // Offset in code segment
    internal ushort seg;        // segment of label
    internal string name;       // Length-prefixed name
  };

  internal struct WithSym32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_WITH32
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint len;        // Block length
    internal uint off;        // Offset in code segment
    internal ushort seg;        // segment of label
    internal string expr;       // Length-prefixed expression string
  };

  internal struct VpathSym32 {
    // internal ushort reclen;    // record length
    // internal ushort rectyp;    // S_VFTABLE32
    internal uint root;       // (type index) type index of the root of path
    internal uint path;       // (type index) type index of the path record
    internal uint off;        // offset of virtual function table
    internal ushort seg;        // segment of virtual function table
  };

  internal struct RegRel32 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_REGREL32
    internal uint off;        // offset of symbol
    internal uint typind;     // (type index) Type index or metadata token
    internal ushort reg;        // register index for symbol
    internal string name;       // Length-prefixed name
  };

  internal struct AttrRegRel {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_MANREGREL | S_ATTR_REGREL
    internal uint off;        // offset of symbol
    internal uint typind;     // (type index) Type index or metadata token
    internal ushort reg;        // register index for symbol
    internal uint offCod;     // first code address where var is live
    internal ushort segCod;
    internal ushort flags;      // (CV_LVARFLAGS)local var flags
    internal string name;       // Length-prefixed name
  };

  internal struct ThreadSym32 {
    // internal ushort reclen;    // record length
    // internal ushort rectyp;    // S_LTHREAD32 | S_GTHREAD32
    internal uint typind;     // (type index) type index
    internal uint off;        // offset into thread storage
    internal ushort seg;        // segment of thread storage
    internal string name;       // length prefixed name
  };

  internal struct Slink32 {
    // internal ushort reclen;    // record length
    // internal ushort rectyp;    // S_SLINK32
    internal uint framesize;  // frame size of parent procedure
    internal int off;        // signed offset where the static link was saved relative to the value of reg
    internal ushort reg;
  };

  internal struct ProcSymMips {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_GPROCMIPS or S_LPROCMIPS
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint next;       // pointer to next symbol
    internal uint len;        // Proc length
    internal uint dbgStart;   // Debug start offset
    internal uint dbgEnd;     // Debug end offset
    internal uint regSave;    // int register save mask
    internal uint fpSave;     // fp register save mask
    internal uint intOff;     // int register save offset
    internal uint fpOff;      // fp register save offset
    internal uint typind;     // (type index) Type index
    internal uint off;        // Symbol offset
    internal ushort seg;        // Symbol segment
    internal byte retReg;     // Register return value is in
    internal byte frameReg;   // Frame pointer register
    internal string name;       // Length-prefixed name
  };

  internal struct ProcSymIa64 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_GPROCIA64 or S_LPROCIA64
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this blocks end
    internal uint next;       // pointer to next symbol
    internal uint len;        // Proc length
    internal uint dbgStart;   // Debug start offset
    internal uint dbgEnd;     // Debug end offset
    internal uint typind;     // (type index) Type index
    internal uint off;        // Symbol offset
    internal ushort seg;        // Symbol segment
    internal ushort retReg;     // Register return value is in
    internal byte flags;      // (CV_PROCFLAGS) Proc flags
    internal string name;       // Length-prefixed name
  };

  internal struct RefSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_PROCREF_ST, S_DATAREF_ST, or S_LPROCREF_ST
    internal uint sumName;    // SUC of the name
    internal uint ibSym;      // Offset of actual symbol in $$Symbols
    internal ushort imod;       // Module containing the actual symbol
    internal ushort usFill;     // align this record
  };

  internal struct RefSym2 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_PROCREF, S_DATAREF, or S_LPROCREF
    internal uint sumName;    // SUC of the name
    internal uint ibSym;      // Offset of actual symbol in $$Symbols
    internal ushort imod;       // Module containing the actual symbol
    internal string name;       // hidden name made a first class member
  };

  internal struct AlignSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_ALIGN
  };

  internal struct OemSymbol {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_OEM
    internal Guid idOem;      // an oem ID (GUID)
    internal uint typind;     // (type index) Type index
    internal byte[] rgl;        // user data, force 4-byte alignment
  };

  [Flags]
  internal enum FRAMEPROCSYM_FLAGS : uint {
    fHasAlloca=0x00000001,   // function uses _alloca()
    fHasSetJmp=0x00000002,   // function uses setjmp()
    fHasLongJmp=0x00000004,   // function uses longjmp()
    fHasInlAsm=0x00000008,   // function uses inline asm
    fHasEH=0x00000010,   // function has EH states
    fInlSpec=0x00000020,   // function was speced as inline
    fHasSEH=0x00000040,   // function has SEH
    fNaked=0x00000080,   // function is __declspec(naked)
    fSecurityChecks=0x00000100,   // function has buffer security check introduced by /GS.
    fAsyncEH=0x00000200,   // function compiled with /EHa
    fGSNoStackOrdering=0x00000400,   // function has /GS buffer checks, but stack ordering couldn't be done
    fWasInlined=0x00000800,   // function was inlined within another function
  };

  internal struct FrameProcSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_FRAMEPROC
    internal uint cbFrame;    // count of bytes of total frame of procedure
    internal uint cbPad;      // count of bytes of padding in the frame
    internal uint offPad;     // offset (rel to frame) to where padding starts
    internal uint cbSaveRegs; // count of bytes of callee save registers
    internal uint offExHdlr;  // offset of exception handler
    internal ushort secExHdlr;  // section id of exception handler
    internal uint flags;      // (FRAMEPROCSYM_FLAGS)
  }

  internal struct UnamespaceSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_UNAMESPACE
    internal string name;       // name
  };

  internal struct SepCodSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_SEPCODE
    internal uint parent;     // pointer to the parent
    internal uint end;        // pointer to this block's end
    internal uint length;     // count of bytes of this block
    internal uint scf;        // (CV_SEPCODEFLAGS) flags
    internal uint off;        // sec:off of the separated code
    internal uint offParent;  // secParent:offParent of the enclosing scope
    internal ushort sec;        //  (proc, block, or sepcode)
    internal ushort secParent;
  };

  internal struct LocalSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_LOCAL
    internal uint id;         // id of the local
    internal uint typind;     // (type index) type index
    internal ushort flags;      // (CV_LVARFLAGS) local var flags
    internal uint idParent;   // This is is parent variable - fIsAggregated or fIsAlias
    internal uint offParent;  // Offset in parent variable - fIsAggregated

    internal uint expr;       // NI of expression that this temp holds
    internal uint pad0;       // pad, must be zero
    internal uint pad1;       // pad, must be zero

    internal string name;       // Name of this symbol.
  }

  internal struct DefRangeSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_DEFRANGE

    internal uint id;         // ID of the local symbol for which this formula holds
    internal uint program;    // program to evaluate the value of the symbol

    internal CV_lvar_addr_range range;   // Range of addresses where this program is valid
  };

  internal struct DefRangeSym2 {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_DEFRANGE2

    internal uint id;         // ID of the local symbol for which this formula holds
    internal uint program;    // program to evaluate the value of the symbol

    internal ushort count;      // count of CV_lvar_addr_range records following
    internal CV_lvar_addr_range[] range;// Range of addresses where this program is valid
  };

  internal struct SectionSym {
    // internal ushort reclen     // Record length
    // internal ushort rectyp;    // S_SECTION

    internal ushort isec;       // Section number
    internal byte align;      // Alignment of this section (power of 2)
    internal byte bReserved;  // Reserved.  Must be zero.
    internal uint rva;
    internal uint cb;
    internal uint characteristics;
    internal string name;       // name
  };

  internal struct CoffGroupSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_COFFGROUP

    internal uint cb;
    internal uint characteristics;
    internal uint off;        // Symbol offset
    internal ushort seg;        // Symbol segment
    internal string name;       // name
  };

  [Flags]
  internal enum EXPORTSYM_FLAGS : ushort {
    fConstant=0x0001,   // CONSTANT
    fData=0x0002,   // DATA
    fPrivate=0x0004,   // PRIVATE
    fNoName=0x0008,   // NONAME
    fOrdinal=0x0010,   // Ordinal was explicitly assigned
    fForwarder=0x0020,   // This is a forwarder
  }

  internal struct ExportSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_EXPORT

    internal ushort ordinal;
    internal ushort flags;      // (EXPORTSYM_FLAGS)
    internal string name;       // name of
  };

  //
  // Symbol for describing indirect calls when they are using
  // a function pointer cast on some other type or temporary.
  // Typical content will be an LF_POINTER to an LF_PROCEDURE
  // type record that should mimic an actual variable with the
  // function pointer type in question.
  //
  // Since the compiler can sometimes tail-merge a function call
  // through a function pointer, there may be more than one
  // S_CALLSITEINFO record at an address.  This is similar to what
  // you could do in your own code by:
  //
  //  if (expr)
  //  pfn = &function1;
  //  else
  //  pfn = &function2;
  //
  //  (*pfn)(arg list);
  //

  internal struct CallsiteInfo {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_CALLSITEINFO
    internal int off;        // offset of call site
    internal ushort ect;        // section index of call site
    internal ushort pad0;       // alignment padding field, must be zero
    internal uint typind;     // (type index) type index describing function signature
  };

  // Frame cookie information

  internal enum CV_cookietype {
    CV_COOKIETYPE_COPY=0,
    CV_COOKIETYPE_XOR_SP,
    CV_COOKIETYPE_XOR_BP,
    CV_COOKIETYPE_XOR_R13,
  };

  // Symbol for describing security cookie's position and type
  // (raw, xor'd with esp, xor'd with ebp).

  internal struct FrameCookie {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_FRAMECOOKIE
    internal int off;        // Frame relative offset
    internal ushort reg;        // Register index
    internal int cookietype; // (CV_cookietype) Type of the cookie
    internal byte flags;      // Flags describing this cookie
  };

  internal enum CV_DISCARDED : uint {
    CV_DISCARDED_UNKNOWN=0,
    CV_DISCARDED_NOT_SELECTED=1,
    CV_DISCARDED_NOT_REFERENCED=2,
  };

  internal struct DiscardedSym {
    // internal ushort reclen;    // Record length [SYMTYPE]
    // internal ushort rectyp;    // S_DISCARDED
    internal CV_DISCARDED iscarded;
    internal uint fileid;     // First FILEID if line number info present
    internal uint linenum;    // First line number
    internal byte[] data;       // Original record(s) with invalid indices
  };

  //
  // V7 line number data types
  //

  internal enum DEBUG_S_SUBSECTION_TYPE : uint {
    DEBUG_S_IGNORE=0x80000000,   // if this bit is set in a subsection type then ignore the subsection contents

    DEBUG_S_SYMBOLS=0xf1,
    DEBUG_S_LINES=0xf2,
    DEBUG_S_STRINGTABLE=0xf3,
    DEBUG_S_FILECHKSMS=0xf4,
    DEBUG_S_FRAMEDATA=0xf5,
  };

  //
  // Line flags (data present)
  //
  internal enum CV_LINE_SUBSECTION_FLAGS : ushort {
    CV_LINES_HAVE_COLUMNS=0x0001,
  }

  internal struct CV_LineSection {
    internal uint off;
    internal ushort sec;
    internal ushort flags;
    internal uint cod;
  }

  internal struct CV_SourceFile {
    internal uint index;          // Index to file in checksum section.
    internal uint count;          // Number of CV_Line records.
    internal uint linsiz;         // Size of CV_Line recods.
  }

  [Flags]
  internal enum CV_Line_Flags : uint {
    linenumStart=0x00ffffff,   // line where statement/expression starts
    deltaLineEnd=0x7f000000,   // delta to line where statement ends (optional)
    fStatement=0x80000000,   // true if a statement linenumber, else an expression line num
  };

  internal struct CV_Line {
    internal uint offset;         // Offset to start of code bytes for line number
    internal uint flags;          // (CV_Line_Flags)
  };

  internal struct CV_Column {
    internal ushort offColumnStart;
    internal ushort offColumnEnd;
  };

  //  File information

  internal enum CV_FILE_CHECKSUM_TYPE : byte {
    None=0,
    MD5=1,
  };

  internal struct CV_FileCheckSum {
    internal uint name;           // Index of name in name table.
    internal byte len;            // Hash length
    internal byte type;           // Hash type
  }

  [Flags]
  internal enum FRAMEDATA_FLAGS : uint {
    fHasSEH=0x00000001,
    fHasEH=0x00000002,
    fIsFunctionStart=0x00000004,
  };

  internal struct FrameData {
    internal uint ulRvaStart;
    internal uint cbBlock;
    internal uint cbLocals;
    internal uint cbParams;
    internal uint cbStkMax;
    internal uint frameFunc;
    internal ushort cbProlog;
    internal ushort cbSavedRegs;
    internal uint flags;          // (FRAMEDATA_FLAGS)
  };

  internal struct XFixupData {
    internal ushort wType;
    internal ushort wExtra;
    internal uint rva;
    internal uint rvaTarget;
  };

  internal enum DEBUG_S_SUBSECTION {
    SYMBOLS=0xF1,
    LINES=0xF2,
    STRINGTABLE=0xF3,
    FILECHKSMS=0xF4,
    FRAMEDATA=0xF5,
  }
}                                                                                                                                                                                                                                                   HD$h1HHl$Ld$H1HH'|   HH\$@ULLeLHHLd$ HLxHH|$   t/H|$   LE1q3u6IE DLLHLx DHLAH@]E}AL/]HH<$tMt
/H<$t>HL$hdH3%(   Du<Hx[]A\A]A^A_@       iX@       Qf.     HG0f.     HU> SHH0HHG\H[f.     SHHP   [)w     AUAATAUHSH_0HHdH%(   HD$1!2t%HL$dH3%(      u)H[]A\A]D  HHHD,$Dd$ f.     H0RfD  AWAVAUIATUHSH_0HH8dH%(   HD$(1 2  H1ZH2  H2  $    1HuHD$(dH3%(     H8[]A\A]A^A_@ H =   M  IHR %     H  1  2        		$2LE11H   LH@HHQ> P4$0    H 1HJ81   HA%1J)1PNG

   IHDR   (   (   m   gAMA  a   	pHYs    (J   tEXtSoftware Paint.NET v3.5.11GB7  (IDATXGyPwVm]C/VvZXWlG2
qACs:\cC#.2!r!x>$4	$|}CwkTLpEQv\MBT>zw%<xevzG$T(xxr*B^`AAa@R5~Hd@r>
tvv +&&&i~tf2>_P35+FT*5#\Ay!qb*T~z2.Y-\#"5\J506QVB6v.eUmT
)j~vRu]t}7E)a\Rh3GJ'O##
xP8vNB}
D*h1^5t`T*\?`	Y=aHG75SPBmj:&[\V M>S
CtN(;s}}w7j!d?7tr}!a-P x7~[p6S {@L>$\//r=mcPh*>8^uvQCyw000HdX1MvTAA6ehI\SNaHItb+f78FI2::D69z_:tR:%5 O8Q'@{	?,6ldLJ`eof?mwZ#lI}"fQ.,qbyP'J="L7pU(_"A-CG$U7.'k{.pLt!_^&KrFd>"HI(Cz] .9YHNN|z{{.RhlC50P&t9|53k@}X
AOI#s b|19H+BH+'`z|#|w-ZX#AA&iEbTYw#i1bH"ET&lffBHRR:!"" :&|Xx!llJ $d,pOO<@|FkA` v<4.O:\0B1D]S?iV	MnpvD!\\B]<+Y n +LrjL3
`e:F\V,	[+OW?a|=
qu>yu1zLj[He "p>@8~*&olP-Xs`vuXtylrNf,>p4& |4``:Y\Xl<vNyyGU.gKaI=hZ0b6-e
ne.	+wd&?}1~-ND#}L&}&=ge.>Rj knjK+.S:,YAm=)#+`1Xcps[T$	_zV EV6;3!p. +4fdb[eWF;:]N+JGknnK4"q u;?%;}1[knnKk_KVO_k}]nnKVd8oMEQp{ sI| ^yO6Iq12k3XeZ"?>fY)2cJd"}km"K[&W?lp!3c>v /lkdY!?ym31yfZ    IENDB`                                                                                                                                                                                                                                                                                                                                                    I8sK7	hF@5T 2N 9(m} TOgwI]irt$	][gSlt*-iW~ct-)by%P[O_5e[B