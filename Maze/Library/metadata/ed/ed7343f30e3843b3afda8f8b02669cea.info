/*
 * Copyright (c) 2008-2017, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */


#include "ApexDefs.h"
#if APEX_CUDA_SUPPORT

#include "Apex.h"
#include "ApexSDKIntl.h"
#include "SceneIntl.h"
#include "ApexCutil.h"
#include "CudaModuleScene.h"
#include <cuda.h>
#include <texture_types.h>

#include "PxTaskManager.h"
#include "PxGpuDispatcher.h"
#include "PxCudaContextManager.h"

#define CUDA_KERNEL_CHECK_ALWAYS 0

namespace nvidia
{
class PhysXGpuIndicator;

namespace apex
{

/**
 * Workaround hacks for using nvcc --compiler output object files
 * without linking with CUDART.  We must implement our own versions
 * of these functions that the object files are hard-coded to call into.
 */

#define MAX_MODULES					64
static void* moduleTable[ MAX_MODULES ];
static int numRegisteredModules = 0;

#define MAX_FUNCTIONS				256
typedef struct
{
	int         modIndex;
	const char* funcName;
} cuFuncDesc;
static cuFuncDesc functionTable[ MAX_FUNCTIONS ];
static int numRegisteredFunctions = 0;

const char* funcNameTable[ MAX_FUNCTIONS ];


#define MAX_TEXTURES				256
typedef struct
{
	int                             modIndex;
	const char*                     texRefName;
	const struct textureReference*  texRefData;
	int                             dim;
	int                             read_normalized_float;
} cuTexRefDesc;
static cuTexRefDesc textureTable[ MAX_TEXTURES ];
static int numRegisteredTextures = 0;


#define MAX_SURFACES				256
typedef struct
{
	int                             modIndex;
	const char*                     surfRefName;
	const struct surfaceReference*  surfRefData;
	int                             dim;
} cuSurfRefDesc;
static cuSurfRefDesc surfaceTable[ MAX_SURFACES ];
static int numRegisteredSurfaces = 0;


#define MAX_VARIABLES				256
typedef struct
{
	int			modIndex;
	const char* varName;
	int			size;
} cuVarDesc;
static cuVarDesc variableTable[ MAX_VARIABLES ];
static int numRegisteredVariables = 0;

CudaModuleScene::CudaModuleScene(SceneIntl& scene, Module& module, const char* modulePrefix)
	: mSceneIntl(scene)
{
	PX_UNUSED(modulePrefix);

	PxTaskManager* tm = scene.getTaskManager();
	PxGpuDispatcher* gd = tm->getGpuDispatcher();
	PX_ASSERT(gd != NULL);
	PxScopedCudaLock _lock_(*gd->getCudaContextManager());

	ApexCudaObjManager::init(&module, &scene.getApexCudaTestManager(), gd);

	mCudaModules.resize((uint32_t)numRegisteredModules);

	ApexSDKIntl* apexSdk = GetInternalApexSDK();
	mPhysXGpuIndicator = apexSdk->registerPhysXIndicatorGpuClient();
}

void CudaModuleScene::destroy(SceneIntl&)
{
	{
		PxScopedCudaLock _lock_(*getGpuDispatcher()->getCudaContextManager());

		ApexCudaObjManager::releaseAll();

		for (uint32_t i = 0 ; i < mCudaModules.size() ; i++)
		{
			mCudaModules[i].release();
		}
	}

	ApexSDKIntl* apexSdk = GetInternalApexSDK();
	apexSdk->unregisterPhysXIndicatorGpuClient(mPhysXGpuIndicator);
	mPhysXGpuIndicator = NULL;
}

void CudaModuleScene::onBeforeLaunchApexCudaFunc(const ApexCudaFunc& func, CUstream stream)
{
	if (mCudaProfileSession)
	{
		mCudaProfileSession->onFuncStart(func.getProfileId(), stream);
	}
}

void CudaModuleScene::onAfterLaunchApexCudaFunc(const ApexCudaFunc& func, CUstream stream)
{
	if (mCudaProfileSession)
	{
		mCudaProfileSession->onFuncFinish(func.getProfileId(), stream);
	}

#if !CUDA_KERNEL_CHECK_ALWAYS
	if (mSceneIntl.getCudaKernelCheckEnabled())
#endif
	{
		CUresult ret = cuStreamSynchronize(stream);
		if ( CUDA_SUCCESS != ret )
		{
			APEX_INTERNAL_ERROR("Cuda Error %d after launch of func '%s'", ret, func.getName());
			PX_ALWAYS_ASSERT();
		}
	}
}

ApexCudaModule* CudaModuleScene::getCudaModule(int modIndex)
{
	mCudaModules[(uint32_t)modIndex].init(moduleTable[(uint32_t)modIndex]);
	return &mCudaModules[(uint32_t)modIndex];
}

void CudaModuleScene::initCudaObj(ApexCudaTexRef& texRef)
{
	const char* texRefName = texRef.getName();

	for (int j = 0 ; j < numRegisteredTextures ; j++)
	{
		if (nvidia::strcmp(textureTable[j].texRefName, texRefName) == 0)
		{
			ApexCudaModule* cudaModule = getCudaModule(textureTable[j].modIndex);
			PX_ASSERT(cudaModule->isValid());

			CUtexref cuTexRef;
			CUT_SAFE_CALL(cuModuleGetTexRef(&cuTexRef, cudaModule->getCuModule(), texRefName));

			const struct textureReference* texRefData = textureTable[j].texRefData;

			PX_ASSERT(texRefData->channelDesc.x > 0);
			int numChannels = 1;
			if (texRefData->channelDesc.y > 0)
			{
				PX_ASSERT(texRefData->channelDesc.y == texRefData->channelDesc.x);
				++numChannels;
			}
			if (texRefData->channelDesc.z > 0)
			{
				PX_ASSERT(texRefData->channelDesc.z == texRefData->channelDesc.x);
				++numChannels;
			}
			if (texRefData->channelDesc.w > 0)
			{
				PX_ASSERT(texRefData->channelDesc.w == texRefData->channelDesc.x);
				++numChannels;
			}

			CUarray_format cuFormat = CUarray_format(0);
			switch (texRefData->channelDesc.f)
			{
			case cudaChannelFormatKindSigned:
				switch (texRefData->channelDesc.x)
				{
				case  8:
					cuFormat = CU_AD_FORMAT_SIGNED_INT8;
					break;
				case 16:
					cuFormat = CU_AD_FORMAT_SIGNED_INT16;
					break;
				case 32:
					cuFormat = CU_AD_FORMAT_SIGNED_INT32;
					break;
				}
				break;
			case cudaChannelFormatKindUnsigned:
				switch (texRefData->channelDesc.x)
				{
				case  8:
					cuFormat = CU_AD_FORMAT_UNSIGNED_INT8;
					break;
				case 16:
					cuFormat = CU_AD_FORMAT_UNSIGNED_INT16;
					break;
				case 32:
					cuFormat = CU_AD_FORMAT_UNSIGNED_INT32;
					break;
				}
				break;
			case cudaChannelFormatKindFloat:
				cuFormat = CU_AD_FORMAT_FLOAT;
				break;
			default:
				PX_ASSERT(0);
			};
			PX_ASSERT(cuFormat != 0);

			int cuFlags = 0;
			if (textureTable[j].read_normalized_float == 0)
			{
				cuFlags |= CU_TRSF_READ_AS_INTEGER;
			}
			if (textureTable[j].texRefData->normalized != 0)
			{
				cuFlags |= CU_TRSF_NORMALIZED_COORDINATES;
			}

			texRef.init(this, cuTexRef, cudaModule, cuFormat, numChannels, textureTable[j].dim, cuFlags);
			break;
		}
	}
}

void CudaModuleScene::initCudaObj(ApexCudaVar& var)
{
	const char* varName = var.getName();

	for (int j = 0 ; j < numRegisteredVariables ; j++)
	{
		if (nvidia::strcmp(variableTable[j].varName, varName) == 0)
		{
			ApexCudaModule* cudaModule = getCudaModule(variableTable[j].modIndex);
			PX_ASSERT(cudaModule->isValid());

			CUdeviceptr cuDevPtr;
			size_t size;
			cuModuleGetGlobal(&cuDevPtr, &size, cudaModule->getCuModule(), varName);

			var.init(this, cudaModule, cuDevPtr, size, getGpuDispatcher()->getCudaContextManager());
			break;
		}
	}
}

void CudaModuleScene::initCudaObj(ApexCudaFunc& func)
{
	for (int j = 0 ; j < numRegisteredFunctions ; j++)
	{
		const char* funcName = functionTable[j].funcName;
		if (func.testNameMatch(funcName))
		{
			ApexCudaModule* cudaModule = getCudaModule(functionTable[j].modIndex);
			PX_ASSERT(cudaModule->isValid());

			CUfunction cuFunc = 0;
			CUT_SAFE_CALL(cuModuleGetFunction(&cuFunc, cudaModule->getCuModule(), funcName));

			func.init(this, funcName, cuFunc, cudaModule);
		}
	}
}

void CudaModuleScene::initCudaObj(ApexCudaSurfRef& surfRef)
{
	if (getGpuDispatcher()->getCudaContextManager()->supportsArchSM20() == false)
	{
		return;
	}

	const char* surfRefName = surfRef.getName();

	for (int j = 0 ; j < numRegisteredSurfaces ; j++)
	{
		if (nvidia::strcmp(surfaceTable[j].surfRefName, surfRefName) == 0)
		{
			ApexCudaModule* cudaModule = getCudaModule(surfaceTable[j].modIndex);
			PX_ASSERT(cudaModule->isValid());

			CUsurfref cuSurfRef;
			CUT_SAFE_CALL(cuModuleGetSurfRef(&cuSurfRef, cudaModule->getCuModule(), surfRefName));

			surfRef.init(this, cuSurfRef, cudaModule);
			break;
		}
	}

}

/*
 * These calls are all made _before_ main() during static initialization
 * of your APEX module.  So calling into APEX Framework or other
 * external code modules is out of the question.
 */

#include "driver_types.h"

#define CUDARTAPI __stdcall

typedef struct uint3_t
{
	unsigned int x, y, z;
} uint3;

typedef struct dim3_t
{
	unsigned int x, y, z;
} dim3;

extern "C"
void** CUDARTAPI __cudaRegisterFatBinary(void* fatBin)
{
	//HACK to get real fatbin in CUDA 4.0
	struct CUIfatbinStruct
	{
		int magic;
		int version;
		void* fatbinArray;
		char* fatbinFile;
	};
	const CUIfatbinStruct* fatbinStruct = (const CUIfatbinStruct*)fatBin;
	if (fatbinStruct->magic == 0x466243B1)
	{
		fatBin = fatbinStruct->fatbinArray;
	}

	if (numRegisteredModules < MAX_MODULES)
	{
		moduleTable[ numRegisteredModules ] = fatBin;
		return (void**)(size_t) numRegisteredModules++;
	}
	return NULL;
}

extern "C"
void CUDARTAPI __cudaUnregisterFatBinary(void** fatCubinHandle)
{
	moduleTable[(int)(size_t) fatCubinHandle ] = 0;
}

extern "C"
void CUDARTAPI __cudaRegisterTexture(
    void**                    fatCubinHandle,
    const struct textureReference*  hostvar,
    const void**                    deviceAddress,
    const char*                     deviceName,
    int                       dim,
    int                       read_normalized_float,
    int                       ext)
{
	PX_UNUSED(fatCubinHandle);
	PX_UNUSED(hostvar);
	PX_UNUSED(deviceAddress);
	PX_UNUSED(deviceName);
	PX_UNUSED(dim);
	PX_UNUSED(read_normalized_float);
	PX_UNUSED(ext);

	if (numRegisteredTextures < MAX_TEXTURES)
	{
		//Fix for CUDA 5.5 - remove leading "::"
		while (*deviceName == ':')
		{
			++deviceName;
		}

		// We need this association of function to module in order to find textures and globals
		textureTable[ numRegisteredTextures ].modIndex = (int)(size_t) fatCubinHandle;
		textureTable[ numRegisteredTextures ].texRefName = deviceName;
		textureTable[ numRegisteredTextures ].texRefData = hostvar;
		textureTable[ numRegisteredTextures ].dim = dim;
		textureTable[ numRegisteredTextures ].read_normalized_float = read_normalized_float;
		numRegisteredTextures++;
	}
}

extern "C"
void CUDARTAPI __cudaRegisterSurface(
    void**                          fatCubinHandle,
    const struct surfaceReference*        hostvar,
    const void**                          deviceAddress,
    const char*                           deviceName,
    int                             dim,
    int                             ext)
{
	PX_UNUSED(fatCubinHandle);
	PX_UNUSED(hostvar);
	PX_UNUSED(deviceAddress);
	PX_UNUSED(deviceName);
	PX_UNUSED(dim);
	PX_UNUSED(ext);

	if (numRegisteredSurfaces < MAX_SURFACES)
	{
		//Fix for CUDA 5.5 - remove leading "::"
		while (*deviceName == ':')
		{
			++deviceName;
		}

		surfaceTable[ numRegisteredSurfaces ].modIndex = (int)(size_t) fatCubinHandle;
		surfaceTable[ numRegisteredSurfaces ].surfRefName = deviceName;
		surfaceTable[ numRegisteredSurfaces ].surfRefData = hostvar;
		surfaceTable[ numRegisteredSurfaces ].dim = dim;
		numRegisteredSurfaces++;
	}
}

extern "C" void CUDARTAPI __cudaRegisterVar(
    void**                    fatCubinHandle,
    char*                    hostVar,
    char*                    deviceAddress,
    const char*                    deviceName,
    int                      ext,
    int                      size,
    int                      constant,
    int                      global)
{
	PX_UNUSED(fatCubinHandle);
	PX_UNUSED(hostVar);
	PX_UNUSED(deviceAddress);
	PX_UNUSED(deviceName);
	PX_UNUSED(ext);
	PX_UNUSED(size);
	PX_UNUSED(constant);
	PX_UNUSED(global);

	if (constant != 0 && numRegisteredVariables < MAX_VARIABLES)
	{
		variableTable[ numRegisteredVariables ].modIndex = (int)(size_t) fatCubinHandle;
		variableTable[ numRegisteredVariables ].varName = deviceName;
		variableTable[ numRegisteredVariables ].size = size;
		numRegisteredVariables++;
	}
}


extern "C" void CUDARTAPI __cudaRegisterShared(
    void**                    fatCubinHandle,
    void**                    devicePtr
)
{
	PX_UNUSED(fatCubinHandle);
	PX_UNUSED(devicePtr);
}



extern "C"
void CUDARTAPI __cudaRegisterFunction(
    void**  fatCubinHandle,
    const char*   hostFun,
    char*   deviceFun,
    const char*   deviceName,
    int     thread_limit,
    uint3*  tid,
    uint3*  bid,
    dim3*   bDim,
    dim3*   gDim,
    int*    wSize)
{
	PX_UNUSED(hostFun);
	PX_UNUSED(deviceFun);
	PX_UNUSED(thread_limit);
	PX_UNUSED(tid);
	PX_UNUSED(bid);
	PX_UNUSED(bDim);
	PX_UNUSED(gDim);
	PX_UNUSED(wSize);

	if (numRegisteredFunctions < MAX_FUNCTIONS)
	{
		// We need this association of function to module in order to find textures and globals
		functionTable[ numRegisteredFunctions ].modIndex = (int)(size_t) fatCubinHandle;
		functionTable[ numRegisteredFunctions ].funcName = deviceName;
		funcNameTable[ numRegisteredFunctions ] = deviceName;
		numRegisteredFunctions++;
	}
}

/* These functions are implemented just to resolve link dependencies */

extern "C"
cudaError_t CUDARTAPI cudaLaunch(const char* entry)
{
	PX_UNUSED(entry);
	return cudaSuccess;
}

extern "C"
cudaError_t CUDARTAPI cudaSetupArgument(
    const void*   arg,
    size_t  size,
    size_t  offset)
{
	PX_UNUSED(arg);
	PX_UNUSED(size);
	PX_UNUSED(offset);
	return cudaSuccess;
}

extern "C"
struct cudaChannelFormatDesc CUDARTAPI cudaCreateChannelDesc(
    int x, int y, int z, int w, enum cudaChannelFormatKind f)
{
	struct cudaChannelFormatDesc desc;
	desc.x = x;
	desc.y = y;
	desc.z = z;
	desc.w = w;
	desc.f = f;
	return desc;
}

}
} // namespace nvidia

#endif
                                                                                                                                                                                             ¼â»·ÕøôµÙ3™b4cEÆrÏ{RºèLw>´¢;×¡&‰‰ˆÜÚêÖ@'â_kcxkîºò·‹Ø#1tBÄô"%kf9hGá~r¨^¦×::q3PÌèB¸\%ııÜñ½Z”ƒ÷/Æµ~’ü¾óƒıƒ{E†=eö‹FîÁSScl‰lGXœœÆ\Õı…PùÓÎH÷&ÙmMÔÖë¶Æ¢è¬fb>(Í›Pè)‹²s®)¼×œo­€£Ão¤3¶?±-(ıéĞìCédÚX"Sü,<‘2„+ã!a´C¼SïXÌÄ÷4——XĞuàõz…Å[ø’nãò7õrÆ§À1ŒE?z}IÏŸ“á6ˆ/bÄÇÓ §½Š²;Š°³‹¶íwüípHĞ#jƒº¢ò3á§7°oá£wn?›´óÍ7q£Z¾’•dŒ?q04{°ì¬²Ââ³å$Å½N‹É)!›•*Q~Ô´™¾÷Mò¨òÜ	ú6‰#d–ÖÚc(Ä‹ôköÍ½\Oúgc*UŸËK²3ò
Üf0u‘…Š¢ÅP¯#s§ok4È_ªÂÃ‰õo\ÉÃÀìú/Éÿÿ[)q%×}§+|Ñõóen±Ä…d60d²Ì2œ33¦ÊÆ™'€A°‹K°8YŒ§³{ñ•Z³1+î/ë­…WwCVñiã¯bFèíÑ^ó¸ÕÑ/EìÜ.7)æ3JŸt"ŞŞÖ›è“®†òAzâsÿÕ$ß½±(qügZ…¦í¾v-M§ˆì\ Y’.µ¨ˆ·ï ‘êÂÙ82ö¾
ñ¡7<"5¨t6hTšŒ¡]P'vyõŠ>°7ñÎœ	Ó¶^Á§SÛ‹9ãµè¯HDM&òSd¹{ÙÛfìóM½ƒ	u°0À®RƒÍÿ¼cd#2oJqiÁã¼c*ì†â+÷àİ÷î¾4:Ä€xâÄ&Œú¬ü¬NaÈğ¤Ê›ø‚×ŒQTj­ß‚ƒ8\™7Pç}ûéÙÜ#Íş]¨¤ùIx€_MŞÏ“[¬x‘‚oßò9 Ønæ)¥‘™éq*½Ã »o¼C÷NÔéèr™^0¥¯lé\3Í©“Äs^ğ›½ùQ•cvl»Ög¸´U"ÁX®2Ã^¿
 ‚.÷e2ÔŸš¿l,M(Ë<kâ%ìJË%Á¡_QŠ]ªï¤>KŸ¼'z½&,Ğ7hæğòÑöoq^	ænJ5Ø~,“w6èĞ:Í?Ÿiã¶º7ù'm“Á¯šTvL‘›YÜ	Ãè(§ÿlgÏ:âs¤{bİ¿ÙRÆ(\%ŒD«‡"g	‰W†—kƒUjn¹ò–š¶ÚËMGóˆ§$uˆM}ÂJÙoIƒÛñÌŠ<”˜”m‘>5P5÷4”ÁcúÍ:Ê0¾•Û%sòİ)Íxóúìg|Šá2^=¬6bíÂ»Êôüé¯®¡Q‰-U†rOqE‘ßJ‰ê;BıâAQäjPúŠÙEÊ1¬uc¬×Ü–¤fëÅ'Üƒs‚oõ'²ÇÂ¦«}~)—|™Ññ)jŞ`Š¤ƒ7É³š2e®Ó.ø?ÄU>ƒ¼®ŞC}´VwJ‡/~…£x ¿,Ò8{}÷p¶×¶ÜÓYö–ô‚{A—eéçM„³U;7é£•=Ü0ÉŠfL½“~j#²]-š32ßkAæc$$¾Ç]Ì¿;4?ßö-İ™LoÀ~N·ÿŠ²¼¢U=:Ÿ@y’/OrD—üg¤é‹ƒÓÒ»´—|Š§Qwóî¢àæ<æW)H€Ë§íKWb£_`b~Íé)fø+¥ö½r¥‚|´¨|şz<!hr-4ÈXR„Ïn- TÍ* nÏçp{í7Wjôõ“dzŒ˜MÕ+XÎšºël»º£Öüö¾Ó_4))¨NÃÎd:Ê•ºÛ³@ñ™åªÆ! „ŸZÑ±Ìrx2FeËïSûwÉrq·†k,AĞbÃßÃÄ;4ui‡–lÆsöRA‰´lcyøG‚¸@™´ÕäÑÀ~#;µzËµÃ€
6yÃó¶ø2dÃ†Î£a<6„ÿ¯üÊ„“¥|#üíWí™Q¶œ
1Æ1qÏ_Kä—/[uf‡ÂÄ5Ë¢%ä‰Á9ÉŞ{ùEâ¾æçï’KbÔSğG* —3†c²ò¥õ¼½#¨ÎGPï.ÍcLû—ÓJÁqËsL³9D„®N©Ú
ıSoÃÕZhûÈ^…Kn¬îñœà°ms¢W¨<V ç<A€¯ÚYEìó¡‘ıB”ÆÔÌ(´”ºïMR|AzŸË"S<ÈÛüÉO.ä³ÃZ0H0"yˆ0Ë€¦Âıö¾âK£Ö98«¹v‡§ÍêÆœ;qºÁ‚şÍìšNDh}­­ÈËe aõŞ÷ØMASÅÎPM¼4ı¥UzçXì2y/¯tüIhlğÒ1Û½è.[N8ä½YóàXDŠ¥º
‡’øÙ)§áGQyƒÏ‹|ƒ[„¥bRj^ş{ÌÙ_{Ê~Ä”Ÿ«sƒ¬£1º#[öÖËD¶k.?ˆŞ·ÊŸ:Œ„‡šK2\([:®æÕÜ«qb®‰ÛóÎêÅş_fuZC‰Pš-›CÉ†iÖŠ®ñ¡k<svg id="Regular" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><defs><style>.cls-1{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px}</style></defs><title>dog-mouth-protection-1</title><path class="cls-1" d="M15.487 7.9A9.247 9.247 0 0 0 7.5 3.5 9.346 9.346 0 0 0 .75 6.369"/><path class="cls-1" d="M7.5 3.5V11A1.5 1.5 0 0 1 6 12.5H3.75a1.5 1.5 0 0 1-1.5-1.5V9.5m13.237-1.6l-4.4 9.1 8.313 1.37c2.686 0 3.607-3.134 3.844-6.246.08-1.044-.726-1.678-1.711-2.1zM11.085 17a18.974 18.974 0 0 0-7.422 2.051L.75 20.62m22.104-5.919L13.262 12.5m6.386-3.135l-2.99 8.553m-5.783-9.804a.375.375 0 0 0-.375.375m.75 0a.375.375 0 0 0-.375-.375m0 .75a.375.375 0 0 0 .375-.375m-.75 0a.375.375 0 0 0 .375.375"/></svg>                                                                                                                                                                                                                                                                     c/9Ê+20h;M>‚ş	û²ñ—ÀOõjÃ,YŞhb6@§HÆKğ‚uÃÉİ¯ÂT÷q®è4¨›¨ö×è¾Œ·ƒ~-`ù{ıQ2í%oú£áH7÷ãğâıéåEò±~Ş?¹FÉé¹ËŸ¾Mú'Ÿ’¿O@İÉ9ü…óÂJrâ+ã&7ˆü¤©ò©¹´Ud•M›y1¼8ta×O†'oÏ‡'ï'İäÃàüğ=Ì²ÿfx<¼øD$ôvxq2qú@_Æ8ëŸÃ]÷Ï“³Ëó³ÓÑ€¥-GgY€ù/á¥9E(2ÃVaL.pre±,sTÏiÁS .ü	Ñ_à¸Æ_ÊŞÆª—«ì:¯ˆ³WÅ8÷f23u‰³’7ÖZ›Æ,ÓŞŸzğ·n)>tœ§W”ŸÔK†(y“ÓÖh<|4#g'Ì,mãjÑHĞÊºÙõ,íkœuº>Úİ\¹Şóó ½ï³¢€>ıY~E
Mîı>n¡¯\aBEÑñöûÁÜ3è”Ñ#›åôbñĞÑ¦óô:öáãÓš’ªe†±u}†Š-‡PaŸ.ädPåĞèsƒy£»ºä˜9Jq/«1j\7ti7×Ç¬ù“|!‡iøªõìß×Yá²gìuQLîò™õ~¡\,—)z	Q'XãÄ§i>[—,ÒÙt½Ê	Á–LŒ ñÚıàgÒ!*èuGœŒáééä6§ éTÒ7àÈ&hrƒÏ7à§å.éŞ)çÅ7÷ƒ 6—âãªîñu­ï·©:¾)
ö‚’§3
¶“Ïô¶iFüXÍ0]Œ3^Ä’İ Âı6DwÙ|©%Á!ÆÛ:Ó¹'ÅÕL¼P¤·|l5_µÀzğ¾ˆ}•+õÆûâ-!6%ı†Ñ~šÃú(£e13Ñ¯sKX„œ¸ò12ÒÀFi¾¤é„(JàèÁSdÈ@|Âh3åSæÏxáù¾ÓŞLıŞL²)˜+ühÆ“×yZÎ‰©ríw1\çuY†h™x1ƒ°Äë#NÔnÓo|µe#,hƒ;öÔ+ów†ÚèçÂ<89B¹Ú–Gß÷ÏÎà'Ã¿½Â#$opÔ¤/ØÔ=ü¦rçcIğßÅ#èJEìMPµº€[SRºXsİ`ÉOól6©pÙ™é_a”2ÊÜû÷ÿØóŒ<"í6JLÄUÅê3–t/Ù?*ßù|sGuğÿ½“µNfjêP¨ø~b±mb³xWªğó/>JF=O ø<8«0@Å¿?©rqú-ÓPj¬lv‘š¹Ta¬¡Õ+S×ARI…îÁäÈq<xeEù”äœ&^îãñ²swõî™àäHËñF¬™B0ñß7ğß$ÿNó†yÖ¢¬ÿA?"™›)&Ÿ¨Ò#ÙÇøœËÎkBíd,¾´FÔø|!f(±FOQ^ÅI‚Õ_\‘·,\vJÈéÊ'º>rzºûÉhp€Å)øÈc4ômº‡äœá0Æ¥ÖÌpÂ ıÁ6ü‰ê·*Ş´m#©ŠC«5@3°´ÅõT‹zfŸxK‚¾^5×…EE»ÎW~3:J$;:¤$ëß\a°ãWºÑaÿ¸Ÿe8î	úı_<{öâàÅ³ç/’ÁÙÛc°ÈÒu•.@ı¢ìŠì-@´RÎ˜:RŞRÄˆŒhŸªxGZğm6+–Á©yVb1Ê|çñTòb‚åJ”Ö…q1‰à}Uò6ƒ2ôÑ@´—²ñÍ¢˜×›dgÜ±S†çVÿÈJ8{œÎYİnïÒåêŠ¢%~n§¾r;NÉBkÛ'r’G[¸_-XEZdÃÛ`-º8 µ-Å©.Ùê•¦~Çñ7RrmB	Ù'L`xjoˆL£bZsÅğÒÅ¤6£‰·ø}ÖF}&ğF»-2
ş6“¡§Š’õÆ«Î(I 1™ĞäDzö45åáDøş@åşi½èş‹Jb86 «Ú(2ò+2oˆ›‚X…ï2qşÌŒg³¨Š²#­B®“çh FM’W`fÈ¦.ŞGÉèôíğÖ°İäìüô—áÑà(yó)¹x?HÎï'^ã
ƒÓóQòŸÿI|ú»ïğ+‡ìwğ·³st2 o~8;Â cw“áÉáñåÑğä]7!Ğ]¬åÃğ~vqÚÅ—¹æcÈÚkšJäĞhqe8\ÎÑptxÜ~ÑoL¿Àb’Ñûşñq´:'aqo0·ş›ã£Àâ†çƒÃ\Eø×!lL˜ßèlp8Äş6€5ôÏ?ueÌÑà_/áGğ¥;êè¿ƒ%í?°p‡—çäÍÁå.ßŒ.†—ƒäİééNÖç¿ [½NOG´ITrÔ¿èÓ‹aØ!øşıær4¤½€.}~y†2³“¼?ı»qîûğèmêé	-6æôüŠ{ N¤ïğù9î#íT· N/œù¼6ğÂ¬19¼;Â6ğÛSåãp4è$ıóá0ä×~ìr(åQç‡£Yñ?vé “!ˆû£_†8mù1ùh(äqúÖ.ß'¼İ¿•,28­æüÿR°b6İHüsÊ‘üKĞàŸÿF~ï´œì\TÇ²ùÏ›,-ÿÒMşX´³ò/[pÌ¢Ù+VQFŸ¦]5S-l‡ë\ˆÓPtâkEò³ùg`íùo"ÀxqÛä×ŸÁ<Hù?èQIfãmòì+$™wZÔäÙ·I²ÙáéÙ§óá»÷Àùç-"M-	4}Ì=] ·¸ûÚŸëKüKc‰È1÷t9&Œuä.Ç/ÇÜSåXä˜ûF9–4å˜û69–´Ë1÷•r,ùıäXòs×$ĞşQ­&¿.òßPH±€j“Oÿl¢È=Ù”ŠØ>û¾ÖÚ…¥ÓpÿÛSäO³tğ[­§ÿaØ­«üSä)¦ˆù™{š)RcáîM‘ßš…3àBrÄî²¹†´,U¯^éç½çNÀHuQLv<3wxúáãìÓñé‘P¦@}‹ÉşáÑÑqÇÎ0!ÎkñveÃw½Z9ºQ°+®^’4.Á/³tÅ±WÇÁs£)´€?‘Å›•Şı"~·ÎXçÀŠzÙCrª¥4Š"CuEŸ^Åš3zÛ£èÚ>¥pn:]Ï¤i¨øQª(¾’õb¤#¯giN+yI+¹ÍĞ¹¯3òi'w˜2ÎåªÓòvşjÜiÛÎ@—œa”+íÂ²¢ñãÚk@ÑQÓ*3Ù
4†¹–[JXır€å(óö¼ê› 5œÄ+¶QºĞ©’ÜGH—0ö`ì!’),HnbVÚWl§Êi^‚Æz¡Š_ĞØò–q“ìâçğG˜Ã1†×Ë„+Õ¥ú“3¸œ†O%«šKÖKQß?>Òr(­B"Á)ïóïÚçôcÏ€ènXèÿË?ù_ÚÓ¹I}‘%«0pOÉ-ŞÕ;O¿äóõ<É¾P_ÖPQÆR¨BEo•ë6—ãâD=Ì„´Åˆ4N:æĞW×fvèó!Áà6ÛÀ†pÒbXĞO° ˆn-9"¢q]Fåğ?Nc»^%{%¯è÷’>)¥Xóg¤às—s®;-º˜T”1–~«§mõd]˜¦x3ƒè‹îm“r°ø¾XWñm}-³}Ã³]dwfÆø¯æÿ•oyM_Ó÷‡mïÉ‹¢VjÛÂàwıú~şN¹1Ù¯<iF’_ä}tçtúZ:O)yXì`¢©­C)%˜‡”Á±gªÁmQà>¦ -Š;
pÓŞ %§Ó•nC¸Õ¶%-Î)&G¹ØX6Èr*]RJîZx'“t•Á.m(í‰†½¬œz"×ìc]F1bßÎ-;Iƒaša-¾T:€)£p3ˆ±£MF‰@6ˆCRZË8
ÏQÀ6àeôj"!•ÜCU†FnCG®-óål£‡a9“Òl·Foõ™7å˜ğÇ“UH¡<R¥•Şã¹U  í  .d         2019.2.0a14 şÿÿÿ      ÿÿ’3$øÌuñì˜²e+ Í=   ^          7  €ÿÿÿÿ     €            ¦ €² €                   Ğ  €                       ¦ €                       ¦ €                       ¦ €#                       ¦ €+                       H €3   ÿÿÿÿ    €           1  €1  €ÿÿÿÿ   @            Ş  € €   	                Q  €j  €   
                H €<   ÿÿÿÿ    €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   Õ €I   ÿÿÿÿ    €           1  €1  €ÿÿÿÿ    À            Ş  € €                    H €j  €ÿÿÿÿ    €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   ™ €P                     AssetMetaData guid data[0] data[1] data[2] data[3] pathName originalName labels assetStoreRef    ÿÿfš†!ë5˜9İ4QÁóB   í          7  €ÿÿÿÿ     €            ¦ €² €                      E €                   Ş  €#          €           . €,          €           5   a €                   Ş  €#          €           . €,          €           † €r €                   Ş  €#      	    €           . €,      
    €           H €« €ÿÿÿÿ   €          1  €1  €ÿÿÿÿ   @           Ş  € €                  Q  €j  €                  ñ  €J   ÿÿÿÿ    À           1  €1  €ÿÿÿÿ    €            Ş  € €                     €j  €ÿÿÿÿ    €            \   ›  €ÿÿÿÿ    €            H €r   ÿÿÿÿ    €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   H €w   ÿÿÿÿ    €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   H €€   ÿÿÿÿ    €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   y €
 €                     Ş  €#      !    €           . €,      "    €            €…   ÿÿÿÿ#   @          1  €1  €ÿÿÿÿ$               Ş  € €   %               . €j  €   &               Õ €“   ÿÿÿÿ'    €           1  €1  €ÿÿÿÿ(    À            Ş  € €   )                  €j  €ÿÿÿÿ*    €            H €›  €ÿÿÿÿ+    €           1  €1  €ÿÿÿÿ,   @            Ş  € €   -                Q  €j  €   .                y €
 €   /                 Ş  €#      0    €           . €,      1    €             €§      2    @            ¾ €¶      3    @            Ş  €#      4    €           . €,      5    €           H €»   ÿÿÿÿ6   €           1  €1  €ÿÿÿÿ7   @            Ş  € €   8                Q  €j  €   9                H €Æ   ÿÿÿÿ:   €           1  €1  €ÿÿÿÿ;   @            Ş  € €   <                Q  €j  €   =                H €Ø   ÿÿÿÿ>   €           1  €1  €ÿÿÿÿ?   @            Ş  € €   @                Q  €j  €   A              MonoImporter PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_ExternalObjects SourceAssetIdentifier type assembly name m_UsedFileIDs m_DefaultReferences executionOrder icon m_UserData m_AssetBundleName m_AssetBundleVariant s    ÿÿ£Gñ×ÜZ56 :!@iÁJ*          €7  €ÿÿÿÿ     €            ¦ €² €                       E €                   Ş  €          €           . €          €           (   a €                   Ş  €          €           . €          €           † €r €                   Ş  €      	    €           . €      
    €           H €« €ÿÿÿÿ   €          1  €1  €ÿÿÿÿ   @           Ş  € €                  Q  €j  €                  H €ê €ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   ñ  €=   ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   €            Ş  € €                    €j  €ÿÿÿÿ   €            H €›  €ÿÿÿÿ   €           1  €1  €ÿÿÿÿ   @            Ş  € €                   Q  €j  €                   y €
 €                   Ş  €          €           . €          €           y €Q                       Ş  €          €           . €           €           Ş  €X      !                H €i   ÿÿÿÿ"   €           1  €1  €ÿÿÿÿ#   @            Ş  € €   $                Q  €j  €   %                H €u   ÿÿÿÿ&   €           1  €1  €ÿÿÿÿ'   @            Ş  € €   (                Q  €j  €   )              PPtr<EditorExtension> m_FileID m_PathID PPtr<PrefabInstance> m_DefaultReferences m_Icon m_ExecutionOrder m_ClassName m_Namespace                 t              x   \      ày¯     Ø   |                                     ¹,k™QxIaıyÑœèâI   Packages/com.unity.timeline/Editor/Signals/TreeView/SignalReceiverItem.cs                                                                          ày¯                                                                                    SignalReceiverItem  é  using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor.IMGUI.Controls;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Timeline;
using Object = UnityEngine.Object;

namespace UnityEditor.Timeline.Signals
{
    class SignalReceiverItem : TreeViewItem, ISignalAssetProvider
    {
        static readonly SignalEventDrawer k_EvtDrawer = new SignalEventDrawer();

        readonly SerializedProperty m_Asset;
        readonly SerializedProperty m_Evt;
        readonly SignalReceiverTreeView m_TreeView;

        int m_CurrentRowIdx;
        SignalReceiver m_CurrentReceiver;

        internal readonly bool enabled;
        internal readonly bool readonlySignal;

        internal const string SignalName = "SignalName";
        internal const string SignalNameReadOnly = "SignalNameReadOnly";
        internal const string SignalOptions = "SignalOptions";

        public SignalReceiverItem(SerializedProperty signalAsset, SerializedProperty eventListEntry, int id, bool readonlySignal, bool enabled, SignalReceiverTreeView treeView)
            : base(id, 0)
        {
            m_Asset = signalAsset;
            m_Evt = eventListEntry;
            this.enabled = enabled;
            this.readonlySignal = readonlySignal;
            m_TreeView = treeView;
        }

        public SignalAsset signalAsset
        {
            get { return m_CurrentReceiver.GetSignalAssetAtIndex(m_CurrentRowIdx); }
            set
            {
                Undo.RegisterCompleteObjectUndo(m_CurrentReceiver, Styles.UndoCreateSignalAsset);
                m_CurrentReceiver.ChangeSignalAtIndex(m_CurrentRowIdx, value);
            }
        }

        public float GetHeight()
        {
            return k_EvtDrawer.GetPropertyHeight(m_Evt, GUIContent.none);
        }

        public void Draw(Rect rect, int colIdx, int rowIdx, float padding, SignalReceiver target)
        {
            switch (colIdx)
            {
                case 0:
                    DrawSignalNameColumn(rect, padding, target, rowIdx);
                    break;
                case 1:
                    DrawReactionColumn(rect, rowIdx);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        void DrawSignalNameColumn(Rect rect, float padding, SignalReceiver target, int rowIdx)
        {
            using (new EditorGUI.DisabledScope(!enabled))
            {
                if (!readonlySignal)
                {
                    m_CurrentRowIdx = rowIdx;
                    m_CurrentReceiver = target;

                    rect.x += padding;
                    rect.width -= padding;
                    rect.height = EditorGUIUtility.singleLineHeight;
                    GUI.SetNextControlName(SignalName);
                    SignalUtility.DrawSignalNames(this, rect, GUIContent.none, false);
                }
                else
                {
                    GUI.SetNextControlName(SignalNameReadOnly);
                    var signalAsset = m_Asset.objectReferenceValue;
                    GUI.Label(rect,
                        signalAsset != null
                        ? EditorGUIUtility.TempContent(signalAsset.name)
                        : Styles.EmptySignalList);
                }
            }
        }

        void DrawReactionColumn(Rect rect, int rowIdx)
        {
            if (!readonlySignal)
            {
                var optionButtonSize = GetOptionButtonSize();
                rect.width -= optionButtonSize.x;

                var optionButtonRect = new Rect
                {
                    x = rect.xMax,
                    y = rect.y,
                    width = optionButtonSize.x,
                    height = optionButtonSize.y
                };
                DrawOptionsButton(optionButtonRect, rowIdx, m_CurrentReceiver);
            }

            using (new EditorGUI.DisabledScope(!enabled))
            {
                var nameAsString = m_Asset.objectReferenceValue == null ? "Null" : m_Asset.objectReferenceValue.name;
                using (var change = new EditorGUI.ChangeCheckScope())
                {
                    EditorGUI.PropertyField(rect, m_Evt, EditorGUIUtility.TempContent(nameAsString));
                    if (change.changed)
                        m_TreeView.dirty = true;
                }
            }
        }

        static Vector2 GetOptionButtonSize()
        {
            EditorGUIUtility.SetIconSize(Vector2.zero);
            return EditorStyles.iconButton.CalcSize(EditorGUI.GUIContents.titleSettingsIcon);
        }

        void DrawOptionsButton(Rect rect, int rowIdx, SignalReceiver target)
        {
            GUI.SetNextControlName(SignalOptions);
            if (EditorGUI.DropdownButton(rect, EditorGUI.GUIContents.titleSettingsIcon, FocusType.Passive, EditorStyles.iconButton))
            {
                var menu = new GenericMenu();
                menu.AddItem(new GUIContent(Styles.SignalListDuplicateOption), false, () =>
                {
                    Undo.RegisterCompleteObjectUndo(target, "Duplicate Row");
                    var evtCloner = ScriptableObject.CreateInstance<UnityEventCloner>();
                    evtCloner.evt = target.GetReactionAtIndex(rowIdx);
                    var clone = Object.Instantiate(evtCloner);
                    target.AddEmptyReaction(clone.evt);
                    m_TreeView.dirty = true;
                });
                menu.AddItem(new GUIContent(Styles.SignalListDeleteOption), false, () =>
                {
                    Undo.RegisterCompleteObjectUndo(target, "Delete Row");
                    target.RemoveAtIndex(rowIdx);
                    m_TreeView.dirty = true;
                });
                menu.ShowAsContext();
            }
        }

        IEnumerable<SignalAsset> ISignalAssetProvider.AvailableSignalAssets()
        {
            var ret = SignalManager.assets.Except(m_CurrentReceiver.GetRegisteredSignals());
            return signalAsset == null ? ret : ret.Union(new List<SignalAsset> {signalAsset}).ToList();
        }

        void ISignalAssetProvider.CreateNewSignalAsset(string path)
        {
            var newSignalAsset = SignalManager.CreateSignalAssetInstance(path);
            m_CurrentReceiver.ChangeSignalAtIndex(m_CurrentRowIdx, newSignalAsset);
            AssetDatabase.CreateAsset(newSignalAsset, path);
            GUIUtility.ExitGUI();
        }

        class UnityEventCloner : ScriptableObject
        {
            public UnityEvent evt;
        }
    }
}
                          SignalReceiverItem     UnityEditor.Timeline.Signals                                                                                                                                                                                                                                                                                                                                                                                                                            <svg id="Regular" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><defs><style>.cls-1{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px}</style></defs><title>dog-carrier</title><path class="cls-1" d="M.75 12.75H7.5M19.625 9l-.666-4a1.5 1.5 0 0 0-1.48-1.253H5.021A1.5 1.5 0 0 0 3.541 5L2.25 12.75m5.25 9H5.021a1.5 1.5 0 0 1-1.48-1.25L2.25 12.75m4.5-6v3m4.5-3v3m4.5-3v1.5m-7.5-4.5a3 3 0 0 1 6 0"/><circle class="cls-1" cx="16.5" cy="13.5" r="1.5"/><circle class="cls-1" cx="11.25" cy="16.5" r="1.5"/><circle class="cls-1" cx="21.75" cy="16.5" r="1.5"/><path class="cls-1" d="M13.5 23.25a.748.748 0 0 1-.6-1.2l3-4a.75.75 0 0 1 1.2 0l3 4a.75.75 0 0 1-.6 1.2z"/></svg>                                                                                                                                                                                                                                                                                                         »bH+<'Æ>¿nõJw˜Sû¾æ~]Ô6i49…Ò]£¹6Œš¹ô‡ªµLœn½äCf[ÒäkQsNıƒŞ\@-²Á=]x¾‚<ÃÚÿ‘Npô@‡–…ğ=_n¬ŞË¦q?ƒ9è
h˜ÇC†'ZdàøV“'š’†şê
ÃAkZ,g_ìq=v\7œšM‰/±¸Å³™=¸óÉå«Ü3¥åúB¶:¬Ø†çµÁxßùöSO2©ŒŠ,Í­ä8\FÈa’Ouˆ‚gÓç’¦àÃdgWªAìL9ViÔ5á`¤]Šö)Lõ
–hÿg
ßÁ
3ß Ğ©Wé›&OôÌâZøÈc/\Ç$íB4*_ˆÈè Óä»I¦vV
†R8Ä ğ¥-¦»$˜Ã4¶nµ	>Ÿ+|·“ğÅD”Z˜9ÄØßâcIê±$w0]<p¬COˆ¤
_¡tR‘J`R˜¼îâ^´æPˆ Y’ı™$b½d}„<g6yªäû„êòÏQÄÄoPK   IJV…:
eo  ±ª    META-INF/LICENSES.txtí½ûrÛH–>ø÷æS`µñ‹'(–/Õ]]voGĞm³Z–4¢TnÏÄDD‚Ê$ÁHÉì}}}²=×Ì“ (É«¦wb*&¦-’Häåä¹Ÿï\ÜäU2ÍgY2.«4_TÉê&K¦ëÙ,™åãlQeÉ*û²JŠ)}‘/Æ³õ$›Ày9I–i¹Ú¸Y~U¦eU½ämQ&é")n³ò6Ïîô1ªJª,£NN/†‡ƒŞ
FÆ·÷œs;ıÏõ—é^4*¦«»´Ì’cB7ù%+«¼X$/zÏ\’ÈÏ‹ù¼€Å¿ÉÒÅå*ŸUÍ¯‹Ù,¯àÑÖ/çË2«Z¿YLóëu™â“Í¯‡§ÍÏÓÅuË§ÅõuŞöÅ‡tuÓüôN-|
ÿğkÒ?Ö?:,Ê¬şÙqº)Öp0p–?NO€ æËYº²¿[ÃffÉş¼˜¬gÙ«ä*†]Œ‹I6®:Û9¦éİûƒ2»çë¿¯³rdWe¥ùÕ¨±H^½JñÏ¶Ïí)ğå£~wúîè¸õwíÃÜVÅu™.o6ôw¾¼r{Ì/7àû´º‰ˆÀÿrp›-V-Ÿ1¦Ói–ÃNe‡¦iµÊÓ¢Êğ©áY2ş³‚Õë–ŸÎ&ÉÏı¿½Iú‹E±¢©’ı_ÓÛôKïË|Ö»Ê“Nxî ?3Ÿy¿ÊŸ“t•âƒæğóÒR•5?EB¤O?ËIé&¿¤³|Â'Å”ı3Ì	p¼.Ël1Ş$E1«hoáş#“Úè¯Nà¹Û,éÇºèÛ´ªò
7ãW8²ls 1+€ØngÙ}_ùåé÷ev0å|$Ñ‡Dÿµq¬æ‹_ÓÜ|~3ËV«¼¢gğŸL«Õ2A>•¯6öóáiÛ§£6¤ñ¾RÉ.ú–t¶˜Ì˜Ğüw<2°yûáÇì*].ê–Àãù,Fëå²(WöWûpœ¬Íã¿wY9ºÉf3ú«,ğè«ãû$È$ùòi>˜§×‹b–§øÏ¬„w¸S²U™+]À	¾éû7k òÒÿyˆÌ(şëû÷gæ#9ş“m?Ïªbvk>¸(ÓE%k«}òıá,Å|?X´¨mßÿõ_×Ù:kùSäÖçåë‡¿\ä_Ìºà½™ãÏp”Éy–‰èßë…Üäñ(şåü|™ Zø×hœÎRxbŠ"şşøaø^‘]KiúÿT°ø¾ï÷F°wá>/Öpİ“Ïı°õ¡¸F¯¾ÿşîî®—ÒkzEyı½*+ßÓì.çFIÿä(9<=9^OOFÉÛÓóär4è&çƒ³óÓ£ËCü¸K¿:.Î‡o.ñày/9Ê¦ù"'ØÓ%ïÉŠö’ê&mkb••óŠ® p™	?Eç´Fí¥Ì–%ğeÒCº2şv¬«Ì¯Ötªi•Lğ• §]mğúó Ïaü²X_ß$?±bºß¤¯çÀ¦êó*ÊÆÄÆÅrSæ×7 ŞëK`Jğ ğ•$]¯nŠ2ÿ½OÆi{bu“®x)È3xHrNÖL »NgÉ€†nLb½ÀŠZ‰ô£è,`Rº;ø_?	ÏáW#Û.‹Y7A…Pş˜Ñ¤»¸ün<æ¹4ş'?LîòÕÃ/dmç±\—ËÕ[¿«şÀõŒöd”=Z
ÈÏ¼Ã"#ìÂñ•pJ8	‰ôïn²*@X¯+R˜eşŠv Æ¸H¯3<<|oµßÈÄºÉİMFË‡Ó§÷¦4¶İ™»©	FÙÏa&t< Y,q¤i>…İ\¯Å¡÷ÿğìuèu(Eyãu õªZÁ®ãÀ1ú #ÂW ¶MóqGnæüS±ŞKöáYüW¹×±§ÿ‡{r›OÖ8V™Xú²/0Û¼Â‰À¼çyUÁñ% ciÚŞ6†+×k^§4ĞçA˜”ğ8};¥'F
ŠQ>iWé³e„_Ã%L@£gãÛá+µB*za‚jr×ß=5ğ?şAWï¿QFÑN2ìãô
u„æÔÓÅ†?ƒãXÏè~LËb_oÒÌZ/È
Eş2U‚¢Ofòç4IŞ®/PÆ¨-®Í2ÇUĞäd™×@	°ø8Z°å^°Ò[æŞÃwwMò4Ym–vÙ‹òsƒ)ÜÁ‡4câCHiá
ä]†¿ ¼u²¬y:Fr›æ³ôj¦÷ßğ¥.rS$Àq*¤”z¾ Ü¶~ìÙ›7’sÚÖtµBÙB;¤³•!öaÙ—Ì«ÖdÎâ/A«ÊàÍ_à2ÍŠ»NØ…£¬ÌoYƒÅ©öê€ïhßY½ŒÄ{ GÕoAWq‚ï@êêa^…¯¢ãÂ»pw“o3€ÃÍ¯{™İæt”HÅŞè&ìpQê_0„³½M2J¹¬J¡İOáeÅŒ.<–ƒoiy“+ŸšF×¿›Ô·Ov©YÎ†©QfsĞõõ~f`|¥à¾Ğ2@+Íf¸‹Ï´qhÖ ,ÒyÖÑCÏ•ÓtLB¢kd¤ßÔÆ¤pw²bNıY¹ÈøÖ¯ßeÍûüÊ…SYêçƒEgB4<MDG*xoè)ø~Ûä»æR¬ëğê™²íj}¼C˜‡êD]4sš\zññ†Z¡§Lâî^iaäÊôz¤÷«6s
[±]yyœ´Oöüšöd,–÷-ÃC*ÕeÌ¸‹§p•ÎˆîJ|nAÊÇz¡ÖTÅ6¤ßô,lîÓª
—…ö¿êŞ+Š<ï²ï€ÿs˜£éU+Íˆ,¯
U›j•Í+ËÂAæ®3!llÈ/øøQò±¶âu-»é]ÃF"*0»û:îx]‘”§7Î‰_Šù‘8^MÙİ„x­J°”
ìu±®àòÎÓò3²¾2hGªreU~½ Ş¤ˆgDÛJ‰È¬öN`¿Éáïjo¯y…kúµ_¶ŞÀU»Èçµ—&70™«è	TÆŒ89LÚ¾'\Â*ûûèg†¯°ß,®Qá5×Ñ‹^òÕ*|í¡_¾jV`ü³pZm5fÌ5³\ÌÓ›ÄlP‚,æLZé Â*AÃ[f+Ø%?`}³É]ºÆ^:ù
VŒ€ÖS^£áTlÒÙjs0-3ø+Åî¶##oHsï÷.¼µOÀ["78]`çËõ<»„ºœ¥@èş˜3‹ÚŠ>ÅÂÚmVÍ÷¼˜”åÆ[Ä9ñ> —æ€ÎRdºÿNgË–+¼``r¬TEÊ1¢@Q'YòZÍéºƒİ¤·iy:!²£ô‘ÈfÀ~ùÿG)ÊŒç¢(‹VHlFW†[Àg¤oMÑ†¢a‡N»Œ¼K¦6¥9ì7ÿÖ,v‘±»ëùæ"C×XZæt;§%pµh²\eŸ½øûUÌàb‘‰Dö‰×êé±úº ¶pEÚÂôYÉ‹''¯¸Ã£PY×K†S<oUÀ©¦ı¡¬òkBz// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using Internal.Runtime.Augments;
using System.Diagnostics; // for TraceInformation
using System.Runtime.CompilerServices;

namespace System.Threading
{
    public enum LockRecursionPolicy
    {
        NoRecursion = 0,
        SupportsRecursion = 1,
    }

    //
    // ReaderWriterCount tracks how many of each kind of lock is held by each thread.
    // We keep a linked list for each thread, attached to a ThreadStatic field.
    // These are reused wherever possible, so that a given thread will only
    // allocate N of these, where N is the maximum number of locks held simultaneously
    // by that thread.
    // 
    internal class ReaderWriterCount
    {
        // Which lock does this object belong to?  This is a numeric ID for two reasons:
        // 1) We don't want this field to keep the lock object alive, and a WeakReference would
        //    be too expensive.
        // 2) Setting the value of a long is faster than setting the value of a reference.
        //    The "hot" paths in ReaderWriterLockSlim are short enough that this actually
        //    matters.
        public long lockID;

        // How many reader locks does this thread hold on this ReaderWriterLockSlim instance?
        public int readercount;

        // Ditto for writer/upgrader counts.  These are only used if the lock allows recursion.
        // But we have to have the fields on every ReaderWriterCount instance, because 
        // we reuse it for different locks.
        public int writercount;
        public int upgradecount;

        // Next RWC in this thread's list.
        public ReaderWriterCount next;
    }

    /// <summary>
    /// A reader-writer lock implementation that is intended to be simple, yet very
    /// efficient.  In particular only 1 interlocked operation is taken for any lock 
    /// operation (we use spin locks to achieve this).  The spin lock is never held
    /// for more than a few instructions (in particular, we never call event APIs
    /// or in fact any non-trivial API while holding the spin lock).   
    /// </summary>
    public class ReaderWriterLockSlim : IDisposable
    {
        private static readonly int ProcessorCount = Environment.ProcessorCount;

        //Specifying if the lock can be reacquired recursively.
        private readonly bool _fIsReentrant;

        // Lock specification for _spinLock:  This lock protects exactly the local fields associated with this
        // instance of ReaderWriterLockSlim.  It does NOT protect the memory associated with 
        // the events that hang off this lock (eg writeEvent, readEvent upgradeEvent).
        SpinLock _spinLock;

        // These variables allow use to avoid Setting events (which is expensive) if we don't have to. 
        private uint _numWriteWaiters;        // maximum number of threads that can be doing a WaitOne on the writeEvent 
        private uint _numReadWaiters;         // maximum number of threads that can be doing a WaitOne on the readEvent
        private uint _numWriteUpgradeWaiters;      // maximum number of threads that can be doing a WaitOne on the upgradeEvent (at most 1). 
        private uint _numUpgradeWaiters;

        private WaiterStates _waiterStates;

        private int _upgradeLockOwnerId;
        private int _writeLockOwnerId;

        // conditions we wait on. 
        private EventWaitHandle _writeEvent;    // threads waiting to acquire a write lock go here.
        private EventWaitHandle _readEvent;     // threads waiting to acquire a read lock go here (will be released in bulk)
        private EventWaitHandle _upgradeEvent;  // thread waiting to acquire the upgrade lock
        private EventWaitHandle _waitUpgradeEvent;  // thread waiting to upgrade from the upgrade lock to a write lock go here (at most one)

        // Every lock instance has a unique ID, which is used by ReaderWriterCount to associate itself with the lock
        // without holding a reference to it.
        private static long s_nextLockID;
        private long _lockID;

        // See comments on ReaderWriterCount.
        [ThreadStatic]
        private static ReaderWriterCount t_rwc;

        private bool _fUpgradeThreadHoldingRead;

        private const int MaxSpinCount = 20;

        //The uint, that contains info like if the writer lock is held, num of 
        //readers etc.
        private uint _owners;

        //Various R/W masks
        //Note:
        //The Uint is divided as follows:
        //
        //Writer-Owned  Waiting-Writers   Waiting Upgraders     Num-Readers
        //    31          30                 29                 28.......0
        //
        //Dividing the uint, allows to vastly simplify logic for checking if a 
        //reader should go in etc. Setting the writer bit will automatically
        //make the value of the uint much larger than the max num of readers 
        //allowed, thus causing the check for max_readers to fail. 

        private const uint WRITER_HELD = 0x80000000;
        private const uint WAITING_WRITERS = 0x40000000;
        private const uint WAITING_UPGRADER = 0x20000000;

        //The max readers is actually one less then its theoretical max.
        //This is done in order to prevent reader count overflows. If the reader
        //count reaches max, other readers will wait.
        private const uint MAX_READER = 0x10000000 - 2;

        private const uint READER_MASK = 0x10000000 - 1;

        private bool _fDisposed;

        private void InitializeThreadCounts()
        {
            _upgradeLockOwnerId = -1;
            _writeLockOwnerId = -1;
        }

        public ReaderWriterLockSlim()
            : this(LockRecursionPolicy.NoRecursion)
        {
        }

        public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)
        {
            if (recursionPolicy == LockRecursionPolicy.SupportsRecursion)
            {
                _fIsReentrant = true;
            }
            InitializeThreadCounts();
            _waiterStates = WaiterStates.NoWaiters;
            _lockID = Interlocked.Increment(ref s_nextLockID);
        }

        private bool HasNoWaiters
        {
            get
            {
#if DEBUG
                Debug.Assert(_spinLock.IsHeld);
#endif

                return (_waiterStates & WaiterStates.NoWaiters) != WaiterStates.None;
            }
            set
            {
#if DEBUG
                Debug.Assert(_spinLock.IsHeld);
#endif

                if (value)
                {
                    _waiterStates |= WaiterStates.NoWaiters;
                }
                else
                {
                    _waiterStates &= ~WaiterStates.NoWaiters;
                }
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsRWEntryEmpty(ReaderWriterCount rwc)
        {
            if (rwc.lockID == 0)
                return true;
            else if (rwc.readercount == 0 && rwc.writercount == 0 && rwc.upgradecount == 0)
                return true;
            else
                return false;
        }

        private bool IsRwHashEntryChanged(ReaderWriterCount lrwc)
        {
            return lrwc.lockID != _lockID;
        }

        /// <summary>
        /// This routine retrieves/sets the per-thread counts needed to enforce the
        /// various rules related to acquiring the lock. 
        /// 
        /// DontAllocate is set to true if the caller just wants to get an existing
        /// entry for this thread, but doesn't want to add one if an existing one
        /// could not be found.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ReaderWriterCount GetThreadRWCount(bool dontAllocate)
        {
            ReaderWriterCount rwc = t_rwc;
            ReaderWriterCount empty = null;
            while (rwc != null)
            {
                if (rwc.lockID == _lockID)
                    return rwc;

                if (!dontAllocate && empty == null && IsRWEntryEmpty(rwc))
                    empty = rwc;

                rwc = rwc.next;
            }

            if (dontAllocate)
                return null;

            if (empty == null)
            {
                empty = new ReaderWriterCount();
                empty.next = t_rwc;
                t_rwc = empty;
            }

            empty.lockID = _lockID;
            return empty;
        }

        public void EnterReadLock()
        {
            TryEnterReadLock(-1);
        }

        //
        // Common timeout support
        //
        private struct TimeoutTracker
        {
            private int _total;
            private int _start;

            public TimeoutTracker(TimeSpan timeout)
            {
                long ltm = (long)timeout.TotalMilliseconds;
                if (ltm < -1 || ltm > (long)int.MaxValue)
                    throw new ArgumentOutOfRangeException(nameof(timeout));
                _total = (int)ltm;
                if (_total != -1 && _total != 0)
                    _start = Environment.TickCount;
                else
                    _start = 0;
            }

            public TimeoutTracker(int millisecondsTimeout)
            {
                if (millisecondsTimeout < -1)
                    throw new ArgumentOutOfRangeException(nameof(millisecondsTimeout));
                _total = millisecondsTimeout;
                if (_total != -1 && _total != 0)
                    _start = Environment.TickCount;
                else
                    _start = 0;
            }

            public int RemainingMilliseconds
            {
                get
                {
                    if (_total == -1 || _total == 0)
                        return _total;

                    int elapsed = Environment.TickCount - _start;
                    // elapsed may be negative if TickCount has overflowed by 2^31 milliseconds.
                    if (elapsed < 0 || elapsed >= _total)
                        return 0;

                    return _total - elapsed;
                }
            }

            public bool IsExpired
            {
                get
                {
                    return RemainingMilliseconds == 0;
                }
            }
        }

        public bool TryEnterReadLock(TimeSpan timeout)
        {
            return TryEnterReadLock(new TimeoutTracker(timeout));
        }

        public bool TryEnterReadLock(int millisecondsTimeout)
        {
            return TryEnterReadLock(new TimeoutTracker(millisecondsTimeout));
        }

        private bool TryEnterReadLock(TimeoutTracker timeout)
        {
            return TryEnterReadLockCore(timeout);
        }

        private bool TryEnterReadLockCore(TimeoutTracker timeout)
        {
            if (_fDisposed)
                throw new ObjectDisposedException(null);

            ReaderWriterCount lrwc = null;
            int id = Environment.CurrentManagedThreadId;

            if (!_fIsReentrant)
            {
                if (id == _writeLockOwnerId)
                {
                    //Check for AW->AR
                    throw new LockRecursionException(SR.LockRecursionException_ReadAfterWriteNotAllowed);
                }

                _spinLock.Enter(EnterSpinLockReason.EnterAnyRead);

                lrwc = GetThreadRWCount(false);

                //Check if the reader lock is already acquired. Note, we could
                //check the presence of a reader by not allocating rwc (But that 
                //would lead to two lookups in the common case. It's better to keep
                //a count in the structure).
                if (lrwc.readercount > 0)
                {
                    _spinLock.Exit();
                    throw new LockRecursionException(SR.LockRecursionException_RecursiveReadNotAllowed);
                }
                else if (id == _upgradeLockOwnerId)
                {
                    //The upgrade lock is already held.
                    //Update the global read counts and exit.

                    lrwc.readercount++;
                    _owners++;
                    _spinLock.Exit();
                    return true;
                }
            }
            else
            {
                _spinLock.Enter(EnterSpinLockReason.EnterAnyRead);
                lrwc = GetThreadRWCount(false);
                if (lrwc.readercount > 0)
                {
                    lrwc.readercount++;
                    _spinLock.Exit();
                    return true;
                }
                else if (id == _upgradeLockOwnerId)
                {
                    //The upgrade lock is already held.
                    //Update the global read counts and exit.
                    lrwc.readercount++;
                    _owners++;
                    _spinLock.Exit();
                    _fUpgradeThreadHoldingRead = true;
                    return true;
                }
                else if (id == _writeLockOwnerId)
                {
                    //The write lock is already held.
                    //Update global read counts here,
                    lrwc.readercount++;
                    _owners++;
                    _spinLock.Exit();
                    return true;
                }
            }

            bool retVal = true;
            int spinCount = 0;

            for (; ;)
            {
                // We can enter a read lock if there are only read-locks have been given out
                // and a writer is not trying to get in.  

                if (_owners < MAX_READER)
                {
                    // Good case, there is no contention, we are basically done
                    _owners++;       // Indicate we have another reader
                    lrwc.readercount++;
                    break;
                }

                if (timeout.IsExpired)
                {
                    _spinLock.Exit();
                    return false;
                }

                if (spinCount < MaxSpinCount && ShouldSpinForEnterAnyRead())
                {
                    _spinLock.Exit();
                    spinCount++;
                    SpinWait(spinCount);
                    _spinLock.Enter(EnterSpinLockReason.EnterAnyRead);
                    //The per-thread structure may have been recycled as the lock is acquired (due to message pumping), load again.
                    if (IsRwHashEntryChanged(lrwc))
                        lrwc = GetThreadRWCount(false);
                    continue;
                }

                // Drat, we need to wait.  Mark that we have waiters and wait.  
                if (_readEvent == null)      // Create the needed event 
                {
                    LazyCreateEvent(ref _readEvent, EnterLockType.Read);
                    if (IsRwHashEntryChanged(lrwc))
                        lrwc = GetThreadRWCount(false);
                    continue;   // since we left the lock, start over. 
                }

                retVal = WaitOnEvent(_readEvent, ref _numReadWaiters, timeout, EnterLockType.Read);
                if (!retVal)
                {
                    return false;
                }
                if (IsRwHashEntryChanged(lrwc))
                    lrwc = GetThreadRWCount(false);
            }

            _spinLock.Exit();
            return retVal;
        }

        public void EnterWriteLock()
        {
            TryEnterWriteLock(-1);
        }

        public bool TryEnterWriteLock(TimeSpan timeout)
        {
            return TryEnterWriteLock(new TimeoutTracker(timeout));
        }

        public bool TryEnterWriteLock(int millisecondsTimeout)
        {
            return TryEnterWriteLock(new TimeoutTracker(millisecondsTimeout));
        }

        private bool TryEnterWriteLock(TimeoutTracker timeout)
        {
            return TryEnterWriteLockCore(timeout);
        }

        private bool TryEnterWriteLockCore(TimeoutTracker timeout)
        {
            if (_fDisposed)
                throw new ObjectDisposedException(null);

            int id = Environment.CurrentManagedThreadId;
            ReaderWriterCount lrwc;
            bool upgradingToWrite = false;

            if (!_fIsReentrant)
            {
                EnterSpinLockReason enterMyLockReason;
                if (id == _writeLockOwnerId)
                {
                    //Check for AW->AW
                    throw new LockRecursionException(SR.LockRecursionException_RecursiveWriteNotAllowed);
                }
                else if (id == _upgradeLockOwnerId)
                {
                    //AU->AW case is allowed once.
                    upgradingToWrite = true;
                    enterMyLockReason = EnterSpinLockReason.UpgradeToWrite;
                }
                else
                {
                    enterMyLockReason = EnterSpinLockReason.EnterWrite;
                }
                _spinLock.Enter(enterMyLockReason);

                lrwc = GetThreadRWCount(true);

                //Can't acquire write lock with reader lock held. 
                if (lrwc != null && lrwc.readercount > 0)
                {
                    _spinLock.Exit();
                    throw new LockRecursionException(SR.LockRecursionException_WriteAfterReadNotAllowed);
                }
            }
            else
            {
                EnterSpinLockReason enterMyLockReason;
                if (id == _writeLockOwnerId)
                {
                    enterMyLockReason = EnterSpinLockReason.EnterRecursiveWrite;
                }
                else if (id == _upgradeLockOwnerId)
                {
                    enterMyLockReason = EnterSpinLockReason.UpgradeToWrite;
                }
                else
                {
                    enterMyLockReason = EnterSpinLockReason.EnterWrite;
                }
                _spinLock.Enter(enterMyLockReason);

                lrwc = GetThreadRWCount(false);

                if (id == _writeLockOwnerId)
                {
                    lrwc.writercount++;
                    _spinLock.Exit();
                    return true;
                }
                else if (id == _upgradeLockOwnerId)
                {
                    upgradingToWrite = true;
                }
                else if (lrwc.readercount > 0)
                {
                    //Write locks may not be acquired if only read locks have been
                    //acquired.
                    _spinLock.Exit();
                    throw new LockRecursionException(SR.LockRecursionException_WriteAfterReadNotAllowed);
                }
            }

            bool retVal = true;
            int spinCount = 0;

            for (; ;)
            {
                if (IsWriterAcquired())
                {
                    // Good case, there is no contention, we are basically done
                    SetWriterAcquired();
                    break;
                }

                //Check if there is just one upgrader, and no readers.
                //Assumption: Only one thread can have the upgrade lock, so the 
                //following check will fail for all other threads that may sneak in 
                //when the upgrading thread is waiting.

                if (upgradingToWrite)
                {
                    uint readercount = GetNumReaders();

                    if (readercount == 1)
                    {
                        //Good case again, there is just one upgrader, and no readers.
                        SetWriterAcquired();    // indicate we have a writer.
                        break;
                    }
                    else if (readercount == 2)
                    {
                        if (lrwc != null)
                        {
                            if (IsRwHashEntryChanged(lrwc))
                                lrwc = GetThreadRWCount(false);

                            if (lrwc.readercount > 0)
                            {
                                //This check is needed for EU->ER->EW case, as the owner count will be two.
                                Debug.Assert(_fIsReentrant);
                                Debug.Assert(_fUpgradeThreadHoldingRead);

                                //Good case again, there is just one upgrader, and no readers.
                                SetWriterAcquired();   // indicate we have a writer.
                                break;
                            }
                        }
                    }
                }

                if (timeout.IsExpired)
                {
                    _spinLock.Exit();
                    return false;
                }

                if (spinCount < MaxSpinCount && ShouldSpinForEnterAnyWrite(upgradingToWrite))
                {
                    _spinLock.Exit();
                    spinCount++;
                    SpinWait(spinCount);
                    _spinLock.Enter(upgradingToWrite ? EnterSpinLockReason.UpgradeToWrite : EnterSpinLockReason.EnterWrite);
                    continue;
                }

                if (upgradingToWrite)
                {
                    if (_waitUpgradeEvent == null)   // Create the needed event
                    {
                        LazyCreateEvent(ref _waitUpgradeEvent, EnterLockType.UpgradeToWrite);
                        continue;   // since we left the lock, start over. 
                    }

                    Debug.Assert(_numWriteUpgradeWaiters == 0, "There can be at most one thread with the upgrade lock held.");

                    retVal = WaitOnEvent(_waitUpgradeEvent, ref _numWriteUpgradeWaiters, timeout, EnterLockType.UpgradeToWrite);

                    //The lock is not held in case of failure.
                    if (!retVal)
                        return false;
                }
                else
                {
                    // Drat, we need to wait.  Mark that we have waiters and wait.
                    if (_writeEvent == null)     // create the needed event.
                    {
                        LazyCreateEvent(ref _writeEvent, EnterLockType.Write);
                        continue;   // since we left the lock, start over. 
                    }

                    retVal = WaitOnEvent(_writeEvent, ref _numWriteWaiters, timeout, EnterLockType.Write);
                    //The lock is not held in case of failure.
                    if (!retVal)
                        return false;
                }
            }

            Debug.Assert((_owners & WRITER_HELD) > 0);

            if (_fIsReentrant)
            {
                if (IsRwHashEntryChanged(lrwc))
                    lrwc = GetThreadRWCount(false);
                lrwc.writercount++;
            }

            _spinLock.Exit();

            _writeLockOwnerId = id;

            return true;
        }

        public void EnterUpgradeableReadLock()
        {
            TryEnterUpgradeableReadLock(-1);
        }

        public bool TryEnterUpgradeableReadLock(TimeSpan timeout)
        {
            return TryEnterUpgradeableReadLock(new TimeoutTracker(timeout));
        }

        public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)
        {
            return TryEnterUpgradeableReadLock(new TimeoutTracker(millisecondsTimeout));
        }

        private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout)
        {
            return TryEnterUpgradeableReadLockCore(timeout);
        }

        private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout)
        {
            if (_fDisposed)
                throw new ObjectDisposedException(null);

            int id = Environment.CurrentManagedThreadId;
            ReaderWriterCount lrwc;

            if (!_fIsReentrant)
            {
                if (id == _upgradeLockOwnerId)
                {
                    //Check for AU->AU
                    throw new LockRecursionException(SR.LockRecursionException_RecursiveUpgradeNotAllowed);
                }
                else if (id == _writeLockOwnerId)
                {
                    //Check for AU->AW
                    throw new LockRecursionException(SR.LockRecursionException_UpgradeAfterWriteNotAllowed);
                }

                _spinLock.Enter(EnterSpinLockReason.EnterAnyRead);
                lrwc = GetThreadRWCount(true);
                //Can't acquire upgrade lock with reader lock held. 
                if (lrwc != null && lrwc.readercount > 0)
                {
                    _spinLock.Exit();
                    throw new LockRecursionException(SR.LockRecursionException_UpgradeAfterReadNotAllowed);
                }
            }
            else
            {
                _spinLock.Enter(EnterSpinLockReason.EnterAnyRead);
                lrwc = GetThreadRWCount(false);

                if (id == _upgradeLockOwnerId)
                {
                    lrwc.upgradecount++;
                    _spinLock.Exit();
                    return true;
                }
                else if (id == _writeLockOwnerId)
                {
                    //Write lock is already held, Just update the global state 
                    //to show presence of upgrader.
                    Debug.Assert((_owners & WRITER_HELD) > 0);
                    _owners++;
                    _upgradeLockOwnerId = id;
                    lrwc.upgradecount++;
                    if (lrwc.readercount > 0)
                        _fUpgradeThreadHoldingRead = true;
                    _spinLock.Exit();
                    return true;
                }
                else if (lrwc.readercount > 0)
                {
                    //Upgrade locks may not be acquired if only read locks have been
                    //acquired.                
                    _spinLock.Exit();
                    throw new LockRecursionException(SR.LockRecursionException_UpgradeAfterReadNotAllowed);
                }
            }

            bool retVal = true;
            int spinCount = 0;

            for (; ;)
            {
                //Once an upgrade lock is taken, it's like having a reader lock held
                //until upgrade or downgrade operations are performed.              

                if ((_upgradeLockOwnerId == -1) && (_owners < MAX_READER))
                {
                    _owners++;
                    _upgradeLockOwnerId = id;
                    break;
                }

                if (timeout.IsExpired)
                {
                    _spinLock.Exit();
                    return false;
                }

                if (spinCount < MaxSpinCount && ShouldSpinForEnterAnyRead())
                {
                    _spinLock.Exit();
                    spinCount++;
                    SpinWait(spinCount);
                    _spinLock.Enter(EnterSpinLockReason.EnterAnyRead);
                    continue;
                }

                // Drat, we need to wait.  Mark that we have waiters and wait. 
                if (_upgradeEvent == null)   // Create the needed event
                {
                    LazyCreateEvent(ref _upgradeEvent, EnterLockType.UpgradeableRead);
                    continue;   // since we left the lock, start over. 
                }

                //Only one thread with the upgrade lock held can proceed.
                retVal = WaitOnEvent(_upgradeEvent, ref _numUpgradeWaiters, timeout, EnterLockType.UpgradeableRead);
                if (!retVal)
                    return false;
            }

            if (_fIsReentrant)
            {
                //The lock may have been dropped getting here, so make a quick check to see whether some other
                //thread did not grab the entry.
                if (IsRwHashEntryChanged(lrwc))
                    lrwc = GetThreadRWCount(false);
                lrwc.upgradecount++;
            }

            _spinLock.Exit();

            return true;
        }

        public void ExitReadLock()
        {
            ReaderWriterCount lrwc = null;

            _spinLock.Enter(EnterSpinLockReason.ExitAnyRead);

            lrwc = GetThreadRWCount(true);

            if (lrwc == null || lrwc.readercount < 1)
            {
                //You have to be holding the read lock to make this call.
                _spinLock.Exit();
                throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedRead);
            }

            if (_fIsReentrant)
            {
                if (lrwc.readercount > 1)
                {
                    lrwc.readercount--;
                    _spinLock.Exit();
                    return;
                }

                if (Environment.CurrentManagedThreadId == _upgradeLockOwnerId)
                {
                    _fUpgradeThreadHoldingRead = false;
                }
            }

            Debug.Assert(_owners > 0, "ReleasingReaderLock: releasing lock and no read lock taken");

            --_owners;

            Debug.Assert(lrwc.readercount == 1);
            lrwc.readercount--;

            ExitAndWakeUpAppropriateWaiters();
        }

        public void ExitWriteLock()
        {
            ReaderWriterCount lrwc;
            if (!_fIsReentrant)
            {
                if (Environment.CurrentManagedThreadId != _writeLockOwnerId)
                {
                    //You have to be holding the write lock to make this call.
                    throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedWrite);
                }
                _spinLock.Enter(EnterSpinLockReason.ExitAnyWrite);
            }
            else
            {
                _spinLock.Enter(EnterSpinLockReason.ExitAnyWrite);
                lrwc = GetThreadRWCount(false);

                if (lrwc == null)
                {
                    _spinLock.Exit();
                    throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedWrite);
                }

                if (lrwc.writercount < 1)
                {
                    _spinLock.Exit();
                    throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedWrite);
                }

                lrwc.writercount--;

                if (lrwc.writercount > 0)
                {
                    _spinLock.Exit();
                    return;
                }
            }

            Debug.Assert((_owners & WRITER_HELD) > 0, "Calling ReleaseWriterLock when no write lock is held");

            ClearWriterAcquired();

            _writeLockOwnerId = -1;

            ExitAndWakeUpAppropriateWaiters();
        }

        public void ExitUpgradeableReadLock()
        {
            ReaderWriterCount lrwc;
            if (!_fIsReentrant)
            {
                if (Environment.CurrentManagedThreadId != _upgradeLockOwnerId)
                {
                    //You have to be holding the upgrade lock to make this call.
                    throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedUpgrade);
                }
                _spinLock.Enter(EnterSpinLockReason.ExitAnyRead);
            }
            else
            {
                _spinLock.Enter(EnterSpinLockReason.ExitAnyRead);
                lrwc = GetThreadRWCount(true);

                if (lrwc == null)
                {
                    _spinLock.Exit();
                    throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedUpgrade);
                }

                if (lrwc.upgradecount < 1)
                {
                    _spinLock.Exit();
                    throw new SynchronizationLockException(SR.SynchronizationLockException_MisMatchedUpgrade);
                }

                lrwc.upgradecount--;

                if (lrwc.upgradecount > 0)
                {
                    _spinLock.Exit();
                    return;
                }

                _fUpgradeThreadHoldingRead = false;
            }

            _owners--;
            _upgradeLockOwnerId = -1;

            ExitAndWakeUpAppropriateWaiters();
        }

        /// <summary>
        /// A routine for lazily creating a event outside the lock (so if errors
        /// happen they are outside the lock and that we don't do much work
        /// while holding a spin lock).  If all goes well, reenter the lock and
        /// set 'waitEvent' 
        /// </summary>
        private void LazyCreateEvent(ref EventWaitHandle waitEvent, EnterLockType enterLockType)
        {
#if DEBUG
            Debug.Assert(_spinLock.IsHeld);
            Debug.Assert(waitEvent == null);
#endif

            _spinLock.Exit();

            var newEvent =
                new EventWaitHandle(
                    false,
                    enterLockType == EnterLockType.Read ? EventResetMode.ManualReset : EventResetMode.AutoReset);

            EnterSpinLockReason enterMyLockReason;
            switch (enterLockType)
            {
                case EnterLockType.Read:
                case EnterLockType.UpgradeableRead:
                    enterMyLockReason = EnterSpinLockReason.EnterAnyRead | EnterSpinLockReason.Wait;
                    break;

                case EnterLockType.Write:
                    enterMyLockReason = EnterSpinLockReason.EnterWrite | EnterSpinLockReason.Wait;
                    break;

                default:
                    Debug.Assert(enterLockType == EnterLockType.UpgradeToWrite);
                    enterMyLockReason = EnterSpinLockReason.UpgradeToWrite | EnterSpinLockReason.Wait;
                    break;
            }
            _spinLock.Enter(enterMyLockReason);

            if (waitEvent == null)          // maybe someone snuck in. 
                waitEvent = newEvent;
            else
                newEvent.Dispose();
        }

        /// <summary>
        /// Waits on 'waitEvent' with a timeout  
        /// Before the wait 'numWaiters' is incremented and is restored before leaving this routine.
        /// </summary>
        private bool WaitOnEvent(
            EventWaitHandle waitEvent,
            ref uint numWaiters,
            TimeoutTracker timeout,
            EnterLockType enterLockType)
        {
#if DEBUG
            Debug.Assert(_spinLock.IsHeld);
#endif

            WaiterStates waiterSignaledState = WaiterStates.None;
            EnterSpinLockReason enterMyLockReason;
            switch (enterLockType)
            {
                case EnterLockType.UpgradeableRead:
                    waiterSignaledState = WaiterStates.UpgradeableReadWaiterSignaled;
                    goto case EnterLockType.Read;

                case EnterLockType.Read:
                    enterMyLockReason = EnterSpinLockReason.EnterAnyRead;
                    break;

                case EnterLockType.Write:
                    waiterSignaledState = WaiterStates.WriteWaiterSignaled;
                    enterMyLockReason = EnterSpinLockReason.EnterWrite;
                    break;

                default:
                    Debug.Assert(enterLockType == EnterLockType.UpgradeToWrite);
                    enterMyLockReason = EnterSpinLockReason.UpgradeToWrite;
                    break;
            }

            // It was not possible to acquire the RW lock because some other thread was holding some type of lock. The other
            // thread, when it releases its lock, will wake appropriate waiters. Along with resetting the wait event, clear the
            // waiter signaled bit for this type of waiter if applicable, to indicate that a waiter of this type is no longer
            // signaled.
            //
            // If the waiter signaled bit is not updated upon event reset, the following scenario would lead to deadlock:
            //   - Thread T0 signals the write waiter event or the upgradeable read waiter event to wake a waiter
            //   - There are no threads waiting on the event, but T1 is in WaitOnEvent() after exiting the spin lock and before
            //     actually waiting on the event (that is, it's recorded that there is one waiter for the event). It remains in
            //     this region for a while, in the repro case it typically gets context-switched out.
            //   - T2 acquires the RW lock in some fashion that blocks T0 or T3 from acquiring the RW lock
            //   - T0 or T3 fails to acquire the RW lock enough times for it to enter WaitOnEvent for the same event as T1
            //   - T0 or T3 resets the event
            //   - T2 releases the RW lock and does not wake a waiter because the reset at the previous step lost a signal but
            //     _waiterStates was not updated to reflect that
            //   - T1 and other threads begin waiting on the event, but there's no longer any thread that would wake them
            if (waiterSignaledState != WaiterStates.None && (_waiterStates & waiterSignaledState) != WaiterStates.None)
            {
                _waiterStates &= ~waiterSignaledState;
            }
            waitEvent.Reset();

            numWaiters++;
            HasNoWaiters = false;

            //Setting these bits will prevent new readers from getting in.
            if (_numWriteWaiters == 1)
                SetWritersWaiting();
            if (_numWriteUpgradeWaiters == 1)
                SetUpgraderWaiting();

            bool waitSuccessful = false;
            _spinLock.Exit();      // Do the wait outside of any lock

            try
            {
                waitSuccessful = waitEvent.WaitOne(timeout.RemainingMilliseconds);
            }
            finally
            {
                _spinLock.Enter(enterMyLockReason);

                --numWaiters;

                if (waitSuccessful &&
                    waiterSignaledState != WaiterStates.None &&
                    (_waiterStates & waiterSignaledState) != WaiterStates.None)
                {
                    // Indicate that a signaled waiter of this type has woken. Since non-read waiters are signaled to wake one
                    // at a time, we avoid waking up more than one waiter of that type upon successive enter/exit loops until
                    // the signaled thread actually wakes up. For example, if there are multiple write waiters and one thread is
                    // repeatedly entering and exiting a write lock, every exit would otherwise signal a different write waiter
                    // to wake up unnecessarily when only one woken waiter may actually succeed in entering the write lock.
                    _waiterStates &= ~waiterSignaledState;
                }

                if (_numWriteWaiters == 0 && _numWriteUpgradeWaiters == 0 && _numUpgradeWaiters == 0 && _numReadWaiters == 0)
                    HasNoWaiters = true;

                if (_numWriteWaiters == 0)
                    ClearWritersWaiting();
                if (_numWriteUpgradeWaiters == 0)
                    ClearUpgraderWaiting();

                if (!waitSuccessful)        // We may also be about to throw for some reason.  Exit myLock.
                {
                    if (enterLockType >= EnterLockType.Write)
                    {
                        // Write waiters block read waiters from acquiring the lock. Since this was the last write waiter, try
                        // to wake up the appropriate read waiters.
                        ExitAndWakeUpAppropriateReadWaiters();
                    }
                    else
                    {
                        _spinLock.Exit();
                    }
                }
            }
            return waitSuccessful;
        }

        /// <summary>
        /// Determines the appropriate events to set, leaves the locks, and sets the events. 
        /// </summary>
        private void ExitAndWakeUpAppropriateWaiters()
        {
#if DEBUG
            Debug.Assert(_spinLock.IsHeld);
#endif
            if (HasNoWaiters)
            {
                _spinLock.Exit();
                return;
            }

            ExitAndWakeUpAppropriateWaitersPreferringWriters();
        }

        private void ExitAndWakeUpAppropriateWaitersPreferringWriters()
        {
            uint readercount = GetNumReaders();

            //We need this case for EU->ER->EW case, as the read count will be 2 in
            //that scenario.
            if (_fIsReentrant)
            {
                if (_numWriteUpgradeWaiters > 0 && _fUpgradeThreadHoldingRead && readercount == 2)
                {
                    _spinLock.Exit();      // Exit before signaling to improve efficiency (wakee will need the lock)
                    _waitUpgradeEvent.Set();     // release all upgraders (however there can be at most one). 
                    return;
                }
            }

            if (readercount == 1 && _numWriteUpgradeWaiters > 0)
            {
                //We have to be careful now, as we are dropping the lock. 
                //No new writes should be allowed to sneak in if an upgrade
                //was pending. 

                _spinLock.Exit();      // Exit before signaling to improve efficiency (wakee will need the lock)
                _waitUpgradeEvent.Set();     // release all upgraders (however there can be at most one).            
            }
            else if (readercount == 0 && _numWriteWaiters > 0)
            {
                // Check if a waiter of the same type has already been signaled but hasn't woken yet. If so, avoid signaling
                // and waking another waiter unnecessarily.
                WaiterStates signaled = _waiterStates & WaiterStates.WriteWaiterSignaled;
                if (signaled == WaiterStates.None)
                {
                    _waiterStates |= WaiterStates.WriteWaiterSignaled;
                }

                _spinLock.Exit();      // Exit before signaling to improve efficiency (wakee will need the lock)

                if (signaled == WaiterStates.None)
                {
                    _writeEvent.Set();   // release one writer. 
                }
            }
            else
            {
                ExitAndWakeUpAppropriateReadWaiters();
            }
        }

        private void ExitAndWakeUpAppropriateReadWaiters()
        {
#if DEBUG
            Debug.Assert(_spinLock.IsHeld);
#endif

            if (_numWriteWaiters != 0 || _numWriteUpgradeWaiters != 0 || HasNoWaiters)
            {
                _spinLock.Exit();
                return;
            }

            Debug.Assert(_numReadWaiters != 0 || _numUpgradeWaiters != 0);

            bool setReadEvent = _numReadWaiters != 0;
            bool setUpgradeEvent = _numUpgradeWaiters != 0 && _upgradeLockOwnerId == -1;
            if (setUpgradeEvent)
            {
                // Check if a waiter of the same type has already been signaled but hasn't woken yet. If so, avoid signaling
                // and waking another waiter unnecessarily.
                if ((_waiterStates & WaiterStates.UpgradeableReadWaiterSignaled) == WaiterStates.None)
                {
                    _waiterStates |= WaiterStates.UpgradeableReadWaiterSignaled;
                }
                else
                {
                    setUpgradeEvent = false;
                }
            }

            _spinLock.Exit();    // Exit before signaling to improve efficiency (wakee will need the lock)

            if (setReadEvent)
                _readEvent.Set();  // release all readers. 

            if (setUpgradeEvent)
                _upgradeEvent.Set(); //release one upgrader.
        }

        private bool IsWriterAcquired()
        {
            return (_owners & ~WAITING_WRITERS) == 0;
        }

        private void SetWriterAcquired()
        {
            _owners |= WRITER_HELD;    // indicate we have a writer.
        }

        private void ClearWriterAcquired()
        {
            _owners &= ~WRITER_HELD;
        }

        private void SetWritersWaiting()
        {
            _owners |= WAITING_WRITERS;
        }

        private void ClearWritersWaiting()
        {
            _owners &= ~WAITING_WRITERS;
        }

        private void SetUpgraderWaiting()
        {
            _owners |= WAITING_UPGRADER;
        }

        private void ClearUpgraderWaiting()
        {
            _owners &= ~WAITING_UPGRADER;
        }

        private uint GetNumReaders()
        {
            return _owners & READER_MASK;
        }

        private bool ShouldSpinForEnterAnyRead()
        {
            // If there is a write waiter or write upgrade waiter, the waiter would block a reader from acquiring the RW lock
            // because the waiter takes precedence. In that case, the reader is not likely to make progress by spinning.
            // Although another thread holding a write lock would prevent this thread from acquiring a read lock, it is by
            // itself not a good enough reason to skip spinning.
            return HasNoWaiters || (_numWriteWaiters == 0 && _numWriteUpgradeWaiters == 0);
        }

        private bool ShouldSpinForEnterAnyWrite(bool isUpgradeToWrite)
        {
            // If there is a write upgrade waiter, the waiter would block a writer from acquiring the RW lock because the waiter
            // holds a read lock. In that case, the writer is not likely to make progress by spinning. Regarding upgrading to a
            // write lock, there is no type of waiter that would block the upgrade from happening. Although another thread
            // holding a read or write lock would prevent this thread from acquiring the write lock, it is by itself not a good
            // enough reason to skip spinning.
            return isUpgradeToWrite || _numWriteUpgradeWaiters == 0;
        }

        private static void SpinWait(int spinCount)
        {
            const int LockSpinCycles = 20;

            //Exponential back-off
            if ((spinCount < 5) && (ProcessorCount > 1))
            {
                RuntimeThread.SpinWait(LockSpinCycles * spinCount);
            }
            else
            {
                RuntimeThread.Sleep(0);
            }

            // Don't want to Sleep(1) in this spin wait:
            //   - Don't want to spin for that long, since a proper wait will follow when the spin wait fails. The artificial
            //     delay introduced by Sleep(1) will in some cases be much longer than desired.
            //   - Sleep(1) would put the thread into a wait state, and a proper wait will follow when the spin wait fails
            //     anyway, so it's preferable to put the thread into the proper wait state
        }

        public void Dispose()
        {
            Dispose(true);
        }

        private void Dispose(bool disposing)
        {
            if (disposing && !_fDisposed)
            {
                if (WaitingReadCount > 0 || WaitingUpgradeCount > 0 || WaitingWriteCount > 0)
                    throw new SynchronizationLockException(SR.SynchronizationLockException_IncorrectDispose);

                if (IsReadLockHeld || IsUpgradeableReadLockHeld || IsWriteLockHeld)
                    throw new SynchronizationLockException(SR.SynchronizationLockException_IncorrectDispose);

                if (_writeEvent != null)
                {
                    _writeEvent.Dispose();
                    _writeEvent = null;
                }

                if (_readEvent != null)
                {
                    _readEvent.Dispose();
                    _readEvent = null;
                }

                if (_upgradeEvent != null)
                {
                    _upgradeEvent.Dispose();
                    _upgradeEvent = null;
                }

                if (_waitUpgradeEvent != null)
                {
                    _waitUpgradeEvent.Dispose();
                    _waitUpgradeEvent = null;
                }

                _fDisposed = true;
            }
        }

        public bool IsReadLockHeld
        {
            get
            {
                if (RecursiveReadCount > 0)
                    return true;
                else
                    return false;
            }
        }

        public bool IsUpgradeableReadLockHeld
        {
            get
            {
                if (RecursiveUpgradeCount > 0)
                    return true;
                else
                    return false;
            }
        }

        public bool IsWriteLockHeld
        {
            get
            {
                if (RecursiveWriteCount > 0)
                    return true;
                else
                    return false;
            }
        }

        public LockRecursionPolicy RecursionPolicy
        {
            get
            {
                if (_fIsReentrant)
                {
                    return LockRecursionPolicy.SupportsRecursion;
                }
                else
                {
                    return LockRecursionPolicy.NoRecursion;
                }
            }
        }

        public int CurrentReadCount
        {
            get
            {
                int numreaders = (int)GetNumReaders();

                if (_upgradeLockOwnerId != -1)
                    return numreaders - 1;
                else
                    return numreaders;
            }
        }


        public int RecursiveReadCount
        {
            get
            {
                int count = 0;
                ReaderWriterCount lrwc = GetThreadRWCount(true);
                if (lrwc != null)
                    count = lrwc.readercount;

                return count;
            }
        }

        public int RecursiveUpgradeCount
        {
            get
            {
                if (_fIsReentrant)
                {
                    int count = 0;

                    ReaderWriterCount lrwc = GetThreadRWCount(true);
                    if (lrwc != null)
                        count = lrwc.upgradecount;

                    return count;
                }
                else
                {
                    if (Environment.CurrentManagedThreadId == _upgradeLockOwnerId)
                        return 1;
                    else
                        return 0;
                }
            }
        }

        public int RecursiveWriteCount
        {
            get
            {
                if (_fIsReentrant)
                {
                    int count = 0;

                    ReaderWriterCount lrwc = GetThreadRWCount(true);
                    if (lrwc != null)
                        count = lrwc.writercount;

                    return count;
                }
                else
                {
                    if (Environment.CurrentManagedThreadId == _writeLockOwnerId)
                        return 1;
                    else
                        return 0;
                }
            }
        }

        public int WaitingReadCount
        {
            get
            {
                return (int)_numReadWaiters;
            }
        }

        public int WaitingUpgradeCount
        {
            get
            {
                return (int)_numUpgradeWaiters;
            }
        }

        public int WaitingWriteCount
        {
            get
            {
                return (int)_numWriteWaiters;
            }
        }

        private struct SpinLock
        {
            private int _isLocked;

            /// <summary>
            /// Used to deprioritize threads attempting to enter the lock when they would not make progress after doing so.
            /// <see cref="EnterSpin(EnterSpinLockReason)"/> avoids acquiring the lock as long as the operation for which it
            /// was called is deprioritized.
            /// 
            /// Layout:
            /// - Low 16 bits: Number of threads that have deprioritized an enter-any-write operation
            /// - High 16 bits: Number of threads that have deprioritized an enter-any-read operation
            /// </summary>
            private int _enterDeprioritizationState;

            // Layout-specific constants for _enterDeprioritizationState
            private const int DeprioritizeEnterAnyReadIncrement = 1 << 16;
            private const int DeprioritizeEnterAnyWriteIncrement = 1;

            // The variables controlling spinning behavior of this spin lock
            private const int LockSpinCycles = 20;
            private const int LockSpinCount = 10;
            private const int LockSleep0Count = 5;
            private const int DeprioritizedLockSleep1Count = 5;

            private static int GetEnterDeprioritizationStateChange(EnterSpinLockReason reason)
            {
                EnterSpinLockReason operation = reason & EnterSpinLockReason.OperationMask;
                switch (operation)
                {
                    case EnterSpinLockReason.EnterAnyRead:
                        return 0;

                    case EnterSpinLockReason.ExitAnyRead:
                        // A read lock is held until this thread is able to exit it, so deprioritize enter-write threads as they
                        // will not be able to make progress
                        return DeprioritizeEnterAnyWriteIncrement;

                    case EnterSpinLockReason.EnterWrite:
                        // Writers are typically much less frequent and much less in number than readers. Waiting writers take
                        // precedence over new read attempts in order to let current readers release their lock and allow a
                        // writer to obtain the lock. Before a writer can register as a waiter though, the presence of just
                        // relatively few enter-read spins can easily starve the enter-write from even entering this lock,
                        // delaying its spin loop for an unreasonable duration.
                        //
                        // Deprioritize enter-read to preference enter-write. This makes it easier for enter-write threads to
                        // starve enter-read threads. However, writers can already by design starve readers. A waiting writer
                        // blocks enter-read threads and a new enter-write that needs to wait will be given precedence over
                        // previously waiting enter-read threads. So this is not a new problem, and the RW lock is designed for
                        // scenarios where writers are rare compared to readers.
                        return DeprioritizeEnterAnyReadIncrement;

                    default:
                        Debug.Assert(
                            operation == EnterSpinLockReason.UpgradeToWrite ||
                            operation == EnterSpinLockReason.EnterRecursiveWrite ||
                            operation == EnterSpinLockReason.ExitAnyWrite);

                        // UpgradeToWrite:
                        // - A read lock is held and an exit-read is not nearby, so deprioritize enter-write threads as they
                        //   will not be able to make progress. This thread also intends to enter a write lock, so deprioritize
                        //   enter -read threads as well, see case EnterSpinLockReason.EnterWrite for the rationale.
                        // EnterRecursiveWrite, ExitAnyWrite:
                        // - In both cases, a write lock is held until this thread is able to exit it, so deprioritize
                        //   enter -read and enter-write threads as they will not be able to make progress
                        return DeprioritizeEnterAnyReadIncrement + DeprioritizeEnterAnyWriteIncrement;
                }
            }

            private ushort EnterForEnterAnyReadDeprioritizedCount
            {
                get
                {
                    Debug.Assert(DeprioritizeEnterAnyReadIncrement == (1 << 16));
                    return (ushort)((uint)_enterDeprioritizationState >> 16);
                }
            }

            private ushort EnterForEnterAnyWriteDeprioritizedCount
            {
                get
                {
                    Debug.Assert(DeprioritizeEnterAnyWriteIncrement == 1);
                    return (ushort)_enterDeprioritizationState;
                }
            }

            private bool IsEnterDeprioritized(EnterSpinLockReason reason)
            {
                Debug.Assert((reason & EnterSpinLockReason.Wait) != 0 || reason == (reason & EnterSpinLockReason.OperationMask));
                Debug.Assert(
                    (reason & EnterSpinLockReason.Wait) == 0 ||
                    (reason & EnterSpinLockReason.OperationMask) == EnterSpinLockReason.EnterAnyRead ||
                    (reason & EnterSpinLockReason.OperationMask) == EnterSpinLockReason.EnterWrite ||
                    (reason & EnterSpinLockReason.OperationMask) == EnterSpinLockReason.UpgradeToWrite);

                switch (reason)
                {
                    default:
                        Debug.Assert(
                            (reason & EnterSpinLockReason.Wait) != 0 ||
                            reason == EnterSpinLockReason.ExitAnyRead ||
                            reason == EnterSpinLockReason.EnterRecursiveWrite ||
                            reason == EnterSpinLockReason.ExitAnyWrite);
                        return false;

                    case EnterSpinLockReason.EnterAnyRead:
                        return EnterForEnterAnyReadDeprioritizedCount != 0;

                    case EnterSpinLockReason.EnterWrite:
                        Debug.Assert((GetEnterDeprioritizationStateChange(reason) & DeprioritizeEnterAnyWriteIncrement) == 0);
                        return EnterForEnterAnyWriteDeprioritizedCount != 0;

                    case EnterSpinLockReason.UpgradeToWrite:
                        Debug.Assert((GetEnterDeprioritizationStateChange(reason) & DeprioritizeEnterAnyWriteIncrement) != 0);
                        return EnterForEnterAnyWriteDeprioritizedCount > 1;
                }
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            private bool TryEnter()
            {
                return Interlocked.CompareExchange(ref _isLocked, 1, 0) == 0;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Enter(EnterSpinLockReason reason)
            {
                if (!TryEnter())
                {
                    EnterSpin(reason);
                }
            }

            private void EnterSpin(EnterSpinLockReason reason)
            {
                int deprioritizationStateChange = GetEnterDeprioritizationStateChange(reason);
                if (deprioritizationStateChange != 0)
                {
                    Interlocked.Add(ref _enterDeprioritizationState, deprioritizationStateChange);
                }

                int processorCount = ProcessorCount;
                for (int spinIndex = 0; ; spinIndex++)
                {
                    if (spinIndex < LockSpinCount && processorCount > 1)
                    {
                        RuntimeThread.SpinWait(LockSpinCycles * (spinIndex + 1)); // Wait a few dozen instructions to let another processor release lock.
                    }
                    else if (spinIndex < (LockSpinCount + LockSleep0Count))
                    {
                        RuntimeThread.Sleep(0);   // Give up my quantum.
                    }
                    else
                    {
                        RuntimeThread.Sleep(1);   // Give up my quantum.
                    }

                    if (!IsEnterDeprioritized(reason))
                    {
                        if (_isLocked == 0 && TryEnter())
                        {
                            if (deprioritizationStateChange != 0)
                            {
                                Interlocked.Add(ref _enterDeprioritizationState, -deprioritizationStateChange);
                            }
                            return;
                        }
                        continue;
                    }

                    // It's possible for an Enter thread to be deprioritized for an extended duration. It's undesirable for a
                    // deprioritized thread to keep waking up to spin despite a Sleep(1) when a large number of such threads are
                    // involved. After a threshold of Sleep(1)s, ignore the deprioritization and enter this lock to allow this
                    // thread to stop spinning and hopefully enter a proper wait state.
                    Debug.Assert(
                        reason == EnterSpinLockReason.EnterAnyRead ||
                        reason == EnterSpinLockReason.EnterWrite ||
                        reason == EnterSpinLockReason.UpgradeToWrite);
                    if (spinIndex >= (LockSpinCount + LockSleep0Count + DeprioritizedLockSleep1Count))
                    {
                        reason |= EnterSpinLockReason.Wait;
                        spinIndex = -1;
        