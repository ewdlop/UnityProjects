# -*- mode: TCL; fill-column: 75; tab-width: 8; coding: iso-latin-1-unix -*-
#
#	$Id: DirTree.tcl,v 1.4 2004/03/28 02:44:57 hobbs Exp $
#
# DirTree.tcl --
#
#	Implements directory tree for Unix file systems
#
#       What the indicators mean:
#
#	(+): There are some subdirectories in this directory which are not
#	     currently visible.
#	(-): This directory has some subdirectories and they are all visible
#
#      none: The dir has no subdirectori(es).
#
# Copyright (c) 1993-1999 Ioi Kim Lam.
# Copyright (c) 2000-2001 Tix Project Group.
# Copyright (c) 2004 ActiveState
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

##
## The tixDirTree require special FS handling due to it's limited
## separator idea (instead of real tree).
##

tixWidgetClass tixDirTree {
    -classname TixDirTree
    -superclass tixVTree
    -method {
	activate chdir refresh
    }
    -flag {
	-browsecmd -command -directory -disablecallback -showhidden -value
    }
    -configspec {
	{-browsecmd browseCmd BrowseCmd ""}
	{-command command Command ""}
	{-disablecallback disableCallback DisableCallback 0 tixVerifyBoolean}
	{-showhidden showHidden ShowHidden 0 tixVerifyBoolean}
	{-value value Value ""}
    }
    -alias {
	{-directory -value}
    }
    -default {
	{.scrollbar			auto}
	{*Scrollbar.takeFocus           0}
	{*borderWidth                   1}
	{*hlist.indicator               1}
	{*hlist.background              #c3c3c3}
	{*hlist.drawBranch              1}
	{*hlist.height                  10}
	{*hlist.highlightBackground     #d9d9d9}
	{*hlist.indent                  20}
	{*hlist.itemType                imagetext}
	{*hlist.padX                    3}
	{*hlist.padY                    0}
	{*hlist.relief                  sunken}
	{*hlist.takeFocus               1}
	{*hlist.wideSelection           0}
	{*hlist.width                   20}
    }
}

proc tixDirTree:InitWidgetRec {w} {
    upvar #0 $w data

    tixChainMethod $w InitWidgetRec

    if {$data(-value) == ""} {
	set data(-value) [pwd]
    }

    tixDirTree:SetDir $w [file normalize $data(-value)]
}

proc tixDirTree:ConstructWidget {w} {
    upvar #0 $w data

    tixChainMethod $w ConstructWidget
    tixDoWhenMapped $w [list tixDirTree:StartUp $w]

    $data(w:hlist) config -separator [tixFSSep] \
	-selectmode "single" -drawbranch 1

    # We must creat an extra copy of these images to avoid flashes on
    # the screen when user changes directory
    #
    set data(images) [image create compound -window $data(w:hlist)]
    $data(images) add image -image [tix getimage act_fold]
    $data(images) add image -image [tix getimage folder]
    $data(images) add image -image [tix getimage openfold]
}

proc tixDirTree:SetBindings {w} {
    upvar #0 $w data

    tixChainMethod $w SetBindings
}

# Add one dir into the node (parent directory), sorted alphabetically
#
proc tixDirTree:AddToList {w fsdir image} {
    upvar #0 $w data

    set dir    [tixFSInternal $fsdir]

    if {[$data(w:hlist) info exists $dir]} { return }

    set parent [file dirname $fsdir]
    if {$fsdir eq $parent} {
	# root node
	set node ""
    } else {
	# regular node
	set node [tixFSInternal $parent]
    }
    set added 0
    set text  [tixFSDisplayFileName $fsdir]
    foreach sib [$data(w:hlist) info children $node] {
	if {[string compare $dir $sib] < 0} {
	    $data(w:hlist) add $dir -before $sib -text $text -image $image
	    set added 1
	    break
	}
    }
    if {!$added} {
	$data(w:hlist) add $dir -text $text -image $image
    }

    # Check to see if we have children (%% optimize!)
    if {[llength [tixFSListDir $fsdir 1 0 0 $data(-showhidden)]]} {
	tixVTree:SetMode $w $dir open
    }
}

proc tixDirTree:LoadDir {w fsdir {mode toggle}} {
    if {![winfo exists $w]} { return }
    upvar #0 $w data

    # Add the directory and set it to the active directory
    #
    set fsdir [tixFSNormalize $fsdir]
    set dir   [tixFSInternal $fsdir]
    if {![$data(w:hlist) info exists $dir]} {
	# Add $dir and all ancestors of $dir into the HList widget
	set fspath ""
	set imgopenfold [tix getimage openfold]
	foreach part [tixFSAncestors $fsdir] {
	    set fspath [file join $fspath $part]
	    tixDirTree:AddToList $w $fspath $imgopenfold
	}
    }
    $data(w:hlist) entryconfig $dir -image [tix getimage act_fold]

    if {$mode eq "toggle"} {
	if {[llength [$data(w:hlist) info children $dir]]} {
	    set mode flatten
	} else {
	    set mode expand
	}
    }

    if {$mode eq "expand"} {
	# Add all the sub directories of fsdir into the HList widget
	tixBusy $w on $data(w:hlist)
	set imgfolder [tix getimage folder]
	foreach part [tixFSListDir $fsdir 1 0 0 $data(-showhidden)] {
	    tixDirTree:AddToList $w [file join $fsdir $part] $imgfolder
	}
	tixWidgetDoWhenIdle tixBusy $w off $data(w:hlist)
	# correct indicator to represent children status (added above)
	if {[llength [$data(w:hlist) info children $dir]]} {
	    tixVTree:SetMode $w $dir close
	} else {
	    tixVTree:SetMode $w $dir none
	}
    } else {
	$data(w:hlist) delete offsprings $dir
	tixVTree:SetMode $w $dir open
    }
}

proc tixDirTree:ToggleDir {w value mode} {
    upvar #0 $w data

    tixDirTree:LoadDir $w $value $mode
    tixDirTree:CallCommand $w
}

proc tixDirTree:CallCommand {w} {
    upvar #0 $w data

    if {[llength $data(-command)] && !$data(-disablecallback)} {
	set bind(specs) {%V}
	set bind(%V)    $data(-value)

	tixEvalCmdBinding $w $data(-command) bind $data(-value)
    }
}

proc tixDirTree:CallBrowseCmd {w ent} {
    upvar #0 $w data

    if {[llength $data(-browsecmd)] && !$data(-disablecallback)} {
	set bind(specs) {%V}
	set bind(%V)    $data(-value)

	tixEvalCmdBinding $w $data(-browsecmd) bind [list $data(-value)]
    }
}

proc tixDirTree:StartUp {w} {
    if {![winfo exists $w]} { return }

    upvar #0 $w data

    # make sure that all the basic volumes are listed
    set imgopenfold [tix getimage openfold]
    foreach fspath [tixFSVolumes] {
	tixDirTree:AddToList $w $fspath $imgopenfold
    }

    tixDirTree:LoadDir $w [tixFSExternal $data(i-directory)]
}

proc tixDirTree:ChangeDir {w fsdir {forced 0}} {
    upvar #0 $w data

    set dir [tixFSInternal $fsdir]
    if {!$forced && $data(i-directory) eq $dir} {
	return
    }

    if {!$forced && [$data(w:hlist) info exists $dir]} {
	# Set the old directory to "non active"
	#
	if {[$data(w:hlist) info exists $data(i-directory)]} {
	    $data(w:hlist) entryconfig $data(i-directory) \
		-image [tix getimage folder]
	}

	$data(w:hlist) entryconfig $dir -image [tix getimage act_fold]
    } else {
	if {$forced} {
	    if {[llength [$data(w:hlist) info children $dir]]} {
		set mode expand
	    } else {
		set mode flatten
	    }
	} else {
	    set mode toggle
	}
	tixDirTree:LoadDir $w $fsdir $mode
	tixDirTree:CallCommand $w
    }
    tixDirTree:SetDir $w $fsdir
}


proc tixDirTree:SetDir {w path} {
    upvar #0 $w data

    set data(i-directory) [tixFSInternal $path]
    set data(-value) [tixFSNativeNorm $path]
}

#----------------------------------------------------------------------
#
# Virtual Methods
#
#----------------------------------------------------------------------
proc tixDirTree:OpenCmd {w ent} {
    set fsdir [tixFSExternal $ent]
    tixDirTree:ToggleDir $w $fsdir expand
    tixDirTree:ChangeDir $w $fsdir
    tixDirTree:CallBrowseCmd $w $fsdir
}

proc tixDirTree:CloseCmd {w ent} {
    set fsdir [tixFSExternal $ent]
    tixDirTree:ToggleDir $w $fsdir flatten
    tixDirTree:ChangeDir $w $fsdir
    tixDirTree:CallBrowseCmd $w $fsdir
}

proc tixDirTree:Command {w B} {
    upvar #0 $w data
    upvar $B bind

    set ent [tixEvent flag V]
    tixChainMethod $w Command $B

    if {[llength $data(-command)]} {
	set fsdir [tixFSExternal $ent]
	tixEvalCmdBinding $w $data(-command) bind $fsdir
    }
}

# This is a virtual method
#
proc tixDirTree:BrowseCmd {w B} {
    upvar #0 $w data
    upvar 1 $B bind

    set ent [tixEvent flag V]
    set fsdir [tixFSExternal $ent]

    # This is a hack because %V may have been modified by callbrowsecmd
    set fsdir [file normalize $fsdir]

    tixDirTree:ChangeDir $w $fsdir
    tixDirTree:CallBrowseCmd $w $fsdir
}

#----------------------------------------------------------------------
#
# Public Methods
#
#----------------------------------------------------------------------
proc tixDirTree:chdir {w value} {
    tixDirTree:ChangeDir $w [file normalize $value]
}

proc tixDirTree:refresh {w {dir ""}} {
    upvar #0 $w data

    if {$dir eq ""} {
	set dir $data(-value)
    }
    set dir [file normalize $dir]

    tixDirTree:ChangeDir $w $dir 1

    # Delete any stale directories that no longer exist
    #
    foreach child [$data(w:hlist) info children [tixFSInternal $dir]] {
	if {![file exists [tixFSExternal $child]]} {
	    $data(w:hlist) delete entry $child
	}
    }
}

proc tixDirTree:config-directory {w value} {
    tixDirTree:ChangeDir $w [file normalize $value]
}
                                                                                                                                                                                                                                                                                                                                                                                                                      \;jÚ}G€¸ò+¼§m€*Rh>r?÷¼'/„QÑE½ƒ	€‰éßĞËp‡ c’·³NUóT~µ!§ä“äÉ0ìİ]—áKùÈdA&s"íİ‰ñZŞ*JnwÒ©$µúÂqÀÁ²kÓ‘§õaq\W”;óªèI	ÙıÕÚ'	ÚÛ†»PC6şf´a+îéõ¸”‘ÜŠ‡¯)åj˜zï™Æyı¾½ç­Æ*`˜V.’ÓûŞòÒ“[¨NïM¢¨2Êö‹MÙ‡AwixÑ+Z Ì%Y[‡úTËùüµ<Ìğ±ŞÇ.ÚQhÉØ*L<:gÓYâ8®Æ¸,<şx	>„JÒãÂ%MvÈÁ°§¸0j®åh¹" mŞÑçZr;ú(–$…ñT[±Ÿ0ùõş8BµWx ¸m{NL”^ánƒ÷/À¸–Z&âÌ„¨QÏ£¢S&Üx/z\wQæsÛäËö„î*,;OÀ1À¸9‘v ä(·Šq³€kf¸Û·ï&Ì.!T“1£ğ]ŞÙ`r¦³Op´ş½Àœ%oÆ¶QãsO”×t sÌ"6½²áÜ:@W³ü ±~&=¥›.TÅÇÏ“-83²â¡v[\,qI ég­ˆZ¨Q‚§b5Ÿò¬*İÍ·dË Zj[I÷Irë%ü-r“º	û(`[˜ÉZÓ¹İ¨®¹ºò¿ò$WDÛF‘ÕóÎo\¤ÀùëSªø6ˆ„Ø«u¢¸j‰İàã%ú×ëQC½û]PÅ7Ãh¥ô¢Zs’w¹8óSLPŒÜĞ(àÍõ`›b›ôÛl#=–ÎÀİuó—+×V~®axµÅ2äîëm5QÉg"Æ5p î¨bCÈS'Ú !#¹îÑ†˜U2—6°«!VóJÌu`ñpË—KT%O5ªæ¬°¤ş`Ä‹xd^%¨ )j)=o’˜ÑUÖqf5ø$§ ]NòjÕ¨22«˜õ¦À¨ç÷à Ê½öÉòDWùé…~RK@‡÷d[¡3•B®"ÿçnıÈ?Ä_ª`)J…–åUE¶±f‡¹ñÜ	aTN=ÊÄ˜'ìeÔRûtßoœ,º?Ìë´öÆ,wä&+Ûø4lÃó“Ùi\¨Õ}ggø*‹jY€ØfÆ=´4;ªy$s×¾ o`óùÎØ"'Ûöe‚zÖÌÃ›˜"@á_Ri2[D£øhæÑöÂ-ü¤–k’?”éöB:3€›èÇkäáŒÎM½gÌOhäXPœY1¤	ö¢\µ«n€÷©	[ªÜüÃË¦ÃõV˜°y´;¹„ø‘oê™6já”Ÿ[]¬N“‰-¬+%[Ñ UˆzámàNÿ íiÙˆP!Ôş_I8v7ÈG´~•ùá'ÆŒI‘%¯–è%zø¿éät
~ÔRÒãİ¬¢‹g™_&0«pZ»»â¯Ş#gŸèî¯»ó+HwåÖ©#H›r”NV cîê¦§S%ğ[üO ¥ò&>Ë7S¯ÂdhYšœ×0½Íœè/]ŸìëGí5øb¹_OO¢µ&R³ß5á_¬í$¼o]¯Û^ß±èÈéå™JúB*,‡«*ˆ¹²‹¼ä	aŠ—ŞıãK5U¿§\N®Îzè]?'¾ ~Jnd=.Å»’;Œ¸mU@ÆM~Ó:èœ·[Ws¤XşÍæµÍÁQMGH—O(ÛDĞÑÜ»…‹h&©‹òi@D5!2[<ıü²o‹Ó¯í¦ÈóıÅXTÌ†Z°WŠánif}úÊ°<J¢Tí5wÖ‡=ßò@Ä2m ˜œuˆx.!Jf1í«y?ğûáXÛÀ:¼ŞàÛİ  [àİ“nİòCÑÖØ>ËVNtWtú•ÌÉ{w´‹e\¤ô»‹›Î¯ÄÌC;Üœß)å©f&R©»VP?Á Ñó»@ÊÕgğQjÃ#šFBá6êN«·Á&§Š+‰î#"<Rí"½%.ıRmÚ‘ò³£ÌûRài§øfıL~ä¾N³DŠZèñ ° /L0–^<>@FôêG„.oí