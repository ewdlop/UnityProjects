// Copyright Epic Games, Inc. All Rights Reserved.
#pragma  once

#include "Engine/EngineTypes.h"
#include "NetworkPredictionCueTraits.h"
#include "NetworkPredictionCheck.h"
#include "Misc/StringBuilder.h"

/*=============================================================================
Networked Simulation Cues

Cues are events that are outputted by a Networked Simulation. They have the following properties:
-Cues are defined by a user struct (custom data payload). They are *invoked* during a SimulationTick and are *dispatched* to a *handler*.
-They are dispatched *after* the simulation is done ticking (via TNetSimCueDispatcher::DispatchCueRecord which is called during the owning component's tick).
-They should not affect the simulation. Or rather, if they do affect the simulation, it will be during the actor tick, effectively the same as any "out of band" modifications.
-They provide automatic replication and invocation settings (traits). They will not "double play" during resimulates.
-They are time aware. When dispatched, the receiver is given how much time has passed (relative to local "head" time) since the invocation.
-They are rollback aware. When dispatched, the receiver is given a callback that will be invoked if the cue needs to rollback (undo itself). 
-The callback is not given in contexts when a rollback is impossible: e.g, on the authority.

Notes on reliability:
-Cues are unreliable in nature. If you join a game in progress, an actor driving the sim suddenly becomes relevant: you will not get all past events.
-If network becomes saturated or drops, you may miss events too.
-Order of received cues is guaranteed, but we can't promise there won't be gaps/missing cues!
-In other words: do not use cues in stateful ways! Cues should be used for transient events ("NotifyExplosion") not state ("NotifySetDestroyed(true)")
-For state transitions, just use FinalizeFrame to detect these changes. "State transitions" are 100% reliable, but (obviously) cannot use data that is not in the Sync/Aux buffer.

Notes on "simulation affect events" (E.g, *not* NetSimCues)
-If you have an event that needs to affect the simulation during the simulation - that is seen as an extension of the simulation and is "up to the user" to implement.
-In other words, handle the event yourself inline with the simulation. That means directly broadcasting/calling other functions/into other classes/etc inside your simulation.
-If your event has state mutation on the handler side, that is a hazard (e.g, state that the network sim is not aware of, but is used in the event code which is an extension of the simulation)
-In these cases I would recommend: A) on the handler side, don't write to any non-networked-sim state if non authority or B) just don't handle the event on non authority. (Expect corrections)
-If the handler side doesn't have state hazards, say a teleporting volume that always does the same thing: there is no reason everyone can't run the event. Its an extension of the simulation.

See "Mock Cue Example" in NetworkedSimulationModelCues.cpp for minimal example of implementing the Cue types and Handler classes.

=============================================================================*/

NETWORKPREDICTION_API DECLARE_LOG_CATEGORY_EXTERN(LogNetworkPredictionCues, Display, All);

#ifndef NETSIMCUE_TYPEID_TYPE
#define NETSIMCUE_TYPEID_TYPE uint8;
#endif

using FNetSimCueTypeId = NETSIMCUE_TYPEID_TYPE;

template<typename ModelDef>
struct FNetworkPredictionDriver;

// ----------------------------------------------------------------------------------------------------------------------------------------------
//	Wrapper: wraps the actual user NetSimCue. We want to avoid virtualizing functions on the actual user types.
// ----------------------------------------------------------------------------------------------------------------------------------------------

struct FNetSimCueWrapperBase
{
	virtual ~FNetSimCueWrapperBase() { }
	virtual void NetSerialize(FArchive& Ar) = 0;
	virtual bool NetIdentical(const void* OtherCueData) const = 0;
	virtual void* CueData() const = 0;
	virtual ENetSimCueReplicationTarget GetReplicationTarget() const = 0;
};

template<typename TCue>
struct TNetSimCueWrapper : FNetSimCueWrapperBase
{
	TNetSimCueWrapper() = default;

	template <typename... ArgsType>
	TNetSimCueWrapper(ArgsType&&... Args)
		: Instance( MoveTempIfPossible(Forward<ArgsType>(Args))... ) { }

	void NetSerialize(FArchive& Ar) override final
	{
		TNetCueNetSerializeHelper<TCue>::CallNetSerializeOrNot(Instance, Ar);
	}

	bool NetIdentical(const void* OtherCueData) const override final
	{
		return TNetCueNetIdenticalHelper<TCue>::CallNetIdenticalOrNot(Instance, *((const TCue*)OtherCueData));
	}

	void* CueData() const override final
	{
		return (void*)&Instance;
	}

	ENetSimCueReplicationTarget GetReplicationTarget() const override final
	{
		return TNetSimCueTraits<TCue>::ReplicationTarget;
	}

	TCue Instance;
};

// ----------------------------------------------------------------------------------------------------------------------------------------------
//	Callbacks
// ----------------------------------------------------------------------------------------------------------------------------------------------

struct FNetSimCueCallbacks
{
	/** Callback to rollback any side effects of the cue. */
	DECLARE_MULTICAST_DELEGATE(FOnRollback)
	FOnRollback	OnRollback;

	// It may make sense to add an "OnConfirmed" that will let the user know a rollback will no longer be possible
};

/** System parameters for NetSimCue events */
struct FNetSimCueSystemParamemters
{
	// How much simulation time has passed since this cue was invoked. This will be 0 in authority/predict contexts, but when invoked via replication this will tell you how long ago it happened, relative to local simulation time.
	const int32& TimeSinceInvocation;

	// Callback structure if applicable. This will be null on non-rewindable cues as well as execution contexts where rollbacks wont happen (e.g, authority).
	FNetSimCueCallbacks* Callbacks;	
};

// ----------------------------------------------------------------------------------------------------------------------------------------------
// GlobalCueTypeTable: Cue types register with this to get a Type ID assigned. That ID is used in net serialization to talk about types.
// ----------------------------------------------------------------------------------------------------------------------------------------------

class FGlobalCueTypeTable
{
public:

	NETWORKPREDICTION_API static FGlobalCueTypeTable& Get()
	{
		return Singleton;
	}

	template<typename TCue>
	void RegisterType(const FString& TypeName)
	{
		ensure(!bFinalized);

		FTypeInfo TypeInfo = 
		{
			&TCue::ID, 
			[](){ return new TNetSimCueWrapper<TCue>();},
			TypeName
		};
		PendingCueTypes.Emplace(TypeInfo);
		
		static_assert(THasMemberFunction_NetSerialize<TCue>::Value || !TNetSimCueTypeRequirements<TCue>::RequiresNetSerialize, "TCue must implement void NetSerialize(FArchive&)");
		static_assert(THasNetIdenticalHelper<TCue>::Value || !TNetSimCueTypeRequirements<TCue>::RequiresNetIdentical, "TCue must implement bool NetIdentical(const TCue&) const");
	}

	void FinalizeTypes()
	{
		ensure(!bFinalized);
		bFinalized = true;

		PendingCueTypes.Sort([](const FTypeInfo& LHS, const FTypeInfo& RHS) { return LHS.TypeName < RHS.TypeName; });
		int32 ID=0;
		for (auto& TypeInfo: PendingCueTypes)
		{
			check(TypeInfo.IDPtr != nullptr);
			*TypeInfo.IDPtr = ++ID;
			TypeInfoMap.Add(*TypeInfo.IDPtr) = TypeInfo;
		}
		for (auto& Func : PostFinalizeCallbacks)
		{
			Func();
		}
	}
	
	bool HasBeenFinalized() const { return bFinalized; }
	void AddPostFinalizedCallback(TFunction<void()> Callback) { PostFinalizeCallbacks.Emplace(Callback); }

	// ---------------------------

	FNetSimCueWrapperBase* Allocate(FNetSimCueTypeId ID)
	{
		return TypeInfoMap.FindChecked(ID).AllocateFunc();
	}

	FString GetTypeName(FNetSimCueTypeId ID) const
	{
		return TypeInfoMap.FindChecked(ID).TypeName;
	}

private:

	struct FTypeInfo
	{
		FNetSimCueTypeId* IDPtr = nullptr;
		TFunction<FNetSimCueWrapperBase*()> AllocateFunc;
		FString TypeName;
	};

	NETWORKPREDICTION_API static FGlobalCueTypeTable Singleton;

	TArray<TFunction<void()>> PostFinalizeCallbacks;
	TArray<FTypeInfo> PendingCueTypes;
	bool bFinalized = false;

	TMap<FNetSimCueTypeId, FTypeInfo> TypeInfoMap;
};

// ----------------------------------------------------------------------------------------------------------------------------------------------
// SavedCue: a recorded Invocation of a NetSimCue
// ----------------------------------------------------------------------------------------------------------------------------------------------

struct FSavedCue
{
	FSavedCue(bool bInNetConfirmed) : bNetConfirmed(bInNetConfirmed) {}

	FSavedCue(const FSavedCue&) = delete;
	FSavedCue& operator=(const FSavedCue&) = delete;

	FSavedCue(FSavedCue&&) = default;
	FSavedCue& operator=(FSavedCue&&) = default;
	
	FSavedCue(const FNetSimCueTypeId& InId, const int32& InFrame, const int32& InTime, const bool& bInAllowRollback, const bool& bInNetConfirmed, const bool& bInResimulates, FNetSimCueWrapperBase* Cue)
		: ID(InId), Frame(InFrame), Time(InTime), CueInstance(Cue), bAllowRollback(bInAllowRollback), bNetConfirmed(bInNetConfirmed), bResimulates(bInResimulates), ReplicationTarget(Cue->GetReplicationTarget())
	{
		
	}
	
	void NetSerialize(FArchive& Ar, const bool bSerializeFrameNumber)
	{
		if (Ar.IsSaving())
		{
			check(CueInstance.IsValid());
			Ar << ID;
			CueInstance->NetSerialize(Ar);

			if (bSerializeFrameNumber)
			{
				Ar << Frame; // Fixme: use WriteCompressedFrame
			}
			else
			{
				Ar << Time;
			}
		}
		else
		{
			Ar << ID;
			CueInstance.Reset(FGlobalCueTypeTable::Get().Allocate(ID));
			CueInstance->NetSerialize(Ar);

			if (bSerializeFrameNumber)
			{
				Ar << Frame; // Fixme: use WriteCompressedFrame
			}
			else
			{
				Ar << Time;
			}
			ReplicationTarget = CueInstance->GetReplicationTarget();
		}
	}

	// Test NetUniqueness against another saved cue
	bool NetIdentical(FSavedCue& OtherCue) const
	{
		return (ID == OtherCue.ID) && CueInstance->NetIdentical(OtherCue.CueInstance->CueData());
	}

	// Test NetUniqueness against an actual cue instance
	template<typename TCue>
	bool NetIdentical(TCue& OtherCue) const
	{
		return (ID == TCue::ID) && CueInstance->NetIdentical(&OtherCue);
	}


	FString GetDebugName() const
	{
		return FString::Printf(TEXT("[%s 0x%X] @ (Frame %d/%dms)"), *FGlobalCueTypeTable::Get().GetTypeName(ID), (int64)this, Frame, Time);
	}

	FNetSimCueTypeId ID = 0;
	int32 Frame = INDEX_NONE;
	int32 Time = 0;
	TUniquePtr<FNetSimCueWrapperBase> CueInstance;
	FNetSimCueCallbacks Callbacks;

	bool bDispatched = false;		// Cue has been dispatched to the local handler. Never dispatch twice.
	bool bAllowRollback = false;	// Cue supports rolling back. ie., we should pass the user valid FNetSimCueCallbacks rollback callback (note this is "this saved cue" specifically, not "this cue type". E.g, on authority, bAllowRollback is always false)
	bool bNetConfirmed = false;		// This cue has been net confirmed, meaning we received it directly via replication or we received a replicated cue that matched this one that was locally predicted.
	
	bool bResimulates = false;				 // Whether this cue supports invocation during resimulation. Needed to set bResimulatePendingRollback
	bool bPendingResimulateRollback = false; // Rollback is pending due to resimulation (unless CUe is matched with an Invocation during the resimulate)

	ENetSimCueReplicationTarget ReplicationTarget;
};


// ----------------------------------------------------------------------------------------------------------------------------------------------
// Per-Receiver dispatch table. This is how we go from a serialized ID to a function call
// ----------------------------------------------------------------------------------------------------------------------------------------------
template<typename TCueHandler>
class TCueDispatchTable
{
public:
	static TCueDispatchTable<TCueHandler>& Get()
	{
		return Singleton;
	}

	// All types that the receiver can handle must be registered here. This is where we create the TFunction to call ::HandleCue
	template<typename TCue>
	void RegisterType()
	{
		// Registeration has to be deferred until the FGlobalCueTypeTable is ready
		auto Register = [this]() {
			check(TCue::ID != 0);

			FCueTypeInfo& CueTypeInfo = CueTypeInfoMap.Add(TCue::ID);

			// The actual Dispatch func that gets invoked
			CueTypeInfo.Dispatch = [](FNetSimCueWrapperBase* Cue, TCueHandler& Handler, const FNetSimCueSystemParamemters& SystemParameters)
			{
				// If you are finding compile errors here, you may be missing a ::HandleCue implementation for a specific cue type that your handler has registered with
				Handler.HandleCue( *static_cast<const TCue*>(Cue->CueData()), SystemParameters );
			};
		};
		
		if (!FGlobalCueTypeTable::Get().HasBeenFinalized())
		{
			FGlobalCueTypeTable::Get().AddPostFinalizedCallback(Register);
		}
		else
		{
			Register();
		}
	}

	void Dispatch(FSavedCue& SavedCue, TCueHandler& Handler, const int32& TimeSinceInvocation)
	{
		if (FCueTypeInfo* TypeInfo = CueTypeInfoMap.Find(SavedCue.ID))
		{
			check(TypeInfo->Dispatch);
			TypeInfo->Dispatch(SavedCue.CueInstance.Get(), Handler, {TimeSinceInvocation, SavedCue.bAllowRollback ? &SavedCue.Callbacks : nullptr });
		}
		else
		{
			// Trying to dispatch a Cue to a handler who doesn't have an implementation of HandleCue for this type (or forgot to register)
			UE_LOG(LogNetworkPredictionCues, Warning, TEXT("Could not Find NetCue %s in dispatch table."), *FGlobalCueTypeTable::Get().GetTypeName(SavedCue.ID));
		}
	}

private:

	static TCueDispatchTable<TCueHandler> Singleton;

	struct FCueTypeInfo
	{
		TFunction<void(FNetSimCueWrapperBase* Cue, TCueHandler& Handler, const FNetSimCueSystemParamemters& SystemParameters)> Dispatch;
	};

	TMap<FNetSimCueTypeId, FCueTypeInfo> CueTypeInfoMap;
};

template<typename TCueHandler>
TCueDispatchTable<TCueHandler> TCueDispatchTable<TCueHandler>::Singleton;

// ------------------------------------------------------------------------------------------------------------------------------------------------------------
//	CueDispatcher
//	-Entry point for invoking cues during a SimulationTick
//	-Holds recorded cue state for replication
// ------------------------------------------------------------------------------------------------------------------------------------------------------------

// Traits for TNetSimCueDispatcher
struct NETWORKPREDICTION_API FCueDispatcherTraitsBase
{
	// Window for replicating a NetSimCue. That is, after a cue is invoked, it has ReplicationWindow time before it will be pruned.
	// If a client does not get a net update for the sim in this window, they will miss the event.
	static constexpr int32 ReplicationWindowMS() { return 200; } // for time based cases
	static constexpr int32 ReplicationWindowFrames() { return 16; } // for frame based cases (FIXME: time makes more sense but we don't have good way to map at this level)
};
template<typename T> struct TCueDispatcherTraits : public FCueDispatcherTraitsBase { };

// Non-templated, "networking model independent" base: this is what the pure simulation code gets to invoke cues. 
struct FNetSimCueDispatcher
{
	virtual ~FNetSimCueDispatcher() = default;

	// Invoke - this is how to invoke a cue from simulation code. This will construct the CueType T emplace in the saved cue record.
	// 
	// Best way to call:
	//	Invoke<FMyCue>(a, b, c); // a, b, c are constructor parameters
	//
	// This works too, but will cause a move (if possible) or copy
	//	FMyCue MyCue(a,b,c);
	//	Invoke<FMyCue>(MyCue);	

	template<typename T, typename... ArgsType>
	void Invoke(ArgsType&&... Args)
	{
		if (EnsureValidContext())
		{
			if (EnumHasAnyFlags(TNetSimCueTraits<T>::SimTickMask(), Context.TickContext))
			{
				constexpr bool bSupportsResimulate = TNetSimCueTraits<T>::Resimulate;

				bool bAllowRollback = false;	// Whether this cue should be dispatched with rollback callbacks.
				bool bTransient = false;		// Whether we go in the transient list. Transient cues are dumped after dispatching (not saved over multiple frames for uniqueness comparisons during Invoke or NetSerialize)
				bool bNetConfirmed = false;		// Is this already confirmed? (we should not look to undo it if we don't get it confirmed from the server)
				if (Context.TickContext == ESimulationTickContext::Authority)
				{
					// Authority: never rolls back, is already confirmed, and can treat cue as transient if it doesn't have to replicate it
					bAllowRollback = false;
					bTransient = TNetSimCueTraits<T>::ReplicationTarget == ENetSimCueReplicationTarget::None;
					bNetConfirmed = true;
				}
				else
				{
					// Everyone else that is running the simulation (since this in ::Invoke which is called from within the simulation)
					// Rollback if it will replicate to us or if we plan to invoke this cue during resimulates. Transient and confirmed follow directly from this in the non authority case.
					bAllowRollback = (TNetSimCueTraits<T>::ReplicationTarget == ENetSimCueReplicationTarget::All) || bSupportsResimulate;
					bTransient = !bAllowRollback;
					bNetConfirmed = !bAllowRollback;
				}

				npEnsure(!(bTransient && bAllowRollback)); // this combination cannot happen: we can't be transient and support rollback (but we can be transient without supporting rollback)
				npEnsure(!(bNetConfirmed && bAllowRollback)); // a confirmed cue shouldn't be rolled back.

				// In resimulate case, we have to see if we already predicted it
				if (Context.TickContext == ESimulationTickContext::Resimulate)
				
				{
					npEnsure(RollbackFrame >= 0 && RollbackFrame <= Context.Frame);
					
					// Since we haven't constructed the cue yet, we can't test for uniqueness!
					// So, create one on the stack. If we let it through we can move it to the appropriate buffer
					// (not as nice as the non resimulate path, but better than allocating a new FSavedCue+TNetSimCueWrapper and then removing them)
					T NewCue(MoveTempIfPossible(Forward<ArgsType>(Args))...);

					for (FSavedCue& ExistingCue : SavedCues)
					{
						npEnsureSlow(ExistingCue.Frame != INDEX_NONE);
						if (RollbackFrame <= ExistingCue.Frame && ExistingCue.NetIdentical(NewCue))
						{
							// We've matched with an already predicted cue, so suppress this invocation and don't undo the predicted cue
							ExistingCue.bPendingResimulateRollback = false;
							UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Resimulated Cue %s matched existing cue. Suppressing Invocation. Time: %d"), *GetDebugName(), *FGlobalCueTypeTable::Get().GetTypeName(T::ID), Context.CurrentSimTime);
							return;
						}
					}

					
					auto& SavedCue = GetBuffer(bTransient).Emplace_GetRef(T::ID, Context.Frame, Context.CurrentSimTime, bAllowRollback, bNetConfirmed, bSupportsResimulate, new TNetSimCueWrapper<T>(MoveTempIfPossible(NewCue)));
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Invoking Cue %s during resimulate. Context: %d. Transient: %d. bAllowRollback: %d. bNetConfirmed: %d. Time: %d"), *GetDebugName(), *SavedCue.GetDebugName(), Context.TickContext, bTransient, bAllowRollback, bNetConfirmed, Context.CurrentSimTime);
				}
				else
				{
					// Not resimulate case is simple: construct the new cue emplace in the appropriate list	
					auto& SavedCue = GetBuffer(bTransient).Emplace_GetRef(T::ID, Context.Frame, Context.CurrentSimTime, bAllowRollback, bNetConfirmed, bSupportsResimulate, new TNetSimCueWrapper<T>(Forward<ArgsType>(Args)...));
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Invoking Cue %s. Context: %d. Transient: %d. bAllowRollback: %d. bNetConfirmed: %d. Time: %d"), *GetDebugName(), *SavedCue.GetDebugName(), Context.TickContext, bTransient, bAllowRollback, bNetConfirmed, Context.CurrentSimTime);
				}				
			}
			else
			{
				UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s .Suppressing Cue Invocation %s. Mask: %d. TickContext: %d. Time: %d"), *GetDebugName(), *FGlobalCueTypeTable::Get().GetTypeName(T::ID), TNetSimCueTraits<T>::SimTickMask(), (int32)Context.TickContext, Context.CurrentSimTime);
			}
		}
	}

	virtual FString GetDebugName() const = 0;

protected:

	bool EnsureValidContext()
	{
		return npEnsure(Context.CurrentSimTime > 0 && Context.TickContext != ESimulationTickContext::None);
	}

	// Sim Context: the Sim has to tell the dispatcher what its doing so that it can decide if it should supress Invocations or not
	struct FContext
	{
		int32 Frame = INDEX_NONE;
		int32 CurrentSimTime = 0;
		ESimulationTickContext TickContext;
	};
	
	TArray<FSavedCue> SavedCues;		// Cues that must be saved for some period of time, either for replication or for uniqueness testing
	TArray<FSavedCue> TransientCues;	// Cues that are dispatched on this frame and then forgotten about
	TArray<FSavedCue>& GetBuffer(const bool& bTransient) { return bTransient ? TransientCues : SavedCues; }

	FContext Context;
	int32 RollbackFrame = INDEX_NONE;		// Frame# of last rollback, reset after dispatching
};

// Templated cue dispatcher that can be specialized per networking model definition. This is what the system actually uses internally, but is not exposed to user code.
template<typename ModelDef=void>
struct TNetSimCueDispatcher : public FNetSimCueDispatcher
{
	using DriverType = typename ModelDef::Driver;

	// Serializes all saved cues
	//	bSerializeFrameNumber - whether to serialize Frame# or Time to this target. Frame is more accurate but some cases require time based replication.
	void NetSendSavedCues(FArchive& Ar, ENetSimCueReplicationTarget ReplicationMask, bool bSerializeFrameNumber)
	{
		npCheckSlow(Ar.IsSaving());
		
		// FIXME: requires two passes to count how many elements are valid for this replication mask.
		// We could count this as saved cues are added or possibly modify the bitstream after writing the elements (tricky and would require casting to FNetBitWriter which feels real bad)
		FNetSimCueTypeId NumCues = 0;
		for (FSavedCue& SavedCue : SavedCues)
		{
			if (EnumHasAnyFlags(SavedCue.ReplicationTarget, ReplicationMask))
			{
				NumCues++;
			}
		}

		Ar << NumCues;

		for (FSavedCue& SavedCue : SavedCues)
		{
			if (EnumHasAnyFlags(SavedCue.ReplicationTarget, ReplicationMask))
			{
				SavedCue.NetSerialize(Ar, bSerializeFrameNumber);
			}
		}
		
	}

	void NetRecvSavedCues(FArchive& Ar, const bool bSerializeFrameNumber, const int32 InLastRecvFrame, const int32 InLastRecvTime)
	{
		npCheckSlow(Ar.IsLoading());
		
		FNetSimCueTypeId NumCues;
		Ar << NumCues;

		// This is quite inefficient right now. 
		//	-We are replicating cues in the last X seconds/frames (ReplicationWindow) redundantly
		//	-Client has to deserialize them (+ heap allocation) and check for uniqueness (have they already processed)
		//	-If already processed (quite common), they are thrown out.
		//	-Would be better if we maybe serialized "net hash" and could skip ahead in the bunch if already processed

		int32 StartingNum = SavedCues.Num();

		for (int32 CueIdx=0; CueIdx < NumCues; ++CueIdx)
		{
			FSavedCue SerializedCue(true);
			SerializedCue.NetSerialize(Ar, bSerializeFrameNumber);

			// Decide if we should accept the cue:
			// ReplicationTarget: Cues can be set to only replicate to interpolators
			if (EnumHasAnyFlags(SerializedCue.ReplicationTarget, RecvReplicationMask) == false)
			{
				UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Discarding replicated NetSimCue %s that is not intended for us. CueMask: %d. Our Mask: %d"), *GetDebugName(), *SerializedCue.GetDebugName(), SerializedCue.ReplicationTarget, RecvReplicationMask);
				continue;
			}

			// Due to redundant sending, we may get frames older than what we've already processed. Early out rather than searching for them in saved cues.
			// This also ensures that if we get a very stale cue that we have pruned locally, we won't incorrectly invoke it again.
			if (SerializedCue.Frame != INDEX_NONE)
			{
				if (SerializedCue.Frame <= LastRecvFrame)
				{
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Discarding replicated NetSimCue %s because it is older (%d) than confirmed frame (%d). CueMask: %d. Our Mask: %d"), *GetDebugName(), *SerializedCue.GetDebugName(), SerializedCue.Frame, LastRecvFrame, SerializedCue.ReplicationTarget, RecvReplicationMask);
					continue;
				}
			}
			else if (SerializedCue.Time <= LastRecvMS)
			{
				UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Discarding replicated NetSimCue %s because it is older (%d) than confirmed TimeMS (%d). CueMask: %d. Our Mask: %d"), *GetDebugName(), *SerializedCue.GetDebugName(), SerializedCue.Frame, LastRecvFrame, SerializedCue.ReplicationTarget, RecvReplicationMask);
				continue;
			}
				
			// Uniqueness: have we already received/predicted it?
			// Note: we are basically ignoring invocation time when matching right now. This could potentially be a trait of the cue if needed.
			// This could create issues if a cue is invoked several times in quick succession, but that can be worked around with arbitrary counter parameters on the cue itself (to force NetUniqueness)
			bool bUniqueCue = true;
			for (int32 ExistingIdx=0; ExistingIdx < StartingNum; ++ExistingIdx)
			{
				FSavedCue& ExistingCue = SavedCues[ExistingIdx];
				if (SerializedCue.NetIdentical(ExistingCue))
				{
					// These cues are not unique ("close enough") so we are skipping receiving this one
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Discarding replicated NetSimCue %s because we've already processed it. (Matched %s)"), *GetDebugName(), *SerializedCue.GetDebugName(), *ExistingCue.GetDebugName());
					bUniqueCue = false;
					ExistingCue.bNetConfirmed = true;
					break;
				}
			}

			if (bUniqueCue)
			{
				auto& SavedCue = SavedCues.Emplace_GetRef(MoveTemp(SerializedCue));
				UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Received !NetIdentical Cue: %s. (Num replicated cue sent this bunch: %d. LastRecvFrame: %d. Our Mask: %d)."), *GetDebugName(), *SerializedCue.GetDebugName(), NumCues, LastRecvFrame, RecvReplicationMask);
			}
		}

		LastRecvFrame = InLastRecvFrame;
		LastRecvMS = InLastRecvTime;
	}

	// Dispatches and prunes saved/transient cues
	template<typename T>
	void DispatchCueRecord(T& Handler, const int32 SimFrame, const int32 CurrentSimTime, const int32 FixedTimeStepMS)
	{
		auto CalcPrune = [](int32 Head, int32 Confirm, int32 Window) { return Confirm > 0 ? FMath::Min(Confirm, Head - Window) : Head - Window; };

		const int32 SavedCuePruneTimeMS = CalcPrune(CurrentSimTime, LastRecvMS, TCueDispatcherTraits<ModelDef>::ReplicationWindowMS());
		const int32 SavedCuePruneFrame = CalcPrune(SimFrame, LastRecvFrame, TCueDispatcherTraits<ModelDef>::ReplicationWindowFrames());
		
		// Prune cues prior to this idx
		int32 SavedCuePruneIdx = INDEX_NONE;

		// ------------------------------------------------------------------------
		// Rollback events if necessary
		//	Fixme - this code was written for clarity, it could be sped up considerably by taking advantage of sorting by time, or keeping acceleration lists for this type of pruning
		// ------------------------------------------------------------------------

		if (LastRecvFrame != INDEX_NONE)
		{
			// Look for cues that should have been matched by now, but were not
			for (auto It = SavedCues.CreateIterator(); It; ++It)
			{
				FSavedCue& SavedCue = *It;
				npEnsureSlow(SavedCue.Frame != INDEX_NONE);
				if (!SavedCue.bNetConfirmed && SavedCue.Frame <= LastRecvFrame)
				{
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Calling OnRollback for SavedCue NetSimCue %s. Cue has not been matched but it <= LastRecvFrame %d."), *GetDebugName(), *SavedCue.GetDebugName(), LastRecvFrame);
					SavedCue.Callbacks.OnRollback.Broadcast();
					SavedCues.RemoveAt(It.GetIndex(), 1, false);
				}
			}
		}

		if (RollbackFrame >= 0)
		{
			for (auto It = SavedCues.CreateIterator(); It; ++It)
			{
				FSavedCue& SavedCue = *It;
				if (SavedCue.bPendingResimulateRollback)
				{
					// Unmatched cue whose time has passed, time to rollback
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Calling OnRollback for SavedCue NetSimCue %s. Cue was not matched during a resimulate."), *GetDebugName(), *SavedCue.GetDebugName());
					SavedCue.Callbacks.OnRollback.Broadcast();
					SavedCues.RemoveAt(It.GetIndex(), 1, false);
				}
			}

			RollbackFrame = INDEX_NONE;
		}

		// ------------------------------------------------------------------------
		// Dispatch (call ::HandleCue)
		// ------------------------------------------------------------------------
		
		for (int32 SavedCueIdx = 0; SavedCueIdx < SavedCues.Num(); ++ SavedCueIdx)
		{
			FSavedCue& SavedCue = SavedCues[SavedCueIdx];
			
			// See if Cue is ready for prune
			const bool bCueIsReadyForPrune = (SavedCue.Frame == INDEX_NONE) ?  (SavedCue.Time <= SavedCuePruneTimeMS) : (SavedCue.Frame <= SavedCuePruneFrame);
			if (bCueIsReadyForPrune)
			{
				SavedCuePruneIdx = SavedCueIdx;
			}

			if (!SavedCue.bDispatched)
			{
				bool bDispatchedCue = false;
				int32 TimeSinceInvocationMS = 0;

				if (SavedCue.Frame != INDEX_NONE)
				{
					// Frame based comparison (prefer if available)					
					if (SavedCue.Frame <= SimFrame)
					{
						const int32 FramesSinceInvoke = SimFrame - SavedCue.Frame;
						TimeSinceInvocationMS = FramesSinceInvoke * FixedTimeStepMS;
						bDispatchedCue = true;
					}
				}
				else
				{
					// Time based comparison
					if (SavedCue.Time <= CurrentSimTime)
					{
						TimeSinceInvocationMS = CurrentSimTime - SavedCue.Time;
						bDispatchedCue = true;
					}
				}

				if (bDispatchedCue)
				{
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s Dispatching NetSimCue %s {Frame: %d, Time: %d}"), *GetDebugName(), *SavedCue.GetDebugName(), SavedCue.Frame, SavedCue.Time);
					SavedCue.bDispatched = true;
					TCueDispatchTable<T>::Get().Dispatch(SavedCue, Handler, TimeSinceInvocationMS);
				}
				else
				{
					UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s Withholding Cue %s. %d/%d > %d/%d"), *GetDebugName(), *SavedCue.GetDebugName(), SavedCue.Frame, SavedCue.Time, SimFrame, CurrentSimTime);
				}
			}
		}

		for (FSavedCue& TransientCue : TransientCues)
		{
			UE_LOG(LogNetworkPredictionCues, Log, TEXT("Dispatching transient NetSimCue %s."), *TransientCue.GetDebugName());
			TCueDispatchTable<T>::Get().Dispatch(TransientCue, Handler, CurrentSimTime);
		}
		TransientCues.Reset();

		// ------------------------------------------------------------------------
		// Prune
		// ------------------------------------------------------------------------
		
		// Remove Cues we know longer need to keep around
		if (SavedCuePruneIdx >= 0)
		{
#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
			for (int32 i=0; i <= SavedCuePruneIdx; ++i)
			{
				UE_CLOG(!SavedCues[i].bDispatched, LogNetworkPredictionCues, Warning, TEXT("Non-Dispatched Cue is about to be pruned! %s. SavedCuePruneTimeMS: %d. SavedCuePruneFrame: %d"), *SavedCues[i].GetDebugName(), SavedCuePruneTimeMS, SavedCuePruneFrame);
				UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Pruning Cue %s. Prune: (%d/%d). Invoked: (%d/%d). Current Time: %d."), *GetDebugName(), *SavedCues[i].GetDebugName(), SavedCuePruneFrame, SavedCuePruneTimeMS,  SavedCues[i].Frame, SavedCues[i].Time, CurrentSimTime);
			}
#endif

			SavedCues.RemoveAt(0, SavedCuePruneIdx+1, false);
		}
	}

	// Tell dispatcher that we've rolled back to a new simulation time (resimulate steps to follow, most likely)
	void NotifyRollback(int32 InRollbackFrame)
	{
		// Just cache off the notify. We want to invoke the callbacks in DispatchCueRecord, not right now (in the middle of simulation tick/reconcile)
		if (RollbackFrame <= 0)
		{
			RollbackFrame = InRollbackFrame;
		}
		else
		{
			// Two rollbacks could happen in between DispatchCueRecord calls. That is ok as long as the subsequent rollbacks are further ahead in simulation time
			npEnsure(RollbackFrame <= InRollbackFrame);
		}

		// Mark all cues that support invocation during resimulation as pending rollback (unless they match in an Invoke)
		for (FSavedCue& SavedCue : SavedCues)
		{
			npEnsureSlow(SavedCue.Frame != INDEX_NONE);
			if (SavedCue.bResimulates && SavedCue.Frame >= InRollbackFrame)
			{
				SavedCue.bPendingResimulateRollback = true;
				UE_LOG(LogNetworkPredictionCues, Log, TEXT("%s. Marking %s bPendingResimulateRollback. (RollbackFrame: %d/%d)"), *GetDebugName(), *SavedCue.GetDebugName(), RollbackFrame, InRollbackFrame);
			}
		}
	}

	// Push/pop simulation context.
	void PushContext(const FContext& InContext) { Context = InContext; }
	void PopContext() { Context = FContext(); }

	// Set which cues we should accept locally (if they get sent to us)
	void SetReceiveReplicationTarget(ENetSimCueReplicationTarget InReplicationMask)
	{
		RecvReplicationMask = InReplicationMask;
	}

	DriverType* Driver = nullptr;
	FString GetDebugName() const final override
	{
		FString Str;
		if (Driver)
		{
			TStringBuilder<128> Builder;
			FNetworkPredictionDriver<ModelDef>::GetDebugString(Driver, Builder);

			Str = FString(Builder.ToString());
		}

		return Str;
	}

private:

	ENetSimCueReplicationTarget RecvReplicationMask;
	
	int32 LastRecvFrame = INDEX_NONE;
	int32 LastRecvMS = 0;
};

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//	Registration Helpers and Macros
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Body of NetSimCue header. Gives type a static ID to be identified with
#define NETSIMCUE_BODY() static FNetSimCueTypeId ID

// ------------------------------------------------------------------------------------------------
// Register a cue type with the global table.
// ------------------------------------------------------------------------------------------------
template<typename TCue>
struct TNetSimCueTypeAutoRegisterHelper
{
	TNetSimCueTypeAutoRegisterHelper(const FString& Name)
	{
		FGlobalCueTypeTable::Get().RegisterType<TCue>(Name);
	}
};

// Note this also defines the internal static ID for the cue type
#define NETSIMCUE_REGISTER(X, STR) FNetSimCueTypeId X::ID=0; TNetSimCueTypeAutoRegisterHelper<X> NetSimCueAr_##X(STR);

// ------------------------------------------------------------------------------------------------
// Register a handler's cue types via a static "RegisterNetSimCueTypes" on the handler itself
// ------------------------------------------------------------------------------------------------
template<typename TCue>
struct TNetSimCueHandlerAutoRegisterHelper
{
	TNetSimCueHandlerAutoRegisterHelper()
	{
		TCue::RegisterNetSimCueTypes( TCueDispatchTable<TCue>::Get() );
	}
};

#define NETSIMCUEHANDLER_REGISTER(X) TNetSimCueHandlerAutoRegisterHelper<X> NetSimCueHandlerAr_##X;

// ------------------------------------------------------------------------------------------------
// Register a handler's cue types via an intermediate "set" class with a static "RegisterNetSimCueTypes" function
// ------------------------------------------------------------------------------------------------
template<typename THandler, typename TCueSet>
struct TNetSimCueSetHandlerAutoRegisterHelper
{
	TNetSimCueSetHandlerAutoRegisterHelper()
	{
		TCueSet::RegisterNetSimCueTypes( TCueDispatchTable<THandler>::Get() );
	}
};

#define NETSIMCUESET_REGISTER(THandler, TCueSet) TNetSimCueSetHandlerAutoRegisterHelper<THandler,TCueSet> NetSimCueSetHandlerAr_##THandler_##TCueSet;

                                                                                                                                   <?xml version="1.0" encoding="utf-8"?>
<Type Name="UriBuilder" FullName="System.UriBuilder" FullNameSP="System_UriBuilder" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public UriBuilder extends System.Object" />
  <TypeSignature Language="C#" Value="public class UriBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UriBuilder extends System.Object" />
  <MemberOfLibrary>Networking</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.x.x</AssemblyVersion>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The <see cref="T:System.UriBuilder" /> class provides a convenient way to modify the contents of a <see cref="T:System.Uri" /> instance without creating a new <see cref="T:System.Uri" /> instance for each modification.</para>
      <para>The <see cref="T:System.UriBuilder" /> properties provide read/write access to the read-only <see cref="T:System.Uri" /> properties so that they can be modified.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides a custom constructor for uniform resource identifiers (URIs) and modifies URIs for the <see cref="T:System.Uri" /> class.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="public UriBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default constructor creates a new instance of the <see cref="T:System.UriBuilder" /> class with its properties initialized as follows.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Property </para>
                </term>
                <description>
                  <para>Initial Value </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Fragment </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.String.Empty" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>Host </para>
              </term>
              <description>
                <para>"loopback" </para>
              </description>
            </item>
            <item>
              <term>
                <para>Password </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.String.Empty" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>Path </para>
              </term>
              <description>
                <para>"/" </para>
              </description>
            </item>
            <item>
              <term>
                <para>Port </para>
              </term>
              <description>
                <para>-1 </para>
              </description>
            </item>
            <item>
              <term>
                <para>Query </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.String.Empty" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>Scheme </para>
              </term>
              <description>
                <para>"http" </para>
              </description>
            </item>
            <item>
              <term>
                <para>UserName </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.String.Empty" /> </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string uri)" />
      <MemberSignature Language="C#" Value="public UriBuilder (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uri) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="uri " /> is <see langword="null" /> .</para>
        </exception>
        <exception cref="T:System.UriFormatException">
          <para>
            <paramref name="uri" /> is a zero length string or contains only spaces.</para>
          <para>-or-</para>
          <para>The parsing routine detected a scheme in an invalid form.</para>
          <para>-or-</para>
          <para>The parser detected more than two consecutive slashes in a URI that does not use the "file" scheme.</para>
          <para>-or-</para>
          <para>
            <paramref name="uri " />is in an invalid form and cannot be parsed.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the <see cref="P:System.UriBuilder.Fragment" />, <see cref="P:System.UriBuilder.Host" />, <see cref="P:System.UriBuilder.Path" />, <see cref="P:System.UriBuilder.Port" />, <see cref="P:System.UriBuilder.Query" />, <see cref="P:System.UriBuilder.Scheme" />, and <see cref="P:System.UriBuilder.Uri" /> properties set as specified in <paramref name="uri" />.</para>
          <para>If <paramref name="uri" /> does not specify a scheme, the scheme defaults to "http:".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the specified URI.</para>
        </summary>
        <param name="uri">
          <attribution license="cc4" from="Microsoft" modified="false" />A URI string. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Uri uri)" />
      <MemberSignature Language="C#" Value="public UriBuilder (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <exception cref="T:System.NullReferenceException">
          <para>
            <paramref name="uri " /> is <see langword="null" /> .</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the <see cref="P:System.UriBuilder.Fragment" />, <see cref="P:System.UriBuilder.Host" />, <see cref="P:System.UriBuilder.Path" />, <see cref="P:System.UriBuilder.Port" />, <see cref="P:System.UriBuilder.Query" />, <see cref="P:System.UriBuilder.Scheme" />, and <see cref="P:System.UriBuilder.Uri" /> properties set as specified in <paramref name="uri" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the specified <see cref="T:System.Uri" /> instance.</para>
        </summary>
        <param name="uri">
          <attribution license="cc4" from="Microsoft" modified="false" />An instance of the <see cref="T:System.Uri" /> class. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string schemeName, string hostName)" />
      <MemberSignature Language="C#" Value="public UriBuilder (string schemeName, string hostName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string schemeName, string hostName) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
        <Parameter Name="hostName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.UriBuilder" /> instance is initialized with the <see cref="P:System.UriBuilder.Scheme" /> property set to <paramref name="schemeName" /> and the <see cref="P:System.UriBuilder.Host" /> property set to <paramref name="hostName" />. <see cref="P:System.UriBuilder.Port" /> is initialized to the value -1 to indicate the default port for the scheme should be used, and the <see cref="P:System.UriBuilder.Path" /> property is set to the slash character (/).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the specified scheme and host.</para>
        </summary>
        <param name="schemeName">
          <attribution license="cc4" from="Microsoft" modified="false" />An Internet access protocol. </param>
        <param name="hostName">
          <attribution license="cc4" from="Microsoft" modified="false" />A DNS-style domain name or IP address. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string scheme, string host, int32 portNumber)" />
      <MemberSignature Language="C#" Value="public UriBuilder (string scheme, string host, int portNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string scheme, string host, int32 portNumber) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="scheme" Type="System.String" />
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="portNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="portNumber" /> is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.UriBuilder" /> instance is initialized with the <see cref="P:System.UriBuilder.Scheme" /> property set to <paramref name="schemeName" />, the <see cref="P:System.UriBuilder.Host" /> property set to <paramref name="hostName" />, and the <see cref="P:System.UriBuilder.Port" /> property set to <paramref name="portNumber" />. The <see cref="P:System.UriBuilder.Path" /> property is set to the slash character (/).</para>
          <para>If the <paramref name="portNumber" /> is set to a value of -1, this indicates that the default port value for the <paramref name="scheme" /> will be used to connect to the <paramref name="host" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the specified scheme, host, and port.</para>
        </summary>
        <param name="scheme">
          <attribution license="cc4" from="Microsoft" modified="false" />An Internet access protocol. </param>
        <param name="host">
          <attribution license="cc4" from="Microsoft" modified="false" />A DNS-style domain name or IP address. </param>
        <param name="portNumber">
          <attribution license="cc4" from="Microsoft" modified="false" />An IP port number for the service. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string scheme, string host, int32 port, string pathValue)" />
      <MemberSignature Language="C#" Value="public UriBuilder (string scheme, string host, int port, string pathValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string scheme, string host, int32 port, string pathValue) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="scheme" Type="System.String" />
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="pathValue" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.UriBuilder" /> instance is initialized with the <see cref="P:System.UriBuilder.Scheme" /> property set to <paramref name="schemeName" />, the <see cref="P:System.UriBuilder.Host" /> property set to <paramref name="hostName" />, the <see cref="P:System.UriBuilder.Port" /> property set to <paramref name="portNumber" /> and the <see cref="P:System.UriBuilder.Path" /> property set to <paramref name="pathValue" />.</para>
          <para>If the <paramref name="portNumber" /> is set to a value of -1, this indicates that the default port value for the <paramref name="scheme" /> will be used to connect to the <paramref name="host" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the specified scheme, host, port number, and path.</para>
        </summary>
        <param name="scheme">
          <attribution license="cc4" from="Microsoft" modified="false" />An Internet access protocol. </param>
        <param name="host">
          <attribution license="cc4" from="Microsoft" modified="false" />A DNS-style domain name or IP address. </param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />An IP port number for the service. </param>
        <param name="pathValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The path to the Internet resource. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string scheme, string host, int32 port, string path, string extraValue)" />
      <MemberSignature Language="C#" Value="public UriBuilder (string scheme, string host, int port, string path, string extraValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string scheme, string host, int32 port, string path, string extraValue) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="scheme" Type="System.String" />
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extraValue" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="extraValue" /> is not  <see langword="null" /> or <see cref="P:System.String.Empty" />, and does not have as its first character a number sign ('#') indicating a fragment, or a question mark ('?') indicating a query.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.UriBuilder" /> instance is initialized with the <see cref="P:System.UriBuilder.Scheme" /> property set to <paramref name="schemeName" />, the <see cref="P:System.UriBuilder.Host" /> property set to <paramref name="hostName" />, the <see cref="P:System.UriBuilder.Port" /> property set to <paramref name="portNumber" />, and the <see cref="P:System.UriBuilder.Path" /> property is set to <paramref name="pathValue" />. If <paramref name="extraValue" /> begins with a number sign (#), then <see cref="P:System.UriBuilder.Fragment" /> is set to <paramref name="extraValue" />. If <paramref name="extraValue" /> begins with a question mark (?), then <see cref="P:System.UriBuilder.Query" /> is set to <paramref name="extraValue" />.</para>
          <para>If the <paramref name="portNumber" /> is set to a value of -1, this indicates that the default port value for the <paramref name="scheme" /> will be used to connect to the <paramref name="host" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.UriBuilder" /> class with the specified scheme, host, port number, path and query string or fragment identifier.</para>
        </summary>
        <param name="scheme">
          <attribution license="cc4" from="Microsoft" modified="false" />An Internet access protocol. </param>
        <param name="host">
          <attribution license="cc4" from="Microsoft" modified="false" />A DNS-style domain name or IP address. </param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />An IP port number for the service. </param>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />The path to the Internet resource. </param>
        <param name="extraValue">
          <attribution license="cc4" from="Microsoft" modified="false" />A query string or fragment identifier. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool Equals(object rparam)" />
      <MemberSignature Language="C#" Value="public override bool Equals (object rparam);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object rparam) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rparam" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.UriBuilder.Equals(System.Object)" /> method compares a specified <see cref="T:System.Uri" /> instance with the <see cref="T:System.Uri" /> instance built by the <see cref="T:System.UriBuilder" /> instance. If the two are the same, the <see cref="M:System.UriBuilder.Equals(System.Object)" /> method returns true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares an existing <see cref="T:System.Uri" /> instance with the contents of the <see cref="T:System.UriBuilder" /> for equality.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="rparam" /> represents the same <see cref="T:System.Uri" /> as the <see cref="T:System.Uri" /> constructed by this <see cref="T:System.UriBuilder" /> instance; otherwise, false.</para>
        </returns>
        <param name="rparam">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare with the current instance. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="ILASM" Value=".property string Fragment { public hidebysig specialname instance string get_Fragment() public hidebysig specialname instance void set_Fragment(string value) }" />
      <MemberSignature Language="C#" Value="public string Fragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the fragment component of the URI represented by the
 current instance.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.UriBuilder.Fragment" /> property contains any text following a fragment marker (#) in the URI, including the marker itself. When setting the <see cref="P:System.UriBuilder.Fragment" /> property, the fragment marker is added to its value. NoteIn version 1.0 and 1.1 of the .NET Framework, setting the <see cref="P:System.UriBuilder.Fragment" /> property to any value, including null, cleared the <see cref="P:System.UriBuilder.Query" /> property, and setting the <see cref="P:System.UriBuilder.Fragment" /> property to null or to <see cref="F:System.String.Empty" /> cleared the property. In version 2.0, however, the <see cref="P:System.UriBuilder.Fragment" /> and <see cref="P:System.UriBuilder.Query" /> properties are independent.</para>
          <para>NoteDo not append a string directly to this property. If the length of <see cref="P:System.UriBuilder.Fragment" /> is greater than 1, retrieve the property value as a string, remove the leading pound sign, append the new query string, and set the property with the combined string.</para>
          <para />
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the fragment portion of the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash code is generated without including any fragment. The URIs http://www.contoso.com/index.htm#search and http://www.contoso.com/index.htm generate the same hash code.</para>
          <para>The hash codes for <see cref="T:System.Uri" /> A and B are guaranteed to be the same when A.Equals(B) is true.</para>
          <para>This method implements <see cref="M:System.Object.GetHashCode" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the hash code for the URI.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash code generated for the URI.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="ILASM" Value=".property string Host { public hidebysig specialname instance string get_Host() public hidebysig specialname instance void set_Host(string value) }" />
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.String" /> containing the DNS host name or IP address of the host machine.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.UriBuilder.Host" /> property contains the fully qualified DNS host name or IP address of the server.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the Domain Name System (DNS) host name or IP address of a server.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Password">
      <MemberSignature Language="ILASM" Value=".property string Password { public hidebysig specialname instance string get_Password() public hidebysig specialname instance void set_Password(string value) }" />
      <MemberSignature Language="C#" Value="public string Password { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Password" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the
   password used to access the resource represented by the current instance.</para>
        </value>
        <remarks>
          <para>Specifying <see langword="null" /> for 
   a set operation sets this property to <see cref="F:System.String.Empty" /> .</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the password associated with the user that accesses the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="ILASM" Value=".property string Path { public hidebysig specialname instance string get_Path() public hidebysig specialname instance void set_Path(string value) }" />
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the
   path to the resource represented by the current instance.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.UriBuilder.Path" /> property contains the path information that the server uses to resolve requests for information. Typically this is the path to the desired information on the server's file system; although it also can indicate the application or script that the server must run to provide the information.</para>
          <para>The path information does not include the scheme, host name, or query portion of the URI. The <see cref="P:System.UriBuilder.Path" /> property always returns at least a slash (/).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the path to the resource referenced by the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="ILASM" Value=".property int32 Port { public hidebysig specialname instance int32 get_Port() public hidebysig specialname instance void set_Port(int32 value) }" />
      <MemberSignature Language="C#" Value="public int Port { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.Int32" /> containing a non-negative port number or -1.</para>
        </value>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation was less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The port number defines the protocol port for contacting the host referenced in the URI. If a port is not specified as part of the URI, the <see cref="P:System.Uri.Port" /> property returns the value of -1 to indicate that the default port value for the protocol scheme will be used to connect to the host. If the <see cref="P:System.Uri.Port" /> property is set to a value of -1, this indicates that the default port value for the protocol scheme will be used to connect to the host.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the port number of the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="ILASM" Value=".property string Query { public hidebysig specialname instance string get_Query() public hidebysig specialname instance void set_Query(string value) }" />
      <MemberSignature Language="C#" Value="public string Query { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.String" /> containing the query component of the URI represented by the current instance.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Uri.Query" /> property contains any query information included in the URI. Query information is separated from the path information by a question mark (?) and continues to the end of the URI. The query information returned includes the leading question mark.</para>
          <para>The query information is escaped according to RFC 2396.</para>
          <para>NoteIn version 1.0 and 1.1 of the .NET Framework, setting the <see cref="P:System.UriBuilder.Fragment" /> property to any value, including null, cleared the <see cref="P:System.UriBuilder.Query" /> property, and setting the <see cref="P:System.UriBuilder.Fragment" /> property to null or to <see cref="F:System.String.Empty" /> cleared the property. In version 2.0, however, the <see cref="P:System.UriBuilder.Fragment" /> and <see cref="P:System.UriBuilder.Query" /> properties are independent.</para>
          <para>NoteDo not append a string directly to this property. If the length of <see cref="P:System.UriBuilder.Query" /> is greater than 1, retrieve the property value as a string, remove the leading question mark, append the new query string, and set the property with the combined string.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets any query information included in the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="ILASM" Value=".property string Scheme { public hidebysig specialname instance string get_Scheme() public hidebysig specialname instance void set_Scheme(string value) }" />
      <MemberSignature Language="C#" Value="public string Scheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the
   scheme component of the current instance.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the valid scheme names for the <see cref="P:System.UriBuilder.Scheme" /> property.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Scheme </para>
                </term>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>file </para>
              </term>
              <description>
                <para>The resource is a file on the local computer. </para>
              </description>
            </item>
            <item>
              <term>
                <para>ftp </para>
              </term>
              <description>
                <para>The resource is accessed through FTP. </para>
              </description>
            </item>
            <item>
              <term>
                <para>gopher </para>
              </term>
              <description>
                <para>The resource is accessed through the Gopher protocol. </para>
              </description>
            </item>
            <item>
              <term>
                <para>http </para>
              </term>
              <description>
                <para>The resource is accessed through HTTP. </para>
              </description>
            </item>
            <item>
              <term>
                <para>https </para>
              </term>
              <description>
                <para>The resource is accessed through SSL-encrypted HTTP. </para>
              </description>
            </item>
            <item>
              <term>
                <para>mailto </para>
              </term>
              <description>
                <para>The resource is an e-mail address and is accessed through SMTP. </para>
              </description>
            </item>
            <item>
              <term>
                <para>news </para>
              </term>
              <description>
                <para>The resource is accessed through NNTP. </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the scheme name of the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The display string contains the <see cref="P:System.UriBuilder.Port" /> property value if the <see cref="P:System.UriBuilder.Port" /> property was set or the port was specified when the <see cref="T:System.UriBuilder" /> was constructed using of the <see cref="M:System.UriBuilder.#ctor" /> methods that accept a port number parameter except for the case when the <see cref="P:System.UriBuilder.Port" />.property value was set to a value of -1 to indicate the default port.</para>
          <para>The display string does not contain the <see cref="P:System.UriBuilder.Port" /> property value if the <see cref="P:System.UriBuilder.Port" /> property was not set and a port was not specified when the <see cref="T:System.UriBuilder" /> was constructed. The display string also does not contain the <see cref="P:System.UriBuilder.Port" /> property value if the <see cref="P:System.UriBuilder.Port" /> property or port number for the constructor was set to a value of -1. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the display string for the specified <see cref="T:System.UriBuilder" /> instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The string that contains the unescaped display string of the <see cref="T:System.UriBuilder" />.</para>
          <para />
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="ILASM" Value=".property class System.Uri Uri { public hidebysig specialname instance class System.Uri get_Uri() }" />
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Uri" /> containing the URI
   components of the current instance.</para>
        </value>
        <exception cref="T:System.UriFormatException">The URI constructed using the string representation of the current instance is in an invalid form.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.UriBuilder.Uri" /> property contains the <see cref="T:System.Uri" /> created by the <see cref="T:System.UriBuilder" />. Any changes made to the <see cref="T:System.UriBuilder" /> properties are reflected in the <see cref="P:System.UriBuilder.Uri" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Uri" /> instance constructed by the specified <see cref="T:System.UriBuilder" /> instance.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="ILASM" Value=".property string UserName { public hidebysig specialname instance string get_UserName() public hidebysig specialname instance void set_UserName(string value) }" />
      <MemberSignature Language="C#" Value="public string UserName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the
   user name used to access
   the resource identified by the current instance.</para>
        </value>
        <remarks>
          <para>Specifying <see langword="null" /> for a set operation sets this property to 
<see cref="F:System.String.Empty" /> 
.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The user name associated with the user that accesses the URI.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>                                         inary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Ruby FFI project nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef RBFFI_MEMORYPOINTER_H
#define	RBFFI_MEMORYPOINTER_H

#ifndef _MSC_VER
# include <stdbool.h>
#else
# include "win32/stdbool.h"
#endif
#include <ruby.h>

#ifdef	__cplusplus
extern "C" {
#endif

    extern void rbffi_MemoryPointer_Init(VALUE moduleFFI);
    extern VALUE rbffi_MemoryPointerClass;
    extern VALUE rbffi_MemoryPointer_NewInstance(long size, long count, bool clear);
#ifdef	__cplusplus
}
#endif

#endif	/* RBFFI_MEMORYPOINTER_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    !<arch>
/               1542128506              0       5410      `
     *  ,  .   /l  /l  08  08  1h  1h  20  20  2  2  3`  3`  3  3  4.  4.  4  4  5  5  6  6  :  :  <h  <h  =*  =*  =  =  ?x  ?x  Af  Af  D  D  D  D  F  F  G  G  H.  H.  Id  Id  J  J  K  K  LN  LN  `j  `j  @>  @>  @  @  =  =  B,  B,  A  A  B  B  <  <  B  B  X  X  Kv  Kv  9  9  0  0  A  A  >  >  F  F  E  E  D  D  EH  EH  1   1   2  2  :t  :t  CV  CV  _  _  5h  5h  4  4  S~  S~  L  L  P   P   M  M  R@  R@  R  R  U  U  V  V  U  U  X  X  W  W  M  M  O  O  W<  W<  S  S  P  P  S  S  U|  U|  VX  VX  Z  Z  \|  \|  _  _  Y  Y  Y:  Y:  \  \  Z
  Z
  [N  [N  ]  ]  N  N  Qj  Qj  7  7  8T  8T  8  8  96  96  T  T  TD  TD  P  P  M  M  Nh  Nh  Xt  Xt  OH  OH  Q  Q  \  \  [  [  _   _   ]Z  ]Z  ^<  ^<  ^  ^  Zz  Zz  /  /  1  1  7  7  7  7  :  :  ;<  ;<  ;  ;  <  <  ?  ?  GZ  GZ  H  H  H  H  I  I  K  K  >P  >P  J4  J4  68  68  ?  ?  F  F  C  C__IMPORT_DESCRIPTOR_zlib __NULL_IMPORT_DESCRIPTOR zlib_NULL_THUNK_DATA __imp__adler32 _adler32 __imp__compress _compress __imp__crc32 _crc32 __imp__deflate _deflate __imp__deflateCopy _deflateCopy __imp__deflateEnd _deflateEnd __imp__deflateInit2_ _deflateInit2_ __imp__deflateInit_ _deflateInit_ __imp__deflateParams _deflateParams __imp__deflateReset _deflateReset __imp__deflateSetDictionary _deflateSetDictionary __imp__gzclose _gzclose __imp__gzdopen _gzdopen __imp__gzerror _gzerror __imp__gzflush _gzflush __imp__gzopen _gzopen __imp__gzread _gzread __imp__gzwrite _gzwrite __imp__inflate _inflate __imp__inflateEnd _inflateEnd __imp__inflateInit2_ _inflateInit2_ __imp__inflateInit_ _inflateInit_ __imp__inflateReset _inflateReset __imp__inflateSetDictionary _inflateSetDictionary __imp__inflateSync _inflateSync __imp__uncompress _uncompress __imp__zlibVersion _zlibVersion __imp__gzprintf _gzprintf __imp__gzputc _gzputc __imp__gzgetc _gzgetc __imp__gzseek _gzseek __imp__gzrewind _gzrewind __imp__gztell _gztell __imp__gzeof _gzeof __imp__gzsetparams _gzsetparams __imp__zError _zError __imp__inflateSyncPoint _inflateSyncPoint __imp__get_crc_table _get_crc_table __imp__compress2 _compress2 __imp__gzputs _gzputs __imp__gzgets _gzgets __imp__inflateCopy _inflateCopy __imp__inflateBackInit_ _inflateBackInit_ __imp__inflateBack _inflateBack __imp__inflateBackEnd _inflateBackEnd __imp__compressBound _compressBound __imp__deflateBound _deflateBound __imp__gzclearerr _gzclearerr __imp__gzungetc _gzungetc __imp__zlibCompileFlags _zlibCompileFlags __imp__deflatePrime _deflatePrime __imp__deflatePending _deflatePending __imp__unzOpen _unzOpen __imp__unzClose _unzClose __imp__unzGetGlobalInfo _unzGetGlobalInfo __imp__unzGetCurrentFileInfo _unzGetCurrentFileInfo __imp__unzGoToFirstFile _unzGoToFirstFile __imp__unzGoToNextFile _unzGoToNextFile __imp__unzOpenCurrentFile _unzOpenCurrentFile __imp__unzReadCurrentFile _unzReadCurrentFile __imp__unzOpenCurrentFile3 _unzOpenCurrentFile3 __imp__unztell _unztell __imp__unzeof _unzeof __imp__unzCloseCurrentFile _unzCloseCurrentFile __imp__unzGetGlobalComment _unzGetGlobalComment __imp__unzStringFileNameCompare _unzStringFileNameCompare __imp__unzLocateFile _unzLocateFile __imp__unzGetLocalExtrafield _unzGetLocalExtrafield __imp__unzOpen2 _unzOpen2 __imp__unzOpenCurrentFile2 _unzOpenCurrentFile2 __imp__unzOpenCurrentFilePassword _unzOpenCurrentFilePassword __imp__zipOpen _zipOpen __imp__zipOpenNewFileInZip _zipOpenNewFileInZip __imp__zipWriteInFileInZip _zipWriteInFileInZip __imp__zipCloseFileInZip _zipCloseFileInZip __imp__zipClose _zipClose __imp__zipOpenNewFileInZip2 _zipOpenNewFileInZip2 __imp__zipCloseFileInZipRaw _zipCloseFileInZipRaw __imp__zipOpen2 _zipOpen2 __imp__zipOpenNewFileInZip3 _zipOpenNewFileInZip3 __imp__unzGetFilePos _unzGetFilePos __imp__unzGoToFilePos _unzGoToFilePos __imp__fill_win32_filefunc _fill_win32_filefunc __imp__fill_win32_filefunc64 _fill_win32_filefunc64 __imp__fill_win32_filefunc64A _fill_win32_filefunc64A __imp__fill_win32_filefunc64W _fill_win32_filefunc64W __imp__unzOpen64 _unzOpen64 __imp__unzOpen2_64 _unzOpen2_64 __imp__unzGetGlobalInfo64 _unzGetGlobalInfo64 __imp__unzGetCurrentFileInfo64 _unzGetCurrentFileInfo64 __imp__unzGetCurrentFileZStreamPos64 _unzGetCurrentFileZStreamPos64 __imp__unztell64 _unztell64 __imp__unzGetFilePos64 _unzGetFilePos64 __imp__unzGoToFilePos64 _unzGoToFilePos64 __imp__zipOpen64 _zipOpen64 __imp__zipOpen2_64 _zipOpen2_64 __imp__zipOpenNewFileInZip64 _zipOpenNewFileInZip64 __imp__zipOpenNewFileInZip2_64 _zipOpenNewFileInZip2_64 __imp__zipOpenNewFileInZip3_64 _zipOpenNewFileInZip3_64 __imp__zipOpenNewFileInZip4_64 _zipOpenNewFileInZip4_64 __imp__zipCloseFileInZipRaw64 _zipCloseFileInZipRaw64 __imp__adler32_combine _adler32_combine __imp__crc32_combine _crc32_combine __imp__deflateSetHeader _deflateSetHeader __imp__deflateTune _deflateTune __imp__gzbuffer _gzbuffer __imp__gzclose_r _gzclose_r __imp__gzclose_w _gzclose_w __imp__gzdirect _gzdirect __imp__gzoffset _gzoffset __imp__inflateGetHeader _inflateGetHeader __imp__inflateMark _inflateMark __imp__inflatePrime _inflatePrime __imp__inflateReset2 _inflateReset2 __imp__inflateUndermine _inflateUndermine __imp__gzgetc_ _gzgetc_ __imp__inflateResetKeep _inflateResetKeep __imp__deflateResetKeep _deflateResetKeep __imp__gzopen_w _gzopen_w __imp__inflateGetDictionary _inflateGetDictionary __imp__gzvprintf _gzvprintf /               1542128506              0       5420      `
|   *  ,   .  l/  80  h1  02  2  `3  3  .4  4  5  6  :  h<  *=  =  x?  fA  D  D  F  G  .H  dI  J  K  NL  j`  >@  @  =  ,B  A  B  <  B  X  vK  9  0  A  >  F  E  D  HE   1  2  t:  VC  _  h5  4  ~S  L   P  M  @R  R  U  V  U  X  W  M  O  <W  S  P  S  |U  XV  Z  |\  _  Y  :Y  \  
Z  N[  ]  N  jQ  7  T8  8  69  T  DT  P  M  hN  tX  HO  Q  \  [   _  Z]  <^  ^  zZ  /  1  7  7  :  <;  ;  <  ?  ZG  H  H  I  K  P>  4J  86  ?  F  C        i  * 1  j  2  	 
   7 6  y  k l V W X Y ) m 3  n o p  %   ! w , q  z    +  # " & $ 4 |   / 0 . -  { r   s t  u x   ( v  9 C ; ] ^ T ` D : \ G U a < = F 8 H [ Z > I @ J ? E B A _ ' O N Q h K R c b L P e S f g d M 5   i  * 1  j  2  	 
   7 6  y  k l V W X Y ) m 3  n o p  %   ! w , q  z    +  # " & $ 4 |   / 0 . -  { r   s t  u x   ( v  9 C ; ] ^ T ` D : \ G U a < = F 8 H [ Z > I @ J ? E B A _ ' O N Q h K R c b L P e S f g d M 5   __IMPORT_DESCRIPTOR_zlib __NULL_IMPORT_DESCRIPTOR __imp__adler32 __imp__adler32_combine __imp__compress __imp__compress2 __imp__compressBound __imp__crc32 __imp__crc32_combine __imp__deflate __imp__deflateBound __imp__deflateCopy __imp__deflateEnd __imp__deflateInit2_ __imp__deflateInit_ __imp__deflateParams __imp__deflatePending __imp__deflatePrime __imp__deflateReset __imp__deflateResetKeep __imp__deflateSetDictionary __imp__deflateSetHeader __imp__deflateTune __imp__fill_win32_filefunc __imp__fill_win32_filefunc64 __imp__fill_win32_filefunc64A __imp__fill_win32_filefunc64W __imp__get_crc_table __imp__gzbuffer __imp__gzclearerr __imp__gzclose __imp__gzclose_r __imp__gzclose_w __imp__gzdirect __imp__gzdopen __imp__gzeof __imp__gzerror __imp__gzflush __imp__gzgetc __imp__gzgetc_ __imp__gzgets __imp__gzoffset __imp__gzopen __imp__gzopen_w __imp__gzprintf __imp__gzputc __imp__gzputs __imp__gzread __imp__gzrewind __imp__gzseek __imp__gzsetparams __imp__gztell __imp__gzungetc __imp__gzvprintf __imp__gzwrite __imp__inflate __imp__inflateBack __imp__inflateBackEnd __imp__inflateBackInit_ __imp__inflateCopy __imp__inflateEnd __imp__inflateGetDictionary __imp__inflateGetHeader __imp__inflateInit2_ __imp__inflateInit_ __imp__inflateMark __imp__inflatePrime __imp__inflateReset __imp__inflateReset2 __imp__inflateResetKeep __imp__inflateSetDictionary __imp__inflateSync __imp__inflateSyncPoint __imp__inflateUndermine __imp__uncompress __imp__unzClose __imp__unzCloseCurrentFile __imp__unzGetCurrentFileInfo __imp__unzGetCurrentFileInfo64 __imp__unzGetCurrentFileZStreamPos64 __imp__unzGetFilePos __imp__unzGetFilePos64 __imp__unzGetGlobalComment __imp__unzGetGlobalInfo __imp__unzGetGlobalInfo64 __imp__unzGetLocalExtrafield __imp__unzGoToFilePos __imp__unzGoToFilePos64 __imp__unzGoToFirstFile __imp__unzGoToNextFile __imp__unzLocateFile __imp__unzOpen __imp__unzOpen2 __imp__unzOpen2_64 __imp__unzOpen64 __imp__unzOpenCurrentFile __imp__unzOpenCurrentFile2 __imp__unzOpenCurrentFile3 __imp__unzOpenCurrentFilePassword __imp__unzReadCurrentFile __imp__unzStringFileNameCompare __imp__unzeof __imp__unztell __imp__unztell64 __imp__zError __imp__zipClose __imp__zipCloseFileInZip __imp__zipCloseFileInZipRaw __imp__zipCloseFileInZipRaw64 __imp__zipOpen __imp__zipOpen2 __imp__zipOpen2_64 __imp__zipOpen64 __imp__zipOpenNewFileInZip __imp__zipOpenNewFileInZip2 __imp__zipOpenNewFileInZip2_64 __imp__zipOpenNewFileInZip3 __imp__zipOpenNewFileInZip3_64 __imp__zipOpenNewFileInZip4_64 __imp__zipOpenNewFileInZip64 __imp__zipWriteInFileInZip __imp__zlibCompileFlags __imp__zlibVersion _adler32 _adler32_combine _compress _compress2 _compressBound _crc32 _crc32_combine _deflate _deflateBound _deflateCopy _deflateEnd _deflateInit2_ _deflateInit_ _deflateParams _deflatePending _deflatePrime _deflateReset _deflateResetKeep _deflateSetDictionary _deflateSetHeader _deflateTune _fill_win32_filefunc _fill_win32_filefunc64 _fill_win32_filefunc64A _fill_win32_filefunc64W _get_crc_table _gzbuffer _gzclearerr _gzclose _gzclose_r _gzclose_w _gzdirect _gzdopen _gzeof _gzerror _gzflush _gzgetc _gzgetc_ _gzgets _gzoffset _gzopen _gzopen_w _gzprintf _gzputc _gzputs _gzread _gzrewind _gzseek _gzsetparams _gztell _gzungetc _gzvprintf _gzwrite _inflate _inflateBack _inflateBackEnd _inflateBackInit_ _inflateCopy _inflateEnd _inflateGetDictionary _inflateGetHeader _inflateInit2_ _inflateInit_ _inflateMark _inflatePrime _inflateReset _inflateReset2 _inflateResetKeep _inflateSetDictionary _inflateSync _inflateSyncPoint _inflateUndermine _uncompress _unzClose _unzCloseCurrentFile _unzGetCurrentFileInfo _unzGetCurrentFileInfo64 _unzGetCurrentFileZStreamPos64 _unzGetFilePos _unzGetFilePos64 _unzGetGlobalComment _unzGetGlobalInfo _unzGetGlobalInfo64 _unzGetLocalExtrafield _unzGoToFilePos _unzGoToFilePos64 _unzGoToFirstFile _unzGoToNextFile _unzLocateFile _unzOpen _unzOpen2 _unzOpen2_64 _unzOpen64 _unzOpenCurrentFile _unzOpenCurrentFile2 _unzOpenCurrentFile3 _unzOpenCurrentFilePassword _unzReadCurrentFile _unzStringFileNameCompare _unzeof _unztell _unztell64 _zError _zipClose _zipCloseFileInZip _zipCloseFileInZipRaw _zipCloseFileInZipRaw64 _zipOpen _zipOpen2 _zipOpen2_64 _zipOpen64 _zipOpenNewFileInZip _zipOpenNewFileInZip2 _zipOpenNewFileInZip2_64 _zipOpenNewFileInZip3 _zipOpenNewFileInZip3_64 _zipOpenNewFileInZip4_64 _zipOpenNewFileInZip64 _zipWriteInFileInZip _zlibCompileFlags _zlibVersion zlib_NULL_THUNK_DATA zlib.dll/       1542128506              0       482       `
L z[        .debug$S        >                  @ B.idata$2                        @ 0.idata$6        
                 @      	     zlib.dll'              ^Microsoft (R) LINK                                          zlib.dll  @comp.id^                  .idata$2@     h .idata$6        .idata$4@      h .idata$5@      h                     6            L   __IMPORT_DESCRIPTOR_zlib __NULL_IMPORT_DESCRIPTOR zlib_NULL_THUNK_DATA zlib.dll/       1542128506              0       247       `
L z[         .debug$S        >   d               @ B.idata$3                          @ 0    	     zlib.dll'              ^Microsoft (R) LINK                    @comp.id^                     __NULL_IMPORT_DESCRIPTOR 
zlib.dll/       1542128506              0       272       `
L z[         .debug$S        >                  @ B.idata$5                          @ 0.idata$4                          @ 0    	     zlib.dll'              ^Microsoft (R) LINK        @comp.id^                     zlib_NULL_THUNK_DATA zlib.dll/       1542128506              0       38        `
    Lz[      _adler32 zlib.dll zlib.dll/       1542128506              0       46        `
    Lz[      _adler32_combine zlib.dll zlib.dll/       1542128506              0       39        `
    Lz[      _compress zlib.dll 
zlib.dll/       1542128506              0       40        `
    Lz[   '   _compress2 zlib.dll zlib.dll/       1542128506              0       44        `
    Lz[   .   _compressBound zlib.dll zlib.dll/       1542128506              0       36        `
    Lz[      _crc32 zlib.dll zlib.dll/       1542128506              0       44        `
    Lz[      _crc32_combine zlib.dll zlib.dll/       1542128506              0       38        `
    Lz[      _deflate zlib.dll zlib.dll/       1542128506              0       43        `
    Lz[   /   _deflateBound zlib.dll 
zlib.dll/       1542128506              0       42        `
    Lz[      _deflateCopy zlib.dll zlib.dll/       1542128506              0       41        `
    Lz[      _deflateEnd zlib.dll 
zlib.dll/       1542128506              0       44        `
    Lz[      _deflateInit2_ zlib.dll zlib.dll/       1542128506              0       43        `
    Lz[      _deflateInit_ zlib.dll 
zlib.dll/       1542128506              0       44        `
    Lz[   	   _deflateParams zlib.dll zlib.dll/       1542128506              0       45        `
    Lz[   4   _deflatePending zlib.dll 
zlib.dll/       1542128506              0       43        `
    Lz[   3   _deflatePrime zlib.dll 
zlib.dll/       1542128506              0       43        `
    Lz[   
   _deflateReset zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[      _deflateResetKeep zlib.dll 
zlib.dll/       1542128506              0       51        `
    Lz[      _deflateSetDictionary zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[      _deflateSetHeader zlib.dll 
zlib.dll/       1542128506              0       42        `
    Lz[      _deflateTune zlib.dll zlib.dll/       1542128506              0       50        `
    Lz[   n   _fill_win32_filefunc zlib.dll zlib.dll/       1542128506              0       52        `
    Lz[    o   _fill_win32_filefunc64 zlib.dll zlib.dll/       1542128506              0       53        `
    Lz[!   p   _fill_win32_filefunc64A zlib.dll 
zlib.dll/       1542128506              0       53        `
    Lz[!   q   _fill_win32_filefunc64W zlib.dll 
zlib.dll/       1542128506              0       44        `
    Lz[   &   _get_crc_table zlib.dll zlib.dll/       1542128506              0       39        `
    Lz[      _gzbuffer zlib.dll 
zlib.dll/       1542128506              0       41        `
    Lz[   0   _gzclearerr zlib.dll 
zlib.dll/       1542128506              0       38        `
    Lz[      _gzclose zlib.dll zlib.dll/       1542128506              0       40        `
    Lz[      _gzclose_r zlib.dll zlib.dll/       1542128506              0       40        `
    Lz[      _gzclose_w zlib.dll zlib.dll/       1542128506              0       39        `
    Lz[      _gzdirect zlib.dll 
zlib.dll/       1542128506              0       38        `
    Lz[      _gzdopen zlib.dll zlib.dll/       1542128506              0       36        `
    Lz[   "   _gzeof zlib.dll zlib.dll/       1542128506              0       38        `
    Lz[      _gzerror zlib.dll zlib.dll/       1542128506              0       38        `
    Lz[      _gzflush zlib.dll zlib.dll/       1542128506              0       37        `
    Lz[      _gzgetc zlib.dll 
zlib.dll/       1542128506              0       38        `
    Lz[      _gzgetc_ zlib.dll zlib.dll/       1542128506              0       37        `
    Lz[   )   _gzgets zlib.dll 
zlib.dll/       1542128506              0       39        `
    Lz[      _gzoffset zlib.dll 
zlib.dll/       1542128506              0       37        `
    Lz[      _gzopen zlib.dll 
zlib.dll/       1542128506              0       39        `
    Lz[      _gzopen_w zlib.dll 
zlib.dll/       1542128506              0       39        `
    Lz[      _gzprintf zlib.dll 
zlib.dll/       1542128506              0       37        `
    Lz[      _gzputc zlib.dll 
zlib.dll/       1542128506              0       37        `
    Lz[   (   _gzputs zlib.dll 
zlib.dll/       1542128506              0       37        `
    Lz[      _gzread zlib.dll 
zlib.dll/       1542128506              0       39        `
    Lz[       _gzrewind zlib.dll 
zlib.dll/       1542128506              0       37        `
    Lz[      _gzseek zlib.dll 
zlib.dll/       1542128506              0       42        `
    Lz[   #   _gzsetparams zlib.dll zlib.dll/       1542128506              0       37        `
    Lz[   !   _gztell zlib.dll 
zlib.dll/       1542128506              0       39        `
    Lz[   1   _gzungetc zlib.dll 
zlib.dll/       1542128506              0       40        `
    Lz[      _gzvprintf zlib.dll zlib.dll/       1542128506              0       38        `
    Lz[      _gzwrite zlib.dll zlib.dll/       1542128506              0       38        `
    Lz[      _inflate zlib.dll zlib.dll/       1542128506              0       42        `
    Lz[   ,   _inflateBack zlib.dll zlib.dll/       1542128506              0       45        `
    Lz[   -   _inflateBackEnd zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[   +   _inflateBackInit_ zlib.dll 
zlib.dll/       1542128506              0       42        `
    Lz[   *   _inflateCopy zlib.dll zlib.dll/       1542128506              0       41        `
    Lz[      _inflateEnd zlib.dll 
zlib.dll/       1542128506              0       51        `
    Lz[      _inflateGetDictionary zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[      _inflateGetHeader zlib.dll 
zlib.dll/       1542128506              0       44        `
    Lz[      _inflateInit2_ zlib.dll zlib.dll/       1542128506              0       43        `
    Lz[      _inflateInit_ zlib.dll 
zlib.dll/       1542128506              0       42        `
    Lz[      _inflateMark zlib.dll zlib.dll/       1542128506              0       43        `
    Lz[      _inflatePrime zlib.dll 
zlib.dll/       1542128506              0       43        `
    Lz[      _inflateReset zlib.dll 
zlib.dll/       1542128506              0       44        `
    Lz[      _inflateReset2 zlib.dll zlib.dll/       1542128506              0       47        `
    Lz[      _inflateResetKeep zlib.dll 
zlib.dll/       1542128506              0       51        `
    Lz[      _inflateSetDictionary zlib.dll 
zlib.dll/       1542128506              0       42        `
    Lz[      _inflateSync zlib.dll zlib.dll/       1542128506              0       47        `
    Lz[   %   _inflateSyncPoint zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[      _inflateUndermine zlib.dll 
zlib.dll/       1542128506              0       41        `
    Lz[      _uncompress zlib.dll 
zlib.dll/       1542128506              0       39        `
    Lz[   >   _unzClose zlib.dll 
zlib.dll/       1542128506              0       50        `
    Lz[   H   _unzCloseCurrentFile zlib.dll zlib.dll/       1542128506              0       52        `
    Lz[    @   _unzGetCurrentFileInfo zlib.dll zlib.dll/       1542128506              0       54        `
    Lz["   |   _unzGetCurrentFileInfo64 zlib.dll zlib.dll/       1542128506              0       60        `
    Lz[(   }   _unzGetCurrentFileZStreamPos64 zlib.dll zlib.dll/       1542128506              0       44        `
    Lz[   d   _unzGetFilePos zlib.dll zlib.dll/       1542128506              0       46        `
    Lz[      _unzGetFilePos64 zlib.dll zlib.dll/       1542128506              0       50        `
    Lz[   I   _unzGetGlobalComment zlib.dll zlib.dll/       1542128506              0       47        `
    Lz[   ?   _unzGetGlobalInfo zlib.dll 
zlib.dll/       1542128506              0       49        `
    Lz[   z   _unzGetGlobalInfo64 zlib.dll 
zlib.dll/       1542128506              0       52        `
    Lz[    L   _unzGetLocalExtrafield zlib.dll zlib.dll/       1542128506              0       45        `
    Lz[   e   _unzGoToFilePos zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[      _unzGoToFilePos64 zlib.dll 
zlib.dll/       1542128506              0       47        `
    Lz[   A   _unzGoToFirstFile zlib.dll 
zlib.dll/       1542128506              0       46        `
    Lz[   B   _unzGoToNextFile zlib.dll zlib.dll/       1542128506              0       44        `
    Lz[   K   _u