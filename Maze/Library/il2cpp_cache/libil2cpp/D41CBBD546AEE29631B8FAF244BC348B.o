// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2017 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.  


#include "PxcScratchAllocator.h"
#include "ScConstraintProjectionManager.h"
#include "ScBodySim.h"
#include "ScConstraintSim.h"
#include "ScConstraintInteraction.h"

using namespace physx;


namespace physx
{
namespace Sc
{

template<typename T, const PxU32 elementsPerBlock>
class ScratchAllocatorList
{
private:
	struct ElementBlock
	{
		PX_FORCE_INLINE ElementBlock() {}
		PX_FORCE_INLINE void init(PxU32 countAtStart) { next = NULL; count = countAtStart; }

		ElementBlock* next;
		PxU32 count;
		T elements[elementsPerBlock];
	};

	PX_FORCE_INLINE const ScratchAllocatorList& operator=(const ScratchAllocatorList&) {}


public:
	class Iterator
	{
		friend class ScratchAllocatorList;

	public:
		T const* getNext()
		{
			if (mCurrentBlock)
			{
				if (mIndex < mCurrentBlock->count)
				{
					return &mCurrentBlock->elements[mIndex++];
				}
				else
				{
					if (mCurrentBlock->next)
					{
						PX_ASSERT(mCurrentBlock->count == elementsPerBlock);
						mCurrentBlock = mCurrentBlock->next;
						PX_ASSERT(mCurrentBlock->count > 0);

						mIndex = 1;
						return &mCurrentBlock->elements[0];
					}
					else
						return NULL;
				}
			}
			else
				return NULL;
		}

	private:
		Iterator(const ElementBlock* startBlock) : mCurrentBlock(startBlock), mIndex(0) {}

	private:
		const ElementBlock* mCurrentBlock;
		PxU32 mIndex;
	};

	PX_FORCE_INLINE ScratchAllocatorList(PxcScratchAllocator& scratchAllocator) : mScratchAllocator(scratchAllocator)
	{
		mFirstBlock = reinterpret_cast<ElementBlock*>(scratchAllocator.alloc(sizeof(ElementBlock), true));
		if (mFirstBlock)
			mFirstBlock->init(0);

		mCurrentBlock = mFirstBlock;
	}

	PX_FORCE_INLINE ~ScratchAllocatorList()
	{
		freeMemory();
	}

	PX_FORCE_INLINE bool add(const T& element)
	{
		if (mCurrentBlock)
		{
			if (mCurrentBlock->count < elementsPerBlock)
			{
				mCurrentBlock->elements[mCurrentBlock->count] = element;
				mCurrentBlock->count++;
				return true;
			}
			else
			{
				PX_ASSERT(mCurrentBlock->next == NULL);
				PX_ASSERT(mCurrentBlock->count == elementsPerBlock);

				ElementBlock* newBlock = reinterpret_cast<ElementBlock*>(mScratchAllocator.alloc(sizeof(ElementBlock), true));
				if (newBlock)
				{
					newBlock->init(1);
					newBlock->elements[0] = element;
					mCurrentBlock->next = newBlock;
					mCurrentBlock = newBlock;
					return true;
				}
				else
					return false;
			}
		}
		else
			return false;
	}

	PX_FORCE_INLINE Iterator getIterator() const
	{
		return Iterator(mFirstBlock);
	}

	PX_FORCE_INLINE void freeMemory()
	{
		ElementBlock* block = mFirstBlock;

		while(block)
		{
			ElementBlock* blockToFree = block;
			block = block->next;

			mScratchAllocator.free(blockToFree);
		}
	}


private:
	PxcScratchAllocator& mScratchAllocator;
	ElementBlock* mFirstBlock;
	ElementBlock* mCurrentBlock;
};

}
}


Sc::ConstraintProjectionManager::ConstraintProjectionManager() : 
	mNodePool(PX_DEBUG_EXP("projectionNodePool"))
{
}


void Sc::ConstraintProjectionManager::addToPendingGroupUpdates(Sc::ConstraintSim& s)
{
	PX_ASSERT(!s.readFlag(ConstraintSim::ePENDING_GROUP_UPDATE));
	bool isNew = mPendingGroupUpdates.insert(&s);
	PX_UNUSED(isNew);
	PX_ASSERT(isNew);

	s.setFlag(ConstraintSim::ePENDING_GROUP_UPDATE);
}


void Sc::ConstraintProjectionManager::removeFromPendingGroupUpdates(Sc::ConstraintSim& s)
{
	PX_ASSERT(s.readFlag(ConstraintSim::ePENDING_GROUP_UPDATE));
	bool didExist = mPendingGroupUpdates.erase(&s);
	PX_UNUSED(didExist);
	PX_ASSERT(didExist);

	s.clearFlag(ConstraintSim::ePENDING_GROUP_UPDATE);
}


void Sc::ConstraintProjectionManager::addToPendingTreeUpdates(ConstraintGroupNode& n)
{
	PX_ASSERT(&n == &n.getRoot());
	PX_ASSERT(!n.readFlag(ConstraintGroupNode::ePENDING_TREE_UPDATE));
	bool isNew = mPendingTreeUpdates.insert(&n);
	PX_UNUSED(isNew);
	PX_ASSERT(isNew);

	n.raiseFlag(ConstraintGroupNode::ePENDING_TREE_UPDATE);
}


void Sc::ConstraintProjectionManager::removeFromPendingTreeUpdates(ConstraintGroupNode& n)
{
	PX_ASSERT(&n == &n.getRoot());
	PX_ASSERT(n.readFlag(ConstraintGroupNode::ePENDING_TREE_UPDATE));
	bool didExist = mPendingTreeUpdates.erase(&n);
	PX_UNUSED(didExist);
	PX_ASSERT(didExist);

	n.clearFlag(ConstraintGroupNode::ePENDING_TREE_UPDATE);
}


PX_INLINE Sc::ConstraintGroupNode* Sc::ConstraintProjectionManager::createGroupNode(BodySim& b)
{
	ConstraintGroupNode* n = mNodePool.construct(b);
	b.setConstraintGroup(n);
	return n;
}


//
// Implementation of UNION of 
// UNION-FIND algo.
// It also updates the group traversal
// linked list.
//
void Sc::ConstraintProjectionManager::groupUnion(ConstraintGroupNode& root0, ConstraintGroupNode& root1)
{
	// Should only get called for the roots
	PX_ASSERT(&root0 == root0.parent);
	PX_ASSERT(&root1 == root1.parent);

	if (&root0 != &root1)	//different groups?  If not, its already merged.
	{
		//UNION(this, other);	//union-find algo unites groups.
		ConstraintGroupNode* newRoot;
		ConstraintGroupNode* otherRoot;
		if (root0.rank > root1.rank)
		{
			//hisGroup appended to mygroup.
			newRoot = &root0;
			otherRoot = &root1;
		}
		else
		{
			//myGroup appended to hisGroup. 
			newRoot = &root1;
			otherRoot = &root0;
			//there is a chance that the two ranks were equal, in which case the tree depth just increased.
			root1.rank++;
		}

		PX_ASSERT(newRoot->parent == newRoot);
		otherRoot->parent = newRoot;
		
		//update traversal linked list:
		newRoot->tail->next = otherRoot;
		newRoot->tail = otherRoot->tail;
	}
}


//
// Add a body to a constraint projection group.
//
void Sc::ConstraintProjectionManager::addToGroup(BodySim& b, BodySim* other, ConstraintSim& c)
{
	// If both bodies of the constraint are defined, we want to fetch the reference to the group root
	// from body 0 by default (allows to avoid checking both)
	PX_ASSERT(&b == c.getBody(0) || (c.getBody(0) == NULL && &b == c.getBody(1)));
	PX_UNUSED(c);

	ConstraintGroupNode* myRoot;
	if (!b.getConstraintGroup())
		myRoot = createGroupNode(b);
	else
	{
		myRoot = &b.getConstraintGroup()->getRoot();
		if (myRoot->hasProjectionTreeRoot())
			myRoot->purgeProjectionTrees();  // If a new constraint gets added to a constraint group, projection trees need to be recreated
	}

	if (other)
	{
		ConstraintGroupNode* otherRoot;
		if (!other->getConstraintGroup())
			otherRoot = createGroupNode(*other);
		else
		{
			otherRoot = &other->getConstraintGroup()->getRoot();
			if (otherRoot->hasProjectionTreeRoot())
				otherRoot->purgeProjectionTrees();  // If a new constraint gets added to a constraint group, projection trees need to be recreated
		}

		//merge the two groups, if disjoint.
		groupUnion(*myRoot, *otherRoot);
	}
}


//
// Add all projection constraints connected to the specified body to the pending update list but
// ignore the specified constraint.
//
void Sc::ConstraintProjectionManager::markConnectedConstraintsForUpdate(BodySim& b, ConstraintSim* c)
{
	PxU32 size = b.getActorInteractionCount();
	Interaction** interactions = b.getActorInteractions();
	while(size--)
	{
		Interaction* interaction = *interactions++;
		if (interaction->getType() == In