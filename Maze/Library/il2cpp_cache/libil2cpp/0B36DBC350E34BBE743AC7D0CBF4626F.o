Object);
		}
	}

	// Sort actors by decreasing depth (in order to delete children first)
	ActorsToDelete.Sort([](const FActorAndDepth& Lhs, const FActorAndDepth& Rhs){ return Lhs.Depth > Rhs.Depth; });

	bool bSelectionAffected = false;
	for (const FActorAndDepth& ActorInfo : ActorsToDelete)
	{
		AActor* Actor = ActorInfo.Actor;

		if(Actor && Actor->GetRootComponent())
		{
			// Reattach our children to our parent
			TArray< USceneComponent* > AttachChildren = Actor->GetRootComponent()->GetAttachChildren(); // Make a copy because the array in RootComponent will get modified during the process
			USceneComponent* AttachParent = Actor->GetRootComponent()->GetAttachParent();

			for ( USceneComponent* ChildComponent : AttachChildren )
			{
				if(ChildComponent)
				{
					// skip component with invalid or condemned owner
					AActor* Owner = ChildComponent->GetOwner();
					if ( Owner == nullptr || Owner == Actor || Owner->IsPendingKill() || InContext.Objects.Contains(Owner) /* Slow!!! */)
					{
						continue;
					}

					ChildComponent->AttachToComponent( AttachParent, FAttachmentTransformRules::KeepWorldTransform );
				}
			}
		}

		ObjectsToDelete.Add( Actor );
	}

	DeleteObjects( ObjectsToDelete );
}

void UDataprepMergeActorsOperation::OnExecution_Implementation(const FDataprepContext& InContext)
{
	TArray<AActor*> ActorsToMerge;
	TArray<UPrimitiveComponent*> ComponentsToMerge;
	UWorld* CurrentWorld = nullptr;

	DatasmithEditingOperationsUtils::GetActorsToMerge(CurrentWorld, InContext.Objects, ActorsToMerge, ComponentsToMerge);

	// Nothing to do if there is only one component to merge
	if( ComponentsToMerge.Num() < 2)
	{
		UE_LOG( LogDataprep, Log, TEXT("No static mesh actors to merge") );
		return;
	}

#ifdef LOG_TIME
	DataprepEditingOperationTime::FTimeLogger TimeLogger( TEXT("MergeActors"), [&]( FText Text) { this->LogInfo( Text ); });
#endif

	if(!MergeStaticMeshActors(CurrentWorld, ComponentsToMerge, NewActorLabel.IsEmpty() ? TEXT("Merged") : *NewActorLabel ))
	{
		return;
	}

	// Position the merged actor at the right location
	if(MergedActor->GetRootComponent() == nullptr)
	{
		USceneComponent* RootComponent = NewObject< USceneComponent >( MergedActor, USceneComponent::StaticClass(), *MergedActor->GetActorLabel(), RF_Transactional );

		MergedActor->AddInstanceComponent( RootComponent );
		MergedActor->SetRootComponent( RootComponent );
	}

	MergedActor->GetRootComponent()->SetWorldLocation( MergedMeshWorldLocation );

	// Keep the merged actor in the hierarchy, taking the parent of the first component
	// In the future, the merged actor could be attached to the common ancestor instead of the first parent in the list
	MergedActor->GetRootComponent()->AttachToComponent( ComponentsToMerge[0]->GetAttachParent(), FAttachmentTransformRules::KeepWorldTransform );

	// Collect all objects to be deleted
	TArray<UObject*> ObjectsToDelete;
	ObjectsToDelete.Reserve( ComponentsToMerge.Num() + ActorsToMerge.Num() );

	// Sort merged components to detach children first
	ComponentsToMerge.Sort([](const USceneComponent &A, const USceneComponent &B) -> bool { return A.IsAttachedTo(&B); });

	// Simple way to delete the actors: detach the merged components if it's safe to do so
	for (UPrimitiveComponent* Component : ComponentsToMerge)
	{
		if (Component->GetNumChildrenComponents() == 0)
		{
			Component->DetachFromComponent(FDetachmentTransformRules::KeepRelativeTransform);
		}
		else if (UStaticMeshComponent* StaticMeshComponent = Cast<UStaticMeshComponent>(Component))
		{
			// To keep the children in the hierarchy, simply hide the StaticMesh, but the StaticMeshComponent could be replaced by a SceneComponent and
			// then attach the children to it
			StaticMeshComponent->SetStaticMesh(nullptr);
		}
	}

	// Then delete the merged actors that don't have any children component
	for(AActor* Actor : ActorsToMerge)
	{
		UPrimitiveComponent* RootComponent = Cast<UPrimitiveComponent>(Actor->GetRootComponent());
		if (RootCom