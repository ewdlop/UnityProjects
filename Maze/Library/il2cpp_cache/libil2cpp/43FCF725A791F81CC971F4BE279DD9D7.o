static int collect_filter_prefix(__isl_keep isl_schedule_tree_list *list,
	int n, struct isl_schedule_node_get_filter_prefix_data *data);

/* Update the filter and prefix information in "data" based on the first "n"
 * elements in "list" and the expansion tree root "tree".
 *
 * We first collect the information from the elements in "list",
 * initializing the filter based on the domain of the expansion.
 * Then we map the results to the expanded space and combined them
 * with the results already in "data".
 */
static int collect_filter_prefix_expansion(__isl_take isl_schedule_tree *tree,
	__isl_keep isl_schedule_tree_list *list, int n,
	struct isl_schedule_node_get_filter_prefix_data *data)
{
	struct isl_schedule_node_get_filter_prefix_data contracted;
	isl_union_pw_multi_aff *c;
	isl_union_map *exp, *universe;
	isl_union_set *filter;

	c = isl_schedule_tree_expansion_get_contraction(tree);
	exp = isl_schedule_tree_expansion_get_expansion(tree);

	contracted.initialized = 1;
	contracted.universe_domain = data->universe_domain;
	contracted.universe_filter = data->universe_filter;
	contracted.collect_prefix = data->collect_prefix;
	universe = isl_union_map_universe(isl_union_map_copy(exp));
	filter = isl_union_map_domain(universe);
	if (data->collect_prefix) {
		isl_space *space = isl_union_set_get_space(filter);
		space = isl_space_set_from_params(space);
		contracted.prefix = isl_multi_union_pw_aff_zero(space);
	}
	contracted.filter = filter;

	if (collect_filter_prefix(list, n, &contracted) < 0)
		contracted.filter = isl_union_set_free(contracted.filter);
	if (data->collect_prefix) {
		isl_multi_union_pw_aff *prefix;

		prefix = contracted.prefix;
		prefix =
		    isl_multi_union_pw_aff_pullback_union_pw_multi_aff(prefix,
						isl_union_pw_multi_aff_copy(c));
		data->prefix = isl_multi_union_pw_aff_flat_range_product(
						prefix, data->prefix);
	}
	filter = contracted.filter;
	if (data->universe_domain)
		filter = isl_union_set_preimage_union_pw_multi_aff(filter,
						isl_union_pw_multi_aff_copy(c));
	else
		filter = isl_union_set_apply(filter, isl_union_map_copy(exp));
	if (!data->initialized)
		data->filter = filter;
	else
		data->filter = isl_union_set_intersect(filter, data->filter);
	data->initialized = 1;

	isl_union_pw_multi_aff_free(c);
	isl_union_map_free(exp);
	isl_schedule_tree_free(tree);

	return 0;
}

/* Update the filter information in "data" based on the first "n"
 * elements in "list" and the extension tree root "tree", in case
 * data->universe_domain is set and data->collect_prefix is not.
 *
 * We collect the universe domain of the elements in "list" and
 * add it to the universe range of the extension (intersected
 * with the already collected filter, if any).
 */
static int collect_universe_domain_extension(__isl_take isl_schedule_tree *tree,
	__isl_keep isl_schedule_tree_list *list, int n,
	struct isl_schedule_node_get_filter_prefix_data *data)
{
	struct isl_schedule_node_get_filter_prefix_data data_outer;
	isl_union_map *extension;
	isl_union_set *filter;

	data_outer.initialized = 0;
	data_outer.universe_domain = 1;
	data_outer.universe_filter = data->universe_filter;
	data_outer.collect_prefix = 0;
	data_outer.filter = NULL;
	data_outer.prefix = NULL;

	if (collect_filter_prefix(list, n, &data_outer) < 0)
		data_outer.filter = isl_union_set_free(data_outer.filter);

	extension = isl_schedule_tree_extension_get_extension(tree);
	extension = isl_union_map_universe(extension);
	filter = isl_union_map_range(extension);
	if (data_outer.initialized)
		filter = isl_union_set_union(filter, data_outer.filter);
	if (data->initialized)
		filter = isl_union_set_intersect(filter, data->filter);

	data->filter = filter;

	isl_schedule_tree_free(tree);

	return 0;
}

/* Update "data" based on the tree node "tree" in case "data" has
 * not been initialized yet.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a filter, then we set data->filter to this filter
 * (or its universe).
 * If "tree" is a domain, then this means we have reached the root
 * of the schedule tree without being able to extract any information.
 * We therefore initialize data->filter to the universe of the domain,
 * or the domain itself if data->universe_domain is not set.
 * If "tree" is a band with at least one member, then we set data->filter
 * to the universe of the schedule domain and replace the zero-dimensional
 * data->prefix by the band schedule (if data->collect_prefix is set).
 */
static int collect_filter_prefix_init(__isl_keep isl_schedule_tree *tree,
	struct isl_schedule_node_get_filter_prefix_data *data)
{
	enum isl_schedule_node_type type;
	isl_multi_union_pw_aff *mupa;
	isl_union_set *filter;

	type = isl_schedule_tree_get_type(tree);
	switch (type) {
	case isl_schedule_node_error:
		return -1;
	case isl_schedule_node_expansion:
		isl_die(isl_schedule_tree_get_ctx(tree), isl_error_internal,
			"should be handled by caller", return -1);
	case isl_schedule_node_extension:
		isl_die(isl_schedule_tree_get_ctx(tree), isl_error_invalid,
			"cannot handle extension nodes", return -1);
	case isl_schedule_node_context:
	case isl_schedule_node_leaf:
	case isl_schedule_node_guard:
	case isl_schedule_node_mark:
	case isl_schedule_node_sequence:
	case isl_schedule_node_set:
		return 0;
	case isl_schedule_node_domain:
		filter = isl_schedule_tree_domain_get_domain(tree);
		if (data->universe_domain)
			filter = isl_union_set_universe(filter);
		data->filter = filter;
		break;
	case isl_schedule_node_band:
		if (isl_schedule_tree_band_n_member(tree) == 0)
			return 0;
		mupa = isl_schedule_tree_band_get_partial_schedule(tree);
		if (data->collect_prefix) {
			isl_multi_union_pw_aff_free(data->prefix);
			mupa = isl_multi_union_pw_aff_reset_tuple_id(mupa,
								isl_dim_set);
			data->prefix = isl_multi_union_pw_aff_copy(mupa);
		}
		filter = isl_multi_union_pw_aff_domain(mupa);
		filter = isl_union_set_universe(filter);
		data->filter = filter;
		break;
	case isl_schedule_node_filter:
		filter = isl_schedule_tree_filter_get_filter(tree);
		if (data->universe_filter)
			filter = isl_union_set_universe(filter);
		data->filter = filter;
		break;
	}

	if ((data->collect_prefix && !data->prefix) || !data->filter)
		return -1;

	data->initialized = 1;

	return 0;
}

/* Update "data" based on the tree node "tree" in case "data" has
 * already been initialized.
 *
 * Return 0 on success and -1 on error.
 *
 * If "tree" is a domain and data->universe_domain is not set, then
 * intersect data->filter with the domain.
 * If "tree" is a filter, then we intersect data->filter with this filter
 * (or its universe).
 * If "tree" is a band with at least one member and data->collect_prefix
 * is set, then we extend data->prefix with the band schedule.
 * If "tree" is an extension, then we make sure that we are not collecting
 * information on any extended domain elements.
 */
static int collect_filter_prefix_update(__isl_keep isl_schedule_tree *tree,
	struct isl_schedule_node_get_filter_prefix_data *data)
{
	enum isl_schedule_node_type type;
	isl_multi_union_pw_aff *mupa;
	isl_union_set *filter;
	isl_union_map *extension;
	int empty;

	type = isl_schedule_tree_get_type(tree);
	switch (type) {
	case isl_schedule_node_error:
		return -1;
	case isl_schedule_node_expansion:
		isl_die(isl_schedule_tree_get_ctx(tree), isl_error_internal,
			"should be handled by caller", return -1);
	case isl_schedule_node_extension:
		extension = isl_schedule_tree_extension_get_extension(tree);
		extension = isl_union_map_intersect_range(extension,
					isl_union_set_copy(data->filter));
		empty = isl_union_map_is_empty(extension);
		isl_union_map_free(extension);
		if (empty < 0)
			return -1;
		if (empty)
			break;
		isl_die(isl_schedule_tree_get_ctx(tree), isl_error_invalid,
			"cannot handle extension nodes", return -1);
	case isl_schedule_node_context:
	case isl_schedule_node_leaf:
	case isl_schedule_node_guard:
	case isl_schedule_node_mark:
	case isl_schedule_node_sequence:
	case isl_schedule_node_set:
		break;
	case isl_schedule_node_domain:
		if (data->universe_domain)
			break;
		filter = isl_schedule_tree_domain_get_domain(tree);
		data->filter = isl_union_set_intersect(data->filter, filter);
		break;
	case isl_schedule_node_band:
		if (isl_schedule_tree_band_n_member(tree) == 0)
			break;
		if (!data->collect_prefix)
			break;
		mupa = isl_schedule_tree_band_get_partial_schedule(tree);
		data->prefix = isl_multi_union_pw_aff_flat_range_product(mupa,
								data->prefix);
		if (!data->prefix)
			return -1;
		break;
	case isl_schedule_node_filter:
		filter = isl_schedule_tree_filter_get_filter(tree);
		if (data->universe_filter)
			filter = isl_union_set_universe(filter);
		data->filter = isl_union_set_intersect(data->filter, filter);
		if (!data->filter)
			return -1;
		break;
	}

	return 0;
}

/* Collect filter and/or prefix information from the first "n"
 * elements in "list" (which represent the ancestors of a node).
 * Store the results in "data".
 *
 * Extension nodes are only supported if they do not affect the outcome,
 * i.e., if we are collecting information on non-extended domain elements,
 * or if we are collecting the universe domain (without prefix).
 *
 * Return 0 on success and -1 on error.
 *
 * We traverse the list from innermost ancestor (last element)
 * to outermost ancestor (first element), calling collect_filter_prefix_init
 * on each node as long as we have not been able to extract any information
 * yet and collect_filter_prefix_update afterwards.
 * If we come across an expansion node, then we interrupt the traversal
 * and call collect_filter_prefix_expansion to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * If we come across an extension node and we are only computing
 * the universe domain, then we interrupt the traversal and call
 * collect_universe_domain_extension to restart the traversal
 * over the remaining ancestors and to combine the results with those
 * that have already been collected.
 * On successful return, data->initialized will be set since the outermost
 * ancestor is a domain node, which always results in an initialization.
 */
static int collect_filter_prefix(__isl_keep isl_schedule_tree_list *list,
	int n, struct isl_schedule_node_get_filter_prefix_data *data)
{
	int i;

	if (!list)
		return -1;

	for (i = n - 1; i >= 0; --i) {
		isl_schedule_tree *tree;
		enum isl_schedule_node_type type;
		int r;

		tree = isl_schedule_tree_list_get_schedule_tree(list, i);
		if (!tree)
			return -1;
		type = isl_schedule_tree_get_type(tree);
		if (type == isl_schedule_node_expansion)
			return collect_filter_prefix_expansion(tree, list, i,
								data);
		if (type == isl_schedule_node_extension &&
		    data->universe_domain && !data->collect_prefix)
			return collect_universe_domain_extension(tree, list, i,
								data);
		if (!data->initialized)
			r = collect_filter_prefix_init(tree, data);
		else
			r = collect_filter_prefix_update(tree, data);
		isl_schedule_tree_free(tree);
		if (r < 0)
			return -1;
	}

	return 0;
}

/* Return the concatenation of the partial schedules of all outer band
 * nodes of "node" interesected with all outer filters
 * as an isl_multi_union_pw_aff.
 * None of the ancestors of "node" may be an extension node, unless
 * there is also a filter ancestor that filters out all the extended
 * domain elements.
 *
 * If