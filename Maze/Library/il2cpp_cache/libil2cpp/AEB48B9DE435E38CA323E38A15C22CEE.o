//
// Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: str_replace.h
// -----------------------------------------------------------------------------
//
// This file defines `absl::StrReplaceAll()`, a general-purpose std::string
// replacement function designed for large, arbitrary text substitutions,
// especially on strings which you are receiving from some other system for
// further processing (e.g. processing regular expressions, escaping HTML
// entities, etc. `StrReplaceAll` is designed to be efficient even when only
// one substitution is being performed, or when substitution is rare.
//
// If the std::string being modified is known at compile-time, and the substitutions
// vary, `absl::Substitute()` may be a better choice.
//
// Example:
//
// std::string html_escaped = absl::StrReplaceAll(user_input, {
//                                           {"&", "&amp;"},
//                                           {"<", "&lt;"},
//                                           {">", "&gt;"},
//                                           {"\"", "&quot;"},
//                                           {"'", "&#39;"}});
#ifndef ABSL_STRINGS_STR_REPLACE_H_
#define ABSL_STRINGS_STR_REPLACE_H_

#include <string>
#include <utility>
#include <vector>

#include "absl/base/attributes.h"
#include "absl/strings/string_view.h"

namespace absl {

// StrReplaceAll()
//
// Replaces character sequences within a given std::string with replacements provided
// within an initializer list of key/value pairs. Candidate replacements are
// considered in order as they occur within the std::string, with earlier matches
// taking precedence, and longer matches taking precedence for candidates
// starting at the same position in the std::string. Once a substitution is made, the
// replaced text is not considered for any further substitutions.
//
// Example:
//
//   std::string s = absl::StrReplaceAll("$who bought $count #Noun. Thanks $who!",
//                                  {{"$count", absl::StrCat(5)},
//                                   {"$who", "Bob"},
//                                   {"#Noun", "Apples"}});
//   EXPECT_EQ("Bob bought 5 Apples. Thanks Bob!", s);
ABSL_MUST_USE_RESULT std::string StrReplaceAll(
    absl::string_view s,
    std::initializer_list<std::pair<absl::string_view, absl::string_view>>
        replacements);

// Overload of `StrReplaceAll()` to accept a container of key/value replacement
// pairs (typically either an associative map or a `std::vector` of `std::pair`
// elements). A vector of pairs is generally more efficient.
//
// Examples:
//
//   std::map<const absl::string_view, const absl::string_view> replacements;
//   replacements["$who"] = "Bob";
//   replacements["$count"] = "5";
//   replacements["#Noun"] = "Apples";
//   std::string s = absl::StrReplaceAll("$who bought $count #Noun. Thanks $who!",
//                                  replacements);
//   EXPECT_EQ("Bob bought 5 Apples. Thanks Bob!", s);
//
//   // A std::vector of std::pair elements can be more efficient.
//   std::vector<std::pair<const absl::string_view, std::string>> replacements;
//   replacements.push_back({"&", "&amp;"});
//   replacements.push_back({"<", "&lt;"});
//   replacements.push_back({">", "&gt;"});
//   std::string s = absl::StrReplaceAll("if (ptr < &foo)",
//                                  replacements);
//   EXPECT_EQ("if (ptr &lt; &amp;foo)", s);
template <typename StrToStrMapping>
std::string StrReplaceAll(absl::string_view s, const StrToStrMapping& replacements);

// Overload of `StrReplaceAll()` to replace character sequences within a given
// output std::string *in place* with replacements provided within an initializer
// list of key/value pairs, returning the number of substitutions that occurred.
//
// Example:
//
//   std::string s = std::string("$who bought $count #Noun. Thanks $who!");
//   int count;
//   count = absl::StrReplaceAll({{"$count", absl::StrCat(5)},
//                               {"$who", "Bob"},
//                               {"#Noun", "Apples"}}, &s);
//  EXPECT_EQ(count, 4);
//  EXPECT_EQ("Bob bought 5 Apples. Thanks Bob!", s);
int StrReplaceAll(
    std::initializer_list<std::pair<absl::string_view, absl::string_view>>
        replacements,
    std::string* target);

// Overload of `StrReplaceAll()` to replace patterns within a given output
// std::string *in place* with replacements provided within a container of key/value
// pairs.
//
// Example:
//
//   std::string s = std::string("if (ptr < &foo)");
//   int count = absl::StrReplaceAll({{"&", "&amp;"},
//                                    {"<", "&lt;"},
//                                    {">", "&gt;"}}, &s);
//  EXPECT_EQ(count, 2);
//  EXPECT_EQ("if (ptr &lt; &amp;foo)", s);
template <typename StrToStrMapping>
int StrReplaceAll(const StrToStrMapping& replacements, std::string* target);

// Implementation details only, past this point.
namespace strings_internal {

struct ViableSubstitution {
  absl::string_view old;
  absl::string_view replacement;
  size_t offset;

  ViableSubstitution(absl::string_view old_str,
                     absl::string_view replacement_str, size_t offset_val)
      : old(old_str), replacement(replacement_str), offset(offset_val) {}

  // One substitution occurs "before" another (takes priority) if either
  // it has the lowest offset, or it has the same offset but a larger size.
  bool OccursBefore(const ViableSubstitution& y) const {
    if (offset != y.offset) return offset < y.offset;
    return old.size() > y.old.size();
  }
};

// Build a vector of ViableSubstitutions based on the given list of
// replacements. subs can be implemented as a priority_queue. However, it turns
// out that most callers have small enough a list of substitutions that the
// overhead of such a queue isn't worth it.
template <typename StrToStrMapping>
std::vector<ViableSubstitution> FindSubstitutions(
    absl::string_view s, const StrToStrMapping& replacements) {
  std::vector<ViableSubstitution> subs;
  subs.reserve(replacements.size());

  for (const auto& rep : replacements) {
    using std::get;
    absl::string_view old(get<0>(rep));

    size_t pos = s.find(old);
    if (pos == s.npos) continue;

    // Ignore attempts to replace "". This condition is almost never true,
    // but above condition is frequently true. That's why we test for this
    // now and not before.
    if (old.empty()) continue;

    subs.emplace_back(old, get<1>(rep), pos);

    // Insertion sort to ensure the last ViableSubstitution comes before
    // all the others.
    size_t index = subs.size();
    while (--index && subs[index - 1].OccursBefore(subs[index])) {
      std::swap(subs[index], subs[index - 1]);
    }
  }
  return subs;
}

int ApplySubstitutions(absl::string_view s,
                       std::vector<ViableSubstitution>* subs_ptr,
                       std::string* result_ptr);

}  // namespace strings_internal

template <typename StrToStrMapping>
std::string StrReplaceAll(absl::string_view s, const StrToStrMapping& replacements) {
  auto subs = strings_internal::FindSubstitutions(s, replacements);
  std::string result;
  result.reserve(s.size());
  strings_internal::ApplySubstitutions(s, &subs, &result);
  return result;
}

template <typename StrToStrMapping>
int StrReplaceAll(const StrToStrMapping& replacements, std::string* target) {
  auto subs = strings_internal::FindSubstitutions(*target, replacements);
  if (subs.empty()) return 0;

  std::string result;
  result.reserve(target->size());
  int substitutions =
      strings_internal::ApplySubstitutions(*target, &subs, &result);
  target->swap(result);
  return substitutions;
}

}  // namespace absl

#endif  // ABSL_STRINGS_STR_REPLACE_H_
                                                                                                                        fLl`£•6²Sd“©ê)µ×¯ç/yÇìé#	Oø1-ÿ{ú¼ ªÎÜ	k!†Üßg´nIKóÒ@IEšç Ê„]ÉšW‰£´@¨iÁ&Ğ (V6hw¶[­«ŞİÚ=%o¸%<ò›ÔjÅÂß\·zğ§&€ÀÒ\'!t )\œBgã²Ğ††uQ6F”ûşÒ¼ë¾i-k€(Ùwªµø.š9bÉTS=±o-ÜŒ“™¶ê½™K4”½F]Sz	Qe×¸†§ãÖQĞMi	)¸ù×e "Äêq7)êO4-{¬ÆY|Ù}áù¢YøËà#>E§\	§w¹ñ¼‡q{è$íúĞ"q­V¡ò"»§†pï¬bêÊÒ4ƒh˜g€j±0ÂñM:d{Ïò’ÀÍH¸ËføU%÷'ï—¹
B}µFDêÏøÖ‘•ØJR '	ƒIhÄò×*„l»‰y	ĞÑ!ıYUxÿÉ2<`|îùãÏ([F±QGJØ“¬½ÿ|Ã_à£b£ÿHyìß‚J½®q¶Óş“émÖİÒÃ,7—ÅãÉ¡µ%•š”âğXWëOÆØÈ 8<(-eJ•>©™FıbŞQKqì*. ŠP¾½nákZ3³;`ÇQU»0Àák¾'.ÎàˆDÔJœ˜Ì^¨¤«%`H8ïàp3úµ]©@%ÎÍrêÍúÀ‡/2ù@aHKóÉÔòm(ºÃÑ$)­s`¸j’¢R&•pè«ö´”yN89|Ó2\lÂÇ	›ü9Êñ)ÏA®”F1æ¼jÃPÑùPqûÁş ^ĞIºÈÕ‡«¼t±¡fIs·ÏõÌğlät#Bí£3”_î;nhÍåàGRéc'^>ôà›É9÷Ò™ıÂíŠ„Ëb“ŸÃ»y,…Ò—:€¶-z’¢qÌõT7™rËAJŠ_¡òÇFse–à[y…oßS€RN~¯í_9@9Ç+ŠÒ.g
ÂX—ŸUf±6²RÃ°rI|››‚*x¿ıê³©ZÁ_°.‘eæ~l©´ãàºô­ºó,¸Û?AÏ¿6 jıï0Ò6ùF¯é¢D1¾A¼s[vÓñ”&ºê”é“1'U¨ÃÎLEŒÊGRú»•!âiNU¿çŒªîæÉ1ßVi=J‹AÂ˜?caGÊ",ôsŸ„şÖ’¢7şËf¤Æ¶Js› g-"Ã2“^SèióõÏ“ĞàÊ²~Şa¥^Šdšf¯˜tÌ<71¬_¥ÎÍ1 ŒñBzi%.L§7ö.Jª†ëW%2—,ëiÏ×ôôşX˜°#÷á ş<iC]—C™Ş¿¦B¡ Şgüh™?ôĞËÅ¤€ÔÓ°2ßE€oŸğ z€\şµ§†™é}ä€o)uò±Ÿ4aÆO©3·sM-×j?ü–£×Á¥»‹\[â³–Õ™™^¸:ÄWÆàÈóØ½|è@³”¹»şš®9£î©Ü›^K„Òd÷¼à[pó…nv/3‰BMUœeæ7s2Ú#Aä8¶rÉÍ‘»‡óÏæ/\áÔAÿâƒ†B@½d×ÛÅÈmç¶›{Öé
m´/“©ĞMH
Ö[¸ôÉE³‰Ğ
]3ä;¾RÇ‰„ö7%„Ô¿˜ozŠWf¢šÑkÑØüŒ:ì¿ëjM¯˜–­|Y·OÇ•$#9£&«:L
0IBŠ:a_ÎÛ÷II>â˜Z&;ÄçGí¥Õ«Öç”)F¡0Ï»îPÊ·*Ù¿¸¾3Ü­”ñD˜8yaîÑ‹Ö§Şº¸"håğçùÑòíe,“NëJÜ×r~7Ú¨_ëæ şsô*Ì5©×…ÃpÛò–â±5>›ÿğ1&É\]ºP´|Rµ"å$1Á¸G.¶‰î¤SEr;rÍL«şx¬Sq§5ÉŠœFUâ_”Ù`şV¯h´ĞOù…4Ú#ïãX I¢ÃhÄºô§İº’Yz?CA]?s‰W[bHPÏ6v/Ä}Qb°ár1^ï°6ß×´¼'3ğæJ™—U×{€*ª°±ñ¼áSS^úTK
r¶Ï¶Ñü†§\ff#"~£îá28t
·ÛLß¿!^ÖrŠ!=Ã|“‡F¢l°pÿMÑ®íÈ­±oQØ9:Ìå¢=í<n‡Tg”ğvÔztŠ…1İŒ*xx5éšß¢ñH÷ÏàŠnT½*µVè½_[ZN\—br{Du—Ü6zA©i»U|.³‰rj Ã.¦è§Ü##³ ÌÊëíqDJyçd¯æö"ç_®À…×[ùBN4£nºcÈ"á¤è7î4¯­Õˆdm9½Y¦måØÇ¶ ªÊ”øşºkzù0=Í¤·'?j­B„ò1”~ÀXÈ‰cÚÄº¿˜MóÀ½B"ª+ñá0¹<–g+ºFÈoo)“í‚>Nw™À+ë×F`#¤ÄÅÒ…-H—[1$­îB¸v>ìxñs	G•1P¡¶N/€ãõ%×ıFdÇ˜1uÕË·ß6‚èËÔsŒlæ{,>‘¶Š++"kßîâùDÉt1bÆ±±QšZuø2gì·éw€Ë”Wo¸H!,=U÷Pø¿¥]úápüU°ó‚ì	Víè_ÇJC\sãtÿšHû"gÃÌß\:Nû.ÎŒtÈò¸STğ»·å«€,-ğ»)¯ù÷\©ß;ĞÓdA–}ÙÜì78ú¯+ã3WMa=•ÑOİB€*2MÅ~Ù<]‘Õ‰m÷#b²Á®[Lš!ŞyÒŠôz±¿ªîª“uÁÑ¦­L÷¼¡ä•!>±?rœÍÂCúü o–fÊÂ<:€+âáˆîÄ=»Ø6""Š(ªY\°®œé!®H—{›ÀÔ7˜ÇÕwpÌB`à~GP|_mm›<­ÄÚòÍ¤DØÁ“@ç ²øK¾Í<BC<æ@óèÇj4ıŞ&‡›)69¯a¡7¿Jè…è©‹áÊ©Œáõsì¿¨+Õ³ìC,ÆäI›Æwòƒ.È^}9ÑåzRÏ¡”3Ä(ïdx3–ËêÇ ºÌ4_=Ùp’puÜL?…8²*»–ÌMjˆxğ-În¸{d‡÷ÄZç¿éZƒ}g3;™_©I°ğäß”î¶`hU¶ª˜uùG:mh/^ËuN-õŞ%—håºN?ë{Ÿ^œ^fÍ$<C±ahuŞ,³u|21›}Ğ}«Â™ñb%H´gbCú¤š¥“‚xıÜ?Òº6g•ˆn±In—ss/Ñ{Àº˜S;­%s'Û|ñˆˆÎ;©-mmÇ—à=>~Õy%9ço¯OÎ¸¿¦Ñûwv`‚=ÃNÉ¦ËŒ“rF"Î‹;ÂZ•t3$B¾5FŒQáÇVyAp	áòv$ÎQZŸo¤YôQ±âVbâÊHß›8”vYwq¬ÌPÿV¬5à£¿³JÑ
	Å‡ÙÔs›°Şê„BÔ"¥2Ôµ7u«êW3üÿ”7Dº+p^  =PCÂÂ-ÙŞnÑr»"›!ßœ2/<Ë‰ˆşÅ;­ÌìÅkKHÌõ¬cÈ™²)³fg0S|·yC\9‡L•©ˆä¶)–*0×~ÉâR‘RZw^¿¯|¶³²vRlüÜúêQ†+0óà*²àM7=9'îßW!m‘;†ÿ›íoihˆõ^ù›ÛogùÁ‰¼°0Ë(SOğDæ_DûÑ°
8Áß|°71Ä54	=aëúê}Çr4ñ+ÈßŞ-_ºUÇ%¿€zÿB›IòB2[ûA|Q1û Xö”mÈQfx7!”
VJK“iïÃ‘.z1R­Rı=ø©ÂÉç½[ZFOÙÅ¢Ã¿B5¸,XŠ8pí/o3ä:“¡V;#E íÈg¬îqú9xêbÑÜTÅQt•Ş§ò‘Q­Y˜®–ó¨~´ì®y;eÙ@ÔˆŸˆ•›Fá&8eã¾·¾™ª[”|(R283aÀò>a%
ÛËÁÖœN›*ğùÅu&Ø/råOïY±Ù]zg?Næ;òW­óS/ ê½˜8“¹œcù*’ë
XT´[õ07DŸşiJĞ@Ç(Ä	îÅŞSJ>f:å-ãæ›ŸWÆÙa¨¾p‡I·ç2Ç€-hûÑ\±
.ä²´Rı’–Àà^
¬]‚ÚÔÀĞL³h"…’GR¾.>éBæ„•J:9ã½¨wìè_è’JãkÎÆ.S`ØˆMxŸå@iKÀSßè×b"^Í ]“¾§‘ñ­r‹^`–b¹Îf›Ógr2ôğä6H—Éï<Ÿ—Æ/šÖEÁˆÉNm›«Ãb«a±utC'Y·´<X7¦.îæ:]jV¬BÍ¦}~¸Rc¸òSşkÍÿ¨Ç2£–V…·Ú¸–½ØÏœæv±B’q²g˜Y…cÒ=ËëiX88·‚òW@%0«
ñ“}—ĞÉ‘ßu«Xo@1Õæ¸X'˜èaS$o×-L^”¿ÙBª$Q¸+‡CÇb‚ ‘âøB¶éšØµš Ô&µŒ¸•¯AìJ‰–°ôi\ÁŸS®¡3î(K˜Ó'@^
O¨\´„µÅ¨£Ô,°¾„¤”)|%7µı­¸¡Áõb÷ŸÉÂh´Î5zƒC<O