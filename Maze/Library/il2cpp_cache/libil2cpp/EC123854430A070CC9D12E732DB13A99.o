ep isl_basic_map *bmap2)
{
	isl_bool disjoint;
	isl_bool intersect;
	isl_basic_map *test;

	disjoint = isl_basic_map_plain_is_disjoint(bmap1, bmap2);
	if (disjoint < 0 || disjoint)
		return disjoint;

	disjoint = isl_basic_map_is_empty(bmap1);
	if (disjoint < 0 || disjoint)
		return disjoint;

	disjoint = isl_basic_map_is_empty(bmap2);
	if (disjoint < 0 || disjoint)
		return disjoint;

	intersect = isl_basic_map_plain_is_universe(bmap1);
	if (intersect < 0 || intersect)
		return intersect < 0 ? isl_bool_error : isl_bool_false;

	intersect = isl_basic_map_plain_is_universe(bmap2);
	if (intersect < 0 || intersect)
		return intersect < 0 ? isl_bool_error : isl_bool_false;

	test = isl_basic_map_intersect(isl_basic_map_copy(bmap1),
		isl_basic_map_copy(bmap2));
	disjoint = isl_basic_map_is_empty(test);
	isl_basic_map_free(test);

	return disjoint;
}

/* Are "bset1" and "bset2" disjoint?
 */
isl_bool isl_basic_set_is_disjoint(__isl_keep isl_basic_set *bset1,
	__isl_keep isl_basic_set *bset2)
{
	return isl_basic_map_is_disjoint(bset1, bset2);
}

isl_bool isl_set_plain_is_disjoint(__isl_keep isl_set *set1,
	__isl_keep isl_set *set2)
{
	return isl_map_plain_is_disjoint(set_to_map(set1), set_to_map(set2));
}

/* Are "set1" and "set2" disjoint?
 */
isl_bool isl_set_is_disjoint(__isl_keep isl_set *set1, __isl_keep isl_set *set2)
{
	return isl_map_is_disjoint(set1, set2);
}

/* Is "v" equal to 0, 1 or -1?
 */
static int is_zero_or_one(isl_int v)
{
	return isl_int_is_zero(v) || isl_int_is_one(v) || isl_int_is_negone(v);
}

/* Check if we can combine a given div with lower bound l and upper
 * bound u with some other div and if so return that other div.
 * Otherwise return -1.
 *
 * We first check that
 *	- the bounds are opposites of each other (except for the constant
 *	  term)
 *	- the bounds do not reference any other div
 *	- no div is defined in terms of this div
 *
 * Let m be the size of the range allowed on the div by the bounds.
 * That is, the bounds are of the form
 *
 *	e <= a <= e + m - 1
 *
 * with e some expression in the other variables.
 * We look for another div b such that no third div is defined in terms
 * of this second div b and such that in any constraint that contains
 * a (except for the given lower and upper bound), also contains b
 * with a coefficient that is m times that of b.
 * That is, all constraints (except for the lower and upper bound)
 * are of the form
 *
 *	e + f (a + m b) >= 0
 *
 * Furthermore, in the constraints that only contain b, the coefficient
 * of b should be equal to 1 or -1.
 * If so, we return b so that "a + m b" can be replaced by
 * a single div "c = a + m b".
 */
static int div_find_coalesce(struct isl_basic_map *bmap, int *pairs,
	unsigned div, unsigned l, unsigned u)
{
	int i, j;
	unsigned dim;
	int coalesce = -1;

	if (bmap->n_div <= 1)
		return -1;
	dim = isl_space_dim(bmap->dim, isl_dim_all);
	if (isl_seq_first_non_zero(bmap->ineq[l] + 1 + dim, div) != -1)
		return -1;
	if (isl_seq_first_non_zero(bmap->ineq[l] + 1 + dim + div + 1,
				   bmap->n_div - div - 1) != -1)
		return -1;
	if (!isl_seq_is_neg(bmap->ineq[l] + 1, bmap->ineq[u] + 1,
			    dim + bmap->n_div))
		return -1;

	for (i = 0; i < bmap->n_div; ++i) {
		if (isl_int_is_zero(bmap->div[i][0]))
			continue;
		if (!isl_int_is_zero(bmap->div[i][1 + 1 + dim + div]))
			return -1;
	}

	isl_int_add(bmap->ineq[l][0], bmap->ineq[l][0], bmap->ineq[u][0]);
	if (isl_int_is_neg(bmap->ineq[l][0])) {
		isl_int_sub(bmap->ineq[l][0],
			    bmap->ineq[l][0], bmap->ineq[u][0]);
		bmap = isl_basic_map_copy(bmap);
		bmap = isl_basic_map_set_to_empty(bmap);
		isl_basic_map_free(bmap);
		return -1;
	}
	isl_int_add_ui(bmap->ineq[l][0], bmap->ineq[l][0], 1);
	for (i = 0; i < bmap->n_div; ++i) {
		if (i == div)
			continue;
		if (!pairs[i])
			continue;
		for (j = 0; j < bmap->n_div; ++j) {
			if (isl_int_is_zero(bmap->div[j][0]))
				continue;
			if (!isl_int_is_zero(bmap->div[j][1 + 1 + dim + i]))
				break;
		}
		if (j < bmap->n_div)
			continue;
		for (j = 0; j < bmap->n_ineq; ++j) {
			int valid;
			if (j == l || j == u)
				continue;
			if (isl_int_is_zero(bmap->ineq[j][1 + dim + div])) {
				if (is_zero_or_one(bmap->ineq[j][1 + dim + i]))
					continue;
				break;
			}
			if (isl_int_is_zero(bmap->ineq[j][1 + dim + i]))
				break;
			isl_int_mul(bmap->ineq[j][1 + dim + div],
				    bmap->ineq[j][1 + dim + div],
				    bmap->ineq[l][0]);
			valid = isl_int_eq(bmap->ineq[j][1 + dim + div],
					   bmap->ineq[j][1 + dim + i]);
			isl_int_divexact(bmap->ineq[j][1 + dim + div],
					 bmap->ineq[j][1 + dim + div],
					 bmap->ineq[l][0]);
			if (!valid)
				break;
		}
		if (j < bmap->n_ineq)
			continue;
		coalesce = i;
		break;
	}
	isl_int_sub_ui(bmap->ineq[l][0], bmap->ineq[l][0], 1);
	isl_int_sub(bmap->ineq[l][0], bmap->ineq[l][0], bmap->ineq[u][0]);
	return coalesce;
}

/* Internal data structure used during the construction and/or evaluation of
 * an inequality that ensures that a pair of bounds always allows
 * for an integer value.
 *
 * "tab" is the tableau in which the inequality is evaluated.  It may
 * be NULL until it is actually needed.
 * "v" contains the inequality coefficients.
 * "g", "fl" and "fu" are temporary scalars used during the construction and
 * evaluation.
 */
struct test_ineq_data {
	struct isl_tab *tab;
	isl_vec *v;
	isl_int g;
	isl_int fl;
	isl_int fu;
};

/* Free all the memory allocated by the fields of "data".
 */
static void test_ineq_data_clear(struct test_ineq_data *data)
{
	isl_tab_free(data->tab);
	isl_vec_free(data->v);
	isl_int_clear(data->g);
	isl_int_clear(data->fl);
	isl_int_clear(data->fu);
}

/* Is the inequality stored in data->v satisfied by "bmap"?
 * That is, does it only attain non-negative values?
 * data->tab is a tableau corresponding to "bmap".
 */
static isl_bool test_ineq