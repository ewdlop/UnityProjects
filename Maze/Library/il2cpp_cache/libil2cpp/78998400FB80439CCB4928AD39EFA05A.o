int32_t cookedDataOffset;
	uint32_t cookedDataLength;
};
struct PhysicalLod_Type
{
	uint32_t costWithoutIterations;
	uint32_t submeshId;
	float solverIterationScale;
	float maxDistanceReduction;
};
struct ConstrainCoefficient_Type
{
	float maxDistance;
	float collisionSphereRadius;
	float collisionSphereDistance;
};
struct PhysicalMesh_Type
{
	uint32_t numVertices;
	uint32_t numIndices;
	uint32_t numBonesPerVertex;
	VEC3_DynamicArray1D_Type vertices;
	VEC3_DynamicArray1D_Type normals;
	VEC3_DynamicArray1D_Type skinningNormals;
	U32_DynamicArray1D_Type vertexFlags;
	ConstrainCoefficient_DynamicArray1D_Type constrainCoefficients;
	U16_DynamicArray1D_Type boneIndices;
	F32_DynamicArray1D_Type boneWeights;
	U32_DynamicArray1D_Type indices;
	float maximumMaxDistance;
	float shortestEdgeLength;
	float averageEdgeLength;
	bool isTetrahedralMesh;
};
struct SkinClothMapB_Type
{
	physx::PxVec3 vtxTetraBary;
	uint32_t vertexIndexPlusOffset;
	physx::PxVec3 nrmTetraBary;
	uint32_t faceIndex0;
	uint32_t tetraIndex;
	uint32_t submeshIndex;
};
struct TetraLink_Type
{
	physx::PxVec3 vertexBary;
	uint32_t tetraIndex0;
	physx::PxVec3 normalBary;
	uint32_t _dummyForAlignment;
};

struct ParametersStruct
{

	PhysicalMesh_Type physicalMesh;
	PhysicalSubmesh_DynamicArray1D_Type submeshes;
	U8_DynamicArray1D_Type deformableCookedData;
	uint32_t deformableCookedDataVersion;
	PhysicalLod_DynamicArray1D_Type physicalLods;
	SkinClothMapB_DynamicArray1D_Type transitionUpB;
	SkinClothMapC_DynamicArray1D_Type transitionUpC;
	float transitionUpThickness;
	float transitionUpOffset;
	SkinClothMapB_DynamicArray1D_Type transitionDownB;
	SkinClothMapC_DynamicArray1D_Type transitionDownC;
	float transitionDownThickness;
	float transitionDownOffset;
	uint32_t referenceCount;

};

static const uint32_t checksum[] = { 0x52405a64, 0xbedbf4ae, 0xaab8ec54, 0x28862c74, };

} // namespace ClothingPhysicalMeshParameters_0p0NS

#ifndef NV_PARAMETERIZED_ONLY_LAYOUTS
class ClothingPhysicalMeshParameters_0p0 : public NvParameterized::NvParameters, public ClothingPhysicalMeshParameters_0p0NS::ParametersStruct
{
public:
	ClothingPhysicalMeshParameters_0p0(NvParameterized::Traits* traits, void* buf = 0, int32_t* refCount = 0);

	virtual ~ClothingPhysicalMeshParameters_0p0();

	virtual void destroy();

	static const char* staticClassName(void)
	{
		return("ClothingPhysicalMeshParameters");
	}

	const char* className(void) const
	{
		return(staticClassName());
	}

	static const uint32_t ClassVersion = ((uint32_t)0 << 16) + (uint32_t)0;

	static uint32_t staticVersion(void)
	{
		return ClassVersion;
	}

	uint32_t version(void) const
	{
		return(staticVersion());
	}

	static const uint32_t ClassAlignment = 8;

	static const uint32_t* staticChecksum(uint32_t& bits)
	{
		bits = 8 * sizeof(ClothingPhysicalMeshParameters_0p0NS::checksum);
		return ClothingPhysicalMeshParameters_0p0NS::checksum;
	}

	static void freeParameterDefinitionTable(NvParameterized::Traits* traits);

	const uint32_t* checksum(uint32_t& bits) const
	{
		return staticChecksum(bits);
	}

	const ClothingPhysicalMeshParameters_0p0NS::ParametersStruct& parameters(void) const
	{
		ClothingPhysicalMeshParameters_0p0* tmpThis = const_cast<ClothingPhysicalMeshParameters_0p0*>(this);
		return *(static_cast<ClothingPhysicalMeshParameters_0p0NS::ParametersStruct*>(tmpThis));
	}

	ClothingPhysicalMeshParameters_0p0NS::ParametersStruct& parameters(void)
	{
		return *(static_cast<ClothingPhysicalMeshParameters_0p0NS::ParametersStruct*>(this));
	}

	virtual NvParameterized::ErrorType getParameterHandle(const char* long_name, NvParameterized::Handle& handle) const;
	virtual NvParameterized::ErrorType getParameterHandle(const char* long_name, NvParameterized::Handle& handle);

	void initDefaults(void);

protected:

	virtual const NvParameterized::Defin