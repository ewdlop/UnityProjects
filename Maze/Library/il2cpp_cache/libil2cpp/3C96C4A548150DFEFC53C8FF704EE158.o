riables in the range [first, first + n)
 * that are not marked as having an explicit representation?
 */
static isl_bool bmap_eq_involves_unknown_divs(__isl_keep isl_basic_map *bmap,
	int eq, unsigned first, unsigned n)
{
	unsigned o_div;
	int i;

	if (!bmap)
		return isl_bool_error;

	o_div = isl_basic_map_offset(bmap, isl_dim_div);
	for (i = 0; i < n; ++i) {
		isl_bool unknown;

		if (isl_int_is_zero(bmap->eq[eq][o_div + first + i]))
			continue;
		unknown = isl_basic_map_div_is_marked_unknown(bmap, first + i);
		if (unknown < 0)
			return isl_bool_error;
		if (unknown)
			return isl_bool_true;
	}

	return isl_bool_false;
}

/* The last local variable involved in the equality constraint
 * at position "eq" in "bmap" is the local variable at position "div".
 * It can therefore be used to extract an explicit representation
 * for that variable.
 * Do so unless the local variable already has an explicit representation or
 * the explicit representation would involve any other local variables
 * that in turn do not have an explicit representation.
 * An equality constraint involving local variables without an explicit
 * representation can be used in isl_basic_map_drop_redundant_divs
 * to separate out an independent local variable.  Introducing
 * an explicit representation here would block this transformation,
 * while the partial explicit representation in itself is not very useful.
 * Set *progress if anything is changed.
 *
 * The equality constraint is of the form
 *
 *	f(x) + n e >= 0
 *
 * with n a positive number.  The explicit representation derived from
 * this constraint is
 *
 *	floor((-f(x))/n)
 */
static __isl_give isl_basic_map *set_div_from_eq(__isl_take isl_basic_map *bmap,
	int div, int eq, int *progress)
{
	unsigned total, o_div;
	isl_bool involves;

	if (!bmap)
		return NULL;

	if (!isl_int_is_zero(bmap->div[div][0]))
		return bmap;

	involves = bmap_eq_involves_unknown_divs(bmap, eq, 0, div);
	if (involves < 0)
		return isl_basic_map_free(bmap);
	if (involves)
		return bmap;

	total = isl_basic_map_dim(bmap, isl_dim_all);
	o_div = isl_basic_map_offset(bmap, isl_dim_div);
	isl_seq_neg(bmap->div[div] + 1, bmap->eq[eq], 1 + total);
	isl_int_set_si(bmap->div[div][1 + o_div + div], 0);
	isl_int_set(bmap->div[div][0], bmap->eq[eq][o_div + div]);
	if (progress)
		*progress = 1;
	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);

	return bmap;
}

__isl_give isl_basic_map *isl_basic_map_gauss(__isl_take isl_basic_map *bmap,
	int *progress)
{
	int k;
	int done;
	int last_var;
	unsigned total_var;
	unsigned total;

	bmap = isl_basic_map_order_divs(bmap);

	if (!bmap)
		return NULL;

	total = isl_basic_map_total_dim(bmap);
	total_var = total - bmap->n_div;

	last_var = total - 1;
	for (done = 0; done < bmap->n_eq; ++done) {
		for (; last_var >= 0; --last_var) {
			for (k = done; k < bmap->n_eq; ++k)
				if (!isl_int_is_zero(bmap->eq[k][1+last_var]))
					break;
			if (k < bmap->n_eq)
				break;
		}
		if (last_var < 0)
			break;
		if (k != done)
			swap_equality(bmap, k, done);
		if (isl_int_is_neg(bmap->eq[done][1+last_var]))
			isl_seq_neg(bmap->eq[done], bmap->eq[done], 1+total);

		eliminate_var_using_equality(bmap, last_var, bmap->eq[done], 1,
						progress);

		if (last_var >= total_var)
			bmap = set_div_from_eq(bmap, last_var - total_var,
						done, progress);
		if (!bmap)
			return NULL;
	}
	if (done == bmap->n_eq)
		return bmap;
	for (k = done; k < bmap->n_eq; ++k) {
		if (isl_int_is_zero(bmap->eq[k][0]))
			continue;
		return isl_basic_map_set_to_empty(bmap);
	}
	isl_basic_map_free_equality(bmap, bmap->n_eq-done);
	return bmap;
}

__isl_give isl_basic_set *isl_basic_set_gauss(
	__isl_take isl_basic_set *bset, int *progress)
{
	return bset_from_bmap(isl_basic_map_gauss(bset_to_bmap(bset),
							progress));
}


static unsigned int round_up(unsigned int v)
{
	int old_v = v;

	while (v) {
		old_v = v;
		v ^= v & -v;
	}
	return old_v << 1;
}

/* Hash table of inequalities in a basic map.
 * "index" is an array of addresses of inequalities in the basic map, some
 * of which are NULL.  The inequalities are hashed on the coefficients
 * except the constant term.
 * "size" is the number of elements in the array and is always a power of two
 * "bits" is the number of bits need to represent an index into the array.
 * "total" is the total dimension of the basic map.
 */
struct isl_constraint_index {
	unsigned int size;
	int bits;
	isl_int ***index;
	unsigned total;
};

/* Fill in the "ci" data structure for holding the inequalities of "bmap".
 */
static isl_stat create_constraint_index(struct isl_constraint_index *ci,
	__isl_keep isl_basic_map *bmap)
{
	isl_ctx *ctx;

	ci->index = NULL;
	if (!bmap)
		return isl_stat_error;
	ci->total = isl_basic_set_total_dim(bmap);
	if (bmap->n_ineq == 0)
		return isl_stat_ok;
	ci->size = round_up(4 * (bmap->n_ineq + 1) / 3 - 1);
	ci->bits = ffs(ci->size) - 1;
	ctx = isl_basic_map_get_ctx(bmap);
	ci->index = isl_calloc_array(ctx, isl_int **, ci->size);
	if (!ci->index)
		return isl_stat_error;

	return isl_stat_ok;
}

/* Free the memory allocated by create_constraint_index.
 */
static void constraint_index_free(struct isl_constraint_index *ci)
{
	free(ci->index);
}

/* Return the position in ci->index that contains the address of
 * an inequality that is equal to *ineq up to the constant term,
 * provided this address is not identical to "ineq".
 * If there is no such inequality, then return the position where
 * such an inequality should be inserted.
 */
static int hash_index_ineq(struct isl_constraint_index *ci, isl_int **ineq)
{
	int h;
	uint32_t hash = isl_seq_get_hash_bits((*ineq) + 1, ci->total, ci->bits);
	for (h = hash; ci->index[h]; h = (h+1) % ci->size)
		if (ineq != ci->index[h] &&
		    isl_seq_eq((*ineq) + 1, ci->index[h][0]+1, ci->total))
			break;
	return h;
}

/* Return the position in ci->index that contains the address of
 * an inequality that is equal to the k'th inequality of "bmap"
 * up to the constant term, provided it does not point to the very
 * same inequality.
 * If there is no such inequality, then return the position where
 * such an inequality should be inserted.
 */
static int hash_index(struct isl_constraint_index *ci,
	__isl_keep isl_basic_map *bmap, int k)
{
	return hash_index_ineq(ci, &bmap->ineq[k]);
}

static int set_hash_index(struct isl_constraint_index *ci,
	__isl_keep isl_basic_set *bset, int k)
{
	return hash_index(ci, bset, k);
}

/* Fill in the "ci" data structure with the inequalities of "bset".
 */
static isl_stat setup_constraint_index(struct isl_constraint_index *ci,
	__isl_keep isl_basic_set *bset)
{
	int k, h;

	if (create_constraint_index(ci, bset) < 0)
		return isl_stat_error;

	for (k = 0; k < bset->n_ineq; ++k) {
		h = set_hash_index(ci, bset, k);
		ci->index[h] = &bset->ineq[k];
	}

	return isl_stat_ok;
}

/* Is the inequality ineq (obviously) redundant with respect
 * to the constraints in "ci"?
 *
 * Look for an inequality in "ci" with the same coefficients and then
 * check if the contant term of "ineq" is greater than or equal
 * to the constant term of that inequality.  If so, "ineq" is clearly
 * redundant.
 *
 * Note that hash_index_ineq ignores a stored constraint if it has
 * the same address as the passed inequality.  It is ok to pass
 * the address of a local variable here since it will never be
 * the same as the address of a constraint in "ci".
 */
static isl_bool constraint_index_is_redundant(struct isl_constraint_index *ci,
	isl_int *ineq)
{
	int h;

	h = hash_index_ineq(ci, &ineq);
	if (!ci->index[h])
		return isl_bool_false;
	return isl_int_ge(ineq[0], (*ci->index[h])[0]);
}

/* If we can eliminate more than one div, then we need to make
 * sure we do it from last div to first div, in order not to
 * change the position of the other divs that still need to
 * be removed.
 */
static __isl_give isl_basic_map *remove_duplicate_divs(
	__isl_take isl_basic_map *bmap, int *progress)
{
	unsigned int size;
	int *index;
	int *elim_for;
	int k, l, h;
	int bits;
	struct isl_blk eq;
	unsigned total_var;
	unsigned total;
	struct isl_ctx *ctx;

	bmap = isl_basic_map_order_divs(bmap);
	if (!bmap || bmap->n_div <= 1)
		return bmap;

	total_var = isl_space_dim(bmap->dim, isl_dim_all);
	total = total_var + bmap->n_div;

	ctx = bmap->ctx;
	for (k = bmap->n_div - 1; k >= 0; --k)
		if (!isl_int_is_zero(bmap->div[k][0]))
			break;
	if (k <= 0)
		return bmap;

	size = round_up(4 * bmap->n_div / 3 - 1);
	if (size == 0)
		return bmap;
	elim_for = isl_calloc_array(ctx, int, bmap->n_div);
	bits = ffs(size) - 1;
	index = isl_calloc_array(ctx, int, size);
	if (!elim_for || !index)
		goto out;
	eq = isl_blk_alloc(ctx, 1+total);
	if (isl_blk_is_error(eq))
		goto out;

	isl_seq_clr(eq.data, 1+total);
	index[isl_seq_get_hash_bits(bmap->div[k], 2+total, bits)] = k + 1;
	for (--k; k >= 0; --k) {
		uint32_t hash;

		if (isl_int_is_zero(bmap->div[k][0]))
			continue;

		hash = isl_seq_get_hash_bits(bmap->div[k], 2+total, bits);
		for (h = hash; index[h]; h = (h+1) % size)
			if (isl_seq_eq(bmap->div[k],
				       bmap->div[index[h]-1], 2+total))
				break;
		if (index[h]) {
			*progress = 1;
			l = index[h] - 1;
			elim_for[l] = k + 1;
		}
		index[h] = k+1;
	}
	for (l = bmap->n_div - 1; l >= 0; --l) {
		if (!elim_for[l])
			continue;
		k = elim_for[l] - 1;
		isl_int_set_si(eq.data[1+total_var+k], -1);
		isl_int_set_si(eq.data[1+total_var+l], 1);
		bmap = eliminate_div(bmap, eq.data, l, 1);
		if (!bmap)
			break;
		isl_int_set_si(eq.data[1+total_var+k], 0);
		isl_int_set_si(eq.data[1+total_var+l], 0);
	}

	isl_blk_free(ctx, eq);
out:
	free(index);
	free(elim_for);
	return bmap;
}

static int n_pure_div_eq(struct isl_basic_map *bmap)
{
	int i, j;
	unsigned total;

	total = isl_space_dim(bmap->dim, isl_dim_all);
	for (i = 0, j = bmap->n_div-1; i < bmap->n_eq; ++i) {
		while (j >= 0 && isl_int_is_zero(bmap->eq[i][1 + total + j]))
			--j;
		if (j < 0)
			break;
		if (isl_seq_first_non_zero(bmap->eq[i] + 1 + total, j) != -1)
			return 0;
	}
	return i;
}

/* Normalize divs that appear in equalities.
 *
 * In particular, we assume that bmap contains some equalities
 * of the form
 *
 *	a x = m * e_i
 *
 * and we want to replace the set of e_i by a minimal set and
 * such that the new e_i have a canonical representation in terms
 * of the vector x.
 * If any of the equalities involves more than one divs, then
 * we currently simply bail out.
 *
 * Let us first additionally assume that all equalities involve
 * a div.  The equalities then express modulo constraints on the
 * remaining variables and we can use "parameter compression"
 * to find a minimal set of constraints.  The result is a transformation
 *
 *	x = T(x') = x_0 + G x'
 *
 * with G a lower-triangular matrix with all elements below the diagonal
 * non-negative and smaller than the diagonal element on the same row.
 * We first normalize x_0 by making the same property hold in the affine
 * T matrix.
 * The rows i of G with a 1 on the diagonal do not impose any modulo
 * constraint and simply express x_i = x'_i.
 * For each of the remaining rows i, we introduce a div and a corresponding
 * equality.  In particular
 *
 *	g_ii e_j = x_i - g_i(x')
 *
 * where each x'_k is replaced either by x_k (if g_kk = 1) or the
 * corresponding div (if g_kk != 1).
 *
 * If there are any equalities not involving any div, then we
 * first apply a variable compression on the variables x:
 *
 *	x = C x''	x'' = C_2 x
 *
 * and perform the above parameter compression on A C instead of on A.
 * The resulting compression is then of the form
 *
 *	x'' = T(x') = x_0 + G x'
 *
 * and in constructing the new divs and the corresponding equalities,
 * we have to replace each x'', i.e., the x'_k with (g_kk = 1),
 * by the corresponding row from C_2.
 */
static __isl_give isl_basic_map *normalize_divs(__isl_take isl_basic_map *bmap,
	int *progress)
{
	int i, j, k;
	int total;
	int div_eq;
	struct isl_mat *B;
	struct isl_vec *d;
	struct isl_mat *T = NULL;
	struct isl_mat *C = NULL;
	struct isl_mat *C2 = NULL;
	isl_int v;
	int *pos = NULL;
	int dropped, needed;

	if (!bmap)
		return NULL;

	if (bmap->n_div == 0)
		return bmap;

	if (bmap->n_eq == 0)
		return bmap;

	if (ISL_F_ISSET(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS))
		return bmap;

	total = isl_space_dim(bmap