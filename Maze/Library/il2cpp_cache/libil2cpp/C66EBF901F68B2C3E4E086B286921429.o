er);
		}
	}
	static FORCEINLINE void ColorMaskIndexed(GLuint Index, GLboolean Red, GLboolean Green, GLboolean Blue, GLboolean Alpha)
	{
		if (bSupportsDrawBuffersBlend)
		{
			// ES 3.2 or extension
			glColorMaskiEXT(Index, Red, Green, Blue, Alpha);
		}
		else
		{
			check(Index == 0);
			glColorMask(Red, Green, Blue, Alpha);
		}
	}
	static FORCEINLINE void BlendEquationi(GLuint Buf, GLenum Mode)
	{
		// ES 3.2 or extension
		glBlendEquationiEXT(Buf, Mode);
	}
	static FORCEINLINE void BlendEquationSeparatei(GLuint Buf, GLenum ModeRGB, GLenum ModeAlpha)
	{
		// ES 3.2 or extension
		glBlendEquationSeparateiEXT(Buf, ModeRGB, ModeAlpha);
	}
	static FORCEINLINE void BlendFunci(GLuint Buf, GLenum Src, GLenum Dst)
	{
		// ES 3.2 or extension
		glBlendFunciEXT(Buf, Src, Dst);
	}
	static FORCEINLINE void BlendFuncSeparatei(GLuint Buf, GLenum SrcRGB, GLenum DstRGB, GLenum SrcAlpha, GLenum DstAlpha)
	{
		// ES 3.2 or extension
		glBlendFuncSeparateiEXT(Buf, SrcRGB, DstRGB, SrcAlpha, DstAlpha);
	}

	static FORCEINLINE void TexBuffer(GLenum Target, GLenum InternalFormat, GLuint Buffer)
	{
		// ES 3.2 or extension
		glTexBufferEXT(Target, InternalFormat, Buffer);
	}

	static FORCEINLINE void TexBufferRange(GLenum Target, GLenum InternalFormat, GLuint Buffer, GLintptr Offset, GLsizeiptr Size)
	{
		// ES 3.2 or extension
		glTexBufferRangeEXT(Target, InternalFormat, Buffer, Offset, Size);
	}

	static FORCEINLINE void ProgramUniform4uiv(GLuint Program, GLint Location, GLsizei Count, const GLuint* Value)
	{
		glUniform4uiv(Location, Count, Value);
	}

	static FORCEINLINE bool SupportsProgramBinary() { return true; }

	static FORCEINLINE void GetProgramBinary(GLuint Program, GLsizei BufSize, GLsizei* Length, GLenum* BinaryFormat, void* Binary)
	{
		glGetProgramBinary(Program, BufSize, Length, BinaryFormat, Binary);
	}

	static FORCEINLINE void ProgramBinary(GLuint Program, GLenum BinaryFormat, const void* Binary, GLsizei Length)
	{
		glProgramBinary(Program, BinaryFormat, Binary, Length);
	}

	static FORCEINLINE void ProgramParameter(GLuint Program, GLenum PName, GLint Value)
	{
		glProgramParameteri(Program, PName, Value);
	}

	static FORCEINLINE void BindBufferBase(GLenum Target, GLuint Index, GLuint Buffer)
	{
		glBindBufferBase(Target, Index, Buffer);
	}

	static FORCEINLINE void BindBufferRange(GLenum Target, GLuint Index, GLuint Buffer, GLintptr Offset, GLsizeiptr Size)
	{
		glBindBufferRange(Target, Index, Buffer, Offset, Size);
	}

	static FORCEINLINE GLuint GetUniformBlockIndex(GLuint Program, const GLchar* UniformBlockName)
	{
		return glGetUniformBlockIndex(Program, UniformBlockName);
	}

	static FORCEINLINE void UniformBlockBinding(GLuint Program, GLuint UniformBlockIndex, GLuint UniformBlockBinding)
	{
		glUniformBlockBinding(Program, UniformBlockIndex, UniformBlockBinding);
	}

	static FORCEINLINE void BufferSubData(GLenum Target, GLintptr Offset, GLsizeiptr Size, const GLvoid* Data)
	{
		glBufferSubData(Target, Offset, Size, Data);
	}

	static FORCEINLINE void VertexAttribIPointer(GLuint Index, GLint Size, GLenum Type, GLsizei Stride, const GLvoid* Pointer)
	{
		glVertexAttribIPointer(Index, Size, Type, Stride, Pointer);
	}

	static FORCEINLINE void GenSamplers(GLsizei Count, GLuint* Samplers)
	{
		glGenSamplers(Count, Samplers);
	}

	static FORCEINLINE void DeleteSamplers(GLsizei Count, GLuint* Samplers)
	{
		glDeleteSamplers(Count, Samplers);
	}

	static FORCEINLINE void SetSamplerParameter(GLuint Sampler, GLenum Parameter, GLint Value)
	{
		glSamplerParameteri(Sampler, Parameter, Value);
	}

	static FORCEINLINE void BindSampler(GLuint Unit, GLuint Sampler)
	{
		glBindSampler(Unit, Sampler);
	}

	static FORCEINLINE void MemoryBarrier(GLbitfield Barriers)
	{
		glMemoryBarrier(Barriers);
	}

	static FORCEINLINE void DispatchCompute(GLuint NumGroupsX, GLuint NumGroupsY, GLuint NumGroupsZ)
	{
		glDispatchCompute(NumGroupsX, NumGroupsY, NumGroupsZ);
	}

	static FORCEINLINE void DispatchComputeIndirect(GLintptr Offset)
	{
		glDispatchComputeIndirect(Offset);
	}

	static FORCEINLINE void BindImageTexture(GLuint Unit, GLuint Texture, GLint Level, GLboolean Layered, GLint Layer, GLenum Access, GLenum Format)
	{
		glBindImageTexture(Unit, Texture, Level, Layered, Layer, Access, Format);
	}
	
	static FORCEINLINE void DepthRange(GLdouble Near, GLdouble Far)
	{
		glDepthRangef(Near, Far);
	}

	static FORCEINLINE void VertexAttribPointer(GLuint Index, GLint Size, GLenum Type, GLboolean Normalized, GLsizei Stride, const GLvoid* Pointer)
	{
		Size = (Size == GL_BGRA) ? 4 : Size;
		glVertexAttribPointer(Index, Size, Type, Normalized, Stride, Pointer);
	}

	static FORCEINLINE void ClearDepth(GLdouble Depth)
	{
		glClearDepthf(Depth);
	}

	static FORCEINLINE GLuint GetMajorVersion()
	{
		return 3;
	}

	static FORCEINLINE GLuint GetMinorVersion()
	{
		return 1;
	}

	static FORCEINLINE EShaderPlatform GetShaderPlatform()
	{
		return SP_OPENGL_ES3_1_ANDROID;
	}

	static FORCEINLINE ERHIFeatureLevel::Type GetFeatureLevel()
	{
		return ERHIFeatureLevel::ES3_1;
	}

	static FORCEINLINE FString GetAdapterName()
	{
		return (TCHAR*)ANSI_TO_TCHAR((const ANSICHAR*)glGetString(GL_RENDERER));
	}

	static FORCEINLINE void TexParameter(GLenum Target, GLenum Parameter, GLint Value)
	{
		glTexParameteri(Target, Parameter, Value);
	}

	static FORCEINLINE void FramebufferTexture(GLenum Target, GLenum Attachment, GLuint Texture, GLint Level)
	{
		check(0);
	}

	static FORCEINLINE void FramebufferTexture3D(GLenum Target, GLenum Attachment, GLenum TexTarget, GLuint Texture, GLint Level, GLint ZOffset)
	{
		check(0);
	}

	static FORCEINLINE void FramebufferTextureLayer(GLenum Target, GLenum Attachment, GLuint Texture, GLint Level, GLint Layer)
	{
		glFramebufferTextureLayer(Target, Attachment, Texture, Level, Layer);
	}

	static FORCEINLINE void FramebufferTexture2D(GLenum Target, GLenum Attachment, GLenum TexTarget, GLuint Texture, GLint Level)
	{
		check(Attachment == GL_COLOR_ATTACHMENT0 ||
				Attachment == GL_DEPTH_ATTACHMENT || 
				Attachment == GL_STENCIL_ATTACHMENT ||
				Attachment == GL_DEPTH_STENCIL_ATTACHMENT ||
				(SupportsMultipleRenderTargets() && Attachment >= GL_COLOR_ATTACHMENT0 && Attachment <= GL_COLOR_ATTACHMENT7));

		glFramebufferTexture2D(Target, Attachment, TexTarget, Texture, Level);
		VERIFY_GL(FramebufferTexture_2D);
	}

	static FORCEINLINE void BlitFramebuffer(GLint SrcX0, GLint SrcY0, GLint SrcX1, GLint SrcY1, GLint DstX0, GLint DstY0, GLint DstX1, GLint DstY1, GLbitfield Mask, GLenum Filter)
	{
		glBlitFramebuffer(SrcX0, SrcY0, SrcX1, SrcY1, DstX0, DstY0, DstX1, DstY1, Mask, Filter);
	}

	static FORCEINLINE bool TexStorage2D(GLenum Target, GLint Levels, GLint InternalFormat, GLsizei Width, GLsizei Height, GLenum Format, GLenum Type, uint32 Flags)
	{
		glTexStorage2D(Target, Levels, InternalFormat, Width, Height);
		VERIFY_GL(glTexStorage2D);
		return true;
	}

	static FORCEINLINE void DrawArraysInstanced(GLenum Mode, GLint First, GLsizei Count, GLsizei InstanceCount)
	{
		glDrawArraysInstanced(Mode, First, Count, InstanceCount);
	}

	static FORCEINLINE void DrawElementsInstanced(GLenum Mode, GLsizei Count, GLenum Type, const GLvoid* Indices, GLsizei InstanceCount)
	{
		glDrawElementsInstanced(Mode, Count, Type, Indices, InstanceCount);
	}

	static FORCEINLINE void CopyBufferSubData(GLenum ReadTarget, GLenum WriteTarget, GLintptr ReadOffset, GLintptr WriteOffset, GLsizeiptr Size)
	{
		glCopyBufferSubData(ReadTarget, WriteTarget, ReadOffset, WriteOffset, Size);
	}

	static FORCEINLINE void DrawArraysIndirect(GLenum Mode, const void* Offset)
	{
		glDrawArraysIndirect(Mode, Offset);
	}

	static FORCEINLINE void DrawElementsIndirect(GLenum Mode, GLenum Type, const void* Offset)
	{
		glDrawElementsIndirect(Mode, Type, Offset);
	}

	static FORCEINLINE void VertexAttribDivisor(GLuint Index, GLuint Divisor)
	{
		glVertexAttribDivisor(Index, Divisor);
	}

	static FORCEINLINE void TexStorage3D(GLenum Target, GLint Levels, GLint InternalFormat, GLsizei Width, GLsizei Height, GLsizei Depth, GLenum Format, GLenum Type)
	{
		glTexStorage3D(Target, Levels, InternalFormat, Width, Height, Depth);
	}

	static FPlatformOpenGLDevice* CreateDevice()	UGL_REQUIRED(NULL)
	static FPlatformOpenGLContext* CreateContext(FPlatformOpenGLDevice* Device, void* WindowHandle)	UGL_REQUIRED(NULL)

	static FORCEINLINE void InvalidateFramebuffer(GLenum Target, GLsizei NumAttachments, const GLenum* Attachments)
	{
		glInvalidateFramebuffer(Target, NumAttachments, Attachments);
	}

	static FORCEINLINE void GenBuffers(GLsizei n, GLuint* buffers)
	{
		glGenBuffers(n, buffers);
	}

	static FORCEINLINE void GenTextures(GLsizei n, GLuint* textures)
	{
		glGenTextures(n, textures);
	}

	static FORCEINLINE bool TimerQueryDisjoint()
	{
		bool Disjoint = false;

		if (bTimerQueryCanBeDisjoint)
		{
			GLint WasDisjoint = 0;
			glGetIntegerv(GL_GPU_DISJOINT_EXT, &WasDisjoint);
			Disjoint = (WasDisjoint != 0);
		}

		return Disjoint;
	}

	static FORCEINLINE void BindVertexBuffer(GLuint BindingIndex, GLuint Buffer, GLintptr Offset, GLsizei Stride)
	{
		glBindVertexBuffer(BindingIndex, Buffer, Offset, Stride);
	}
	static FORCEINLINE void VertexAttribFormat(GLuint AttribIndex, GLint Size, GLenum Type, GLboolean Normalized, GLuint RelativeOffset)
	{
		glVertexAttribFormat(AttribIndex, Size, Type, Normalized, RelativeOffset);
	}
	static FORCEINLINE void VertexAttribIFormat(GLuint AttribIndex, GLint Size, GLenum Type, GLuint RelativeOffset)
	{
		glVertexAttribIFormat(AttribIndex, Size, Type, RelativeOffset);
	}
	static FORCEINLINE void VertexAttribBinding(GLuint AttribIndex, GLuint BindingIndex)
	{
		glVertexAttribBinding(AttribIndex, BindingIndex);
	}
	static FORCEINLINE void VertexBindingDivisor(GLuint BindingIndex, GLuint Divisor)
	{
		glVertexBindingDivisor(BindingIndex, Divisor);
	}

	static FORCEINLINE void BufferStorage(GLenum Target, GLsizeiptr Size, const void* Data, GLbitfield Flags)
	{
		glBufferStorageEXT(Target, Size, Data, Flags);
	}
protected:
	/** GL_EXT_disjoint_timer_query */
	static bool bSupportsDisjointTimeQueries;

	/** Some timer query implementations are never disjoint */
	static bool bTimerQueryCanBeDisjoint;

	/** GL_APPLE_texture_format_BGRA8888 */
	static bool bSupportsBGRA8888;

	/** GL_NV_texture_compression_s3tc, GL_EXT_texture_compression_s3tc */
	static bool bSupportsDXT;

	/** OpenGL ES 3.0 profile */
	static bool bSupportsETC2;

	/** GL_EXT_color_buffer_float */
	static bool bSupportsColorBufferFloat;

	/** GL_EXT_color_buffer_half_float */
	static bool bSupportsColorBufferHalfFloat;

	/** GL_EXT_shader_framebuffer_fetch */
	static bool bSupportsShaderFramebufferFetch;

	/** workaround for GL_EXT_shader_framebuffer_fetch */
	static bool bRequiresUEShaderFramebufferFetchDef;

	/** GL_ARM_shader_framebuffer_fetch_depth_stencil */
	static bool bSupportsShaderDepthStencilFetch;

	/** GL_EXT_MULTISAMPLED_RENDER_TO_TEXTURE */
	static bool bSupportsMultisampledRenderToTexture;

	/** GL_FRAGMENT_SHADER, GL_LOW_FLOAT */
	static int ShaderLowPrecision;

	/** GL_FRAGMENT_SHADER, GL_MEDIUM_FLOAT */
	static int ShaderMediumPrecision;

	/** GL_FRAGMENT_SHADER, GL_HIGH_FLOAT */
	static int ShaderHighPrecision;

	/** GL_NV_framebuffer_blit */
	static bool bSupportsNVFrameBufferBlit;

	/** GL_OES_standard_derivations */
	static bool bSupportsStandardDerivativesExtension;

	/** Maximum number of MSAA samples supported on chip in tile memory, or 1 if not available */
	static GLint MaxMSAASamplesTileMem;
public:
	/* This indicates failure when attempting to retrieve driver's binary representation of the hack program  */
	static bool bBinaryProgramRetrievalFailed;

	/* Some Mali devices do not work correctly with early_fragment_test enabled */
	static bool bRequiresDisabledEarlyFragmentTests;
		
	/* This is to avoid a bug in Adreno drivers that define GL_ARM_shader_framebuffer_fetch_depth_stencil even when device does not support this extension  */
	static bool bRequiresARMShaderFramebufferFetchDepthStencilUndef;

	/** GL_OES_vertex_type_10_10_10_2 */
	static bool bSupportsRGB10A2;

	/** GL_OES_get_program_binary */
	static bool bSupportsProgramBinary;

	/** GL_EXT_buffer_storage */
	static bool bSupportsBufferStorage;

	enum class EFeatureLevelSupport : uint8
	{
		Invalid,	// no feature level has yet been determined
		ES2,
		ES31,
		ES32
	};

	/** Describes which feature level is currently being supported */
	static EFeatureLevelSupport CurrentFeatureLevelSupport;

	/** Whether device supports Hidden Surface Removal */
	static bool bHasHardwareHiddenSurfaceRemoval;

	/** Whether device supports mobile multi-view */
	static bool bSupportsMobileMultiView;

	static GLint MaxComputeTextureImageUnits;
	static GLint MaxComputeUniformComponents;

	static GLint MaxCombinedUAVUnits;
	static GLint MaxComputeUAVUnits;
	static GLint MaxPixelUAVUnits;
};

#endif //desktop
                                          [\#΋aa3"4b#nÃi\ԩ$OJ%`1{9}fӍ7>N5L¤44$esoZE GE4:K
I/=K+s-l^aڧxZLIgYsU6n"g",J5G7J	H6Ok׆K=|qchbZР6b~(2JQKWHWmޙ5(֫_}~Hu5(gH	 &KOU#8N3嗲؁|H8{꾩PP+jn21;aHD^:kvH"fYa
.^h{lK)>^l(`{	E'l%bXu؎Ӌd~Z9<Jзi4."=**Nз}LIQ5_fw]*^.Inm>Bњ.	>9F_C3qU4S4,%0qr]hQ+d{c{4"uVma	+h&3z/we|w=^xj{{5ԭx0X
P=bV(	-@dy+($#դU4j^]l+N4阂=uT;?7(Q#Ix{ɒ,f'H-E\'%JH:K.gPfm$lɑ
o^Lߗ[$/k!VplqR5?j瀊Ҹ}2B@%?㽯E#[Tps9]9P0nU+kzqPZԩgf	8aDMOW79VK{ gШ%j%vݹN&ȃ536H*۬D::3c0?NQؗTCcI0Ţ;ګj͛q>$ÿ$7o"=A"{4ǜp@cAIcFFE~~ܳ`7bWQŸA/Q=Fѫ(>`W/~'liY@RzdI?б+h5H=ǴqE5Ͽ>-U<k~Di6/3
>o\8;2w(eF2"wF`vs$J%ߎ;kq$blڗI+3|Ii2{a1B%[KCWU7#S3'Zb&W*
@VV
9&X01!{°0|3rr:axat
kWVNUgt>;D7ũiĜC/0lxV	JѰw{2jbŦHt!̿
M૪eD:S35P|sӂaۼ[)tASwB·vHNKRY8M_}i3,?RV؜=h3a[ˍDRwG_La2nx8	2y(0-1UmGF.q+/lfx?Av?37XHLUX@?eMdts(?a(ЧǓ=X\ 
5b'Ɛ57N.K(<i
B&x֖"'yiA^)T C5r{ZgkèͣNl$X돶dKmSP8myGyki(	Tf;;S΁QXkHuc^cy#Q
ɶ<P#o
\p`CEݲu	c4ȿ,>|c=i~#*KNޏө>3`<GBjjBw^R@[K 8~Z$ãmWZmf \X&hc&M1o:58UnڧxA/pJ>( 	-@Db[t_9X$R@ے[͚୾{:S^Oh[Rљd&[`BVZtJZ1pWtvދ&;~Hц2ԴQh189lm:qT,:Aѹ=$2v3J0
T.U'W\K)Zv#7OwU~	)?mRHCЛZ_yxF 4 9@UΘjoTF;Oqm	 :1"Mf޹KzX*y6v? UT9,˫[D\=E9ݷch.Z	PM^_+wV}0DFu;}@N1W<<Оg?j]e< 	.5_
w$UDKaJN
_ZgUa(4&ϔHE	4?a0j[#3a?1v*BB8X CD]davI6~Ӌux=%aKYJ-OR[X񥳣Vg4Z
z3T{iA)S3>زP^an^jcVQQܤ"T;W}ixBԶ.MK Zֿ\B9ZZd޷By,ٛ7SJ~ʗ	mNoW}"I@mCx7 xg#]R\pW6@k[O)+$ 	,C߫&F-PPrD8݇ڙIruXI\J^\}&/L5^4JtѩJg)C)`-!k|æyD{ːLZn=8_¸Sal=茪 >,i^%q4avvqyrԍHST(+{#]+T/̠nQvp-MU