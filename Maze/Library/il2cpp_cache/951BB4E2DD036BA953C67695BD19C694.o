t) { throw null; }
        public bool IsVisible(System.Drawing.Point pt, System.Drawing.Graphics graphics) { throw null; }
        public bool IsVisible(System.Drawing.PointF point) { throw null; }
        public bool IsVisible(System.Drawing.PointF pt, System.Drawing.Graphics graphics) { throw null; }
        public bool IsVisible(int x, int y) { throw null; }
        public bool IsVisible(int x, int y, System.Drawing.Graphics graphics) { throw null; }
        public bool IsVisible(float x, float y) { throw null; }
        public bool IsVisible(float x, float y, System.Drawing.Graphics graphics) { throw null; }
        public void Reset() { }
        public void Reverse() { }
        public void SetMarkers() { }
        public void StartFigure() { }
        public void Transform(System.Drawing.Drawing2D.Matrix matrix) { }
        [System.MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
        public void Warp(System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect) { }
        [System.MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
        public void Warp(System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix) { }
        [System.MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
        public void Warp(System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode) { }
        [System.MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
        public void Warp(System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness) { }
        [System.MonoTODOAttribute("GdipWidenPath isn't implemented in libgdiplus")]
        public void Widen(System.Drawing.Pen pen) { }
        [System.MonoTODOAttribute("GdipWidenPath isn't implemented in libgdiplus")]
        public void Widen(System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix) { }
        [System.MonoTODOAttribute("GdipWidenPath isn't implemented in libgdiplus")]
        public void Widen(System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness) { }
    }
    public sealed partial class GraphicsPathIterator : System.MarshalByRefObject, System.IDisposable
    {
        public GraphicsPathIterator(System.Drawing.Drawing2D.GraphicsPath path) { }
        public int Count { get { throw null; } }
        public int SubpathCount { get { throw null; } }
        public int CopyData(ref System.Drawing.PointF[] points, ref byte[] types, int startIndex, int endIndex) { throw null; }
        public void Dispose() { }
        public int Enumerate(ref System.Drawing.PointF[] points, ref byte[] types) { throw null; }
        ~GraphicsPathIterator() { }
        public bool HasCurve() { throw null; }
        public int NextMarker(System.Drawing.Drawing2D.GraphicsPath path) { throw null; }
        public int NextMarker(out int startIndex, out int endIndex) { startIndex = default(int); endIndex = default(int); throw null; }
        public int NextPathType(out byte pathType, out int startIndex, out int endIndex) { pathType = default(byte); startIndex = default(int); endIndex = default(int); throw null; }
        public int NextSubpath(System.Drawing.Drawing2D.GraphicsPath path, out bool isClosed) { isClosed = default(bool); throw null; }
        public int NextSubpath(out int startIndex, out int endIndex, out bool isClosed) { startIndex = default(int); endIndex = default(int); isClosed = default(bool); throw null; }
        public void Rewind() { }
    }
    public sealed partial class GraphicsState : System.MarshalByRefObject
    {
        internal GraphicsState() { }
    }
    public sealed partial class HatchBrush : System.Drawing.Brush
    {
        public HatchBrush(System.Drawing.Drawing2D.HatchStyle hatchstyle, System.Drawing.Color foreColor) { }
        public HatchBrush(System.Drawing.Drawing2D.HatchStyle hatchstyle, System.Drawing.Color foreColor, System.Drawing.Color backColor) { }
        public System.Drawing.Color BackgroundColor { get { throw null; } }
        public System.Drawing.Color ForegroundColor { get { throw null; } }
        public System.Drawing.Drawing2D.HatchStyle HatchStyle { get { throw null; } }
        public override object Clone() { throw null; }
    }
    public enum HatchStyle
    {
        BackwardDiagonal = 3,
        Cross = 4,
        DarkDownwardDiagonal = 20,
        DarkHorizontal = 29,
        DarkUpwardDiagonal = 21,
        DarkVertical = 28,
        DashedDownwardDiagonal = 30,
        DashedHorizontal = 32,
        DashedUpwardDiagonal = 31,
        DashedVertical = 33,
        DiagonalBrick = 38,
        DiagonalCross = 5,
        Divot = 42,
        DottedDiamond = 44,
        DottedGrid = 43,
        ForwardDiagonal = 2,
        Horizontal = 0,
        HorizontalBrick = 39,
        LargeCheckerBoard = 50,
        LargeConfetti = 35,
        LargeGrid = 4,
        LightDownwardDiagonal = 18,
        LightHorizontal = 25,
        LightUpwardDiagonal = 19,
        LightVertical = 24,
        Max = 4,
        Min = 0,
        NarrowHorizontal = 27,
        NarrowVertical = 26,
        OutlinedDiamond = 51,
        Percent05 = 6,
        Percent10 = 7,
        Percent20 = 8,
        Percent25 = 9,
        Percent30 = 10,
        Percent40 = 11,
        Percent50 = 12,
        Percent60 = 13,
        Percent70 = 14,
        Percent75 = 15,
        Percent80 = 16,
        Percent90 = 17,
        Plaid = 41,
        Shingle = 45,
        SmallCheckerBoard = 49,
        SmallConfetti = 34,
        SmallGrid = 48,
        SolidDiamond = 52,
        Sphere = 47,
        Trellis = 46,
        Vertical = 1,
        Wave = 37,
        Weave = 40,
        WideDownwardDiagonal = 22,
        WideUpwardDiagonal = 23,
        ZigZag = 36,
    }
    public enum InterpolationMode
    {
        Bicubic = 4,
        Bilinear = 3,
        Default = 0,
        High = 2,
        HighQualityBicubic = 7,
        HighQualityBilinear = 6,
        Invalid = -1,
        Low = 1,
        NearestNeighbor = 5,
    }
    public sealed partial class LinearGradientBrush : System.Drawing.Brush
    {
        public LinearGradientBrush(System.Drawing.Point point1, System.Drawing.Point point2, System.Drawing.Color color1, System.Drawing.Color color2) { }
        public LinearGradientBrush(System.Drawing.PointF point1, System.Drawing.PointF point2, System.Drawing.Color color1, System.Drawing.Color color2) { }
        public LinearGradientBrush(System.Drawing.Rectangle rect, System.Drawing.Color color1, System.Drawing.Color color2, System.Drawing.Drawing2D.LinearGradientMode linearGradientMode) { }
        public LinearGradientBrush(System.Drawing.Rectangle rect, System.Drawing.Color color1, System.Drawing.Color color2, float angle) { }
        public LinearGradientBrush(System.Drawing.Rectangle rect, System.Drawing.Color color1, System.Drawing.Color color2, float angle, bool isAngleScaleable) { }
        public LinearGradientBrush(System.Drawing.RectangleF rect, System.Drawing.Color color1, System.Drawing.Color color2, System.Drawing.Drawing2D.LinearGradientMode linearGradientMode) { }
        public LinearGradientBrush(System.Drawing.RectangleF rect, System.Drawing.Color color1, System.Drawing.Color color2, float angle) { }
        public LinearGradientBrush(System.Drawing.RectangleF rect, System.Drawing.Color color1, System.Drawing.Color color2, float angle, bool isAngleScaleable) { }
        public System.Drawing.Drawing2D.Blend Blend { get { throw null; } set { } }
        [System.MonoTODOAttribute("The GammaCorrection value is ignored when using libgdiplus.")]
        public bool GammaCorrection { get { throw null; } set { } }
        public System.Drawing.Drawing2D.ColorBlend InterpolationColors { get { throw null; } set { } }
        public System.Drawing.Color[] LinearColors { get { throw null; } set { } }
        public System.Drawing.RectangleF Rectangle { get { throw null; } }
        public System.Drawing.Drawing2D.Matrix Transform { get { throw null; } set { } }
        public System.Drawing.Drawing2D.WrapMode WrapMode { get { throw null; } set { } }
        public override object Clone() { throw null; }
        public void MultiplyTransform(System.Drawing.Drawing2D.Matrix matrix) { }
        public void MultiplyTransform(System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void ResetTransform() { }
        public void RotateTransform(float angle) { }
        public void RotateTransform(float angle, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void ScaleTransform(float sx, float sy) { }
        public void ScaleTransform(float sx, float sy, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void SetBlendTriangularShape(float focus) { }
        public void SetBlendTriangularShape(float focus, float scale) { }
        public void SetSigmaBellShape(float focus) { }
        public void SetSigmaBellShape(float focus, float scale) { }
        public void TranslateTransform(float dx, float dy) { }
        public void TranslateTransform(float dx, float dy, System.Drawing.Drawing2D.MatrixOrder order) { }
    }
    public enum LinearGradientMode
    {
        BackwardDiagonal = 3,
        ForwardDiagonal = 2,
        Horizontal = 0,
        Vertical = 1,
    }
    public enum LineCap
    {
        AnchorMask = 240,
        ArrowAnchor = 20,
        Custom = 255,
        DiamondAnchor = 19,
        Flat = 0,
        NoAnchor = 16,
        Round = 2,
        RoundAnchor = 18,
        Square = 1,
        SquareAnchor = 17,
        Triangle = 3,
    }
    public enum LineJoin
    {
        Bevel = 1,
        Miter = 0,
        MiterClipped = 3,
        Round = 2,
    }
    public sealed partial class Matrix : System.MarshalByRefObject, System.IDisposable
    {
        public Matrix() { }
        public Matrix(System.Drawing.Rectangle rect, System.Drawing.Point[] plgpts) { }
        public Matrix(System.Drawing.RectangleF rect, System.Drawing.PointF[] plgpts) { }
        public Matrix(float m11, float m12, float m21, float m22, float dx, float dy) { }
        public float[] Elements { get { throw null; } }
        public bool IsIdentity { get { throw null; } }
        public bool IsInvertible { get { throw null; } }
        public float OffsetX { get { throw null; } }
        public float OffsetY { get { throw null; } }
        public System.Drawing.Drawing2D.Matrix Clone() { throw null; }
        public void Dispose() { }
        public override bool Equals(object obj) { throw null; }
        ~Matrix() { }
        public override int GetHashCode() { throw null; }
        public void Invert() { }
        public void Multiply(System.Drawing.Drawing2D.Matrix matrix) { }
        public void Multiply(System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void Reset() { }
        public void Rotate(float angle) { }
        public void Rotate(float angle, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void RotateAt(float angle, System.Drawing.PointF point) { }
        public void RotateAt(float angle, System.Drawing.PointF point, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void Scale(float scaleX, float scaleY) { }
        public void Scale(float scaleX, float scaleY, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void Shear(float shearX, float shearY) { }
        public void Shear(float shearX, float shearY, System.Drawing.Drawing2D.MatrixOrder order) { }
        public void TransformPoints(System.Drawing.PointF[] pts) { }
        public void TransformPoints(System.Drawing.Point[] pts) { }
        public void TransformVectors(System.Drawing.PointF[] pts) { }
        public void TransformVectors(System.Drawing.Point[] pts) { }
        public void Translate(float offse