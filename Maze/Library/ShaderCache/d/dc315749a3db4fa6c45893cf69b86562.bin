	// Implicit assumption: no triangles overlap.  
						// NB: what about the case where an edge intersects the texel center?  
						// then it would be 'inside' the two triangles. Currently the first one wins.

						if (TexelData.SignedDistance < 0.) continue;

						// This texel is [i, i+1) x [j, j+1) 
						// The UV of this texel center

						const DVec2d TexelCenterUV = { DeltaX * (i + 0.5), DeltaY * (j + 0.5) };
						//const DVec2d TexelCenterUV = { DeltaX * (i), DeltaY * (j) };
						// Compute the Scaled Distances for a quick inside / outside test applied to the texel center.

						DArray3d ScaledDistances;
						ComputeScaledDistances(TriangleUV, TexelCenterUV, ScaledDistances);
						//ConvertScaledDistanceToBarycentric(TriangleUV, ScaledDistances);

						// This assumes the polygon was given in a counter clockwise orientation.   
						// If the orientation were clockwise, these would all become <= instead.


						const bool bInside = (ScaledDistances[0] >= 0. && ScaledDistances[1] >= 0. && ScaledDistances[2] >= 0.);

						{
							// Only one thread is allowed to compute data for this texel at a time..

							tbb::spin_mutex::scoped_lock(MutexGrid(i, j));

							// verify that another thread hasn't already identified this texel as interior to a triangle.

							if (TexelData