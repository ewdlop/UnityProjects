 sizes match on both platforms
		PX_ASSERT( elemSize >= GetAlignment<float>::value ); //If alignment is non-trivial below algorithm will not work
		PX_ASSERT( size > elemSize );

		//Just swap all PxReals
		for(size_t i = 0; i < size; i += elemSize)
			SwapBytes(data + i, elemSize, TYPE_F32);
	}
}

//Convert value to platform-independent format (network byte order)
template<typename T> PX_INLINE static T Canonize(T x)
{
	if( !IsBigEndian() )
		SwapBytes((char *)&x, sizeof(T), GetDataType<T>::value);

	return x;
}

//Convert value to native format (from network byte order)
template<typename T> PX_INLINE static T Decanonize(T x)
{
	return Canonize(x);
}

//Read platform-independent value from stream and convert it to native format
template<typename T> static PX_INLINE T readAndConvert(const char *&p)
{
	T val;
	memcpy((char *)&val, p, sizeof(T));
	val = De