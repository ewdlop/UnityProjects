es[i].size();s++)
            {
              int part = rand()% parts.size();
              parts[part]._samples[i].push_back(_samples[i][s]);
            }
        }
    }
    
    void 
    writeData(DeepScanLineOutputPart & part) const
    {
        Box2i dw=part.header().dataWindow();
        size_t output_pixels = (dw.size().x+1)*(dw.size().y+1);
        
        // how many times we'll write the same pattern
        size_t repeats = 1+(output_pixels/_results.size());
        
        size_t sample_buffer_size = totalSamples()*repeats;
        
        // buffer for sample counts
        vector<unsigned int> counts(output_pixels);
        
        // buffers for sample pointers
        vector< vector<T *> > sample_pointers(_channels.size());
        
        // buffer for actual sample data
        vector< vector<T> > sample_buffers(_channels.size());
        
        for(size_t i=0;i<sample_buffers.size();i++)
        {
            sample_pointers[i].resize(output_pixels);
            sample_buffers[i].resize(sample_buffer_size);
        }
        
        
        size_t pixel=0; // which pixel we are currently writing
        size_t sample=0; // which sample we are currently writing into
        
        for(size_t p=0;p<output_pixels;p++)
        {
            size_t count = _samples[pixel].size();
            counts[p]=count;
            if( count>0 )
            {
                for(size_t c=0 ; c<_channels.size() ; c++)
                {
                    for(size_t s=0 ; s < count ; s++ )
                    {
                        sample_buffers[c][sample+s]=_samples[pixel][s][c];
                    }
                    sample_pointers[c][p]=&sample_buffers[c][sample];
                }
                sample+=count;
            }
            pixel++;
            if(pixel==_sample