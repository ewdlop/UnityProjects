ame, JobGuid, ProxyDelegate);

	// Position the merged actor at the right location
	if(MergedActor->GetRootComponent() == nullptr)
	{
		USceneComponent* RootComponent = NewObject< USceneComponent >(MergedActor, USceneComponent::StaticClass(), *MergedActor->GetActorLabel(), RF_Transactional);

		MergedActor->AddInstanceComponent(RootComponent);
		MergedActor->SetRootComponent(RootComponent);
	}

	// Keep the merged actor in the hierarchy, taking the parent of the first component
	// In the future, the merged actor could be attached to the common ancestor instead of the first parent in the list
	MergedActor->GetRootComponent()->AttachToComponent(ComponentsToMerge[0]->GetAttachParent(), FAttachmentTransformRules::KeepWorldTransform);

	// Collect all objects to be deleted
	TArray<UObject*> ObjectsToDelete;
	ObjectsToDelete.Reserve(ComponentsToMerge.Num() + ActorsToMerge.Num());

	// Simple way to delete the actors: detach the merged components if it's safe to do so
	for(UPrimitiveComponent* Component : ComponentsToMerge)
	{
		if(Component->GetNumChildrenComponents() == 0)
		{
			Component->DetachFromComponent(FDetachmentTransformRules::KeepRelativeTransform);
		}
		else if(UStaticMeshComponent* StaticMeshComponent = Cast<UStaticMeshComponent>(Component))
		{
			// To keep the children in the hierarchy, simply hide the StaticMesh, but the StaticMeshComponent could be replaced by a SceneComponent and
			// then attach the children to it
			StaticMeshComponent->SetStaticMesh(nullptr);
		}
	}

	// Then delete the merged actors that don't have any children component
	for(AActor* Actor : ActorsToMerge)
	{
		USceneCom