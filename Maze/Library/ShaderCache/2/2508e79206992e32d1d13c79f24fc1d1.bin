 0);
				return retval;
			}
		}

		public CodeBlockEntry CurrentBlock {
			get {
				if ((_block_stack != null) && (_block_stack.Count > 0))
					return (CodeBlockEntry) _block_stack.Peek ();
				else
					return null;
			}
		}

		public LocalVariableEntry[] Locals {
			get {
				if (_locals == null)
					return new LocalVariableEntry [0];
				else {
					return _locals.ToArray ();
				}
			}
		}

		public ICompileUnit SourceFile {
			get {
				return _comp_unit;
			}
		}

		public void AddLocal (int index, string name)
		{
			if (_locals == null)
				_locals = new List<LocalVariableEntry> ();
			int block_idx = CurrentBlock != null ? CurrentBlock.Index : 0;
			_locals.Add (new LocalVariableEntry (index, name, block_idx));
		}

		public ScopeVariable[] ScopeVariables {
			get {
				if (_scope_vars == null)
					return new ScopeVariable [0];

				return _scope_vars.ToArray ();
			}
		}

		public void AddScopeVariable (int scope, int index)
		{
			if (_scope_vars == null)
				_scope_vars = new List<ScopeVariable> ();
			_scope_vars.Add (
				new ScopeVariable (scope, index));
		}

		public void DefineMethod (MonoSymbolFile file)
		{
			DefineMethod (file, method.Token);
		}

		public void DefineMethod (MonoSymbolFile file, int token)
		{
			var blocks = Blocks;
			if (blocks.Length > 0) {
				//
				// When index is provided by user it can be inserted in
				// any order but mdb format does not store its value. It
				// uses stored order as the index instead.
				//
				var sorted = new List<CodeBlockEntry> (blocks.Length);
				int max_index = 0;
				for (int i = 0; i < blocks.Length; ++i) {
					max_index = System.Math.Max (max_index, blocks [i].Index);
				}

				for (int i = 0; i < max_index; ++i) {
					var scope_index = i + 1;

					//
					// Common fast path
					//
					if (i < blocks.Length && blocks [i].Index == scope_index) {
						sorted.Add (blocks [i]);
						continue;
					}

					bool found = false;
					for (int ii = 0; ii < blocks.Length; ++ii) {
						if (blocks [ii].Index == scope_index) {
							sorted.Add (blocks [ii]);
							found = true;
							break;
						}
					}

					if (found)
						continue;

					//
					// Ideally this should never happen but with current design we can
					// generate scope index for unreachable code before reachable code
					//
					sorted.Add (new CodeBlockEntry (scope_i