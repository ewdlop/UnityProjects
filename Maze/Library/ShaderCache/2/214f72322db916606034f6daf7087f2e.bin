nt flags)
    {
        m_stringname = null; // computed lazily
        m_pop = (StackBehaviour)((flags >> StackBehaviourPopShift) & StackBehaviourMask);
        m_push = (StackBehaviour)((flags >> StackBehaviourPushShift) & StackBehaviourMask);
        m_operand = (OperandType)(flags & OperandTypeMask);
        m_type = (OpCodeType)((flags >> OpCodeTypeShift) & OpCodeTypeMask);
        m_size = (flags >> SizeShift) & SizeMask;
        m_s1 = (byte)((int)value >> 8);
        m_s2 = (byte)(int)value;
        m_ctrl = (FlowControl)((flags >> FlowControlShift) & FlowControlMask);
        m_endsUncondJmpBlk = (flags & EndsUncondJmpBlkFlag) != 0;
        m_stackChange = (flags >> StackChangeShift);
    }

    internal bool EndsUncondJmpBlk()
    {
        return m_endsUncondJmpBlk;
    }

    internal int StackChange()
    {
        return m_stackChange;
    }

    public OperandType OperandType
    {
        get
        {
            return (m_operand);
        }
    }

    public FlowControl FlowControl
    {
        get
        {
            return (m_ctrl);
        }
    }

    public OpCodeType OpCodeType
    {
        get
        {
            return (m_type);
        }
    }


    public StackBehaviour StackBehaviourPop
    {
        get
        {
            return (m_pop);
        }
    }

    public StackBehaviour StackBehaviourPush
    {
        get
        {
            return (m_push);
        }
    }

    public int Size
    {
        get
        {
            return (m_size);
        }
    }

    public short Value
    {
        get
        {
            if (m_size == 2)
                return (short)(m_s1 << 8 | m_s2);
            return (short)m_s2;
        }
    }
#endif // FEATURE_CORECLR


    private static volatile string[] g_nameCache;

    public String Name
    {
        get
        {
            if (Size == 0)
                return null;

            // Create and cache the opcode names lazily. They should be rarely used (only for logging, etc.)
            // Note that we do not any locks here because of we always get the same names. The last one wins.
            string[] nameCache = g_nameCache;
            if (nameCache == null) {
                nameCache = new String[0x11f];
                g_nameCache = nameCache;
            }

            OpCodeValues opCodeValue = (OpCodeValues)(ushort)Value;

            int idx = (int)opCodeValue;
     