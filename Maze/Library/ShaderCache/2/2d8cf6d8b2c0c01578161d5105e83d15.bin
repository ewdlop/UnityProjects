ileEntry file = doc != null ? doc.Entry.SourceFile : null;

			for (int n=0; n<offsets.Length; n++) {
				if (n > 0 && offsets[n] == offsets[n-1] && lines[n] == lines[n-1] && columns[n] == columns[n-1])
					continue;
				msw.MarkSequencePoint (offsets[n], file, lines[n], columns[n], false);
			}
		}
		
		public void Initialize (IntPtr emitter, string filename, bool fFullBuild)
		{
			msw = new MonoSymbolWriter (filename);
		}
		
		public void OpenMethod (SymbolToken method)
		{
			currentToken = method.GetToken ();
		}
		
		public void OpenNamespace (string name)
		{
			NamespaceInfo n = new NamespaceInfo ();
			n.NamespaceID = -1;
			n.Name = name;
			namespaceStack.Push (n);
		}

		public int OpenScope (int startOffset)
		{
			return msw.OpenScope (startOffset);
		}
		
		public void SetMethodSourceRange (
			ISymbolDocumentWriter startDoc,
			int startLine,
			int startColumn,
			ISymbolDocumentWriter endDoc,
			int endLine,
			int endColumn)
		{
			int nsId = GetCurrentNamespace (startDoc);
			SourceMethodImpl sm = new SourceMethodImpl (methodName, currentToken, nsId);
			m