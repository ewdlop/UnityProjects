    <item><description>
        ///         XmlnsMappings for static assemblies are not GC'd. In v4.0 we can assume that all static assemblies 
        ///         containing XmlnsDefinition attributes are non-collectible. The CLR will provide no public mechanism 
        ///         for unloading a static assembly or specifying that a static assembly is collectible. While there 
        ///         may be some small number of assemblies identified by the CLR as collectible, none will contain 
        ///         XmlnsDefinition attributes. Should the CLR provide a public mechanism for unloading a static assembly
        ///         or specifying that a static assembly is collectible, we should revisit this decision based on scenarios
        ///         that flow from these mechanisms.
        ///         </description></item>
        ///         <item><description>
        ///         XmlnsMappings for dynamic assemblies are not created. This is because the hosted Visual Basic compiler
        ///         does not support dynamic assembly references. Should support for dynamic assembly references be 
        ///         added to the Visual Basic compiler, we should strip away Assembly.IsDynamic checks from this class and
        ///         update the code ensure that VisualBasicImportReference instances are removed in a timely manner.
        ///         </description></item>
        ///     </list>
        /// </remarks>
        static class AssemblyCache
        {
            static bool initialized = false;

            // This is here so that obtaining the lock is not required to be SecurityCritical.
            public static object XmlnsMappingsLockObject = new object();

            [Fx.Tag.SecurityNote(Critical = "Critical because we are storing assembly references and if we alloed PT access, they could mess with that.")]
            [SecurityCritical]
            static Dictionary<XNamespace, XmlnsMapping> xmlnsMappings;

            public static Dictionary<XNamespace, XmlnsMapping> XmlnsMappings
            {
                [Fx.Tag.SecurityNote(Critical = "Critical because providing access to the critical xmlnsMappings dictionary.")]
                [SecurityCritical]
                get
                {
                    EnsureInitialized();
                    return xmlnsMappings;
                }
            }

            [Fx.Tag.SecurityNote(Critical = "Critical because we are accessing critical member xmlnsMappings and CacheLoadedAssembly. Only called from CLR.")]
            [SecurityCritical]
            static void OnAssemblyLoaded(object sender, AssemblyLoadEventArgs args)
            {
                Assembly assembly = args.LoadedAssembly;

                if (assembly.IsDefined(typeof(XmlnsDefinitionAttribute), false) && !assembly.IsDynamic)
                {
                    lock (XmlnsMappingsLockObject)
                    {
                        CacheLoadedAssembly(assembly);
                    }
                }
            }

            [Fx.Tag.SecurityNote(Critical = "Critical because we are accessing AppDomain.AssemblyLoaded and we are accessing critical member xmlnsMappings.")]
            [SecurityCritical]
            static void EnsureInitialized()            
            {
                if (initialized)