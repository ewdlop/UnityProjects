//===- Endian.h - Utilities for IO with endian specific data ----*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file declares generic functions to read and write endian specific data.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_SUPPORT_ENDIAN_H
#define LLVM_SUPPORT_ENDIAN_H

#include "llvm/Support/AlignOf.h"
#include "llvm/Support/Host.h"
#include "llvm/Support/SwapByteOrder.h"

#pragma warning( push )           // HLSL Change - constant comparisons are done for portability
#pragma warning( disable : 6326 ) // 'Potential comparison of a constant with another constant.'

namespace llvm {
namespace support {
enum endianness {big, little, native};

// These are named values for common alignments.
enum {aligned = 0, unaligned = 1};

namespace detail {
  /// \brief ::value is either alignment, or alignof(T) if alignment is 0.
  template<class T, int alignment>
  struct PickAlignment {
    enum {value = alignment == 0 ? AlignOf<T>::Alignment : alignment};
  };
} // end namespace detail

namespace endian {
/// Swap the bytes of value to match the given endianness.
template<typename value_type, endianness endian>
inline value_type byte_swap(value_type value) {
  if (endian != native && sys::IsBigEndianHost != (endian == big))
    sys::swapByteOrder(value);
  return value;
}

/// Read a value of a particular endianness from memory.
template<typename value_type,
         endianness endian,
         std::size_t alignment>
inline value_type read(const void *memory) {
  value_type ret;

  memcpy(&ret,
         LLVM_ASSUME_ALIGNED(memory,
           (detail::PickAlignment<value_type, alignment>::value)),
         sizeof(value_type));
  return byte_swap<value_type, endian>(ret);
}

/// Read a value of a particular endianness from a buffer, and increment the
/// buffer past that value.
template<typename value_type, endianness endian, std::size_t alignment,
         typename CharT>
inline value_type readNext(const CharT *&memory) {
  value_type ret = read<value_type, endian, alignment>(memory);
  memory += sizeof(value_type);
  return ret;
}

/// Write a value to memory with a particular endianness.
template<typename value_type,
         endianness endian,
         std::size_t alignment>
inline void write(void *memory, value_type value) {
  value = byte_swap<value_type, endian>(value);
  memcpy(LLVM_ASSUME_ALIGNED(memory,
           (detail::PickAlignment<value_type, alignment>::value)),
         &value,
         sizeof(value_type));
}
} // end namespace endian

namespace detail {
template<typename value_type,
         endianness endian,
         std::size_t alignment>
struct packed_endian_specific_integral {
  operator value_type() const {
    return endian::read<value_type, endian, alignment>(
      (const void*)Value.buffer);
  }

  void operator=(value_type newValue) {
    endian::write<value_type, endian, alignment>(
      (void*)Value.buffer, newValue);
  }

  packed_endian_specific_integral &operator+=(value_type newValue) {
    *this = *this + newValue;
    return *this;
  }

  packed_endian_specific_integral &operator-=(value_type newValue) {
    *this = *this - newValue;
    return *this;
  }

  packed_endian_specific_integral &operator|=(value_type newValue) {
    *this = *this | newValue;
    return *this;
  }

  packed_endian_specific_integral &operator&=(value_type newValue) {
    *this = *this & newValue;
    return *this;
  }

private:
  AlignedCharArray<PickAlignment<value_type, alignment>::value,
                   sizeof(value_type)> Value;

public:
  struct ref {
    explicit ref(void *Ptr) : Ptr(Ptr) {}

    operator value_type() const {
      return endian::read<value_type, endian, alignment>(Ptr);
    }

    void operator=(value_type NewValue) {
      endian::write<value_type, endian, alignment>(Ptr, NewValue);
    }

  private:
    void *Ptr;
  };
};

} // end namespace detail

typedef detail::packed_endian_specific_integral
                  <uint16_t, little, unaligned> ulittle16_t;
typedef detail::packed_endian_specific_integral
                  <uint32_t, little, unaligned> ulittle32_t;
typedef detail::packed_endian_specific_integral
                  <uint64_t, little, unaligned> ulittle64_t;

typedef detail::packed_endian_specific_integral
                   <int16_t, little, unaligned> little16_t;
typedef detail::packed_endian_specific_integral
                   <int32_t, little, unaligned> little32_t;
typedef detail::packed_endian_specific_integral
                   <int64_t, little, unaligned> little64_t;

typedef detail::packed_endian_specific_integral
                    <uint16_t, little, aligned> aligned_ulittle16_t;
typedef detail::packed_endian_specific_integral
                    <uint32_t, little, aligned> aligned_ulittle32_t;
typedef detail::packed_endian_specific_integral
                    <uint64_t, little, aligned> aligned_ulittle64_t;

typedef detail::packed_endian_specific_integral
                     <int16_t, little, aligned> aligned_little16_t;
typedef detail::packed_endian_specific_integral
                     <int32_t, little, aligned> aligned_little32_t;
typedef detail::packed_endian_specific_integral
                     <int64_t, little, aligned> aligned_little64_t;

typedef detail::packed_endian_specific_integral
                  <uint16_t, big, unaligned>    ubig16_t;
typedef detail::packed_endian_specific_integral
                  <uint32_t, big, unaligned>    ubig32_t;
typedef detail::packed_endian_specific_integral
                  <uint64_t, big, unaligned>    ubig64_t;

typedef detail::packed_endian_specific_integral
                   <int16_t, big, unaligned>    big16_t;
typedef detail::packed_endian_specific_integral
                   <int32_t, big, unaligned>    big32_t;
typedef detail::packed_endian_specific_integral
                   <int64_t, big, unaligned>    big64_t;

typedef detail::packed_endian_specific_integral
                    <uint16_t, big, aligned>    aligned_ubig16_t;
typedef detail::packed_endian_specific_integral
                    <uint32_t, big, aligned>    aligned_ubig32_t;
typedef detail::packed_endian_specific_integral
                    <uint64_t, big, aligned>    aligned_ubig64_t;

typedef detail::packed_endian_specific_integral
                     <int16_t, big, aligned>    aligned_big16_t;
typedef detail::packed_endian_specific_integral
                     <int32_t, big, aligned>    aligned_big32_t;
typedef detail::packed_endian_specific_integral
                     <int64_t, big, aligned>    aligned_big64_t;

typedef detail::packed_endian_specific_integral
                  <uint16_t, native, unaligned> unaligned_uint16_t;
typedef detail::packed_endian_specific_integral
                  <uint32_t, native, unaligned> unaligned_uint32_t;
typedef detail::packed_endian_specific_integral
                  <uint64_t, native, unaligned> unaligned_uint64_t;

typedef detail::packed_endian_specific_integral
                   <int16_t, native, unaligned> unaligned_int16_t;
typedef detail::packed_endian_specific_integral
                   <int32_t, native, unaligned> unaligned_int32_t;
typedef detail::packed_endian_specific_integral
                   <int64_t, native, unaligned> unaligned_int64_t;

namespace endian {
inline uint16_t read16le(const void *p) { return *(const ulittle16_t *)p; }
inline uint32_t read32le(const void *p) { return *(const ulittle32_t *)p; }
inline uint64_t read64le(const void *p) { return *(const ulittle64_t *)p; }
inline uint16_t read16be(const void *p) { return *(const ubig16_t *)p; }
inline uint32_t read32be(const void *p) { return *(const ubig32_t *)p; }
inline uint64_t read64be(const void *p) { return *(const ubig64_t *)p; }

inline void write16le(void *p, uint16_t v) { *(ulittle16_t *)p = v; }
inline void write32le(void *p, uint32_t v) { *(ulittle32_t *)p = v; }
inline void write64le(void *p, uint64_t v) { *(ulittle64_t *)p = v; }
inline void write16be(void *p, uint16_t v) { *(ubig16_t *)p = v; }
inline void write32be(void *p, uint32_t v) { *(ubig32_t *)p = v; }
inline void write64be(void *p, uint64_t v) { *(ubig64_t *)p = v; }
} // end namespace endian
} // end namespace support
} // end namespace llvm

#pragma warning( pop ) // HLSL Change - pop warning level

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                            <Á˝Iëf8∑˜Ñ“p√!¨‚ÊÕnÈU_GÃ~jï◊tÊŒ≠LkÃø„ú•ÃÁÆœ(œ´‡ 1Y Ù_ˇBYÖ¿ﬂ¿π£p~Ÿ›sù±Y3{üﬂèòÌ ≤G"µ!nobLÀ¥ èu&#‚çÅ®y˛õ†⁄õ©…+.˙Û¢2óJ^Â ıB∞U´‘5éS‡Î˛Ã‹ÜÎ∂√.9ÆU 4P˜∫R8—nΩBˇxIã{∂8»-å°@÷'oU1˜6 7lΩè ™
Ïâ›ÿ÷È¶2•’ùà÷P”áõÅL¸ﬂ˛ß ∏f±7a©õÅWç∫œ–m¡Â¬Ã–˙!Q1ãVŒ±e‡‰2èÛ¡°°j√°>	∞"∞ΩnπÙ“‚cc"˝§RÊ[}“pTÈÏ†´Kπ)-ad∆ê$äySu'ŒSR7µ(SmØ®YˇÏ+qZ p,.»2≥\<Köàñ∫:æñÇÍ`É|û∑íÆ,bç~T‡ π˙Ô

WÓ∑¬˙ÂÂπ¸—rÀ∂3ó[è¡ˆD4Ü™ÛzÚ5JS%ÜÕ•≠YGˆ‡ïñÓÉÓüö˛F˘Ä√;˛ƒîI9¢Ωî˘~®fŒØœ^æUéâCî6¿$®m…®±íO—ÃÂpC!;&N˚SÄG‘f)\˜_÷#∂øÍ∫ú‚ˇüé1˜÷£ˆ[ÉVú0¿¿["ÇGttäŒ˛sùäPè◊cñ7|è∞ã\*/q ¸f√ ˚O4ÊÜTµ^HùÃ?z$’Ø7Y”¥Ú•ÚI—M÷!b∏ù>,.X´n¸¯¥.‘˘ ˛√ü›Ü‚¥zQ`∏£Ã;E^1qÍPmZ ≤l~√¿<∂Ä`Ú_t^∏©%∏o˝œHÃÏ¢N8›”∂zóÖó∏®`© :ıˇÆÉBä≈ ¬™≥Y˚ËñÈXY∫πåtR~äê(XkûR:¬∞ñ∞}#€F∆ˆˇõ—Tπ7´*ChÜÕBhÿæïîúoz<swπsd€yﬁk60jnœˇIâw´$µ&2/∏ôµ!´=ô∫ˇê¥W€⁄ØçUï'¿¥aI
GÇÅ•?öZˆµ{+ 9ä≠◊®¿¯ÊÖûòd≈Ì€›G8,≥˚dJ#pxÛıD"Ú˚JÓ˚9Ãi'+ê˛˚	rÕÉÕÑ]’·üJ∑µáÔÌj¿`í À4“¶9JSo˜›~Ì5U>j™$¸…Ÿ'∫ÑÛÇÏça6Ø´1e˝øŸÁ§˜Ø|—ß2‡‰Sßçß}1R˘õ7êÂ &¬)πÀÔPjbp∫”_‰uyl/˛,y≠∫âˇ∆ö†æÅcn´=%î1¯MxÌ0≥w˘–˘Ä’Q∑;7k>YÖ ﬂöË˙Vb‘jf„Ÿ>ªÀ&ÑiΩ;÷K¯åÄÕÆ*dÁjR—¡Î†R0¸S∂¬ÑËÌ â“u˙™æ~ ˙Ω∏§√sÀH0Æ®:ìØ“Œ‰ı¥V]@⁄·<htK|p"Ùj‚›@ÜîêDH#˚Ç{ ≈a'«‘NêîˇüüÚ1ãÛˆù◊OiâÛ«$$[*	â1|ÿX£_«_ŒÊ˙ÌíÔY.éÄw}}úKsNæïX?g„≤Uw%‘9¶Àm{·B~@∏uı≥ó≤vîz∑`[8&f¶t+¥Â/\Òà~B%⁄d§™˙¿0äDZ}Äò˚)eo)´xñ„ùVj†bÆπÔ∑œÃ~kÌF\ =ô\˚£…ÕgèÄTeé>/ùÒ¨BÔøñ-«l∆ÁÎE?0<®e±◊LËéƒ∆ˇ~Äh5/áàˆ\'E«ÏyÂŸ^Qπ™ÖZŒ∫ä¨ERË~/ìZ¬è»
/·€YxÊ∏/´8–à3H‘r”éü˙øaÏØ≥.(ÙT¨£Í`∏yce]ÃŒ”≤kDΩƒ‹∂Ü–h}û´≠˛khlœp!$(J†÷BˇÿïjhJªŒ¬©Ñ„Ù–aR=AK˛Èsî|X±ÍKö‚Ùöän≥/2ı4À›mu2z†{õ5‡Bªë`Ñí|!c"YÅøMbı06…áüΩà∞v¶ıå0?“º¸Á8õ°{Qà∫=hÂÃ,ÓW√◊eç%•3Eö.Ô!ª¨óäËvE›Ø√ïÒm
S%w1“ G:Ö3†$Ö±îOﬂˇ?ÔïÌ±öˇM‹ÃêGÈ„3ç≠|(°ZÚΩe”&®|4 2ŸÊ˙7±HvS'¯+,ûù"´…-¢‡——gÜ5cºÔ<P}È∏tæ/3Ó“ìV(,ÃsáÓD¸l≥ù>2p>¢˝√˚‡Äì8µ∆´œ3™‚'>˙‘v|√˘RÏﬁxøŒ∏ä]úºuAÍ®N∑UÊ…&˚á¥*Ç[¨B}◊IúØá¥‘S’ZñUgV⁄ls'ÿòÉL(8∞m√ıﬂ?∞7]MÆø ≠˙ôòÒL,îÌ8CìEŸQ£}ÑÅõÀhˆn∆)±Iˆ‡˙{ﬂæêˆ+•ô∆£ùú-}í‰>°¶Äkç‚Ñh~W ´‰w¢””4iw±ˇ=≠µÁ',∏¡ŒHg∏"¢Nç+ﬂ~(?†µˇƒr#à/IÁÑZ  pÊG√c"hÛµWCëHÌf˙àı»„ÔàÕì·‘jLã÷¥ˇ(_xû•)ÚpçåÀl}·8{c˚k<ˆÉ`Î'˛`‹ÇCÿùæ⁄rÜáøÉ%BÓ‚Ç2∑gBÆÊ
[Ÿ–Z)#V<\D@·ÉÚƒXÅwà≠:ä˘f/Ë€<yGct4ª}Je”êe`CK1µa¢‹£÷yvºpNXœØ≤ì¥3•æ6ƒYhIÇ»õã˛ªüÙ±yæã˙˙∆ÕïÉÏ.Q‹~ùÚ\ˇù‚Õı|1s+mFÖ„O/˘∞=oΩ9É¬ÿ; ïïø™⁄∞„k _îB.m˜EGP~ò¸‚‰PÙ`£ Õ0MlØ:–mc∏eŸ(Ω1dZb3=YgSnæÍÚ≥“:	&F…HHîô9ıƒqÃ<\¡É1
éQ‹´#6öU„∞yKx–eÃπêµJ÷Û˜PS˜tA“¶Ÿ:ﬂ∆˙ÿxm•€c*:å.c{lá Ó#‰¸püÙY‹}ÀMòˆ+jXFø	Äf√$uÍ&Zñçˇ\‚P~xë{-	ud˝â¯äÌdRÿﬁπ,∫î)oï]O◊{1Üÿ:®r‡}Ò¿¬LÓÍé3i`°–¡|7™peüeÜÀ¯.∂Óú§¶9ƒÌ´Ö4MÑŒïOª|Ø°∂0¶ä~eÛˇ˚ÁÏâM _ÍY+M±ﬁÍ-p<â9Ùwï˘í˛MÛé^‹h\ÍÒÍàî5I«<„°C ˆ˙ˆÂOgF[≠?*¢1ëÙÄö7FíGKNZlÛb˘y∞eyHtﬂ‘ﬁùÃ2a€_*/‘”÷X≠i†IZEãﬂ$:O»x*∂€NﬂH¢ÏáI(•Q4Ÿ¸˛◊ûCŒ5É\%ªp¢A˙|ìÅräFîP7ÜÍDòõµÕÊÄ_ÍÄsaÎÈ√¯‹˝Fw¢Œç∞∏ü-ÙﬁÓQA∫∂wö∆