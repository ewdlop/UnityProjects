  The returned string shall always be allocated on the heap with
   OPENSSL_malloc(), and need to be free'd with OPENSSL_free().

   If the ui_method doesn't contain a pointer to a user-defined prompt
   constructor, a default string is built, looking like this:

	"Enter {object_desc} for {object_name}:"

   So, if object_desc has the value "pass phrase" and object_name has
   the value "foo.key", the resulting string is:

	"Enter pass phrase for foo.key:"
*/
char *UI_construct_prompt(UI *ui_method,
	const char *object_desc, const char *object_name);


/* The following function is used to store a pointer to user-specific data.
   Any previous such pointer will be returned and replaced.

   For callback purposes, this function makes a lot more sense than using
   ex_data, since the latter requires that different parts of OpenSSL or
   applications share the same ex_data index.

   Note that the UI_OpenSSL() method completely ignores the user data.
   Other methods may not, however.  */
void *UI_add_user_data(UI *ui, void *user_data);
/* We need a user data retrieving function as well.  */
void *UI_get0_user_data(UI *ui);

/* Return the result associated with a prompt given with the index i. */
const char *UI_get0_result(UI *ui, int i);

/* When all strings have been added, process the whole thing. */
int UI_process(UI *ui);

/* Give a user interface parametrised control commands.  This can be used to
   send down an integer, a data pointer or a function pointer, as well as
   be used to get information from a UI. */
int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)(void));

/* The commands */
/* Use UI_CONTROL_PRINT_ERRORS with the value 1 to have UI_process print the
   OpenSSL error stack before printing any info or added error messages and
   before any prompting. */
#define UI_CTRL_PRINT_ERRORS		1
/* Check if a UI_process() is possible to do again with the same instance of
   a user interface.  This makes UI_ctrl() return 1 if it is redoable, and 0
   if not. */
#define UI_CTRL_IS_REDOABLE		2


/* Some methods may use extra data */
#define UI_set_app_data(s,arg)         UI_set_ex_data(s,0,arg)
#define UI_get_app_data(s)             UI_get_ex_data(s,0)
int UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int UI_set_ex_data(UI *r,int idx,void *arg);
void *UI_get_ex_data(UI *r, int idx);

/* Use specific methods instead of the built-in one */
void UI_set_default_method(const UI_METHOD *meth);
const UI_METHOD *UI_get_default_method(void);
const UI_METHOD *UI_get_method(UI *ui);
const UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth);

/* The method with all the built-in thingies */
UI_METHOD *UI_OpenSSL(void);


/* ---------- For method writers ---------- */
/* A method contains a number of functions that implement the low level
   of the User Interface.  The functions are:

	an opener	This function starts a session, maybe by opening
			a channel to a tty, or by opening a window.
	a writer	This function is called to write a given string,
			maybe to the tty, maybe as a field label in a
			window.
	a flusher	This function is called to flush everything that
			has been output so far.  It can be used to actually
			display a dialog box after it has been built.
	a reader	This function is called to read a given prompt,
			maybe from the tty, maybe from a field in a
			window.  Note that it's called wth all string
			structures, not only the prompt ones, so it must
			check such things itself.
	a closer	This function closes the session, maybe by closing
			the channel to the tty, or closing the window.

   All these functions are expected to return:

	0	on error.
	1	on success.
	-1	on out-of-band events, for example if some prompting has
		been canceled (by pressing Ctrl-C, for example).  This is
		only checked when returned by the flusher or the reader.

   The way this is used, the opener is first called, then the writer for all
   strings, then the flusher, then the reader for all strings and finally the
   closer.  Note that if you want to prompt from a terminal or other command
   line interfa