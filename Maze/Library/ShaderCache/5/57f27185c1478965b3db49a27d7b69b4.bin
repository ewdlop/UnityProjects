//----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//----------------------------------------------------------------------------

namespace System.ServiceModel.Channels
{
    using System.Collections.Generic;
    using System.Messaging;
    using System.Runtime;
    using System.Security;
    using System.Security.Permissions;
    using System.ServiceModel;
    using System.Threading;

    class MsmqBindingMonitor
    {
        static readonly TimeSpan DefaultUpdateInterval = TimeSpan.FromMinutes(10);

        CommunicationState currentState = CommunicationState.Created;
        List<MsmqBindingFilter> filters = new List<MsmqBindingFilter>();
        string host;
        int iteration;
        Dictionary<string, MatchState> knownPublicQueues = new Dictionary<string, MatchState>();
        Dictionary<string, MatchState> knownPrivateQueues = new Dictionary<string, MatchState>();
        object thisLock = new object();
        IOThreadTimer timer;
        TimeSpan updateInterval;
        ManualResetEvent firstRoundComplete;
        bool retryMatchedFilters;

        public MsmqBindingMonitor(string host)
            : this(host, DefaultUpdateInterval, false)
        {
        }

        public MsmqBindingMonitor(string host, TimeSpan updateInterval, bool retryMatchedFilters)
        {
            if (string.Compare(host, "localhost", StringComparison.OrdinalIgnoreCase) == 0)
            {
                this.host = ".";
            }
            else
            {
                this.host = host;
            }

            this.firstRoundComplete = new ManualResetEvent(false);

            this.updateInterval = updateInterval;
            this.retryMatchedFilters = retryMatchedFilters;
            this.iteration = 1;
        }

        public void AddFilter(MsmqBindingFilter filter)
        {
            lock (this.thisLock)
            {
                this.filters.Add(filter);

                // Now - see if we match any known queues
                MatchFilter(filter, knownPublicQueues.Values);
                MatchFilter(filter, knownPrivateQueues.Values);
            }
        }

        public bool ContainsFilter(MsmqBindingFilter filter)
        {
            lock (this.thisLock)
            {
                return this.filters.Contains(filter);
            }
        }

        public void Open()
        {
            lock (this.thisLock)
            {
                if (this.currentState != CommunicationState.Created)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.CommunicationObjectCannotBeModified, this.GetType().ToString())));
                }

                this.currentState = CommunicationState.Opened;
                this.ScheduleRetryTimerIfNotSet();
            }
        }

        public void Close()
        {
            lock (this.thisLock)
            {
                if (this.currentState != CommunicationState.Opened)
                {
                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.CommunicationObjectCannotBeModified, this.GetType().ToString())));
                }

                this.currentState = CommunicationState.Closed;
                this.CancelRetryTimer();
            }
        }

        public void RemoveFilter(MsmqBindingFilter filter)
        {
            lock (this.thisLock)
            {
                this.filters.Remove(filter);

                RematchQueues(filter, knownPublicQueues.Values);
                RematchQueues(filter, knownPrivateQueues.Values);
            }
        }

        public void WaitForFirstRoundComplete()
        {
            this.firstRoundComplete.WaitOne();
        }

        void ScheduleRetryTimerIfNotSet()
        {
            if (this.timer == null)
            {
                this.timer = new IOThreadTimer(new Action<object>(OnTimer), null, false);
                // Schedule one enumeration to run immediately...
                this.timer.Set(0);
            }
        }

        void CancelRetryTimer()
        {
            if (this.timer != null)
            {
                this.timer.Cancel();
                this.timer = null;
            }
        }

        void MatchFilter(MsmqBindingFilter filter, IEnumerable<MatchState> queues)
        {
            // Run through all the queues - see if we are better than any existing matches...
            foreach (MatchState state in queues)
            {
                int matchLength = filter.Match(state.QueueName);
                if (matchLength > state.LastMatchLength)
                {
                    if (state.LastMatch != null)
                    {
                        state.LastMatch.MatchLost(this.host, state.QueueName, state.IsPrivate, state.CallbackState);
                    }

                    state.LastMatchLength = matchLength;
                    state.LastMatch = filter;

                    state.CallbackState = filter.MatchFound(this.host, state.QueueName, state.IsPrivate);
                }
            }
        }

        void RetryMatchFilters(IEnumerable<MatchState> queues)
        {
            // Run through all the queues and call match found on them
            foreach (MatchState state in queues)
            {
                if (state.LastMatch != null)
                {
                    state.CallbackState = state.LastMatch.MatchFound(this.host, state.QueueName, state.IsPrivate);
                }
            }
        }

        void MatchQueue(MatchState state)
        {
            MsmqBindingFilter bestMatch = state.LastMatch;
            int bestMatchLength = state.LastMatchLength;

            // look through all the filters for the largest match:
            foreach (MsmqBindingFilter filter in this.filters)
            {
                int matchLength = filter.Match(state.QueueName);
                if (matchLength > bestMatchLength)
                {
                    bestMatchLength = matchLength;
                    bestMatch = filter;
                }
        