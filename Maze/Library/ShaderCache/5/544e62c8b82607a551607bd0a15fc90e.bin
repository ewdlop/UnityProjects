
    for i in range(adapters.length):
        ncb.Reset()
        ncb.Command = netbios.NCBRESET
        ncb.Lana_num = ord(adapters.lana[i])
        if win32wnet.Netbios(ncb) != 0:
            continue
        ncb.Reset()
        ncb.Command = netbios.NCBASTAT
        ncb.Lana_num = ord(adapters.lana[i])
        ncb.Callname = '*'.ljust(16)
        ncb.Buffer = status = netbios.ADAPTER_STATUS()
        if win32wnet.Netbios(ncb) != 0:
            continue
        status._unpack()
        bytes = status.adapter_address[:6]
        if len(bytes) != 6:
            continue
        mac = int.from_bytes(bytes, 'big')
        if _is_universal(mac):
            return mac
        first_local_mac = first_local_mac or mac
    return first_local_mac or None


_generate_time_safe = _UuidCreate = None
_has_uuid_generate_time_safe = None

# Import optional C extension at toplevel, to help disabling it when testing
try:
    import _uuid
except ImportError:
    _uuid = None


def _load_system_functions():
    """
    Try to load platform-specific functions for generating uuids.
    """
    global _generate_time_safe, _UuidCreate, _has_uuid_generate_time_safe

    if _has_uuid_generate_time_safe is not None:
        return

    _has_uuid_generate_time_safe = False

    if sys.platform == "darwin" and int(os.uname().release.split('.')[0]) < 9:
        # The uuid_generate_* functions are broken on MacOS X 10.5, as noted
        # in issue #8621 the function generates the same sequence of values
        # in the parent process and all children created using fork (unless
        # those children use exec as well).
        #
        # Assume that the uuid_generate functions are broken from 10.5 onward,
        # the test can be adjusted when a later version is fixed.
        pass
    elif _uuid is not None:
        _generate_time_safe = _uuid.generate_time_safe
        _has_uuid_generate_time_safe = _uuid.has_uuid_generate_time_safe
        return

    try:
        # If we couldn't find an extension module, try ctypes to find
        # system routines for UUID generation.
        # Thanks to Thomas Heller for ctypes and for his help with its use here.
        import ctypes
        import ctypes.util

        # The uuid_generate_* routines are provided by libuuid on at least
        # Linux and FreeBSD, and provided by libc on Mac OS X.
        _libnames = ['uuid']
        if not sys.platform.startswith('win'):
            _libnames.append('c')
        for libname in _libnames:
            try:
                lib = ctypes.CDLL(ctypes.util.find_library(libname))
            except Exception:                           # pragma: nocover
                continue
            # Try to find the safe variety first.
            if hasattr(lib, 'uuid_generate_time_safe'):
                _uuid_generate_time_safe = lib.uuid_generate_time_safe
                # int uuid_generate_time_safe(uuid_t out);
                def _generate_time_safe():
                    _buffer = ctypes.create_string_buffer(16)
                    res = _uuid_generate_time_safe(_buffer)
                    return bytes(_buffer.raw), res
                _has_uuid_generate_time_safe = True
                break

            elif hasattr(lib, 'uuid_generate_time'):    # pragma: nocover
                _uuid_generate_time = lib.uuid_generate_time
                # void uuid_generate_time(uuid_t out);
                _uuid_generate_time.restype = None
                def _generate_time_safe():
                    _buffer = ctypes.create_string_buffer(16)
                    _uuid_generate_time(_buffer)
                    return bytes(_buffer.raw), None
                break

        # On Windows prior to 2000, UuidCreate gives a UUID containing the
        # hardware address.  On Windows 2000 and later, UuidCreate makes a
        # random UUID and UuidCreateSequential gives a UUID containing the
        # hardware address.  These routines are provided by the RPC runtime.
        # NOTE:  at least on Tim's WinXP Pro SP2 desktop box, while the last
        # 6 bytes returned by UuidCreateSequential are fixed, they don't appear
        # to bear any relationship to the MAC address of any network device
        # on the box.
        try:
            lib = ctypes.windll.rpcrt4
        except:
            lib = None
        _UuidCreate = getattr(lib, 'UuidCreateSequential',
                              getattr(lib, 'UuidCreate', None))

    except Exception as exc:
        import warnings
        warnings.warn(f"Could not find fallback ctypes uuid functions: {exc}",
                      ImportWarning)


def _unix_getnode():
    """Get the hardware address on Unix using the _uuid extension module
    or ctypes."""
    _load_system_functions()
    uuid_time, _ = _generate_time_safe()
    return UUID(bytes=uuid_time).node

def _windll_getnode():
    """Get the hardware address on Windows using ctypes."""
    import ctypes
    _load_system_functions()
    _buffer = ctypes.create_string_buffer(16)
    if _UuidCreate(_buffer) == 0:
        return UUID(bytes=bytes_(_buffer.raw)).node

def _random_getnode():
    """Get a random node ID."""
    # RFC 4122, $4.1.6 says "For systems with no IEEE address, a randomly or
    # pseudo-randomly generated value may be used; see Section 4.5.  The
    # multicast bit must be set in such addresses, in order that they will
    # never conflict with addresses obtained from network cards."
    #
    # The "multicast bit" of a MAC address is defined to be "the least
    # significant bit of the first octet".  This works out to be the 41st bit
    # counting from 1 being the least significant bit, or 1<<40.
    #
    # See https://en.wikipedia.org/wiki/MAC_address#Unicast_vs._multicast
    import random
    return random.getrandbits(48) | (1 << 40)


_node = None

_NODE_GETTERS_WIN32 = [_windll_getnode, _netbios_getnode, _ipconfig_getnode]

_NODE_GETTERS_UNIX = [_unix_getnode, _ifconfig_getnode, _ip_getnode,
                      _arp_getnode, _lanscan_getnode, _netstat_getnode]

def getnode(*, getters=None):
    """Get the hardware address as a 48-bit positive integer.

    The first time this runs, it may launch a separate program, which could
    be quite slow.  If all attempts to obtain the hardware address fail, we
    choose a random 48-bit number with its eighth bit set to 1 as recommended
    in RFC 4122.
    """
    global _node
    if _node is not None:
        return _node

    if sys.platform == 'win32':
        getters = _NODE_GETTERS_WIN32
    else:
        getters = _NODE_GETTERS_UNIX

    for getter in getters + [_random_getnode]:
        try:
            _node = getter()
        except:
            continue
        if (_node is not None) and (0 <= _node < (1 << 48)):
            return _node
    assert False, '_random_getnode() returned invalid value: {}'.format(_node)


_last_timestamp = None

def uuid1(node=None, clock_seq=None):
    """Generate a UUID from a host ID, sequence number, and the current time.
    If 'node' is not given, getnode() is used to obtain the hardware
    address.  If 'clock_seq' is given, it is used as the sequence number;
    otherwise a random 14-bit sequence number is chosen."""

    # When the system provides a version-1 UUID generator, use it (but don't
    # use UuidCreate here because its UUIDs don't conform to RFC 4122).
    _load_system_functions()
    if _generate_time_safe is not None and node is clock_seq is None:
        uuid_time, safely_generated = _generate_time_safe()
        try:
            is_safe = SafeUUID(safely_generated)
        except ValueError:
            is_safe = SafeUUID.unknown
        return UUID(bytes=uuid_time, is_safe=is_safe)

    global _last_timestamp
    import time
    nanoseconds = int(time.time() * 1e9)
    # 0x01b21dd213814000 is the number of 100-ns intervals between the
    # UUID epoch 1582-10-15 00:00:00 and the Unix epoch 1970-01-01 00:00:00.
    timestamp = int(nanoseconds/100) + 0x01b21dd213814000
    if _last_timestamp is not None and timestamp <= _last_timestamp:
        timestamp = _last_timestamp + 1
    _last_timestamp = timestamp
    if clock_seq is None:
        import random
        clock_seq = random.getrandbits(14) # instead of stable storage
    time_low = timestamp & 0xffffffff
    time_mid = (timestamp >> 32) & 0xffff
    time_hi_version = (timestamp >> 48) & 0x0fff
    clock_seq_low = clock_seq & 0xff
    clock_seq_hi_variant = (clock_seq >> 8) & 0x3f
    if node is None:
        node = getnode()
    return UUID(fields=(time_low, time_mid, time_hi_version,
                        clock_seq_hi_variant, clock_seq_low, node), version=1)

def uuid3(namespace, name):
    """Generate a UUID from the MD5 hash of a namespace UUID and a name."""
    from hashlib import md5
    hash = md5(namespace.bytes + bytes(name, "utf-8")).digest()
    return UUID(bytes=hash[:16], version=3)

def uuid4():
    """Generate a random UUID."""
    return UUID(bytes=os.urandom(16), version=4)

def uuid5(namespace, name):
    """Generate a UUID from the SHA-1 hash of a namespace UUID and a name."""
    from hashlib import sha1
    hash = sha1(namespace.bytes + bytes(name, "utf-8")).digest()
    return UUID(bytes=hash[:16], version=5)

# The following standard UUIDs are for use with uuid3() or uuid5().

NAMESPACE_DNS = UUID('6ba7b810-9dad-11d1-80b4-00c04fd430c8')
NAMESPACE_URL = UUID('6ba7b811-9dad-11d1-80b4-00c04fd430c8')
NAMESPACE_OID = UUID('6ba7b812-9dad-11d1-80b4-00c04fd430c8')
NAMESPACE_X500 = UUID('6ba7b814-9dad-11d1-80b4-00c04fd430c8')
                                                                                                                                                                                                                                                                                                                                                                                                                                            µˆ¾i­à§gOŒÏEŒ"İÂsq”Â?÷Q'$7õR|æ±ÏëØí"Íz‚—¦rIÀ5T{bª¶33¾É=…g¸·_!mÉ@7jThÊÒôb|Zøêú9ÕXıCøTÀ9#Kİ9x˜mÌ«w'‚˜A¨”FÁœVN5¼#8¦ìÿRâE;'Y¦’*	3I:Àî,¨P¦MÆÜÂ)pV:R¡…{°R"¹R‹öŒhˆ±·ŒÂE”“g“Ü‘ö/ş‚—G]#3"qÅÂ‚¨§…"B°ÆA|C\"wş.<Rï@©N”è AL;dIPÜbŒDİé zıÕ#ûÉõ÷-uñùkú
¡ùÌ²şŞÚ24ä*]^¯KgBªn…^* Û2€Çæ[EQÅÖ-yJwqPUC{í 8©>SBcußİ¬êêwğ‡§–OÑŠíüÖY+mõ¦È?<ÿ`˜é¸°«väcON„éh^Z½Iú4C©Km .÷ÛWÁH‡y¿x‘rœ+@—b‰g²¦¡>._ºVy.İ+CˆSOø‘•²)öÁYpSÊ7Ÿ=ŸƒŸ\nŒˆKÕ¢•_=¯°k=B¿=Ê¢=©º=×‡³Š^ş¯ë£æ¯ë	&Ev šA
(êWùOö"®ñ<²r)>:‹ñ—£;N¢Tƒ1˜ÀÕİ$WÛ7”ä×oÀ=FŠ¨ºãĞ©ïƒW~˜‰Ş®°¢aÅ’ÍBsÎá™ÑÛÓk48¦FhŸ°Z…Œ"'ßb3›c©læ>Aô[İGû)4%yê%ßÂ)Fû]øêÂÓr¶ÜO¯ëşµlªu"	ïÁ¦‚Ùè¸YÑñË 8¼ìá({jìl7öˆVÎ$'_m÷¿O-¢t#—Ç<;nWnYÊ¿²eX¿ığÍÃOomGúØéX¿W:ïœpèÛÄ8<­¶i #sWRĞıª DXQù=cpˆfæ*E¬ æZ…Ğ«wuñ)øß Q´şœZ31“iòæ*ßêU.y`ö°òD¬Sı6s£ğ	W*hîÅòÔÌQ^¡1ÎGĞ&¿V'â!¾?7qkK·ÁÉÈmå2}¸ÒßI~ï}ÇîY¤33@wàô”	€ı}j b4#ĞH¢·YX+Ë·z³úH„£¢Cì/,;:*s	PµŞãÊ›>r~ˆµ,ëHˆ:»¤ğr²hAFz^¥%•`
>Çôœ6–š”²{¸ÒÔıûvzÿ@Nƒ°<‰x>Á‚mÔÇ¤MG	ã‘R#•§¦<AK„dS/æ=,ÖJìMº?¹É|ŞzÖĞxúcÉgB­É”ærxwÑ/ÒÑ¯u4Q_a}İ¶è·ÑİÏä= Ş†\ÂRÔ½¤/uÆ¤ÊW¾†8)‰tjÈMAÙëM“kKı¸ˆ¸œ2hg§ÏIYyM€àvî6lâÃÌœ_œò(x?˜o_ûÚ€í6—ì
¥tzÎjœœŞ²¼ïZAÇ6ùT¾Cv©3¢ùÄêg¤Möiı:njˆAác™ÂšñxéÕŸygM³•DÌ„	0Eœ ú]™ÌJŸŞóAĞ0ö]P$êQı7kísÌ¥yîin—”á¥~?¯”Äùÿß$SÅò‰H>”Ûú'–ğà•tÓÓ]¯“=y®áì
¥óËÌÉx·v“PlM Yòï1Š}€+Yæ¶(•„½Ëêg»òâŒMuÛXz§hyÇ?“ƒ”íj|¥±†½/Jôƒ^œÓÄ¢Ét3ü7u´XÕqİl¸&º8‹˜’mÅÕ.¦ŠYgÇ7‡–ìjPñbˆ5f½úı6º¡0‘q‰¢ƒÌàyóEY	DótšY¼å‚ÈW ãäÆè+°ï©áGJS‡ÈäŠj0ÈüSÈ8Q¨ÊhòC¸‰bÑr¦’;oñ³¬{m†Gàj¡½O’˜ßğÕëkJ;üD+L¬YÖ'UkšÚ%™Û{ªSà|d°mMSÇÌrª·	®häKÛ‹I:
ß}>8Ö,®”•Â4¸)vß?ıgå×p‘­Ï2×”†DÿßnòŸks_]äÉ3´ÈKÕjHcI`â îw¾.DPg’ü®üÓî¯ìÓ0ë“ôŞàĞ&væ]âõ÷Au…Knß*’•U¡õiëe³ÏÉµc/`™ã£©Íİ+ùt¾ÏÔb»³ÁvêÁì+ç˜ñ~¤(„Ü€Şsç§lÒC¨Ç½Âq4o$¶õ›‰ù8p¿ğİEÕBı?¢HN)ş	¶“j†ÜDŒO¥¹¾w{jbãC¤c€ôYd¤¯Cb dÚåoèÉÔÆ9y7SîWÍg•
«V™gx¤Ñ>#Rì¶phÙÒÍañšüpc¬ıG"rF <å¯gHE%²Ô	¸­ÅèÆƒíD&Åİïq 6À‚¹˜Í-İh›²–†Ø§@o1]R#	½ò áI‹Ë´›ŠEÈØ‰·Ù˜ú…R³2äQªY€ÎI©8}]¾A«,ˆˆ•¸S|‚+’˜‰cWolœÚéŒdÄˆæ™{Šºl