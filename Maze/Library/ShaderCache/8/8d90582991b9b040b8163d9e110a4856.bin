nabled
static INLINE __m128i load_input_data4(const tran_low_t *data) {
#if CONFIG_VP9_HIGHBITDEPTH
  const __m128i zero = _mm_setzero_si128();
  const __m128i in = _mm_load_si128((const __m128i *)data);
  return _mm_packs_epi32(in, zero);
#else
  return _mm_loadl_epi64((const __m128i *)data);
#endif
}

static INLINE __m128i load_input_data8(const tran_low_t *data) {
#if CONFIG_VP9_HIGHBITDEPTH
  const __m128i in0 = _mm_load_si128((const __m128i *)data);
  const __m128i in1 = _mm_load_si128((const __m128i *)(data + 4));
  return _mm_packs_epi32(in0, in1);
#else
  return _mm_load_si128((const __m128i *)data);
#endif
}

static INLINE void load_transpose_16bit_8x8(const tran_low_t *input,
                                            const int stride,
                                            __m128i *const in) {
  in[0] = load_input_data8(input + 0 * stride);
  in[1] = load_input_data8(input + 1 * stride);
  in[2] = load_input_data8(input + 2 * stride);
  in[3] = load_input_data8(input + 3 * stride);
  in[4] = load_input_data8(input + 4 * stride);
  in[5] = load_input_data8(input + 5 * stride);
  in[6] = load_input_data8(input + 6 * stride);
  in[7] = load_input_data8(input + 7 * stride);
  transpose_16bit_8x8(in, in);
}

static INLINE void recon_and_store(uint8_t *const dest, const __m128i in_x) {
  const __m128i zero = _mm_setzero_si128();
  __m128i d0 = _mm_loadl_epi64((__m128i *)(dest));
  d0 = _mm_unpacklo_epi8(d0, zero);
  d0 = _mm_add_epi16(in_x, d0);
  d0 = _mm_packus_epi16(d0, d0);
  _mm_storel_epi64((__m128i *)(dest), d0);
}

static INLINE void round_shift_8x8(const __m128i *const in,
                                   