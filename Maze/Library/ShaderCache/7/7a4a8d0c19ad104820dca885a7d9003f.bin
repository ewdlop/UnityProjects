e() {}

	/* Prepares the source voice for initialization. This may parse a compressed asset header on some platforms */
	virtual bool PrepareForInitialization(FWaveInstance* InWaveInstance) { return true; }

	/** Returns if the source voice is prepared to initialize. */
	virtual bool IsPreparedToInit() { return true; }

	/** Initializes the sound source. */
	virtual bool Init(FWaveInstance* InWaveInstance) = 0;

	/** Returns whether or not the sound source has initialized. */
	virtual bool IsInitialized() const { return bInitialized; };

	/** Updates the sound source. */
	virtual void Update() = 0;

	/** Plays the sound source. */
	virtual void Play() = 0;

	/** Stops the sound source. */
	ENGINE_API virtual void Stop();

	ENGINE_API virtual void StopNow() { Stop(); };

	/** Whether or not the source is stopping. Only implemented in audio mixer. */
	virtual bool IsStopping() { return false; }

	/** Returns true if the sound source has finished playing. */
	virtual	bool IsFinished() = 0;
	
	/** Pause the source from game pause */
	void SetPauseByGame(bool bInIsPauseByGame);

	/** Pause the source manually */
	void SetPauseManually(bool bInIsPauseManually);

	/** Returns a string describing the source (subclass can override, but it should call the base and append). */
	ENGINE_API virtual FString Describe(bool bUseLongName);

	/** Returns source is an in-game only. Will pause when in UI. */
	bool IsGameOnly() const;

	/** Returns the wave instance of the sound source. */
	const FWaveInstance* GetWaveInstance() const { return WaveInstance; }

	/** Returns whether or not the sound source is playing. */
	bool IsPlaying() const { return Playing; }

	/**  Returns true if the sound is paused. */
	bool IsPaused() const { return Paused; }
	
	/**  Returns true if the sound is paused. */
	bool IsPausedByGame() const { return bIsPausedByGame; }

	bool IsPausedManually() const { return bIsManuallyPaused; }

	/** Returns true if reverb should be applied. */
	bool IsReverbApplied() const { return bReverbApplied; }

	/** Set the bReverbApplied variable. */
	ENGINE_API bool SetReverbApplied(bool bHardwareAvailable);

	/** Set the StereoBleed variable. */
	UE_DEPRECATED(4.25, "Stereo Bleed is no longer supported.")
	ENGINE_API float SetStereoBleed();

	/** Updates and sets the LFEBleed variable. */
	ENGINE_API float SetLFEBleed();

	/** Updates the FilterFrequency value. */
	ENGINE_API void SetFilterFrequency();

	/** Updates the stereo emitter positions of this voice. */
	ENGINE_API void UpdateStereoEmitterPositions();

	/** Gets parameters necessary for computing 3d spatialization of sources. */
	ENGINE_API FSpatializationParams GetSpatializationParams();

	/** Returns the contained sound buffer object. */
	virtual const FSoundBuffer* GetBuffer() const { return Buffer; }

	/** Initializes any source effects for this sound source. */
	virtual void InitializeSourceEffects(uint32 InEffectVoiceId)
	{
	}

	/** Sets if this voice is virtual. */
	void SetVirtual()
	{
		bIsVirtual = true;
	}

	/** Returns the source's playback percent. */
	ENGINE_API virtual float GetPlaybackPercent() const;

	/** Returns the source's envelope at the callback block rate. Only implemented in audio mixer. */
	ENGINE_API virtual float GetEnvelopeValue() const { return 0.0f; };

	ENGINE_API void GetChannelLocations(FVector& Left, FVector&Right) const;

	void NotifyPlaybackData();

protected:

	/** Initializes common data for all sound source types. */
	ENGINE_API void InitCommon();

	/** Updates common data for all sound source types. */
	ENGINE_API void UpdateCommon();

	/** Pauses the sound source. */
	virtual void Pause() = 0;

	/** Updates this source's pause state */
	void UpdatePause();

	/** Returns the volume of the sound source after evaluating debug commands */
	ENGINE_API float GetDebugVolume(const float InVolume);

	/** Owning audio device. */
	FAudioDevice* AudioDevice;

	/** Contained wave instance. */
	FWaveInstance* WaveInstance;

	/** Cached sound buffer associated with currently bound wave instance. */
	FSoundBuffer* Buffer;

	/** The amount of a sound to bleed to the LFE speaker */
	float LFEBleed;

	/** What frequency to set the LPF filter to. Note this could be caused by occlusion, manual LPF application, or LPF distance attenuation. */
	float LPFFrequency;

	/** What frequency to set the HPF filter to. Note this could be caused by HPF distance attenuation. */
	float HPFFrequency;

	/** The last LPF frequency set. Used to avoid making API calls when parameter doesn't changing. */
	float LastLPFFrequency;

	/** The last HPF frequency set. Used to avoid making API calls when parameter doesn't changing. */
	float LastHPFFrequency;

	/** The virtual current playback time. Used to trigger notifications when finished. */
	float PlaybackTime;

	/** The pitch of the sound source. */
	float Pitch;

	/** Last tick when this source was active */
	int32 LastUpdate;

	/** Last tick when this source was active *and* had a hearable volume */
	int32 LastHeardUpdate;

	/** Update tick count. Used to stop oldest stopping sound source. */
	int32 TickCount;

	/** The location of the left-channel source for stereo spatialization. */
	FVector LeftChannelSourceLocation;

	/** The location of the right-channel source for stereo spatialization. */
	FVector RightChannelSourceLocation;

	/** The number of frames (Samples / NumChannels) played by the sound source. */
	int32 NumFramesPlayed;

	/** The total number of frames of audio for the sound wave */
	int32 NumTotalFrames;

	/** The frame we started on. */
	int32 StartFrame;

	/** Effect ID of this sound source in the audio device sound source array. */
	uint32 VoiceId;

	/** Whether we are playing or not. */
	FThreadSafeBool Playing;

	/** Cached sound mode value used to detect when to switch outputs. */
	uint8 bReverbApplied : 1;

	/** Whether we are paused by game state or not. */
	uint8 bIsPausedByGame : 1;

	/** Whether or not we were paused manually. */
	uint8 bIsManuallyPaused : 1;

	/** Whether or not we are actually paused. */
	uint8 Paused : 1;

	/** Whether or not the sound source is initialized. */
	uint8 bInitialized : 1;

	/** Whether or not the sound is a preview sound. */
	uint8 bIsPreviewSound : 1;

	/** True if this isn't a real hardware voice */
	uint32 bIsVirtual : 1;

	friend class FAudioDevice;
	friend struct FActiveSound;

#if ENABLE_AUDIO_DEBUG
public:

	/** Struct containing the debug state of a SoundSource */
	struct ENGINE_API FDebugInfo
	{
		/** True if this sound has been soloed. */
		bool bIsSoloed = false;

		/** True if this sound has been muted . */
		bool bIsMuted = false;

		/** Reason why this sound is mute/soloed. */
		FString MuteSoloReason;

		/** Basic CS so we can pass this around safely. */
		FCriticalSection CS;
	};
	
	TSharedPtr<FDebugInfo, ESPMode::ThreadSafe> DebugInfo;
	friend struct FDebugInfo;
#endif //ENABLE_AUDIO_DEBUG
};

/*-----------------------------------------------------------------------------
	FWaveModInfo. 
-----------------------------------------------------------------------------*/

//
// Structure for in-memory interpretation and modification of WAVE sound structures.
//
class FWaveModInfo
{
public:

	// Pointers to variables in the in-memory WAVE file.
	const uint32* pSamplesPerSec;
	const uint32* pAvgBytesPerSec;
	const uint16* pBlockAlign;
	const uint16* pBitsPerSample;
	const uint16* pChannels;
	const uint16* pFormatTag;

	const uint32* pWaveDataSize;
	const uint32* pMasterSize;
	const uint8*  SampleDataStart;
	const uint8*  SampleDataEnd;
	uint32  SampleDataSize;
	const uint8*  WaveDataEnd;

	uint32  NewDataSize;

	// Constructor.
	FWaveModInfo()
	{
	}
	
	// 16-bit padding.
	static uint32 Pad16Bit( uint32 InDW )
	{
		return ((InDW + 1)& ~1);
	}

	// Read headers and load all info pointers in WaveModInfo. 
	// Returns 0 if invalid data encountered.
	ENGINE_API bool ReadWaveInfo(const uint8* WaveData, int32 WaveDataSize, FString* ErrorMessage = NULL, bool InHeaderDataOnly = false, void** OutFormatHeader = NULL );
	
	/**
	 * Read a wave file header from bulkdata
	 */
	ENGINE_API bool ReadWaveHeader(const uint8* RawWaveData, int32 Size, int32 Offset );

	ENGINE_API void ReportImportFailure() const;
};

/** Utility to serialize raw PCM data into a wave file. */
ENGINE_API void SerializeWaveFile(TArray<uint8>& OutWaveFileData, const uint8* InPCMData, const int32 NumBytes, const int32 NumChannels, const int32 SampleRate);

/**
 * Brings loaded sounds up to date for the given platforms (or all platforms), and also sets persistent variables to cover any newly loaded ones.
 *
 * @param	Platform				Name of platform to cook for, or NULL if all platforms
 */
ENGINE_API void SetCompressedAudioFormatsToBuild(const TCHAR* Platform = NULL);

/**
 * Brings loaded sounds up to date for the given platforms (or all platforms), and also sets persistent variables to cover any newly loaded ones.
 *
 * @param	Platform				Name of platform to cook for, or NULL if all platforms
 */
ENGINE_API const TArray<FName>& GetCompressedAudioFormatsToBuild();


                                                                                                                                                                                                                                                                                                                                                                             EJ2q√JëÛ'9¸©Ù÷Ω4πÊ˘Ô¨Êi–√=˘KœöEÒÜW«üÊ›ïÒÃ+¬Á¥sƒJ>'#ˇ–F≤˘Ωê/6ﬂåKd?íVa≈°“˚l=Núıâ\ŸÈ¸›"∫ƒÌÊ±ô…Ωß:˘Ö‚Ád,Wm9°LïﬁÿJ$l6	Ì”z{òëıürﬂê"A¸ÇÔ
µ)√{Æ-ØBØ”œ„Ö"1ûÌØhbYqSŸoE∏	“≥‹Ï¯–ù‚Vù-*)∂¿⁄πÛóG^òÍá¿ù≠ôsZ;ﬂàåÜSjM¶›ÑsÖ¶âÄU˛B1t9Y”ÖPÂ∂ã¯ƒ∞˝∑€T/Myá–Ó“¬ØRìì¸mÑÃW	ô 	¥Ê~ Y®0äÃÒfØÂôÌ
—˛
€V™˚ıäŸhÙà]¨Ÿç≠˛ã£ñ≠i»x{tu@o2∆ÇFú∑>ÈÑ≈≥ƒ°&õ"ë@Ô√ÕWÄIG‘√í÷V˛qKπûv¡âIñè¥o\´3NîL‹mí 2!RÑ≥ëƒÿ˙â{Oo+.mÔ]_AnNY‘w¬m»QZ/JÛöq"’KS©∆Œv%0+˚(SM~ÈƒøÜ∏Ê
,‚¨#Mô CÃ√mE#ﬁ¥Cs¢úp√‘~Ÿeœî˙œ<`ã9LL›¸¢Ú÷8»˙ÖàÒB∞«tﬂ‰÷‡‘#Wjxóæ›ÿ¡É$òl»Ñ»ÒRåÈû‘I‹ˆ'¯£òˆÇo+_£èWÿün`rí‰≥À‡»ûYQƒ5∂⁄	æi`'—F,éÇV.üßÎ~ºD$¬‡Â
Iõ∑Ãô˙÷õ°pïxPÛ#a◊òp¸z≥hÊµ‚?.¬Jæ-›ßÂÛü)¿°\Û‰≠ ˝Ñ9J}˜—zÈ*ÚÕßΩa›eTã‰	¢Ì±l÷∏‹APÚ‹,¶§¸`\NHÄ*À?VfÜ¬Âcº◊z# /Õ´ˇ {!µfE –∫G¶òê…·Xu˘Ëêã‡u-˘°√ï∑L}}ù0¡í“˘)Í‚¡ºV‡√I6uQXKÜºŸÀõl/=ü ‡Yr…BQj@£Ã∑‰€ë’°°ÄEcÒHπÂfÒX˜¸+Ñ…,ŒπVuËÒe≈“*ç˚©ÈCƒ$—ZúdÅ‡Eó÷,‰7êï√∑ˆ'ÃL]Ï?xÆDK™ö˘≠0üˆ¬xºt2–∆	FŒèÓ&1O±<™H∆Ã1À_≤<<·~{U¢z?]!“]ndù≥ˆë2Øõ˙ˇK~G.ÇE‡r0éêÓª–√.»ÅKêïõ!s≤ÃSπü÷‡*ÄR∆ø˘gÑA8{o^§-oŒ¸Ê§…ı#Æ-Ú⁄é®ø‹gˇÃ-F‡‰PxÙ§†?t∂@ò:¶>*æÛ¬á›P≥¯´Éc∂X˛SØ∆Uçq—-ˆò˝4|)«;¯Uƒóµ4≠≥E∫5≤û4ÀÚ‹l €eúâ„˙ˇî˚}|jLÙÕâj)’◊]»V"≈-~*
dFœV8únu2ª“f53‰ñî‚n”+ßÅ∆cÀÖïW¸âEÉ◊-ÓëfMóà⁄sêHﬂTœ™r–ƒÊÿíz°‹ÙÍôŒ˜eVJ+@‚=¶√∫XÇ‘÷psåTâ´◊|«çy_µéav©¡·û∫ßS •´Õ©‡)ïy
ä˜®ks∂’HÆ~Q®ªP≤œÎo¬ÖM†AxŸh‡•Òˆ“ƒÃ¯òﬁÖÍ?ËÜñ9Ì|P„#¯ˇ—8€-Â˙9∆|ÿ·S™E»êèoê™√“Z@ÓÉ(Ωµ;Alá„¿≥ØH›ùÑÎ†≥2ä®7Ç±‰*2/ÍèN‰Ï˛ÛbÔıÔ≥◊î˚£·’ç©Ò;#Ã€ä°gÚ ï…Ë"7û∏)2Mk
ñ®◊ùE¥ø9é¥X§ÿRÍ≤w⁄|„¯ÿ%\˚-Lf¿ò_'¸<)XT0)‚0u˙äì>ÅGãrw‘.òmåœz0ô‘Æª≥¨ˆ6ä∂mjp≠ú>UÇAπÊöãÕıÃ!jR¡äO∑(éœ;◊6L%∑;€V≤9yh¿ûÍf&≥=LïQ¡p°~¸Î}@Và‘I¬0el®d˜.CD‡ÌhXù7ﬁ£∫lÌiQ’,ﬂã‹0¶ÁøÚ@bCF<_CœÇQ:¶Ÿxœ„1ñÔdêéˇ3/I4m±Ob<ñ%…
F\™O9J¨_XÕ“ˆ6Fá~˛»ó≠´ﬁ(IŸ_	T±Y9%vMNwë*	áπ⁄T,ìtIπ”lFÌÈ÷º&∆Òsç∏àﬁ)Òü sî6Vı†ùÍ’êﬁ£—µ+oòz®˝àˆ∫õµÌØ∆„FxeÀëEåeùhÄ©,Õâ>JË!âMÅ»12Ø
c∑ÒL„˙?A¶›QTI1‚ä◊(‘MÍd‡Á4˙É«,˙¶õ-Ô2°LGEG6CfÏGRÿ t0ï:KπÖtò~∑Tîúy¥ûº˝ûw 9‰Ô<0H>ﬁ`XåÂ%ãl€∏ÜÁ„Cwœf¿_±iôõ^º=#:+$¸›_ÿNÕg!Œt∂ç˚¢∞˘¸>pÈ¥qà,ùLıö*[≈Ï -~Uz™˘…"Û˙‡'ÿ≠N‰n&d(ÏÌ¿ü˛¥•éá(W
√%æ∏Vö∫J…N´âøNïÊ0pÏ#¡OÖ«»6®Fà
+®wSb?«}íâÛ˙Â¸{ÊˇAªY·äîÜÛ©~JÖ#s”“ú≥≈uvpip„È∂ˇnÂ—zâ£-è∆ÊõI∏U˜v˚d¢Ú[Õa‘Z∂˛¯È™S£?çö«;µæ∂î§Óù«◊ínêb›E,¶Sq[…ßA
5t7ñ4}’”EˆÊáNfÚZ¢˘«9¯.êòr-d-	¸Àú@∞!O6≤∫E°}}3ƒà9C~P¢NvÌ·;Uü¸ËÁû;ŒAòﬁö≠Ê<ﬂ¬"ı€Î„»õö•¢Aπ»4	wåÄ
0&W?=óßÒjî79TO–¢4úÛ„L¥…^ßJπ)AáÜ/Ñª´”Ÿì!Œ¡nÒ(ÈïdI´éZÉ¨›‘.îÇÓT`∫èı9@˘‘4ôŸa/Tƒqä#õÍ‰ıõBÌ3ÔœΩ;d√ß˝äu]
∆¢≥¨	eı7€ÒÒüÂjÁçÌx¶∂ÇjUÔ$õﬂqﬂ»?rmgïNÓWIQ⁄D›T=≈PoÏ⁄¸‚ﬁ˛&ÑG>ˇÛe´íz'ÄegW≈
ñ	hæUZ.CÇ‚,érN‰4Å' e$yÿ.’EßxmßwˇºN_t0#4mlj˝Ù™Û˚…ZëdP«ª†]vÚwûÁˇ≤`•fÖ©ã≈®•#¶ÿ?_ûÙ⁄§#_t˘FY	“Gof£ﬁõ⁄cÎÔàÅ†ÃS®®J=“ñ1(//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#ifndef EXPERIMENTAL_ANY_HELPERS_H
#define EXPERIMENTAL_ANY_HELPERS_H

#include <experimental/any>
#include <typeinfo>
#include <type_traits>
#include <cassert>

#include "test_macros.h"

#if !defined(TEST_HAS_NO_RTTI)
#define RTTI_ASSERT(X) assert(X)
#else
#define RTTI_ASSERT(X)
#endif

template <class T>
  struct IsSmallObject
    : public std::integral_constant<bool
        , sizeof(T) <= (sizeof(void*)*3)
          && std::alignment_of<void*>::value
             % std::alignment_of<T>::value == 0
          && std::is_nothrow_move_constructible<T>::value
        >
  {};


// Return 'true' if 'Type' will be considered a small type by 'any'
template <class Type>
bool isSmallType() {
#if defined(_LIBCPP_VERSION)
    return std::experimental::__any_imp::_IsSmallObject<Type>::value;
#else
    return IsSmallObject<Type>::value;
#endif

}

// Assert that an object is empty. If the object used to contain an object
// of type 'LastType' check that it can no longer be accessed.
template <class LastType = int>
void assertEmpty(std::experimental::any const& a) {
    assert(a.empty());
    RTTI_ASSERT(a.type() == typeid(void));
    assert(std::experimental::any_cast<LastType const>(&a) == nullptr);
}

// Assert that an 'any' object stores the specified 'Type' and 'value'.
template <class Type>
_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
void assertContains(std::experimental::any const& a, int value = 1) {
    assert(!a.empty());
    RTTI_ASSERT(a.type() == typeid(Type));
    assert(std::experimental::any_cast<Type const &>(a).value == value);
}

// Modify the value of a "test type" stored within an any to the specified
// 'value'.
template <class Type>
_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
void modifyValue(std::experimental::any& a, int value) {
    assert(!a.empty());
    RTTI_ASSERT(a.type() == typeid(Type));
    std::experimental::any_cast<Type&>(a).value = value;
}

// A test type that will trigger the small object optimization within 'any'.
template <int Dummy = 0>
struct small_type
{
    static int count;
    static int copied;
    static int moved;
    static int const_copied;
    static int non_const_copied;

    static void reset() {
        small_type::copied = 0;
        small_type::moved = 0;
        small_type::const_copied = 0;
        small_type::non_const_copied = 0;
    }

    int value;

    explicit small_type(int val) : value(val) {
        ++count;
    }

    small_type(small_type const & other) throw() {
        value = other.value;
        ++count;
        ++copied;
        ++const_copied;
    }

    small_type(small_type& other) throw() {
        value = other.value;
        ++count;
        ++copied;
        ++non_const_copied;
    }

    small_type(small_type && other) throw() {
        value = other.value;
        other.value = 0;
        ++count;
        ++moved;
    }

    ~small_type() {
        value = -1;
        --count;
    }

private:
    small_type& operator=(small_type const&) = delete;
    small_type& operator=(small_type&&) = delete;
};

template <int Dummy>
int small_type<Dummy>::count = 0;

template <int Dummy>
int small_type<Dummy>::copied = 0;

template <int Dummy>
int small_type<Dummy>::moved = 0;

template <int Dummy>
int small_type<Dummy>::const_copied = 0;

template <int Dummy>
int small_type<Dummy>::non_const_copied = 0;

typedef small_type<> small;
typedef small_type<1> small1;
typedef small_type<2> small2;


// A test type that will NOT trigger the small object optimization in any.
template <int Dummy = 0>
struct large_type
{
    static int count;
    static int copied;
    static int moved;
    static int const_copied;
    static int non_const_copied;

    static void reset() {
        large_type::copied = 0;
        large_type::moved  = 0;
        large_type::const_copied = 0;
        large_type::non_const_copied = 0;
    }

    int value;

    large_type(int val) : value(val) {
        ++count;
        data[0] = 0;
    }

    large_type(large_type const & other) {
        value = other.value;
        ++count;
        ++copied;
        ++const_copied;
    }

    large_type(large_type & other) {
        value = other.value;
        ++count;
        ++copied;
        ++non_const_copied;
    }

    large_type(large_type && other) {
        value = other.value;
        other.value = 0;
        ++count;
        ++moved;
    }

    ~large_type()  {
        value = 0;
        --count;
    }

private:
    large_type& operator=(large_type const&) = delete;
    large_type& operator=(large_type &&) = delete;
    int data[10];
};

template <int Dummy>
int large_type<Dummy>::count = 0;

template <int Dummy>
int large_type<Dummy>::copied = 0;

template <int Dummy>
int large_type<Dummy>::moved = 0;

template <int Dummy>
int large_type<Dummy>::const_copied = 0;

template <int Dummy>
int large_type<Dummy>::non_const_copied = 0;

typedef large_type<> large;
typedef large_type<1> large1;
typedef large_type<2> large2;

// The exception type thrown by 'small_throws_on_copy', 'large