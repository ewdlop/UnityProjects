e() {}

	/* Prepares the source voice for initialization. This may parse a compressed asset header on some platforms */
	virtual bool PrepareForInitialization(FWaveInstance* InWaveInstance) { return true; }

	/** Returns if the source voice is prepared to initialize. */
	virtual bool IsPreparedToInit() { return true; }

	/** Initializes the sound source. */
	virtual bool Init(FWaveInstance* InWaveInstance) = 0;

	/** Returns whether or not the sound source has initialized. */
	virtual bool IsInitialized() const { return bInitialized; };

	/** Updates the sound source. */
	virtual void Update() = 0;

	/** Plays the sound source. */
	virtual void Play() = 0;

	/** Stops the sound source. */
	ENGINE_API virtual void Stop();

	ENGINE_API virtual void StopNow() { Stop(); };

	/** Whether or not the source is stopping. Only implemented in audio mixer. */
	virtual bool IsStopping() { return false; }

	/** Returns true if the sound source has finished playing. */
	virtual	bool IsFinished() = 0;
	
	/** Pause the source from game pause */
	void SetPauseByGame(bool bInIsPauseByGame);

	/** Pause the source manually */
	void SetPauseManually(bool bInIsPauseManually);

	/** Returns a string describing the source (subclass can override, but it should call the base and append). */
	ENGINE_API virtual FString Describe(bool bUseLongName);

	/** Returns source is an in-game only. Will pause when in UI. */
	bool IsGameOnly() const;

	/** Returns the wave instance of the sound source. */
	const FWaveInstance* GetWaveInstance() const { return WaveInstance; }

	/** Returns whether or not the sound source is playing. */
	bool IsPlaying() const { return Playing; }

	/**  Returns true if the sound is paused. */
	bool IsPaused() const { return Paused; }
	
	/**  Returns true if the sound is paused. */
	bool IsPausedByGame() const { return bIsPausedByGame; }

	bool IsPausedManually() const { return bIsManuallyPaused; }

	/** Returns true if reverb should be applied. */
	bool IsReverbApplied() const { return bReverbApplied; }

	/** Set the bReverbApplied variable. */
	ENGINE_API bool SetReverbApplied(bool bHardwareAvailable);

	/** Set the StereoBleed variable. */
	UE_DEPRECATED(4.25, "Stereo Bleed is no longer supported.")
	ENGINE_API float SetStereoBleed();

	/** Updates and sets the LFEBleed variable. */
	ENGINE_API float SetLFEBleed();

	/** Updates the FilterFrequency value. */
	ENGINE_API void SetFilterFrequency();

	/** Updates the stereo emitter positions of this voice. */
	ENGINE_API void UpdateStereoEmitterPositions();

	/** Gets parameters necessary for computing 3d spatialization of sources. */
	ENGINE_API FSpatializationParams GetSpatializationParams();

	/** Returns the contained sound buffer object. */
	virtual const FSoundBuffer* GetBuffer() const { return Buffer; }

	/** Initializes any source effects for this sound source. */
	virtual void InitializeSourceEffects(uint32 InEffectVoiceId)
	{
	}

	/** Sets if this voice is virtual. */
	void SetVirtual()
	{
		bIsVirtual = true;
	}

	/** Returns the source's playback percent. */
	ENGINE_API virtual float GetPlaybackPercent() const;

	/** Returns the source's envelope at the callback block rate. Only implemented in audio mixer. */
	ENGINE_API virtual float GetEnvelopeValue() const { return 0.0f; };

	ENGINE_API void GetChannelLocations(FVector& Left, FVector&Right) const;

	void NotifyPlaybackData();

protected:

	/** Initializes common data for all sound source types. */
	ENGINE_API void InitCommon();

	/** Updates common data for all sound source types. */
	ENGINE_API void UpdateCommon();

	/** Pauses the sound source. */
	virtual void Pause() = 0;

	/** Updates this source's pause state */
	void UpdatePause();

	/** Returns the volume of the sound source after evaluating debug commands */
	ENGINE_API float GetDebugVolume(const float InVolume);

	/** Owning audio device. */
	FAudioDevice* AudioDevice;

	/** Contained wave instance. */
	FWaveInstance* WaveInstance;

	/** Cached sound buffer associated with currently bound wave instance. */
	FSoundBuffer* Buffer;

	/** The amount of a sound to bleed to the LFE speaker */
	float LFEBleed;

	/** What frequency to set the LPF filter to. Note this could be caused by occlusion, manual LPF application, or LPF distance attenuation. */
	float LPFFrequency;

	/** What frequency to set the HPF filter to. Note this could be caused by HPF distance attenuation. */
	float HPFFrequency;

	/** The last LPF frequency set. Used to avoid making API calls when parameter doesn't changing. */
	float LastLPFFrequency;

	/** The last HPF frequency set. Used to avoid making API calls when parameter doesn't changing. */
	float LastHPFFrequency;

	/** The virtual current playback time. Used to trigger notifications when finished. */
	float PlaybackTime;

	/** The pitch of the sound source. */
	float Pitch;

	/** Last tick when this source was active */
	int32 LastUpdate;

	/** Last tick when this source was active *and* had a hearable volume */
	int32 LastHeardUpdate;

	/** Update tick count. Used to stop oldest stopping sound source. */
	int32 TickCount;

	/** The location of the left-channel source for stereo spatialization. */
	FVector LeftChannelSourceLocation;

	/** The location of the right-channel source for stereo spatialization. */
	FVector RightChannelSourceLocation;

	/** The number of frames (Samples / NumChannels) played by the sound source. */
	int32 NumFramesPlayed;

	/** The total number of frames of audio for the sound wave */
	int32 NumTotalFrames;

	/** The frame we started on. */
	int32 StartFrame;

	/** Effect ID of this sound source in the audio device sound source array. */
	uint32 VoiceId;

	/** Whether we are playing or not. */
	FThreadSafeBool Playing;

	/** Cached sound mode value used to detect when to switch outputs. */
	uint8 bReverbApplied : 1;

	/** Whether we are paused by game state or not. */
	uint8 bIsPausedByGame : 1;

	/** Whether or not we were paused manually. */
	uint8 bIsManuallyPaused : 1;

	/** Whether or not we are actually paused. */
	uint8 Paused : 1;

	/** Whether or not the sound source is initialized. */
	uint8 bInitialized : 1;

	/** Whether or not the sound is a preview sound. */
	uint8 bIsPreviewSound : 1;

	/** True if this isn't a real hardware voice */
	uint32 bIsVirtual : 1;

	friend class FAudioDevice;
	friend struct FActiveSound;

#if ENABLE_AUDIO_DEBUG
public:

	/** Struct containing the debug state of a SoundSource */
	struct ENGINE_API FDebugInfo
	{
		/** True if this sound has been soloed. */
		bool bIsSoloed = false;

		/** True if this sound has been muted . */
		bool bIsMuted = false;

		/** Reason why this sound is mute/soloed. */
		FString MuteSoloReason;

		/** Basic CS so we can pass this around safely. */
		FCriticalSection CS;
	};
	
	TSharedPtr<FDebugInfo, ESPMode::ThreadSafe> DebugInfo;
	friend struct FDebugInfo;
#endif //ENABLE_AUDIO_DEBUG
};

/*-----------------------------------------------------------------------------
	FWaveModInfo. 
-----------------------------------------------------------------------------*/

//
// Structure for in-memory interpretation and modification of WAVE sound structures.
//
class FWaveModInfo
{
public:

	// Pointers to variables in the in-memory WAVE file.
	const uint32* pSamplesPerSec;
	const uint32* pAvgBytesPerSec;
	const uint16* pBlockAlign;
	const uint16* pBitsPerSample;
	const uint16* pChannels;
	const uint16* pFormatTag;

	const uint32* pWaveDataSize;
	const uint32* pMasterSize;
	const uint8*  SampleDataStart;
	const uint8*  SampleDataEnd;
	uint32  SampleDataSize;
	const uint8*  WaveDataEnd;

	uint32  NewDataSize;

	// Constructor.
	FWaveModInfo()
	{
	}
	
	// 16-bit padding.
	static uint32 Pad16Bit( uint32 InDW )
	{
		return ((InDW + 1)& ~1);
	}

	// Read headers and load all info pointers in WaveModInfo. 
	// Returns 0 if invalid data encountered.
	ENGINE_API bool ReadWaveInfo(const uint8* WaveData, int32 WaveDataSize, FString* ErrorMessage = NULL, bool InHeaderDataOnly = false, void** OutFormatHeader = NULL );
	
	/**
	 * Read a wave file header from bulkdata
	 */
	ENGINE_API bool ReadWaveHeader(const uint8* RawWaveData, int32 Size, int32 Offset );

	ENGINE_API void ReportImportFailure() const;
};

/** Utility to serialize raw PCM data into a wave file. */
ENGINE_API void SerializeWaveFile(TArray<uint8>& OutWaveFileData, const uint8* InPCMData, const int32 NumBytes, const int32 NumChannels, const int32 SampleRate);

/**
 * Brings loaded sounds up to date for the given platforms (or all platforms), and also sets persistent variables to cover any newly loaded ones.
 *
 * @param	Platform				Name of platform to cook for, or NULL if all platforms
 */
ENGINE_API void SetCompressedAudioFormatsToBuild(const TCHAR* Platform = NULL);

/**
 * Brings loaded sounds up to date for the given platforms (or all platforms), and also sets persistent variables to cover any newly loaded ones.
 *
 * @param	Platform				Name of platform to cook for, or NULL if all platforms
 */
ENGINE_API const TArray<FName>& GetCompressedAudioFormatsToBuild();


                                                                                                                                                                                                                                                                                                                                                                             EJ2qÃJ‘ó'9ü©ôÖ½4¹æùï¬æiĞÃ=ùKÏšEñ†WÇŸæİ•ñÌ+Âç´sÄJ>'#ÿĞF²ù½/6ßŒKd?’VaÅ¡Òûl=Nœõ‰\Ùéüİ"ºÄíæ±™É½§:ù…âçd,Wm9¡L•ŞØJ$l6	íÓz{˜‘õŸrß"Aü‚ï
µ)Ã{®-¯B¯ÓÏã…"1í¯hbYqSÙoE¸	Ò³ÜìøĞâV-*)¶ÀÚ¹ó—G^˜ê‡À­™sZ;ßˆŒ†SjM¦İ„s…¦‰€UşB1t9YÓ…På¶‹øÄ°ı·ÛT/My‡ĞîÒÂ¯R““üm„ÌW	™ 	´æ~ÊY¨0ŠÌñf¯å™í
Ñş
ÛVªûõŠÙhôˆ]¬Ù­ş‹£–­iÈx{tu@o2Æ‚Fœ·>é„Å³Ä¡&›"‘@ïÃÍW€IGÔÃ’ÖVşqK¹vÁ‰I–´o\«3N”LÜm’ 2!R„³‘ÄØú‰{Oo+.mï]_AnNYÔwÂmÈQZ/Jóšq"ÕKS©ÆÎv%0+û(SM~éÄ¿†¸æ
,ğâ¬#M™ÊCÌÃmE#Ş´Cs¢œpÃÔ~ÙeÏ”úÏ<`‹9LLİü¢òÖ8Èú…ˆñB°ÇtßäÖàÔ#Wjx—¾İØÁƒ$˜lÈ„ÈñRŒéÔIÜö'ø£˜ö‚o+_£WØŸn`r’ä³ËàÈYQÄ5¶Ú	¾i`'ÑF,‚V.Ÿ§ë~¼D$Âàå
I›·Ì™úÖ›¡p•xPó#a×˜püz³hæµâ?.ÂJ¾-İ§åóŸ)À¡ğ\óä­ ı„9J}÷Ñzé*òÍ§½aİeT‹ä	¢í±lÖ¸ÜAPòÜ,¦¤ü`\NH€*Ë?Vf†Âåc¼×z# /Í«ÿ {!µfEÊĞºG¦˜ÉáXuùè‹àu-ù¡Ã•·L}}0Á’Òù)êâÁ¼VàÃI6uQXK†¼ÙË›l/=ŸÊàYrÉBQj@£Ì·äÛ‘Õ¡¡€EcñH¹åfñX÷ü+„É,Î¹VuèñeÅÒ*û©éCÄ$ÑZœdàE—Ö,ä7•Ã·ö'ÌL]ì?x®DKªšù­0ŸöÂx¼t2ĞÆ	FÎî&1O±<ªHÆÌ1Ë_²<<á~{U¢z?]!Ò]nd³ö‘2¯›úÿK~G.‚ğEàr0î»ĞÃ.ÈK•›!s²ÌS¹ŸÖà*€RÆ¿ùg„A8{o^¤-oÎüæ¤Éõ#®-òÚ¨¿ÜgÿÌ-FàäPxô¤ ?t¶@˜:¦>*¾óÂ‡İP³ø«ƒc¶XşS¯ÆUqÑ-ö˜ı4|)Ç;øUÄ—µ4­³Eº5²4ËòÜlÊÛeœ‰ãúÿ”û}|jLôÍ‰j)Õ×]ÈV"Å-~*
dFÏV8œnu2»Òf53ä–”ânÓ+§ÆcË…•Wü‰Eƒ×-î‘fM—ˆÚsHßTÏªrĞÄæØ’z¡Üôê™Î÷eVJ+@â=¦ÃºX‚ÔÖpsŒT‰«×|Çğy_µav©Ááº§SÊ¥«Í©à)•y
Š÷¨ks¶ÕH®~Q¨»P²ÏëoÂ…M AxÙhà¥ñöÒÄÌø˜Ş…ê?è†–9íğ|Pã#øÿÑ8Û-åú9Æ|ØáğSªEÈoªÃÒZ@îƒ(½µ;Al‡ãÀ³¯Hİ„ë ³2Š¨7‚±ä*2/êNäìşóbïõï³×”û£áÕ©ñ;#ÌÛŠ¡gò •Éè"7¸ğ)2Mk
–¨×E´¿9´X¤ØRê²wÚ|ãøØ%\û-LfÀ˜_'ü<)XT0)â0uúŠ“>G‹rwÔ.˜mŒÏz0™Ô®»³¬ö6Š¶mjp­œ>U‚A¹æš‹ÍõÌ!jRÁŠO·(Ï;×6L%·;ÛV²9yhÀêf&³=L•QÁp¡~üë}@VˆÔIÂ0el¨d÷.CDàíhX7Ş£ºlíiQÕ,ß‹Ü0¦çğ¿ò@bCF<_CÏ‚Q:¦ÙxÏã1–ïdÿ3/I4m±Ob<–%É
F\ªO9J¬_XÍÒö6F‡~şÈ—­«Ş(IÙ_	T±Y9%vMNw‘*	‡¹ÚT,“tI¹ÓlFíéÖ¼&Æñs¸ˆŞ)ñŸ s”6Võ êÕŞ£Ñµ+o˜z¨ıˆöº›µí¯ÆãFxeË‘EŒeh€©,Í‰>Jè!‰MÈ12¯
c·ñLãú?A¦İQTI1âŠ×(ÔMêdàç4úƒÇ,ú¦›-ï2¡LGEG6CfìGRØ t0•:K¹…t˜~·T”œy´¼ıw 9äï<0H>Ş`XŒå%‹lÛ¸†çãCwÏfÀ_±i™›^¼=#:+$üİ_ØNÍg!Ît¶û¢°ùü>pé´qˆ,Lõš*[Åì -~UzªùÉ"óúà'Ø­Nän&d(ìíÀŸş´¥‡(W
Ã%¾¸VšºJÉN«‰¿N•æ0pì#ÁO…ÇÈ6¨Fˆ
+¨wSb?Ç}’‰óúåü{æÿA»YáŠ”†ó©~J…#sÓÒœ³Åuvpipãé¶ÿnåÑz‰£-Ææ›I¸U÷vûd¢ò[ÍaÔZ¶şøéªS£?šÇ;µ¾¶”¤îÇ×’nbİE,¦Sq[É§A
5t7–4}ÕÓEöæ‡NfòZ¢ùÇ9ø.˜r-d-	üËœ@°!O6²ºE¡}}3Äˆ9C~P¢Nvíá;UŸüèç;ğÎA˜Şš­æ<ßÂ"õÛëğãÈ›š¥¢A¹È4	wŒ€
0&W?=—§ñj”79TOĞ¢4œóãL´É^§J¹)A‡†/„»«ÓğÙ“!ÎÁnñ(é•dI«Zƒ¬İÔ.”‚îT`ºõ9@ùÔ4™Ùa/TÄqŠ#›êäõ›Bí3ïÏ½;dÃ§ıŠu]
Æ¢³¬	eõ7ÛññŸåjçíx¦¶‚jUï$›ßqßÈ?rmg•NîWIQÚDİT=ÅPoìÚüâŞş&„G>ÿóe«’z'€egWÅ
–	h¾UZ.C‚â,ğrNä4' e$yØ.ÕE§xm§wÿ¼N_t0#4mljıôªóûÉZ‘dPÇ» ]vòwçÿ²`¥f…©‹Å¨¥#¦Ø?_ôÚ¤#_tùFY	ÒGof£Ş›Úcëïˆ ÌS¨¨J=Ò–1(//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#ifndef EXPERIMENTAL_ANY_HELPERS_H
#define EXPERIMENTAL_ANY_HELPERS_H

#include <experimental/any>
#include <typeinfo>
#include <type_traits>
#include <cassert>

#include "test_macros.h"

#if !defined(TEST_HAS_NO_RTTI)
#define RTTI_ASSERT(X) assert(X)
#else
#define RTTI_ASSERT(X)
#endif

template <class T>
  struct IsSmallObject
    : public std::integral_constant<bool
        , sizeof(T) <= (sizeof(void*)*3)
          && std::alignment_of<void*>::value
             % std::alignment_of<T>::value == 0
          && std::is_nothrow_move_constructible<T>::value
        >
  {};


// Return 'true' if 'Type' will be considered a small type by 'any'
template <class Type>
bool isSmallType() {
#if defined(_LIBCPP_VERSION)
    return std::experimental::__any_imp::_IsSmallObject<Type>::value;
#else
    return IsSmallObject<Type>::value;
#endif

}

// Assert that an object is empty. If the object used to contain an object
// of type 'LastType' check that it can no longer be accessed.
template <class LastType = int>
void assertEmpty(std::experimental::any const& a) {
    assert(a.empty());
    RTTI_ASSERT(a.type() == typeid(void));
    assert(std::experimental::any_cast<LastType const>(&a) == nullptr);
}

// Assert that an 'any' object stores the specified 'Type' and 'value'.
template <class Type>
_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
void assertContains(std::experimental::any const& a, int value = 1) {
    assert(!a.empty());
    RTTI_ASSERT(a.type() == typeid(Type));
    assert(std::experimental::any_cast<Type const &>(a).value == value);
}

// Modify the value of a "test type" stored within an any to the specified
// 'value'.
template <class Type>
_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
void modifyValue(std::experimental::any& a, int value) {
    assert(!a.empty());
    RTTI_ASSERT(a.type() == typeid(Type));
    std::experimental::any_cast<Type&>(a).value = value;
}

// A test type that will trigger the small object optimization within 'any'.
template <int Dummy = 0>
struct small_type
{
    static int count;
    static int copied;
    static int moved;
    static int const_copied;
    static int non_const_copied;

    static void reset() {
        small_type::copied = 0;
        small_type::moved = 0;
        small_type::const_copied = 0;
        small_type::non_const_copied = 0;
    }

    int value;

    explicit small_type(int val) : value(val) {
        ++count;
    }

    small_type(small_type const & other) throw() {
        value = other.value;
        ++count;
        ++copied;
        ++const_copied;
    }

    small_type(small_type& other) throw() {
        value = other.value;
        ++count;
        ++copied;
        ++non_const_copied;
    }

    small_type(small_type && other) throw() {
        value = other.value;
        other.value = 0;
        ++count;
        ++moved;
    }

    ~small_type() {
        value = -1;
        --count;
    }

private:
    small_type& operator=(small_type const&) = delete;
    small_type& operator=(small_type&&) = delete;
};

template <int Dummy>
int small_type<Dummy>::count = 0;

template <int Dummy>
int small_type<Dummy>::copied = 0;

template <int Dummy>
int small_type<Dummy>::moved = 0;

template <int Dummy>
int small_type<Dummy>::const_copied = 0;

template <int Dummy>
int small_type<Dummy>::non_const_copied = 0;

typedef small_type<> small;
typedef small_type<1> small1;
typedef small_type<2> small2;


// A test type that will NOT trigger the small object optimization in any.
template <int Dummy = 0>
struct large_type
{
    static int count;
    static int copied;
    static int moved;
    static int const_copied;
    static int non_const_copied;

    static void reset() {
        large_type::copied = 0;
        large_type::moved  = 0;
        large_type::const_copied = 0;
        large_type::non_const_copied = 0;
    }

    int value;

    large_type(int val) : value(val) {
        ++count;
        data[0] = 0;
    }

    large_type(large_type const & other) {
        value = other.value;
        ++count;
        ++copied;
        ++const_copied;
    }

    large_type(large_type & other) {
        value = other.value;
        ++count;
        ++copied;
        ++non_const_copied;
    }

    large_type(large_type && other) {
        value = other.value;
        other.value = 0;
        ++count;
        ++moved;
    }

    ~large_type()  {
        value = 0;
        --count;
    }

private:
    large_type& operator=(large_type const&) = delete;
    large_type& operator=(large_type &&) = delete;
    int data[10];
};

template <int Dummy>
int large_type<Dummy>::count = 0;

template <int Dummy>
int large_type<Dummy>::copied = 0;

template <int Dummy>
int large_type<Dummy>::moved = 0;

template <int Dummy>
int large_type<Dummy>::const_copied = 0;

template <int Dummy>
int large_type<Dummy>::non_const_copied = 0;

typedef large_type<> large;
typedef large_type<1> large1;
typedef large_type<2> large2;

// The exception type thrown by 'small_throws_on_copy', 'large