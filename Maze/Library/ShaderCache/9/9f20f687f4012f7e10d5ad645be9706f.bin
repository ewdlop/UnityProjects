Mac OS X
==============================================================================

These instructions are for people using Apple's Mac OS X (pronounced
"ten").

From the developer's point of view, OS X is a sort of hybrid Mac and
Unix system, and you have the option of using either traditional
command line tools or Apple's IDE Xcode.

Command Line Build
==================

To build SDL using the command line, use the standard configure and make
process:

    ./configure
    make
    sudo make install

You can also build SDL as a Universal library (a single binary for both
32-bit and 64-bit Intel architectures), on Mac OS X 10.7 and newer, by using
the gcc-fat.sh script in build-scripts:

    mkdir mybuild
    cd mybuild
    CC=$PWD/../build-scripts/gcc-fat.sh CXX=$PWD/../build-scripts/g++-fat.sh ../configure
    make
    sudo make install

This script builds SDL with 10.5 ABI compatibility on i386 and 10.6
ABI compatibility on x86_64 architectures.  For best compatibility you
should compile your application the same way.

Please note that building SDL requires at least Xcode 4.6 and the 10.7 SDK
(even if you target back to 10.5 systems). PowerPC support for Mac OS X has
been officially dropped as of SDL 2.0.2.

To use the library once it's built, you essential have two possibilities:
use the traditional autoconf/automake/make method, or use Xcode.

==============================================================================
Caveats for using SDL with Mac OS X
==============================================================================

Some things you have to be aware of when using SDL on Mac OS X:

- If you register your own NSApplicationDelegate (using [NSApp setDelegate:]),
  SDL will not register its own. This means that SDL will not terminate using
  SDL_Quit if it receives a termination request, it will terminate like a 
  normal app, and it will not send a SDL_DROPFILE when you request to open a
  file with the app. To solve these issues, put the following code in your 
  NSApplicationDelegate implementation:


    - (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
    {
        if (SDL_GetEventState(SDL_QUIT) == SDL_ENABLE) {
            SDL_Event event;
            event.type = SDL_QUIT;
            SDL_PushEvent(&event);
        }
    
        return NSTerminateCancel;
    }
    
    - (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
    {
        if (SDL_GetEventState(SDL_DROPFILE) == SDL_ENABLE) {
            SDL_Event event;
            event.type = SDL_DROPFILE;
            event.drop.file = SDL_strdup([filename UTF8String]);
            return (SDL_PushEvent(&event) > 0);
        }
    
        return NO;
    }

==============================================================================
Using the Simple DirectMedia Layer with a traditional Makefile
==============================================================================

An existing autoconf/automake build system for your SDL app has good chances
to work almost unchanged on OS X. However, to produce a "real" Mac OS X binary
that you can distribute to users, you need to put the generated binary into a
so called "bundle", which basically is a fancy folder with a name like
"MyCoolGame.app".

To get this build automatically, add something like the following rule to
your Makefile.am:

    bundle_contents = APP_NAME.app/Contents
    APP_NAME_bundle: EXE_NAME
    	mkdir -p $(bundle_contents)/MacOS
    	mkdir -p $(bundle_contents)/Resources
    	echo "APPL????" > $(bundle_contents)/PkgInfo
    	$(INSTALL_PROGRAM) $< $(bundle_contents)/MacOS/

You should replace EXE_NAME with the name of the executable. APP_NAME is what
will be visible to the user in the Finder. Usually it will be the same
as EXE_NAME but capitalized. E.g. if EXE_NAME is "testgame" then APP_NAME 
usually is "TestGame". You might also want to use `@PACKAGE@` to use the package
name as specified in your configure.ac file.

If your project builds more than one application, you will have to do a bit
more. For each of your target applications, you need a separate rule.

If you want the created bundles to be installed, you may want to add this
rule to your Makefile.am:

    install-exec-hook: APP_NAME_bundle
    	rm -rf $(DESTDIR)$(prefix)/Applications/APP_NAME.app
    	mkdir -p $(DESTDIR)$(prefix)/Applications/
    	cp -r $< /$(DESTDIR)$(prefix)Applications/

This rule takes the Bundle created by the rule from step 3 and installs them
into "$(DESTDIR)$(prefix)/Applications/".

Again, if you want to install multiple applications, you will have to augment
the make rule accordingly.


But beware! That is only part of the story! With the above, you end up with
a bare bone .app bundle, which is double clickable from the Finder. But
there are some more things you should do before shipping your product...

1) The bundle right now probably is dynamically linked against SDL. That 
   means that when you copy it to another computer, *it will not run*,
   unless you also install SDL on that other computer. A good solution
   for this dilemma is to static link against SDL. On OS X, you can
   achieve that by linking against the libraries listed by

       sdl-config --static-libs

   instead of those listed by

       sdl-config --libs

   Depending on how exactly SDL is integrated into your build systems, the
   way to achieve that varies, so I won't describe it here in detail

2) Add an 'Info.plist' to your applicat