ling code.  This needs
                // to work, however, so that code that uses a single Memory<char> field to store either
                // a readable ReadOnlyMemory<char> or a writable Memory<char> can still be pinned and
                // used for interop purposes.
                GCHandle handle = GCHandle.Alloc(s, GCHandleType.Pinned);
#if FEATURE_PORTABLE_SPAN
                void* pointer = Unsafe.Add<T>((void*)handle.AddrOfPinnedObject(), _index);
#else
                void* pointer = Unsafe.Add<T>(Unsafe.AsPointer(ref s.GetRawStringData()), _index);
#endif // FEATURE_PORTABLE_SPAN
                return new MemoryHandle(pointer, handle);
            }
            else if (_object is T[] array)
            {
                // Array is already pre-pinned
                if (_length < 0)
                {
#if FEATURE_PORTABLE_SPAN
              