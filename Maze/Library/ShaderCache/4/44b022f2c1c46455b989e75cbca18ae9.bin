/*===---- stdatomic.h - Standard header for atomic types and operations -----===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
#ifndef __CLANG_STDATOMIC_H
#define __CLANG_STDATOMIC_H

/* If we're hosted, fall back to the system's stdatomic.h. FreeBSD, for
 * example, already has a Clang-compatible stdatomic.h header.
 */
#if __STDC_HOSTED__ && __has_include_next(<stdatomic.h>)
# include_next <stdatomic.h>
#else

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/* 7.17.1 Introduction */

#define ATOMIC_BOOL_LOCK_FREE       __GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE       __GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE   __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE   __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE    __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_T_LOCK_FREE    __GCC_ATOMIC_SHORT_T_LOCK_FREE
#define ATOMIC_INT_T_LOCK_FREE      __GCC_ATOMIC_INT_T_LOCK_FREE
#define ATOMIC_LONG_T_LOCK_FREE     __GCC_ATOMIC_LONG_T_LOCK_FREE
#define ATOMIC_LLONG_T_LOCK_FREE    __GCC_ATOMIC_LLONG_T_LOCK_FREE
#define ATOMIC_POINTER_T_LOCK_FREE  __GCC_ATOMIC_POINTER_T_LOCK_FREE

/* 7.17.2 Initialization */

#define ATOMIC_VAR_INIT(value) (value)
#define atomic_init __c11_atomic_init

/* 7.17.3 Order and consistency */

typedef enum memory_order {
  memory_order_relaxed = __ATOMIC_RELAXED,
  memory_order_consume = __ATOMIC_CONSUME,
  memory_order_acquire = __ATOMIC_ACQUIRE,
  memory_order_release = __ATOMIC_RELEASE,
  memory_order_acq_rel = __ATOMIC_ACQ_REL,
  memory_order_seq_cst = __ATOMIC_SEQ_CST
} memory_order;

#define kill_dependency(y) (y)

/* 7.17.4 Fences */

/* These should be provided by the libc implementation. */
void atomic_thread_fence(memory_order);
void atomic_signal_fence(memory_order);

#define atomic_thread_fence(order) __c11_atomic_thread_fence(order)
#define atomic_signal_fence(order) __c11_atomic_signal_fence(order)

/* 7.17.5 Lock-free property */

#define atomic_is_lock_free(obj) __c11_atomic_is_lock_free(sizeof(*(obj)))

/* 7.17.6 Atomic integer types */

#ifdef __cplusplus
typedef _Atomic(bool)               atomic_bool;
#else
typedef _Atomic(_Bool)              atomic_bool;
#endif
typedef _Atomic(char)               atomic_char;
typedef _Atomic(signed char)        atomic_schar;
typedef _Atomic(unsigned char)      atomic_uchar;
typedef _Atomic(short)              atomic_short;
typedef _Atomic(unsigned short)     atomic_ushort;
typedef _Atomic(int)                atomic_int;
typedef _Atomic(unsigned int)       atomic_uint;
typedef _Atomic(long)               atomic_long;
typedef _Atomic(unsigned long)      atomic_ulong;
typedef _Atomic(long long)          atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t)     atomic_char16_t;
typedef _Atomic(uint_least32_t)     atomic_char32_t;
typedef _Atomic(wchar_t)            atomic_wchar_t;
typedef _Atomic(int_least8_t)       atomic_int_least8_t;
typedef _Atomic(uint_least8_t)      atomic_uint_least8_t;
typedef _Atomic(int_least16_t)      atomic_int_least16_t;
typedef _Atomic(uint_least16_t)     atomic_uint_least16_t;
typedef _Atomic(int_least32_t)      atomic_int_least32_t;
typedef _Atomic(uint_least32_t)     atomic_uint_least32_t;
typedef _Atomic(int_least64_t)      atomic_int_least64_t;
typedef _Atomic(uint_least64_t)     atomic_uint_least64_t;
typedef _Atomic(int_fast8_t)        atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t)       atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t)       atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t)      atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t)       atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t)      atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t)       atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t)      atomic_uint_fast64_t;
typedef _Atomic(intptr_t)           atomic_intptr_t;
typedef _Atomic(uintptr_t)          atomic_uintptr_t;
typedef _Atomic(size_t)             atomic_size_t;
typedef _Atomic(ptrdiff_t)          atomic_ptrdiff_t;
typedef _Atomic(intmax_t)           atomic_intmax_t;
typedef _Atomic(uintmax_t)          atomic_uintmax_t;

/* 7.17.7 Operations on atomic types */

#define atomic_store(object, desired) __c11_atomic_store(object, desired, __ATOMIC_SEQ_CST)
#define atomic_store_explicit __c11_atomic_store

#define atomic_load(object) __c11_atomic_load(object, __ATOMIC_SEQ_CST)
#define atomic_load_explicit __c11_atomic_load

#define atomic_exchange(object, desired) __c11_atomic_exchange(object, desired, __ATOMIC_SEQ_CST)
#define atomic_exchange_explicit __c11_atomic_exchange

#define atomic_compare_exchange_strong(object, expected, desired) __c11_atomic_compare_exchange_strong(object, expected, desired, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
#define atomic_compare_exchange_strong_explicit __c11_atomic_compare_exchange_strong

#define atomic_compare_exchange_weak(object, expected, desired) __c11_atomic_compare_exchange_weak(object, expected, desired, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
#define atomic_compare_exchange_weak_explicit __c11_atomic_compare_exchange_weak

#define atomic_fetch_add(object, operand) __c11_atomic_fetch_add(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_add_explicit __c11_atomic_fetch_add

#define atomic_fetch_sub(object, operand) __c11_atomic_fetch_sub(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_sub_explicit __c11_atomic_fetch_sub

#define atomic_fetch_or(object, operand) __c11_atomic_fetch_or(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_or_explicit __c11_atomic_fetch_or

#define atomic_fetch_xor(object, operand) __c11_atomic_fetch_xor(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_xor_explicit __c11_atomic_fetch_xor

#define atomic_fetch_and(object, operand) __c11_atomic_fetch_and(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_and_explicit __c11_atomic_fetch_and

/* 7.17.8 Atomic flag type and operations */

typedef struct atomic_flag { atomic_bool _Value; } atomic_flag;

#define ATOMIC_FLAG_INIT { 0 }

/* These should be provided by the libc implementation. */
#ifdef __cplusplus
bool atomic_flag_test_and_set(volatile atomic_flag *);
bool atomic_flag_test_and_set_explicit(volatile atomic_flag *, memory_order);
#else
_Bool atomic_flag_test_and_set(volatile atomic_flag *);
_Bool atomic_flag_test_and_set_explicit(volatile atomic_flag *, memory_order);
#endif
void atomic_flag_clear(volatile atomic_flag *);
void atomic_flag_clear_explicit(volatile atomic_flag *, memory_order);

#define atomic_flag_test_and_set(object) __c11_atomic_exchange(&(object)->_Value, 1, __ATOMIC_SEQ_CST)
#define atomic_flag_test_and_set_explicit(object, order) __c11_atomic_exchange(&(object)->_Value, 1, order)

#define atomic_flag_clear(object) __c11_atomic_store(&(object)->_Value, 0, __ATOMIC_SEQ_CST)
#define atomic_flag_clear_explicit(object, order) __c11_atomic_store(&(object)->_Value, 0, order)

#ifdef __cplusplus
}
#endif

#endif /* __STDC_HOSTED__ */
#endif /* __CLANG_STDATOMIC_H */


                                                                                                                                                                                                                                                                                                                                                                MÙ™Ys$dJ|R×ˆZé¥ÌÃr¨Ë¿0všËç†³Æ
Vš]ã¼‹tVPR«^A$€A °4ëAÒ²!¸ßé2»ñ´úÕÂ\=9+/ØoóyŠknª
sÎÙØ	xq¢”ë*ğì)Ûèa•Ã›êäuyçYF~sëøNH
uÛ:nÄ<+)<É˜cò ¹(øÖI{(”’6J2®Eö8S€„úA høA æã²%·:Nõç¼__‰¥eÜ<ƒNq¢A/=
à%1ÀÖ)ñÓj¼n¨èNö°ì×Ôl€¢ær¯.×¼)”øoã	NWÜùÁËßÍçËÍ½ œ°c§•¯÷Èº,s'µ.Àpš•Ê‡.n èê>^ISUj´åQ‹‡·UÄ'DœsG¿”şÕj7” ƒo«(ÍÄeMwÜ<û‹Y¶2e+‰o>»p]ê´µÔÁÑ(`ÉØÎBØÉçJ; ¡	J‡>ä .z>á?·‚ù”›úårõÑ­±…\J#ı_ìá×É€Ïò)ãzŞı·Q‚‰û–,ºy§LßDö¨˜«}³ÂuŞ_ÍLt›}§çİ5FÄƒÃŒ<6tŸ`<Uÿ€¢‡ÛHôÚ%ø@Ş»êu`a½Şº—¬§S­Eb‘˜sfŸL	H ‘RÌêCb‚—UK(Ó,t¯Ú¹ÙÕ¬[eÃ;Rr‰¼ ÄK	è/ì™5:;–d˜”úQÇsí®ˆg6^ÿU»¼±]#!v6b¼Ÿ‡9:Í¤` âA¡›¼ éãÁs_¨.ÕÅÊScõèƒºÅ·f:»ilñy˜MŠÉ'Fi3ZÁ&Äò•±	R¿€–5ëeWøß&X¢êzmm_:ÆìM]Ã¿á¹s÷!·Ns¿`&ç!^8Ç„.ê}¼÷d˜0üFû8g>èª™(å„ÖægP»şÃ!dÎÍ27Ío_Gjé9Æ`‰%Úô7üZ¤ã‘ğ³TfÓ4éF$ˆòTİíXÏáÕğÓNÏ¿F“špÉèğnÊÁËÓêóî
=™à„#ïbßm‰.¯Õÿ.lx¦°Y[mÂ&çpèİÔo]fªßè-¾v>ïÅ4»q™*ƒÒ°îf~óEĞáâ^ãYøŸ{ªíğ¦‰-è›L`É¦ÈC›’ I“ñ5ªñŠ{¤+{"½œA
åQ‹JÔœ~;ª!ûHñ(ôtï¦.l—g­rŒ<Ïf¢f¯w§Â0Æö*7ãğ—Ûj’µºÈ¬6”pNï{†Z ÕPÑışòœÑ: ^7:0üz×ƒ{¡ÇAà—ÒN«©Z|²¥4¥° ¦Øä;Ôşüö:Ü÷Õ"_åNµñ |¦Ä*Â–x<ù‘b1É[¾8Ê&€ÓiáœKm¹‘‡•u‡z´À»/ŞÍÚÅĞ‰"qKH¢†oc*½€ê×}G@ÕJ¦TuŸ¢M]p­sBé[Ã¯;)¾›š`”¿-‹£|^UaV I§ï°#xıA ¥˜zf`yñ0â4<—´?Öá£rUfâš_eŸeß˜n·—AX4yÖÿèìIâ£OaoW‡í@bÈĞÆ›5
$W€ÉìÚSÑx‚õPÔ´ã4u»`W­‡ÚÃyüd
w‹ÛuüQË‡'f\-ÂNúŞ$«-ë3YQ-4½,/POÉßÏ|b¥=É&‚ª`Ëuô7÷‡°ª™o8ş;„´ŠÜ±<*È;öBoûUà†Ó;i>Ñíé
¯7iÒ¤ªHsxiu¥Â1	öˆZìe¸¹€Lçÿò™6f6 0ìCj¥Ã±àQ±’èü¿-DÓeöQ ØpuÕT@¡Ëò‚$ƒ¥K—îlçØ8ü}Ãd¡âFÒœ¦ú¨º”Âü·´7ßgWGXİ´8Âƒ\ZBJ;{'ËTb›Íô9¹j•/
pE”sîá]C†_\oœ8`'ğSÙêIÒµ¸ım¬|²'Dê‡ÍbİœĞoà]4M©ã%_a1¨i­‰°åÓsÛæX_A²Æëmæöx]ÈÖğ –ËÄ¢.l†vtüÆqšc2Déx´MÃÒş]z„·bŠ#ÌÅgeQßQcqÄÈÊ®ó“–­©YSüi&/¦éV:0Ğ!ø‰r$ªI¨ˆ[ÙøwÅ0=§ü]cjğNÅ Û›4xwÂW™™+ ØO“Ğw¶xšjóî¶İ†´ÏÎ=x3¥7Çì,­M{^Ú¼µ³}£ÛÉW­ÁœÙÀÉÉ²¡Œõ·üCnzâv·`î»Xœ5ãóñ“¥qä–pL03mb·ò,Y¹Ğ[ÇÛ‚òºs1ñC‘Ûò¶í&µ®´„èUøÿzìªp°Ïü@Ään©§pÇt‹p.„ÁÇú¥ºèó–ö÷+)§@>ë6ëoÇ,!JˆhÍK¸Sí®Ú€)KüŠSŠø?íùcçŒ—×½´Ã„Âö»‚—&Ôí?‡ÖJ‡æGÃrF9!o?jt`‘¬«maşd¡@â°nîxdÑù†^ŞW` xF¯­İ—%nSøÁúfŸĞ<q²±ÖÈµ‚ñ¹ÖµŸuÒXÚĞ©ÅG ‹(’°k@2,å×ã“‘$ÎÚ."ÎÓwF¾U”€·áÈoÙc¿äåáû:¬Ûr"¹ŸùÁF/6«I
*%ƒ^8u	;”2A/ò©æ”ï©Õ|ƒ öİ,²òÛWA
#lş"Vô’¨*|õSôà²P%ôÚN`×m ¸?.ú1?ÆA=‘û"‚kç»&u9r?ñGàô‹mÃ“¼VŞHªhFp\81¬—V 8'	VÚ–`™óX¤x±2[Ç­;‡ç6/ùû9_æš‹*Ún¸j€?Îß—AÉÜ+ß0Ó¢ÁšÅp7ê~åËUP9=œe3a®\°ºÙ§qQÓá6KõáíqÉ¥®0†"tº$ü>¦Õü$os‚| `F_>²} ¿ØğQ<À}ØxéLĞgêÎ€vX÷N¼ glÑ_4Ó’ÈÓl†-XğıÊEj–ï‡¾rî×¤’.54CpsÎ­P³ÜÑ%Ï³ú©¯zVß¶`£…Á/3tGIõÉ>´³Å÷=[£²ì/»!…;ú¼ÛÉÜ¾m3L75ı \Ğ²Tbé:6Š•µPwŒYë¼Ğ ¾ÛÎššNtŸ]ˆ«rıÔ hK²°»;~&B4ƒÂ­¹H$ä€˜9\Ÿ»Ud9XÇ•{­$[?IÏ¼qM²Ï¼Ğí­XW5—)‘}ëtœ‹İHs²Ï“±ƒ)ºñ‰Ç¸Ê¨×øFìÍÅ”ˆà5;iıó›G‰ØfÓo"¸‡‡ìe¨„˜EÏ
N²©‰²6“×çP#,¬I+ä~,›Äš×ŸiT³¨´CÀÀ:Æ¥”³2¹äB >#äÂö'¢ÉªD6Ÿ!£ ×||™š8(µëíÄc©êÔÜr™Fd°"Û¥“¨Lºµ°ƒ¢÷¨?‚X%#PSÓ€a6“Nq1ïİ£ß	VÜ{ŸhPÑ°­•z*›û/„ø—«¯ğÑÁ0z37¾Í³ÛğØf«¨E4:5Ñ‚Šíàx•µu IÒŞacSšä8hêH¯²€@Jî‡„°îĞVïyY·ôal"w3ñ!œk—"¹j†‚	_ö°££é”±ëîXZŒgaàÌ`îkë"–éT3AÏäûªõ‚”gÛH@ç€¬xKbÇq©İuƒ2auÏ 8!ÂøA×¦é.ß­/eæÁ€F±Ã.;ÿ}Í}iY$nj¤«Ö¸á-Ue .QÉÅ¶wˆE“š	¥cH$ÖãP´‚—ò¨`èŠj*±=°(­¥Ã8/ÓMí1­4•9M İ2m½F¦o÷}‹±ÅÍòÓ;p¡Z†Ák„ùK½<Ø ƒ/¥¹ê³i-±EgkzK'4ªä…íªÚ´+@Gu@2ƒ0é¿aãÛIºµdáß`Ö©pª^„‹æm>²¹P}¿¦/078M¯…®gŠqjqNO<nHÑ¸†[p$i:¥ôÜ—¯oüíML\•hbVnâï¶7~Ñ„¤?bÊFŒCŠÚ„ŞÙöŠ ÊN¿J)³æe×éÑÍz¹y:Ê×%œ<$My!üG½İâzP5W ozªPã•¶tè	uüµî	ZÓÍsz='Hj‘+ïVS´%$ïÌ#XY0ñK`1ÄxXë»¡é*aGÃ„m¹,Vº?ŠoıÁ”˜åzô?íœ$s‡û‘Á¦æ¼sÇª§