pl == null;

			if (!Issuer.Equals (other.Issuer))
				return false;

			byte[] thisSerialNumber = GetRawSerialNumber ();
			byte[] otherSerialNumber = other.GetRawSerialNumber ();

			if (thisSerialNumber.Length != otherSerialNumber.Length)
				return false;
			for (int i = 0; i < thisSerialNumber.Length; i++) {
				if (thisSerialNumber[i] != otherSerialNumber[i])
					return false;
			}

			return true;
		}

#endregion

#region CoreFX Implementation - With X509Helper

		public virtual byte[] Export (X509ContentType contentType)
		{
			return Export (contentType, (string)null);
		}

		public virtual byte[] Export (X509ContentType contentType, string password)
		{
			VerifyContentType (contentType);

			if (Impl == null)
				throw new CryptographicException (ErrorCode.E_POINTER);  // Not the greatest error, but needed for backward compat.

			using (var safePasswordHandle = new SafePasswordHandle (password))
				return Impl.Export (contentType, safePasswordHandle);
		}

		[System.CLSCompliantAttribute (false)]
		public virtual byte[] Export (X509ContentType contentType, SecureString password)
		{
			VerifyContentType (contentType);

			if (Impl == null)
				throw new CryptographicException (ErrorCode.E_POINTER);  // Not the greatest error, but needed for backward compat.

			using (var safePasswordHandle = new SafePasswordHandle (password))
				return Impl.Export (contentType, safePasswordHandle);
		}

#endregion

#region CoreFX Implementation

		public virtual string GetRawCertDataString ()
		{
			ThrowIfInvalid ();
			return GetRawCertData ().ToHexStringUpper ();
		}

		public virtual byte[] GetCertHash ()
		{
			ThrowIfInvalid ();
			return GetRawCertHash ().CloneByteArray ();
		}

		public virtual byte[] GetCertHash (HashAlgorithmName hashAlgorithm)
		{
			throw new PlatformNotSupportedException ();
		}

		public virtual bool TryGetCertHash (HashAlgorithmName hashAlgorithm, Span<byte> destination, out int bytesWritten)
		{
			throw new PlatformNotSupportedException ();
		}

		public virtual string GetCertHashString ()
		{
			ThrowIfInvalid ();
			return GetRawCertHash ().ToHexStringUpper ();
		}

		public virtual string GetCertHashString (HashAlgorithmName hashAlgorithm)
		{
			ThrowIfInvalid ();

			return GetCertHash (hashAlgorithm).ToHexStringUpper ();
		}

		// Only use for internal purposes when the returned byte[] will not be mutated
		byte[] GetRawCertHash ()
		{
			return lazyCertHash ?? (lazyCertHash = Impl.Thumbprint);
		}

		public virtual string GetEffe