
//		const PxU32 h0 = Ps::hash((const void*)payload.data[0]);
//		const PxU32 h1 = Ps::hash((const void*)payload.data[1]);
		const PxU32 h0 = PxU32(PX_MAX_U32 & payload.data[0]);
		const PxU32 h1 = PxU32(PX_MAX_U32 & payload.data[1]);
		return Ps::hash(PxU64(h0)|(PxU64(h1)<<32));
#else
		return Ps::hash(PxU64(payload.data[0])|(PxU64(payload.data[1])<<32));
#endif
	}

#ifdef USE_REGULAR_HASH_MAP
	struct BucketPrunerPair : public Ps::UserAllocated
	{
		PX_FORCE_INLINE	BucketPrunerPair()	{}
		PX_FORCE_INLINE	BucketPrunerPair(PxU32 index, PxU32 stamp) : mCoreIndex(index), mTimeStamp(stamp)	{}
		PxU32			mCoreIndex;	// index in mCoreObjects
		PxU32			mTimeStamp;
	};
	typedef Ps::HashMap<PrunerPayload, BucketPrunerPair> BucketPrunerMap;
#else
	struct BucketPrunerPair : public Ps::UserAllocated
	{
		PrunerPayload	mPayload;
		PxU32			mCoreIndex;	// index in mCoreObjects
		PxU32			mTimeStamp;
	};

	// Custom hash-map - currently faster than the regular hash-map (Ps::HashMap), in particular for 'find-and-erase' operations.
	class BucketPrunerMap : public Ps::UserAllocated
	{
		public:
												BucketPrunerMap();
												~BucketPrunerMap();

						void					purge();
						void					shrinkMemory();

						BucketPrunerPair*		addPair				(const PrunerPayload& payload, PxU32 coreIndex, PxU32 timeStamp);
						bool					removePair			(const PrunerPayload& payload, PxU32& coreIndex, PxU32& timeStamp);
						const BucketPrunerPair*	findPair			(const PrunerPayload& payload) const;
		PX_FORCE_INLINE	PxU32					getPairIndex		(const BucketPrunerPair* pair)		const
												{
													return (PxU32((size_t(pair) - size_t(mActivePairs)))/sizeof(BucketPrunerPair));
												}

						PxU32					mHashSize;
						PxU32					mMask;
						PxU32					mNbActivePairs;
						PxU32*					mHashTable;
						PxU32*					mNext;
						BucketPrunerPair*		mActivePairs;
						PxU32					mReservedMemory;

		PX_FORCE_INLINE	BucketPrunerPair*		findPair(const PrunerPayload& payload, PxU32 hashValue) const;
						void					removePairInternal(const PrunerPayload& payload, PxU32 hashValue, PxU32 pairIndex);
						void					reallocPairs();
						void					reserveMemory(PxU32 memSize);
	};
#endif

	class BucketPrunerCore : public Ps::UserAllocated
	{
		public:
											BucketPrunerCore(bool externalMemory=true);
											~BucketPrunerCore();

						void				release();

						void				setExternalMemory(PxU32 nbObjects, PxBounds3* boxes, PrunerPayload* objects);

						bool				addObject(const PrunerPayload& object, const PxBounds3& worldAABB, PxU32 timeStamp=0);
						bool				removeObject(const PrunerPayload& object, PxU32& timeStamp);
						bool				updateObject(const PxBounds3& worldAABB, const PrunerPayload& object);

		// PT: look for objects marked with input timestamp everywhere in the structure, and remove them. This is the same
		// as calling 'removeObject' individually for all these objects, but much more efficient. Returns number of removed objects.
						PxU32				removeMarkedObjects(PxU32 timeStamp);

						PxAgain				raycast(const PxVec3& origin, const PxVec3& unitDir, PxReal& inOutDistance, PrunerCallback&) const;
						PxAgain				overlap(const Gu::ShapeData& queryVolume, PrunerCallback&) const;
						PxAgain				sweep(const Gu::ShapeData& queryVolume, const PxVec3& unitDir, PxReal& inOutDistance, PrunerCallback&) const;

						void				shiftOrigin(const PxVec3& shift);

						void				visualize(Cm::RenderOutput& out, PxU32 color) const;

		PX_FORCE_INLINE	void				build()					{ classifyBoxes();	}

		PX_FORCE_INLINE	PxU32				getNbObjects()	const	{ return mNbFree + mCoreNbObjects;	}

//		private:
						PxU32				mCoreNbObjects;		// Current number of objects in core arrays
						PxU32				mCoreCapacity;		// Capacity of core arrays
						PxBounds3*			mCoreBoxes;			// Core array
						PrunerPayload*		mCoreObjects;		// Core array
						PxU32*				mCoreRemap;			// Remaps core index to sorted index, i.e. sortedIndex = mCoreRemap[coreIndex]

						BucketBox*			mSortedWorldBoxes;	// Sorted array
						PrunerPayload*		mSortedObjects;		// Sorted array

						PxU32				mNbFree;						// Current number of objects in the "free array" (mFreeObjects/mFreeBounds)
						PrunerPayload		mFreeObjects[FREE_PRUNER_SIZE];	// mNbFree objects are stored here
						PxBounds3			mFreeBounds[FREE_PRUNER_SIZE];	// mNbFree object bounds are stored here
						PxU32				mFreeStamps[FREE_PRUNER_SIZE];

						BucketPrunerMap		mMap;			// Maps (PrunerPayload) object to corresponding index in core array.
															// Objects in the free array do not appear in this map.
						PxU32				mSortedNb;
						PxU32				mSortedCapacity;
						PxU32				mSortAxis;

						BucketBox			mGlobalBox;		// Global bounds around all objects in the structure (except the ones in the "free" array)
						BucketPrunerNode	mLevel1;
						BucketPrunerNode	mLevel2[5];
						BucketPrunerNode	mLevel3[5][5];

						bool				mDirty;
						bool				mOwnMemory;
		private:
						void				classifyBoxes();
						void		