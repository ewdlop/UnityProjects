
				)
			]
		]
		+ SVerticalBox::Slot()
		.Padding(5.0f)
		.AutoHeight()
		[
			SNew(SHorizontalBox)
			+SHorizontalBox::Slot()
			.VAlign(VAlign_Center)
			.HAlign(HAlign_Center)
			.FillWidth(0.2f)
			[
				SNew(SButton)
				.ContentPadding(2.0f)
				.OnClicked(this, &SAnimationRemapAssets::OnBestGuessClicked)
				.Content()
				[
					SNew(STextBlock)
					.Text(LOCTEXT("BestGuessButton", "Auto-Fill Using Best Guess"))
				]
			]
			+SHorizontalBox::Slot()
			.VAlign(VAlign_Center)
			.HAlign(HAlign_Center)
			.Padding(FMargin(5.0f, 0.0f, 0.0f, 0.0f))
			[
				SNew(STextBlock)
				.AutoWrapText(true)
				.Text(LOCTEXT("BestGuessDescription", "Auto-Fill will look at the names of all compatible assets for the new skeleton and look for something similar to use for the remapped asset."))
			]
		]

		+ SVerticalBox::Slot()
		.Padding(5.0f)
		.VAlign(VAlign_Center)
		.HAlign(HAlign_Center)
		.AutoHeight()
		[
			SNew(SBox)
			.VAlign(VAlign_Center)
			.HAlign(HAlign_Center)
			.Content()
			[
				SNew(SButton)
				.ContentPadding(FEditorStyle::GetMargin("StandardDialog.ContentPadding"))
				.OnClicked(this, &SAnimationRemapAssets::OnOkClicked)
				.Content()
				[
					SNew(STextBlock)
					.Text(LOCTEXT("OkButton", "OK"))
				]
			]
		]
	];
}

void SAnimationRemapAssets::ShowWindow(FAnimationRetargetContext& RetargetContext, USkeleton* RetargetToSkeleton)
{
	if(DialogWindow.IsValid())
	{
		FSlateApplication::Get().DestroyWindowImmediately(DialogWindow.ToSharedRef());
	}
	
	DialogWindow = SNew(SWindow)
		.Title(LOCTEXT("RemapAssets", "Choose Assets to Remap"))
		.SupportsMinimize(false)
		.SupportsMaximize(false)
		.HasCloseButton(false)
		.MaxWidth(1024.0f)
		.SizingRule(ESizingRule::Autosized);
	
	TSharedPtr<class SAnimationRemapAssets> DialogWidget;
	
	TSharedPtr<SBorder> DialogWrapper =
		SNew(SBorder)
		.BorderImage(FEditorStyle::GetBrush("ToolPanel.GroupBorder"))
		.Padding(4.0f)
		[
			SAssignNew(DialogWidget, SAnimationRemapAssets)
				.NewSkeleton(RetargetToSkeleton)
				.RetargetContext(&RetargetContext)
		];
	
	DialogWindow->SetOnWindowClosed(FRequestDestroyWindowOverride::CreateSP(DialogWidget.Get(), &SAnimationRemapAssets::OnDialogClosed));
	DialogWindow->SetContent(DialogWrapper.ToSharedRef());
	
	FSlateApplication::Get().AddModalWindow(DialogWindow.ToSharedRef(), nullptr);
}

TSharedRef<ITableRow> SAnimationRemapAssets::OnGenerateMontageReferenceRow(TSharedPtr<FDisplayedAssetEntryInfo> Item, const TSharedRef<STableViewBase>& OwnerTable)
{
	return SNew(SAssetEntryRow, OwnerTable)
		.DisplayedInfo(Item);
}

void SAnimationRemapAssets::OnDialogClosed(const TSharedRef<SWindow>& Window)
{
	DialogWindow = nullptr;
}

FReply SAnimationRemapAssets::OnOkClicked()
{
	for(TSharedPtr<FDisplayedAssetEntryInfo> AssetInfo : AssetListInfo)
	{
		if(AssetInfo->RemapAsset)
		{
			RetargetContext->AddRemappedAsset(Cast<UAnimationAsset>(AssetInfo->AnimAsset), Cast<UAnimationAsset>(AssetInfo->RemapAsset));
		}
	}

	DialogWindow->RequestDestroyWindow();

	return FReply::Handled();
}

FReply SAnimationRemapAssets::OnBestGuessClicked()
{
	// collect all compatible assets
	FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
	FString SkeletonName = FAssetData(NewSkeleton).GetExportTextName();

	TArray<FAssetData> CompatibleAssets;
	TArray<FAssetData> AssetDataList;

	AssetRegistryModule.Get().GetAssetsByClass(UAnimationAsset::StaticClass()->GetFName(), AssetDataList, true);

	for(const FAssetData& Data : AssetDataList)
	{
		if(Data.GetTagValueRef<FString>("Skeleton") == SkeletonName)
		{
			CompatibleAssets.Add(Data);
		}
	}

	if(CompatibleAssets.Num() > 0)
	{
		// Do best guess analysis for the assets based on name.
		for(TSharedPtr<FDisplayedAssetEntryInfo>& Info : AssetListInfo)
		{
			const FAssetData* BestMatchData = FindBestGuessMatch(FAssetData(Info->AnimAsset), CompatibleAssets);
			Info->RemapAsset = BestMatchData ? BestMatchData->GetAsset() : nullptr;
		}
	}

	ListWidget->RequestListRefresh();

	return FReply::Handled();
}

const FAssetData* SAnimationRemapAssets::FindBestGuessMatch(const FAssetData& AssetData, const TArray<FAssetData>& PossibleAssets) const
{
	int32 LowestScore = MAX_int32;
	int32 FoundIndex = INDEX_NONE;

	for(int32 Idx = 0 ; Idx < PossibleAssets.Num() ; ++Idx)
	{
		const FAssetData& Data = PossibleAssets[Idx];

		if(Data.AssetClass == AssetData.AssetClass)
		{
			int32 Distance = FAnimationRuntime::GetStringDistance(AssetData.AssetName.ToString(), Data.AssetName.ToString());

			if(Distance < LowestScore)
			{
				LowestScore = Distance;
				FoundIndex = Idx;
			}
		}
	}

	if(FoundIndex != INDEX_NONE)
	{
		return &PossibleAssets[FoundIndex];
	}

	return nullptr;
}

void SAssetEntryRow::Construct(const FArguments& InArgs, const TSharedRef<STableViewBase>& InOwnerTableView)
{
	check(InArgs._DisplayedInfo.IsValid());
	DisplayedInfo = InArgs._DisplayedInfo;

	SkeletonExportName = FAssetData(DisplayedInfo->NewSkeleton).GetExportTextName();

	SMultiColumnTableRow<TSharedPtr<FDisplayedAssetEntryInfo>>::Construct(FSuperRowType::FArguments(), InOwnerTableView);
}

TSharedRef<SWidget> SAssetEntryRow::GenerateWidgetForColumn(const FName& ColumnName)
{
	if(ColumnName == TEXT("AssetName"))
	{
		return SNew(STextBlock)
			.Text(FText::Format(LOCTEXT("AssetNameEntry", "{0}"), FText::FromString(DisplayedInfo->AnimAsset->GetName())));
	}
	else if(ColumnName == TEXT("AssetType"))
	{
		return SNew(STextBlock)
			.Text(FText::Format(LOCTEXT("AssetTypeEntry", "{0}"), FText::FromString(DisplayedInfo->AnimAsset->GetClass()->GetName())));
	}
	else if(ColumnName == TEXT("AssetRemap"))
	{
		return SNew(SBox)
			.Padding(2.0f)
			[
				SNew(SComboButton)
				.ToolTipText(LOCTEXT("AssetRemapTooltip", "Select compatible asset to remap to."))
				.ButtonStyle(FEditorStyle::Get(), "PropertyEditor.AssetComboStyle")
				.ForegroundColor(FEditorStyle::GetColor("PropertyEditor.AssetName.ColorAndOpacity"))
				.OnGetMenuContent(this, &SAssetEntryRow::GetRemapMenuContent)
				.ContentPadding(2.0f)
				.ButtonContent()
				[
					SNew(STextBlock)
					.TextStyle(FEditorStyle::Get(), "PropertyEditor.AssetClass")
					.Font(FEditorStyle::GetFontStyle("PropertyWindow.NormalFont"))
					.Text(this, &SAssetEntryRow::GetRemapMenuButtonText)
				]
			];
	}

	return SNullWidget::NullWidget;
}

TSharedRef<SWidget> SAssetEntryRow::GetRemapMenuContent()
{
	FContentBrowserModule& ContentBrowserModule = FModuleManager::Get().LoadModuleChecked<FContentBrowserModule>(TEXT("ContentBrowser"));
	
	FAssetPickerConfig PickerConfig;
	PickerConfig.SelectionMode = ESelectionMode::Single;
	PickerConfig.Filter.ClassNames.Add(DisplayedInfo->AnimAsset->GetClass()->GetFName());
	PickerConfig.OnAssetSelected = FOnAssetSelected::CreateSP(this, &SAssetEntryRow::OnAssetSelected);
	PickerConfig.OnShouldFilterAsset = FOnShouldFilterAsset::CreateSP(this, &SAssetEntryRow::OnShouldFilterAsset);
	PickerConfig.bAllowNullSelection = true;
	
	return SNew(SBox)
		.WidthOverride(384)
		.HeightOverride(768)
		[
			ContentBrowserModule.Get().CreateAssetPicker(PickerConfig)
		];
}

FText SAssetEntryRow::GetRemapMenuButtonText() const
{
	FText NameText = (DisplayedInfo->RemapAsset) ? FText::FromString(*DisplayedInfo->RemapAsset->GetName()) : LOCTEXT("AssetRemapNone", "None");

	return FText::Format(LOCTEXT("RemapButtonText", "{0}"), NameText);
}

void SAssetEntryRow::OnAssetSelected(const FAssetData& AssetData)
{
	// Close the asset picker menu
	FSlateApplication::Get().DismissAllMenus();

	RemapAsset = AssetData.GetAsset();
	DisplayedInfo->RemapAsset = RemapAsset.Get();
}

bool SAssetEntryRow::OnShouldFilterAsset(const FAssetData& AssetData) const
{
	if(AssetData.GetTagValueRef<FString>("Skeleton") == SkeletonExportName)
	{
		return false;
	}

	return true;
}

TSharedRef<FDisplayedAssetEntryInfo> FDisplayedAssetEntryInfo::Make(UObject* InAsset, USkeleton* InNewSkeleton)
{
	return MakeShareable(new FDisplayedAssetEntryInfo(InAsset, InNewSkeleton));
}

FDisplayedAssetEntryInfo::FDisplayedAssetEntryInfo(UObject* InAsset, USkeleton* InNewSkeleton)
	: NewSkeleton(InNewSkeleton)
	, AnimAsset(InAsset)
	, RemapAsset(nullptr)
{

}

#undef LOCTEXT_NAMESPACE 
       