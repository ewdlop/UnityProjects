mcMsg.Properties[Message.CallContextKey]);

                    }
                }
                finally
                {
                    if (replySink != null)
                    {
                        // Call the reply sink without catching the exceptions
                        // in it. In v2.0 any exceptions in the callback for example
                        // would probably bring down the process
                        replySink.SyncProcessMessage(retMessage);
                    }
                }
            }
            finally {
                // restore the call context on the thread
                if (isCallContextSet)
                    CallContext.SetLogicalCallContext(oldCallCtx);
            }

            return retCtrl; 
        } // AsyncProcessMessage

        public IMessageSink NextSink
        {
            [System.Security.SecurityCritical]  // auto-generated
            get
            {
                // there is no nextSink for the StackBuilderSink
                return null;
            }
        }

        // This check if the call-site on the TP is in our own AD
        // It also handles the special case where the TP is on 
        // a well-known object and we cannot do stack-blting
        [System.Security.SecurityCritical]  // auto-generated
        internal bool IsOKToStackBlt(IMethodMessage mcMsg, Object server)
        {
            bool bOK = false;
            Message msg = mcMsg as Message;
            if(null != msg)
            {
                IInternalMessage iiMsg = (IInternalMessage) msg;
 
         