SocketError.OperationAborted;
                }

                ErrorCode = (int)errorCode;
            }

            if (errorCode==SocketError.Success) {
                return m_ListenSocket.UpdateAcceptSocket(m_AcceptSocket, m_ListenSocket.m_RightEndPoint.Create(remoteSocketAddress), false);
            }
            else
                return null;
        }

#endif // !FEATURE_PAL


        //
        // SetUnmanagedStructures -
        // Fills in Overlapped Structures used in an Async Overlapped Winsock call
        //   these calls are outside the runtime and are unmanaged code, so we need
        //   to prepare specific structures and ints that lie in unmanaged memory
        //   since the Overlapped calls can be Async
        //
        internal void SetUnmanagedStructures(byte[] buffer, int addressBufferLength) {

            // has to be called first to pin memory
            base.SetUnmanagedStructures(buffer);

            //
            // Fill in Buffer Array structure that will be used for our send/recv Buffer
            //
            m_AddressBufferLength = addressBufferLength;
            m_Buffer = buffer;
        }

        /*
        // Consider removing.
        internal void SetUnmanagedStructures(byte[] buffer, int addressBufferLength, ref OverlappedCache overlappedCache)
        {
            SetupCache(ref overlappedCache);
            SetUnmanagedStructures(buffer, addressBufferLength);
        }
        */

        void LogBuffer(long size) {
            GlobalLog.Assert(Logging.On, "AcceptOverlappedAsyncResult#{0}::LogBuffer()|Logging is off!", ValidationHelper.HashString(this));
            IntPtr pinnedBuffer = Marshal.UnsafeAddrOfPinnedArrayElement(m_Buffer, 0);
            if (pinnedBuffer != IntP